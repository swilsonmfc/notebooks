<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />

<title>Interpretability</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<style type="text/css">
    /*!
*
* Twitter Bootstrap
*
*/
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}
body {
  margin: 0;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}
audio,
canvas,
progress,
video {
  display: inline-block;
  vertical-align: baseline;
}
audio:not([controls]) {
  display: none;
  height: 0;
}
[hidden],
template {
  display: none;
}
a {
  background-color: transparent;
}
a:active,
a:hover {
  outline: 0;
}
abbr[title] {
  border-bottom: 1px dotted;
}
b,
strong {
  font-weight: bold;
}
dfn {
  font-style: italic;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
mark {
  background: #ff0;
  color: #000;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sup {
  top: -0.5em;
}
sub {
  bottom: -0.25em;
}
img {
  border: 0;
}
svg:not(:root) {
  overflow: hidden;
}
figure {
  margin: 1em 40px;
}
hr {
  box-sizing: content-box;
  height: 0;
}
pre {
  overflow: auto;
}
code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
button,
input,
optgroup,
select,
textarea {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
html input[type="button"],
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button;
  cursor: pointer;
}
button[disabled],
html input[disabled] {
  cursor: default;
}
button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
input {
  line-height: normal;
}
input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box;
  padding: 0;
}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: textfield;
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}
legend {
  border: 0;
  padding: 0;
}
textarea {
  overflow: auto;
}
optgroup {
  font-weight: bold;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
td,
th {
  padding: 0;
}
/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */
@media print {
  *,
  *:before,
  *:after {
    background: transparent !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
  a,
  a:visited {
    text-decoration: underline;
  }
  a[href]:after {
    content: " (" attr(href) ")";
  }
  abbr[title]:after {
    content: " (" attr(title) ")";
  }
  a[href^="#"]:after,
  a[href^="javascript:"]:after {
    content: "";
  }
  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }
  thead {
    display: table-header-group;
  }
  tr,
  img {
    page-break-inside: avoid;
  }
  img {
    max-width: 100% !important;
  }
  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }
  h2,
  h3 {
    page-break-after: avoid;
  }
  .navbar {
    display: none;
  }
  .btn > .caret,
  .dropup > .btn > .caret {
    border-top-color: #000 !important;
  }
  .label {
    border: 1px solid #000;
  }
  .table {
    border-collapse: collapse !important;
  }
  .table td,
  .table th {
    background-color: #fff !important;
  }
  .table-bordered th,
  .table-bordered td {
    border: 1px solid #ddd !important;
  }
}
@font-face {
  font-family: 'Glyphicons Halflings';
  src: url('../components/bootstrap/fonts/glyphicons-halflings-regular.eot');
  src: url('../components/bootstrap/fonts/glyphicons-halflings-regular.eot?#iefix') format('embedded-opentype'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.woff2') format('woff2'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.woff') format('woff'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.ttf') format('truetype'), url('../components/bootstrap/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular') format('svg');
}
.glyphicon {
  position: relative;
  top: 1px;
  display: inline-block;
  font-family: 'Glyphicons Halflings';
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
.glyphicon-asterisk:before {
  content: "\002a";
}
.glyphicon-plus:before {
  content: "\002b";
}
.glyphicon-euro:before,
.glyphicon-eur:before {
  content: "\20ac";
}
.glyphicon-minus:before {
  content: "\2212";
}
.glyphicon-cloud:before {
  content: "\2601";
}
.glyphicon-envelope:before {
  content: "\2709";
}
.glyphicon-pencil:before {
  content: "\270f";
}
.glyphicon-glass:before {
  content: "\e001";
}
.glyphicon-music:before {
  content: "\e002";
}
.glyphicon-search:before {
  content: "\e003";
}
.glyphicon-heart:before {
  content: "\e005";
}
.glyphicon-star:before {
  content: "\e006";
}
.glyphicon-star-empty:before {
  content: "\e007";
}
.glyphicon-user:before {
  content: "\e008";
}
.glyphicon-film:before {
  content: "\e009";
}
.glyphicon-th-large:before {
  content: "\e010";
}
.glyphicon-th:before {
  content: "\e011";
}
.glyphicon-th-list:before {
  content: "\e012";
}
.glyphicon-ok:before {
  content: "\e013";
}
.glyphicon-remove:before {
  content: "\e014";
}
.glyphicon-zoom-in:before {
  content: "\e015";
}
.glyphicon-zoom-out:before {
  content: "\e016";
}
.glyphicon-off:before {
  content: "\e017";
}
.glyphicon-signal:before {
  content: "\e018";
}
.glyphicon-cog:before {
  content: "\e019";
}
.glyphicon-trash:before {
  content: "\e020";
}
.glyphicon-home:before {
  content: "\e021";
}
.glyphicon-file:before {
  content: "\e022";
}
.glyphicon-time:before {
  content: "\e023";
}
.glyphicon-road:before {
  content: "\e024";
}
.glyphicon-download-alt:before {
  content: "\e025";
}
.glyphicon-download:before {
  content: "\e026";
}
.glyphicon-upload:before {
  content: "\e027";
}
.glyphicon-inbox:before {
  content: "\e028";
}
.glyphicon-play-circle:before {
  content: "\e029";
}
.glyphicon-repeat:before {
  content: "\e030";
}
.glyphicon-refresh:before {
  content: "\e031";
}
.glyphicon-list-alt:before {
  content: "\e032";
}
.glyphicon-lock:before {
  content: "\e033";
}
.glyphicon-flag:before {
  content: "\e034";
}
.glyphicon-headphones:before {
  content: "\e035";
}
.glyphicon-volume-off:before {
  content: "\e036";
}
.glyphicon-volume-down:before {
  content: "\e037";
}
.glyphicon-volume-up:before {
  content: "\e038";
}
.glyphicon-qrcode:before {
  content: "\e039";
}
.glyphicon-barcode:before {
  content: "\e040";
}
.glyphicon-tag:before {
  content: "\e041";
}
.glyphicon-tags:before {
  content: "\e042";
}
.glyphicon-book:before {
  content: "\e043";
}
.glyphicon-bookmark:before {
  content: "\e044";
}
.glyphicon-print:before {
  content: "\e045";
}
.glyphicon-camera:before {
  content: "\e046";
}
.glyphicon-font:before {
  content: "\e047";
}
.glyphicon-bold:before {
  content: "\e048";
}
.glyphicon-italic:before {
  content: "\e049";
}
.glyphicon-text-height:before {
  content: "\e050";
}
.glyphicon-text-width:before {
  content: "\e051";
}
.glyphicon-align-left:before {
  content: "\e052";
}
.glyphicon-align-center:before {
  content: "\e053";
}
.glyphicon-align-right:before {
  content: "\e054";
}
.glyphicon-align-justify:before {
  content: "\e055";
}
.glyphicon-list:before {
  content: "\e056";
}
.glyphicon-indent-left:before {
  content: "\e057";
}
.glyphicon-indent-right:before {
  content: "\e058";
}
.glyphicon-facetime-video:before {
  content: "\e059";
}
.glyphicon-picture:before {
  content: "\e060";
}
.glyphicon-map-marker:before {
  content: "\e062";
}
.glyphicon-adjust:before {
  content: "\e063";
}
.glyphicon-tint:before {
  content: "\e064";
}
.glyphicon-edit:before {
  content: "\e065";
}
.glyphicon-share:before {
  content: "\e066";
}
.glyphicon-check:before {
  content: "\e067";
}
.glyphicon-move:before {
  content: "\e068";
}
.glyphicon-step-backward:before {
  content: "\e069";
}
.glyphicon-fast-backward:before {
  content: "\e070";
}
.glyphicon-backward:before {
  content: "\e071";
}
.glyphicon-play:before {
  content: "\e072";
}
.glyphicon-pause:before {
  content: "\e073";
}
.glyphicon-stop:before {
  content: "\e074";
}
.glyphicon-forward:before {
  content: "\e075";
}
.glyphicon-fast-forward:before {
  content: "\e076";
}
.glyphicon-step-forward:before {
  content: "\e077";
}
.glyphicon-eject:before {
  content: "\e078";
}
.glyphicon-chevron-left:before {
  content: "\e079";
}
.glyphicon-chevron-right:before {
  content: "\e080";
}
.glyphicon-plus-sign:before {
  content: "\e081";
}
.glyphicon-minus-sign:before {
  content: "\e082";
}
.glyphicon-remove-sign:before {
  content: "\e083";
}
.glyphicon-ok-sign:before {
  content: "\e084";
}
.glyphicon-question-sign:before {
  content: "\e085";
}
.glyphicon-info-sign:before {
  content: "\e086";
}
.glyphicon-screenshot:before {
  content: "\e087";
}
.glyphicon-remove-circle:before {
  content: "\e088";
}
.glyphicon-ok-circle:before {
  content: "\e089";
}
.glyphicon-ban-circle:before {
  content: "\e090";
}
.glyphicon-arrow-left:before {
  content: "\e091";
}
.glyphicon-arrow-right:before {
  content: "\e092";
}
.glyphicon-arrow-up:before {
  content: "\e093";
}
.glyphicon-arrow-down:before {
  content: "\e094";
}
.glyphicon-share-alt:before {
  content: "\e095";
}
.glyphicon-resize-full:before {
  content: "\e096";
}
.glyphicon-resize-small:before {
  content: "\e097";
}
.glyphicon-exclamation-sign:before {
  content: "\e101";
}
.glyphicon-gift:before {
  content: "\e102";
}
.glyphicon-leaf:before {
  content: "\e103";
}
.glyphicon-fire:before {
  content: "\e104";
}
.glyphicon-eye-open:before {
  content: "\e105";
}
.glyphicon-eye-close:before {
  content: "\e106";
}
.glyphicon-warning-sign:before {
  content: "\e107";
}
.glyphicon-plane:before {
  content: "\e108";
}
.glyphicon-calendar:before {
  content: "\e109";
}
.glyphicon-random:before {
  content: "\e110";
}
.glyphicon-comment:before {
  content: "\e111";
}
.glyphicon-magnet:before {
  content: "\e112";
}
.glyphicon-chevron-up:before {
  content: "\e113";
}
.glyphicon-chevron-down:before {
  content: "\e114";
}
.glyphicon-retweet:before {
  content: "\e115";
}
.glyphicon-shopping-cart:before {
  content: "\e116";
}
.glyphicon-folder-close:before {
  content: "\e117";
}
.glyphicon-folder-open:before {
  content: "\e118";
}
.glyphicon-resize-vertical:before {
  content: "\e119";
}
.glyphicon-resize-horizontal:before {
  content: "\e120";
}
.glyphicon-hdd:before {
  content: "\e121";
}
.glyphicon-bullhorn:before {
  content: "\e122";
}
.glyphicon-bell:before {
  content: "\e123";
}
.glyphicon-certificate:before {
  content: "\e124";
}
.glyphicon-thumbs-up:before {
  content: "\e125";
}
.glyphicon-thumbs-down:before {
  content: "\e126";
}
.glyphicon-hand-right:before {
  content: "\e127";
}
.glyphicon-hand-left:before {
  content: "\e128";
}
.glyphicon-hand-up:before {
  content: "\e129";
}
.glyphicon-hand-down:before {
  content: "\e130";
}
.glyphicon-circle-arrow-right:before {
  content: "\e131";
}
.glyphicon-circle-arrow-left:before {
  content: "\e132";
}
.glyphicon-circle-arrow-up:before {
  content: "\e133";
}
.glyphicon-circle-arrow-down:before {
  content: "\e134";
}
.glyphicon-globe:before {
  content: "\e135";
}
.glyphicon-wrench:before {
  content: "\e136";
}
.glyphicon-tasks:before {
  content: "\e137";
}
.glyphicon-filter:before {
  content: "\e138";
}
.glyphicon-briefcase:before {
  content: "\e139";
}
.glyphicon-fullscreen:before {
  content: "\e140";
}
.glyphicon-dashboard:before {
  content: "\e141";
}
.glyphicon-paperclip:before {
  content: "\e142";
}
.glyphicon-heart-empty:before {
  content: "\e143";
}
.glyphicon-link:before {
  content: "\e144";
}
.glyphicon-phone:before {
  content: "\e145";
}
.glyphicon-pushpin:before {
  content: "\e146";
}
.glyphicon-usd:before {
  content: "\e148";
}
.glyphicon-gbp:before {
  content: "\e149";
}
.glyphicon-sort:before {
  content: "\e150";
}
.glyphicon-sort-by-alphabet:before {
  content: "\e151";
}
.glyphicon-sort-by-alphabet-alt:before {
  content: "\e152";
}
.glyphicon-sort-by-order:before {
  content: "\e153";
}
.glyphicon-sort-by-order-alt:before {
  content: "\e154";
}
.glyphicon-sort-by-attributes:before {
  content: "\e155";
}
.glyphicon-sort-by-attributes-alt:before {
  content: "\e156";
}
.glyphicon-unchecked:before {
  content: "\e157";
}
.glyphicon-expand:before {
  content: "\e158";
}
.glyphicon-collapse-down:before {
  content: "\e159";
}
.glyphicon-collapse-up:before {
  content: "\e160";
}
.glyphicon-log-in:before {
  content: "\e161";
}
.glyphicon-flash:before {
  content: "\e162";
}
.glyphicon-log-out:before {
  content: "\e163";
}
.glyphicon-new-window:before {
  content: "\e164";
}
.glyphicon-record:before {
  content: "\e165";
}
.glyphicon-save:before {
  content: "\e166";
}
.glyphicon-open:before {
  content: "\e167";
}
.glyphicon-saved:before {
  content: "\e168";
}
.glyphicon-import:before {
  content: "\e169";
}
.glyphicon-export:before {
  content: "\e170";
}
.glyphicon-send:before {
  content: "\e171";
}
.glyphicon-floppy-disk:before {
  content: "\e172";
}
.glyphicon-floppy-saved:before {
  content: "\e173";
}
.glyphicon-floppy-remove:before {
  content: "\e174";
}
.glyphicon-floppy-save:before {
  content: "\e175";
}
.glyphicon-floppy-open:before {
  content: "\e176";
}
.glyphicon-credit-card:before {
  content: "\e177";
}
.glyphicon-transfer:before {
  content: "\e178";
}
.glyphicon-cutlery:before {
  content: "\e179";
}
.glyphicon-header:before {
  content: "\e180";
}
.glyphicon-compressed:before {
  content: "\e181";
}
.glyphicon-earphone:before {
  content: "\e182";
}
.glyphicon-phone-alt:before {
  content: "\e183";
}
.glyphicon-tower:before {
  content: "\e184";
}
.glyphicon-stats:before {
  content: "\e185";
}
.glyphicon-sd-video:before {
  content: "\e186";
}
.glyphicon-hd-video:before {
  content: "\e187";
}
.glyphicon-subtitles:before {
  content: "\e188";
}
.glyphicon-sound-stereo:before {
  content: "\e189";
}
.glyphicon-sound-dolby:before {
  content: "\e190";
}
.glyphicon-sound-5-1:before {
  content: "\e191";
}
.glyphicon-sound-6-1:before {
  content: "\e192";
}
.glyphicon-sound-7-1:before {
  content: "\e193";
}
.glyphicon-copyright-mark:before {
  content: "\e194";
}
.glyphicon-registration-mark:before {
  content: "\e195";
}
.glyphicon-cloud-download:before {
  content: "\e197";
}
.glyphicon-cloud-upload:before {
  content: "\e198";
}
.glyphicon-tree-conifer:before {
  content: "\e199";
}
.glyphicon-tree-deciduous:before {
  content: "\e200";
}
.glyphicon-cd:before {
  content: "\e201";
}
.glyphicon-save-file:before {
  content: "\e202";
}
.glyphicon-open-file:before {
  content: "\e203";
}
.glyphicon-level-up:before {
  content: "\e204";
}
.glyphicon-copy:before {
  content: "\e205";
}
.glyphicon-paste:before {
  content: "\e206";
}
.glyphicon-alert:before {
  content: "\e209";
}
.glyphicon-equalizer:before {
  content: "\e210";
}
.glyphicon-king:before {
  content: "\e211";
}
.glyphicon-queen:before {
  content: "\e212";
}
.glyphicon-pawn:before {
  content: "\e213";
}
.glyphicon-bishop:before {
  content: "\e214";
}
.glyphicon-knight:before {
  content: "\e215";
}
.glyphicon-baby-formula:before {
  content: "\e216";
}
.glyphicon-tent:before {
  content: "\26fa";
}
.glyphicon-blackboard:before {
  content: "\e218";
}
.glyphicon-bed:before {
  content: "\e219";
}
.glyphicon-apple:before {
  content: "\f8ff";
}
.glyphicon-erase:before {
  content: "\e221";
}
.glyphicon-hourglass:before {
  content: "\231b";
}
.glyphicon-lamp:before {
  content: "\e223";
}
.glyphicon-duplicate:before {
  content: "\e224";
}
.glyphicon-piggy-bank:before {
  content: "\e225";
}
.glyphicon-scissors:before {
  content: "\e226";
}
.glyphicon-bitcoin:before {
  content: "\e227";
}
.glyphicon-btc:before {
  content: "\e227";
}
.glyphicon-xbt:before {
  content: "\e227";
}
.glyphicon-yen:before {
  content: "\00a5";
}
.glyphicon-jpy:before {
  content: "\00a5";
}
.glyphicon-ruble:before {
  content: "\20bd";
}
.glyphicon-rub:before {
  content: "\20bd";
}
.glyphicon-scale:before {
  content: "\e230";
}
.glyphicon-ice-lolly:before {
  content: "\e231";
}
.glyphicon-ice-lolly-tasted:before {
  content: "\e232";
}
.glyphicon-education:before {
  content: "\e233";
}
.glyphicon-option-horizontal:before {
  content: "\e234";
}
.glyphicon-option-vertical:before {
  content: "\e235";
}
.glyphicon-menu-hamburger:before {
  content: "\e236";
}
.glyphicon-modal-window:before {
  content: "\e237";
}
.glyphicon-oil:before {
  content: "\e238";
}
.glyphicon-grain:before {
  content: "\e239";
}
.glyphicon-sunglasses:before {
  content: "\e240";
}
.glyphicon-text-size:before {
  content: "\e241";
}
.glyphicon-text-color:before {
  content: "\e242";
}
.glyphicon-text-background:before {
  content: "\e243";
}
.glyphicon-object-align-top:before {
  content: "\e244";
}
.glyphicon-object-align-bottom:before {
  content: "\e245";
}
.glyphicon-object-align-horizontal:before {
  content: "\e246";
}
.glyphicon-object-align-left:before {
  content: "\e247";
}
.glyphicon-object-align-vertical:before {
  content: "\e248";
}
.glyphicon-object-align-right:before {
  content: "\e249";
}
.glyphicon-triangle-right:before {
  content: "\e250";
}
.glyphicon-triangle-left:before {
  content: "\e251";
}
.glyphicon-triangle-bottom:before {
  content: "\e252";
}
.glyphicon-triangle-top:before {
  content: "\e253";
}
.glyphicon-console:before {
  content: "\e254";
}
.glyphicon-superscript:before {
  content: "\e255";
}
.glyphicon-subscript:before {
  content: "\e256";
}
.glyphicon-menu-left:before {
  content: "\e257";
}
.glyphicon-menu-right:before {
  content: "\e258";
}
.glyphicon-menu-down:before {
  content: "\e259";
}
.glyphicon-menu-up:before {
  content: "\e260";
}
* {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
*:before,
*:after {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
html {
  font-size: 10px;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 1.42857143;
  color: #000;
  background-color: #fff;
}
input,
button,
select,
textarea {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}
a {
  color: #337ab7;
  text-decoration: none;
}
a:hover,
a:focus {
  color: #23527c;
  text-decoration: underline;
}
a:focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
figure {
  margin: 0;
}
img {
  vertical-align: middle;
}
.img-responsive,
.thumbnail > img,
.thumbnail a > img,
.carousel-inner > .item > img,
.carousel-inner > .item > a > img {
  display: block;
  max-width: 100%;
  height: auto;
}
.img-rounded {
  border-radius: 3px;
}
.img-thumbnail {
  padding: 4px;
  line-height: 1.42857143;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 2px;
  -webkit-transition: all 0.2s ease-in-out;
  -o-transition: all 0.2s ease-in-out;
  transition: all 0.2s ease-in-out;
  display: inline-block;
  max-width: 100%;
  height: auto;
}
.img-circle {
  border-radius: 50%;
}
hr {
  margin-top: 18px;
  margin-bottom: 18px;
  border: 0;
  border-top: 1px solid #eeeeee;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}
.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  clip: auto;
}
[role="button"] {
  cursor: pointer;
}
h1,
h2,
h3,
h4,
h5,
h6,
.h1,
.h2,
.h3,
.h4,
.h5,
.h6 {
  font-family: inherit;
  font-weight: 500;
  line-height: 1.1;
  color: inherit;
}
h1 small,
h2 small,
h3 small,
h4 small,
h5 small,
h6 small,
.h1 small,
.h2 small,
.h3 small,
.h4 small,
.h5 small,
.h6 small,
h1 .small,
h2 .small,
h3 .small,
h4 .small,
h5 .small,
h6 .small,
.h1 .small,
.h2 .small,
.h3 .small,
.h4 .small,
.h5 .small,
.h6 .small {
  font-weight: normal;
  line-height: 1;
  color: #777777;
}
h1,
.h1,
h2,
.h2,
h3,
.h3 {
  margin-top: 18px;
  margin-bottom: 9px;
}
h1 small,
.h1 small,
h2 small,
.h2 small,
h3 small,
.h3 small,
h1 .small,
.h1 .small,
h2 .small,
.h2 .small,
h3 .small,
.h3 .small {
  font-size: 65%;
}
h4,
.h4,
h5,
.h5,
h6,
.h6 {
  margin-top: 9px;
  margin-bottom: 9px;
}
h4 small,
.h4 small,
h5 small,
.h5 small,
h6 small,
.h6 small,
h4 .small,
.h4 .small,
h5 .small,
.h5 .small,
h6 .small,
.h6 .small {
  font-size: 75%;
}
h1,
.h1 {
  font-size: 33px;
}
h2,
.h2 {
  font-size: 27px;
}
h3,
.h3 {
  font-size: 23px;
}
h4,
.h4 {
  font-size: 17px;
}
h5,
.h5 {
  font-size: 13px;
}
h6,
.h6 {
  font-size: 12px;
}
p {
  margin: 0 0 9px;
}
.lead {
  margin-bottom: 18px;
  font-size: 14px;
  font-weight: 300;
  line-height: 1.4;
}
@media (min-width: 768px) {
  .lead {
    font-size: 19.5px;
  }
}
small,
.small {
  font-size: 92%;
}
mark,
.mark {
  background-color: #fcf8e3;
  padding: .2em;
}
.text-left {
  text-align: left;
}
.text-right {
  text-align: right;
}
.text-center {
  text-align: center;
}
.text-justify {
  text-align: justify;
}
.text-nowrap {
  white-space: nowrap;
}
.text-lowercase {
  text-transform: lowercase;
}
.text-uppercase {
  text-transform: uppercase;
}
.text-capitalize {
  text-transform: capitalize;
}
.text-muted {
  color: #777777;
}
.text-primary {
  color: #337ab7;
}
a.text-primary:hover,
a.text-primary:focus {
  color: #286090;
}
.text-success {
  color: #3c763d;
}
a.text-success:hover,
a.text-success:focus {
  color: #2b542c;
}
.text-info {
  color: #31708f;
}
a.text-info:hover,
a.text-info:focus {
  color: #245269;
}
.text-warning {
  color: #8a6d3b;
}
a.text-warning:hover,
a.text-warning:focus {
  color: #66512c;
}
.text-danger {
  color: #a94442;
}
a.text-danger:hover,
a.text-danger:focus {
  color: #843534;
}
.bg-primary {
  color: #fff;
  background-color: #337ab7;
}
a.bg-primary:hover,
a.bg-primary:focus {
  background-color: #286090;
}
.bg-success {
  background-color: #dff0d8;
}
a.bg-success:hover,
a.bg-success:focus {
  background-color: #c1e2b3;
}
.bg-info {
  background-color: #d9edf7;
}
a.bg-info:hover,
a.bg-info:focus {
  background-color: #afd9ee;
}
.bg-warning {
  background-color: #fcf8e3;
}
a.bg-warning:hover,
a.bg-warning:focus {
  background-color: #f7ecb5;
}
.bg-danger {
  background-color: #f2dede;
}
a.bg-danger:hover,
a.bg-danger:focus {
  background-color: #e4b9b9;
}
.page-header {
  padding-bottom: 8px;
  margin: 36px 0 18px;
  border-bottom: 1px solid #eeeeee;
}
ul,
ol {
  margin-top: 0;
  margin-bottom: 9px;
}
ul ul,
ol ul,
ul ol,
ol ol {
  margin-bottom: 0;
}
.list-unstyled {
  padding-left: 0;
  list-style: none;
}
.list-inline {
  padding-left: 0;
  list-style: none;
  margin-left: -5px;
}
.list-inline > li {
  display: inline-block;
  padding-left: 5px;
  padding-right: 5px;
}
dl {
  margin-top: 0;
  margin-bottom: 18px;
}
dt,
dd {
  line-height: 1.42857143;
}
dt {
  font-weight: bold;
}
dd {
  margin-left: 0;
}
@media (min-width: 541px) {
  .dl-horizontal dt {
    float: left;
    width: 160px;
    clear: left;
    text-align: right;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .dl-horizontal dd {
    margin-left: 180px;
  }
}
abbr[title],
abbr[data-original-title] {
  cursor: help;
  border-bottom: 1px dotted #777777;
}
.initialism {
  font-size: 90%;
  text-transform: uppercase;
}
blockquote {
  padding: 9px 18px;
  margin: 0 0 18px;
  font-size: inherit;
  border-left: 5px solid #eeeeee;
}
blockquote p:last-child,
blockquote ul:last-child,
blockquote ol:last-child {
  margin-bottom: 0;
}
blockquote footer,
blockquote small,
blockquote .small {
  display: block;
  font-size: 80%;
  line-height: 1.42857143;
  color: #777777;
}
blockquote footer:before,
blockquote small:before,
blockquote .small:before {
  content: '\2014 \00A0';
}
.blockquote-reverse,
blockquote.pull-right {
  padding-right: 15px;
  padding-left: 0;
  border-right: 5px solid #eeeeee;
  border-left: 0;
  text-align: right;
}
.blockquote-reverse footer:before,
blockquote.pull-right footer:before,
.blockquote-reverse small:before,
blockquote.pull-right small:before,
.blockquote-reverse .small:before,
blockquote.pull-right .small:before {
  content: '';
}
.blockquote-reverse footer:after,
blockquote.pull-right footer:after,
.blockquote-reverse small:after,
blockquote.pull-right small:after,
.blockquote-reverse .small:after,
blockquote.pull-right .small:after {
  content: '\00A0 \2014';
}
address {
  margin-bottom: 18px;
  font-style: normal;
  line-height: 1.42857143;
}
code,
kbd,
pre,
samp {
  font-family: monospace;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 2px;
}
kbd {
  padding: 2px 4px;
  font-size: 90%;
  color: #888;
  background-color: transparent;
  border-radius: 1px;
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.25);
}
kbd kbd {
  padding: 0;
  font-size: 100%;
  font-weight: bold;
  box-shadow: none;
}
pre {
  display: block;
  padding: 8.5px;
  margin: 0 0 9px;
  font-size: 12px;
  line-height: 1.42857143;
  word-break: break-all;
  word-wrap: break-word;
  color: #333333;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 2px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit;
  white-space: pre-wrap;
  background-color: transparent;
  border-radius: 0;
}
.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll;
}
.container {
  margin-right: auto;
  margin-left: auto;
  padding-left: 0px;
  padding-right: 0px;
}
@media (min-width: 768px) {
  .container {
    width: 768px;
  }
}
@media (min-width: 992px) {
  .container {
    width: 940px;
  }
}
@media (min-width: 1200px) {
  .container {
    width: 1140px;
  }
}
.container-fluid {
  margin-right: auto;
  margin-left: auto;
  padding-left: 0px;
  padding-right: 0px;
}
.row {
  margin-left: 0px;
  margin-right: 0px;
}
.col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 {
  position: relative;
  min-height: 1px;
  padding-left: 0px;
  padding-right: 0px;
}
.col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12 {
  float: left;
}
.col-xs-12 {
  width: 100%;
}
.col-xs-11 {
  width: 91.66666667%;
}
.col-xs-10 {
  width: 83.33333333%;
}
.col-xs-9 {
  width: 75%;
}
.col-xs-8 {
  width: 66.66666667%;
}
.col-xs-7 {
  width: 58.33333333%;
}
.col-xs-6 {
  width: 50%;
}
.col-xs-5 {
  width: 41.66666667%;
}
.col-xs-4 {
  width: 33.33333333%;
}
.col-xs-3 {
  width: 25%;
}
.col-xs-2 {
  width: 16.66666667%;
}
.col-xs-1 {
  width: 8.33333333%;
}
.col-xs-pull-12 {
  right: 100%;
}
.col-xs-pull-11 {
  right: 91.66666667%;
}
.col-xs-pull-10 {
  right: 83.33333333%;
}
.col-xs-pull-9 {
  right: 75%;
}
.col-xs-pull-8 {
  right: 66.66666667%;
}
.col-xs-pull-7 {
  right: 58.33333333%;
}
.col-xs-pull-6 {
  right: 50%;
}
.col-xs-pull-5 {
  right: 41.66666667%;
}
.col-xs-pull-4 {
  right: 33.33333333%;
}
.col-xs-pull-3 {
  right: 25%;
}
.col-xs-pull-2 {
  right: 16.66666667%;
}
.col-xs-pull-1 {
  right: 8.33333333%;
}
.col-xs-pull-0 {
  right: auto;
}
.col-xs-push-12 {
  left: 100%;
}
.col-xs-push-11 {
  left: 91.66666667%;
}
.col-xs-push-10 {
  left: 83.33333333%;
}
.col-xs-push-9 {
  left: 75%;
}
.col-xs-push-8 {
  left: 66.66666667%;
}
.col-xs-push-7 {
  left: 58.33333333%;
}
.col-xs-push-6 {
  left: 50%;
}
.col-xs-push-5 {
  left: 41.66666667%;
}
.col-xs-push-4 {
  left: 33.33333333%;
}
.col-xs-push-3 {
  left: 25%;
}
.col-xs-push-2 {
  left: 16.66666667%;
}
.col-xs-push-1 {
  left: 8.33333333%;
}
.col-xs-push-0 {
  left: auto;
}
.col-xs-offset-12 {
  margin-left: 100%;
}
.col-xs-offset-11 {
  margin-left: 91.66666667%;
}
.col-xs-offset-10 {
  margin-left: 83.33333333%;
}
.col-xs-offset-9 {
  margin-left: 75%;
}
.col-xs-offset-8 {
  margin-left: 66.66666667%;
}
.col-xs-offset-7 {
  margin-left: 58.33333333%;
}
.col-xs-offset-6 {
  margin-left: 50%;
}
.col-xs-offset-5 {
  margin-left: 41.66666667%;
}
.col-xs-offset-4 {
  margin-left: 33.33333333%;
}
.col-xs-offset-3 {
  margin-left: 25%;
}
.col-xs-offset-2 {
  margin-left: 16.66666667%;
}
.col-xs-offset-1 {
  margin-left: 8.33333333%;
}
.col-xs-offset-0 {
  margin-left: 0%;
}
@media (min-width: 768px) {
  .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12 {
    float: left;
  }
  .col-sm-12 {
    width: 100%;
  }
  .col-sm-11 {
    width: 91.66666667%;
  }
  .col-sm-10 {
    width: 83.33333333%;
  }
  .col-sm-9 {
    width: 75%;
  }
  .col-sm-8 {
    width: 66.66666667%;
  }
  .col-sm-7 {
    width: 58.33333333%;
  }
  .col-sm-6 {
    width: 50%;
  }
  .col-sm-5 {
    width: 41.66666667%;
  }
  .col-sm-4 {
    width: 33.33333333%;
  }
  .col-sm-3 {
    width: 25%;
  }
  .col-sm-2 {
    width: 16.66666667%;
  }
  .col-sm-1 {
    width: 8.33333333%;
  }
  .col-sm-pull-12 {
    right: 100%;
  }
  .col-sm-pull-11 {
    right: 91.66666667%;
  }
  .col-sm-pull-10 {
    right: 83.33333333%;
  }
  .col-sm-pull-9 {
    right: 75%;
  }
  .col-sm-pull-8 {
    right: 66.66666667%;
  }
  .col-sm-pull-7 {
    right: 58.33333333%;
  }
  .col-sm-pull-6 {
    right: 50%;
  }
  .col-sm-pull-5 {
    right: 41.66666667%;
  }
  .col-sm-pull-4 {
    right: 33.33333333%;
  }
  .col-sm-pull-3 {
    right: 25%;
  }
  .col-sm-pull-2 {
    right: 16.66666667%;
  }
  .col-sm-pull-1 {
    right: 8.33333333%;
  }
  .col-sm-pull-0 {
    right: auto;
  }
  .col-sm-push-12 {
    left: 100%;
  }
  .col-sm-push-11 {
    left: 91.66666667%;
  }
  .col-sm-push-10 {
    left: 83.33333333%;
  }
  .col-sm-push-9 {
    left: 75%;
  }
  .col-sm-push-8 {
    left: 66.66666667%;
  }
  .col-sm-push-7 {
    left: 58.33333333%;
  }
  .col-sm-push-6 {
    left: 50%;
  }
  .col-sm-push-5 {
    left: 41.66666667%;
  }
  .col-sm-push-4 {
    left: 33.33333333%;
  }
  .col-sm-push-3 {
    left: 25%;
  }
  .col-sm-push-2 {
    left: 16.66666667%;
  }
  .col-sm-push-1 {
    left: 8.33333333%;
  }
  .col-sm-push-0 {
    left: auto;
  }
  .col-sm-offset-12 {
    margin-left: 100%;
  }
  .col-sm-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-sm-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-sm-offset-9 {
    margin-left: 75%;
  }
  .col-sm-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-sm-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-sm-offset-6 {
    margin-left: 50%;
  }
  .col-sm-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-sm-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-sm-offset-3 {
    margin-left: 25%;
  }
  .col-sm-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-sm-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-sm-offset-0 {
    margin-left: 0%;
  }
}
@media (min-width: 992px) {
  .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 {
    float: left;
  }
  .col-md-12 {
    width: 100%;
  }
  .col-md-11 {
    width: 91.66666667%;
  }
  .col-md-10 {
    width: 83.33333333%;
  }
  .col-md-9 {
    width: 75%;
  }
  .col-md-8 {
    width: 66.66666667%;
  }
  .col-md-7 {
    width: 58.33333333%;
  }
  .col-md-6 {
    width: 50%;
  }
  .col-md-5 {
    width: 41.66666667%;
  }
  .col-md-4 {
    width: 33.33333333%;
  }
  .col-md-3 {
    width: 25%;
  }
  .col-md-2 {
    width: 16.66666667%;
  }
  .col-md-1 {
    width: 8.33333333%;
  }
  .col-md-pull-12 {
    right: 100%;
  }
  .col-md-pull-11 {
    right: 91.66666667%;
  }
  .col-md-pull-10 {
    right: 83.33333333%;
  }
  .col-md-pull-9 {
    right: 75%;
  }
  .col-md-pull-8 {
    right: 66.66666667%;
  }
  .col-md-pull-7 {
    right: 58.33333333%;
  }
  .col-md-pull-6 {
    right: 50%;
  }
  .col-md-pull-5 {
    right: 41.66666667%;
  }
  .col-md-pull-4 {
    right: 33.33333333%;
  }
  .col-md-pull-3 {
    right: 25%;
  }
  .col-md-pull-2 {
    right: 16.66666667%;
  }
  .col-md-pull-1 {
    right: 8.33333333%;
  }
  .col-md-pull-0 {
    right: auto;
  }
  .col-md-push-12 {
    left: 100%;
  }
  .col-md-push-11 {
    left: 91.66666667%;
  }
  .col-md-push-10 {
    left: 83.33333333%;
  }
  .col-md-push-9 {
    left: 75%;
  }
  .col-md-push-8 {
    left: 66.66666667%;
  }
  .col-md-push-7 {
    left: 58.33333333%;
  }
  .col-md-push-6 {
    left: 50%;
  }
  .col-md-push-5 {
    left: 41.66666667%;
  }
  .col-md-push-4 {
    left: 33.33333333%;
  }
  .col-md-push-3 {
    left: 25%;
  }
  .col-md-push-2 {
    left: 16.66666667%;
  }
  .col-md-push-1 {
    left: 8.33333333%;
  }
  .col-md-push-0 {
    left: auto;
  }
  .col-md-offset-12 {
    margin-left: 100%;
  }
  .col-md-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-md-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-md-offset-9 {
    margin-left: 75%;
  }
  .col-md-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-md-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-md-offset-6 {
    margin-left: 50%;
  }
  .col-md-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-md-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-md-offset-3 {
    margin-left: 25%;
  }
  .col-md-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-md-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-md-offset-0 {
    margin-left: 0%;
  }
}
@media (min-width: 1200px) {
  .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 {
    float: left;
  }
  .col-lg-12 {
    width: 100%;
  }
  .col-lg-11 {
    width: 91.66666667%;
  }
  .col-lg-10 {
    width: 83.33333333%;
  }
  .col-lg-9 {
    width: 75%;
  }
  .col-lg-8 {
    width: 66.66666667%;
  }
  .col-lg-7 {
    width: 58.33333333%;
  }
  .col-lg-6 {
    width: 50%;
  }
  .col-lg-5 {
    width: 41.66666667%;
  }
  .col-lg-4 {
    width: 33.33333333%;
  }
  .col-lg-3 {
    width: 25%;
  }
  .col-lg-2 {
    width: 16.66666667%;
  }
  .col-lg-1 {
    width: 8.33333333%;
  }
  .col-lg-pull-12 {
    right: 100%;
  }
  .col-lg-pull-11 {
    right: 91.66666667%;
  }
  .col-lg-pull-10 {
    right: 83.33333333%;
  }
  .col-lg-pull-9 {
    right: 75%;
  }
  .col-lg-pull-8 {
    right: 66.66666667%;
  }
  .col-lg-pull-7 {
    right: 58.33333333%;
  }
  .col-lg-pull-6 {
    right: 50%;
  }
  .col-lg-pull-5 {
    right: 41.66666667%;
  }
  .col-lg-pull-4 {
    right: 33.33333333%;
  }
  .col-lg-pull-3 {
    right: 25%;
  }
  .col-lg-pull-2 {
    right: 16.66666667%;
  }
  .col-lg-pull-1 {
    right: 8.33333333%;
  }
  .col-lg-pull-0 {
    right: auto;
  }
  .col-lg-push-12 {
    left: 100%;
  }
  .col-lg-push-11 {
    left: 91.66666667%;
  }
  .col-lg-push-10 {
    left: 83.33333333%;
  }
  .col-lg-push-9 {
    left: 75%;
  }
  .col-lg-push-8 {
    left: 66.66666667%;
  }
  .col-lg-push-7 {
    left: 58.33333333%;
  }
  .col-lg-push-6 {
    left: 50%;
  }
  .col-lg-push-5 {
    left: 41.66666667%;
  }
  .col-lg-push-4 {
    left: 33.33333333%;
  }
  .col-lg-push-3 {
    left: 25%;
  }
  .col-lg-push-2 {
    left: 16.66666667%;
  }
  .col-lg-push-1 {
    left: 8.33333333%;
  }
  .col-lg-push-0 {
    left: auto;
  }
  .col-lg-offset-12 {
    margin-left: 100%;
  }
  .col-lg-offset-11 {
    margin-left: 91.66666667%;
  }
  .col-lg-offset-10 {
    margin-left: 83.33333333%;
  }
  .col-lg-offset-9 {
    margin-left: 75%;
  }
  .col-lg-offset-8 {
    margin-left: 66.66666667%;
  }
  .col-lg-offset-7 {
    margin-left: 58.33333333%;
  }
  .col-lg-offset-6 {
    margin-left: 50%;
  }
  .col-lg-offset-5 {
    margin-left: 41.66666667%;
  }
  .col-lg-offset-4 {
    margin-left: 33.33333333%;
  }
  .col-lg-offset-3 {
    margin-left: 25%;
  }
  .col-lg-offset-2 {
    margin-left: 16.66666667%;
  }
  .col-lg-offset-1 {
    margin-left: 8.33333333%;
  }
  .col-lg-offset-0 {
    margin-left: 0%;
  }
}
table {
  background-color: transparent;
}
caption {
  padding-top: 8px;
  padding-bottom: 8px;
  color: #777777;
  text-align: left;
}
th {
  text-align: left;
}
.table {
  width: 100%;
  max-width: 100%;
  margin-bottom: 18px;
}
.table > thead > tr > th,
.table > tbody > tr > th,
.table > tfoot > tr > th,
.table > thead > tr > td,
.table > tbody > tr > td,
.table > tfoot > tr > td {
  padding: 8px;
  line-height: 1.42857143;
  vertical-align: top;
  border-top: 1px solid #ddd;
}
.table > thead > tr > th {
  vertical-align: bottom;
  border-bottom: 2px solid #ddd;
}
.table > caption + thead > tr:first-child > th,
.table > colgroup + thead > tr:first-child > th,
.table > thead:first-child > tr:first-child > th,
.table > caption + thead > tr:first-child > td,
.table > colgroup + thead > tr:first-child > td,
.table > thead:first-child > tr:first-child > td {
  border-top: 0;
}
.table > tbody + tbody {
  border-top: 2px solid #ddd;
}
.table .table {
  background-color: #fff;
}
.table-condensed > thead > tr > th,
.table-condensed > tbody > tr > th,
.table-condensed > tfoot > tr > th,
.table-condensed > thead > tr > td,
.table-condensed > tbody > tr > td,
.table-condensed > tfoot > tr > td {
  padding: 5px;
}
.table-bordered {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > tbody > tr > th,
.table-bordered > tfoot > tr > th,
.table-bordered > thead > tr > td,
.table-bordered > tbody > tr > td,
.table-bordered > tfoot > tr > td {
  border: 1px solid #ddd;
}
.table-bordered > thead > tr > th,
.table-bordered > thead > tr > td {
  border-bottom-width: 2px;
}
.table-striped > tbody > tr:nth-of-type(odd) {
  background-color: #f9f9f9;
}
.table-hover > tbody > tr:hover {
  background-color: #f5f5f5;
}
table col[class*="col-"] {
  position: static;
  float: none;
  display: table-column;
}
table td[class*="col-"],
table th[class*="col-"] {
  position: static;
  float: none;
  display: table-cell;
}
.table > thead > tr > td.active,
.table > tbody > tr > td.active,
.table > tfoot > tr > td.active,
.table > thead > tr > th.active,
.table > tbody > tr > th.active,
.table > tfoot > tr > th.active,
.table > thead > tr.active > td,
.table > tbody > tr.active > td,
.table > tfoot > tr.active > td,
.table > thead > tr.active > th,
.table > tbody > tr.active > th,
.table > tfoot > tr.active > th {
  background-color: #f5f5f5;
}
.table-hover > tbody > tr > td.active:hover,
.table-hover > tbody > tr > th.active:hover,
.table-hover > tbody > tr.active:hover > td,
.table-hover > tbody > tr:hover > .active,
.table-hover > tbody > tr.active:hover > th {
  background-color: #e8e8e8;
}
.table > thead > tr > td.success,
.table > tbody > tr > td.success,
.table > tfoot > tr > td.success,
.table > thead > tr > th.success,
.table > tbody > tr > th.success,
.table > tfoot > tr > th.success,
.table > thead > tr.success > td,
.table > tbody > tr.success > td,
.table > tfoot > tr.success > td,
.table > thead > tr.success > th,
.table > tbody > tr.success > th,
.table > tfoot > tr.success > th {
  background-color: #dff0d8;
}
.table-hover > tbody > tr > td.success:hover,
.table-hover > tbody > tr > th.success:hover,
.table-hover > tbody > tr.success:hover > td,
.table-hover > tbody > tr:hover > .success,
.table-hover > tbody > tr.success:hover > th {
  background-color: #d0e9c6;
}
.table > thead > tr > td.info,
.table > tbody > tr > td.info,
.table > tfoot > tr > td.info,
.table > thead > tr > th.info,
.table > tbody > tr > th.info,
.table > tfoot > tr > th.info,
.table > thead > tr.info > td,
.table > tbody > tr.info > td,
.table > tfoot > tr.info > td,
.table > thead > tr.info > th,
.table > tbody > tr.info > th,
.table > tfoot > tr.info > th {
  background-color: #d9edf7;
}
.table-hover > tbody > tr > td.info:hover,
.table-hover > tbody > tr > th.info:hover,
.table-hover > tbody > tr.info:hover > td,
.table-hover > tbody > tr:hover > .info,
.table-hover > tbody > tr.info:hover > th {
  background-color: #c4e3f3;
}
.table > thead > tr > td.warning,
.table > tbody > tr > td.warning,
.table > tfoot > tr > td.warning,
.table > thead > tr > th.warning,
.table > tbody > tr > th.warning,
.table > tfoot > tr > th.warning,
.table > thead > tr.warning > td,
.table > tbody > tr.warning > td,
.table > tfoot > tr.warning > td,
.table > thead > tr.warning > th,
.table > tbody > tr.warning > th,
.table > tfoot > tr.warning > th {
  background-color: #fcf8e3;
}
.table-hover > tbody > tr > td.warning:hover,
.table-hover > tbody > tr > th.warning:hover,
.table-hover > tbody > tr.warning:hover > td,
.table-hover > tbody > tr:hover > .warning,
.table-hover > tbody > tr.warning:hover > th {
  background-color: #faf2cc;
}
.table > thead > tr > td.danger,
.table > tbody > tr > td.danger,
.table > tfoot > tr > td.danger,
.table > thead > tr > th.danger,
.table > tbody > tr > th.danger,
.table > tfoot > tr > th.danger,
.table > thead > tr.danger > td,
.table > tbody > tr.danger > td,
.table > tfoot > tr.danger > td,
.table > thead > tr.danger > th,
.table > tbody > tr.danger > th,
.table > tfoot > tr.danger > th {
  background-color: #f2dede;
}
.table-hover > tbody > tr > td.danger:hover,
.table-hover > tbody > tr > th.danger:hover,
.table-hover > tbody > tr.danger:hover > td,
.table-hover > tbody > tr:hover > .danger,
.table-hover > tbody > tr.danger:hover > th {
  background-color: #ebcccc;
}
.table-responsive {
  overflow-x: auto;
  min-height: 0.01%;
}
@media screen and (max-width: 767px) {
  .table-responsive {
    width: 100%;
    margin-bottom: 13.5px;
    overflow-y: hidden;
    -ms-overflow-style: -ms-autohiding-scrollbar;
    border: 1px solid #ddd;
  }
  .table-responsive > .table {
    margin-bottom: 0;
  }
  .table-responsive > .table > thead > tr > th,
  .table-responsive > .table > tbody > tr > th,
  .table-responsive > .table > tfoot > tr > th,
  .table-responsive > .table > thead > tr > td,
  .table-responsive > .table > tbody > tr > td,
  .table-responsive > .table > tfoot > tr > td {
    white-space: nowrap;
  }
  .table-responsive > .table-bordered {
    border: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:first-child,
  .table-responsive > .table-bordered > tbody > tr > th:first-child,
  .table-responsive > .table-bordered > tfoot > tr > th:first-child,
  .table-responsive > .table-bordered > thead > tr > td:first-child,
  .table-responsive > .table-bordered > tbody > tr > td:first-child,
  .table-responsive > .table-bordered > tfoot > tr > td:first-child {
    border-left: 0;
  }
  .table-responsive > .table-bordered > thead > tr > th:last-child,
  .table-responsive > .table-bordered > tbody > tr > th:last-child,
  .table-responsive > .table-bordered > tfoot > tr > th:last-child,
  .table-responsive > .table-bordered > thead > tr > td:last-child,
  .table-responsive > .table-bordered > tbody > tr > td:last-child,
  .table-responsive > .table-bordered > tfoot > tr > td:last-child {
    border-right: 0;
  }
  .table-responsive > .table-bordered > tbody > tr:last-child > th,
  .table-responsive > .table-bordered > tfoot > tr:last-child > th,
  .table-responsive > .table-bordered > tbody > tr:last-child > td,
  .table-responsive > .table-bordered > tfoot > tr:last-child > td {
    border-bottom: 0;
  }
}
fieldset {
  padding: 0;
  margin: 0;
  border: 0;
  min-width: 0;
}
legend {
  display: block;
  width: 100%;
  padding: 0;
  margin-bottom: 18px;
  font-size: 19.5px;
  line-height: inherit;
  color: #333333;
  border: 0;
  border-bottom: 1px solid #e5e5e5;
}
label {
  display: inline-block;
  max-width: 100%;
  margin-bottom: 5px;
  font-weight: bold;
}
input[type="search"] {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
input[type="radio"],
input[type="checkbox"] {
  margin: 4px 0 0;
  margin-top: 1px \9;
  line-height: normal;
}
input[type="file"] {
  display: block;
}
input[type="range"] {
  display: block;
  width: 100%;
}
select[multiple],
select[size] {
  height: auto;
}
input[type="file"]:focus,
input[type="radio"]:focus,
input[type="checkbox"]:focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
output {
  display: block;
  padding-top: 7px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
}
.form-control {
  display: block;
  width: 100%;
  height: 32px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
}
.form-control:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
}
.form-control::-moz-placeholder {
  color: #999;
  opacity: 1;
}
.form-control:-ms-input-placeholder {
  color: #999;
}
.form-control::-webkit-input-placeholder {
  color: #999;
}
.form-control::-ms-expand {
  border: 0;
  background-color: transparent;
}
.form-control[disabled],
.form-control[readonly],
fieldset[disabled] .form-control {
  background-color: #eeeeee;
  opacity: 1;
}
.form-control[disabled],
fieldset[disabled] .form-control {
  cursor: not-allowed;
}
textarea.form-control {
  height: auto;
}
input[type="search"] {
  -webkit-appearance: none;
}
@media screen and (-webkit-min-device-pixel-ratio: 0) {
  input[type="date"].form-control,
  input[type="time"].form-control,
  input[type="datetime-local"].form-control,
  input[type="month"].form-control {
    line-height: 32px;
  }
  input[type="date"].input-sm,
  input[type="time"].input-sm,
  input[type="datetime-local"].input-sm,
  input[type="month"].input-sm,
  .input-group-sm input[type="date"],
  .input-group-sm input[type="time"],
  .input-group-sm input[type="datetime-local"],
  .input-group-sm input[type="month"] {
    line-height: 30px;
  }
  input[type="date"].input-lg,
  input[type="time"].input-lg,
  input[type="datetime-local"].input-lg,
  input[type="month"].input-lg,
  .input-group-lg input[type="date"],
  .input-group-lg input[type="time"],
  .input-group-lg input[type="datetime-local"],
  .input-group-lg input[type="month"] {
    line-height: 45px;
  }
}
.form-group {
  margin-bottom: 15px;
}
.radio,
.checkbox {
  position: relative;
  display: block;
  margin-top: 10px;
  margin-bottom: 10px;
}
.radio label,
.checkbox label {
  min-height: 18px;
  padding-left: 20px;
  margin-bottom: 0;
  font-weight: normal;
  cursor: pointer;
}
.radio input[type="radio"],
.radio-inline input[type="radio"],
.checkbox input[type="checkbox"],
.checkbox-inline input[type="checkbox"] {
  position: absolute;
  margin-left: -20px;
  margin-top: 4px \9;
}
.radio + .radio,
.checkbox + .checkbox {
  margin-top: -5px;
}
.radio-inline,
.checkbox-inline {
  position: relative;
  display: inline-block;
  padding-left: 20px;
  margin-bottom: 0;
  vertical-align: middle;
  font-weight: normal;
  cursor: pointer;
}
.radio-inline + .radio-inline,
.checkbox-inline + .checkbox-inline {
  margin-top: 0;
  margin-left: 10px;
}
input[type="radio"][disabled],
input[type="checkbox"][disabled],
input[type="radio"].disabled,
input[type="checkbox"].disabled,
fieldset[disabled] input[type="radio"],
fieldset[disabled] input[type="checkbox"] {
  cursor: not-allowed;
}
.radio-inline.disabled,
.checkbox-inline.disabled,
fieldset[disabled] .radio-inline,
fieldset[disabled] .checkbox-inline {
  cursor: not-allowed;
}
.radio.disabled label,
.checkbox.disabled label,
fieldset[disabled] .radio label,
fieldset[disabled] .checkbox label {
  cursor: not-allowed;
}
.form-control-static {
  padding-top: 7px;
  padding-bottom: 7px;
  margin-bottom: 0;
  min-height: 31px;
}
.form-control-static.input-lg,
.form-control-static.input-sm {
  padding-left: 0;
  padding-right: 0;
}
.input-sm {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
select.input-sm {
  height: 30px;
  line-height: 30px;
}
textarea.input-sm,
select[multiple].input-sm {
  height: auto;
}
.form-group-sm .form-control {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.form-group-sm select.form-control {
  height: 30px;
  line-height: 30px;
}
.form-group-sm textarea.form-control,
.form-group-sm select[multiple].form-control {
  height: auto;
}
.form-group-sm .form-control-static {
  height: 30px;
  min-height: 30px;
  padding: 6px 10px;
  font-size: 12px;
  line-height: 1.5;
}
.input-lg {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
select.input-lg {
  height: 45px;
  line-height: 45px;
}
textarea.input-lg,
select[multiple].input-lg {
  height: auto;
}
.form-group-lg .form-control {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
.form-group-lg select.form-control {
  height: 45px;
  line-height: 45px;
}
.form-group-lg textarea.form-control,
.form-group-lg select[multiple].form-control {
  height: auto;
}
.form-group-lg .form-control-static {
  height: 45px;
  min-height: 35px;
  padding: 11px 16px;
  font-size: 17px;
  line-height: 1.3333333;
}
.has-feedback {
  position: relative;
}
.has-feedback .form-control {
  padding-right: 40px;
}
.form-control-feedback {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 2;
  display: block;
  width: 32px;
  height: 32px;
  line-height: 32px;
  text-align: center;
  pointer-events: none;
}
.input-lg + .form-control-feedback,
.input-group-lg + .form-control-feedback,
.form-group-lg .form-control + .form-control-feedback {
  width: 45px;
  height: 45px;
  line-height: 45px;
}
.input-sm + .form-control-feedback,
.input-group-sm + .form-control-feedback,
.form-group-sm .form-control + .form-control-feedback {
  width: 30px;
  height: 30px;
  line-height: 30px;
}
.has-success .help-block,
.has-success .control-label,
.has-success .radio,
.has-success .checkbox,
.has-success .radio-inline,
.has-success .checkbox-inline,
.has-success.radio label,
.has-success.checkbox label,
.has-success.radio-inline label,
.has-success.checkbox-inline label {
  color: #3c763d;
}
.has-success .form-control {
  border-color: #3c763d;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-success .form-control:focus {
  border-color: #2b542c;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #67b168;
}
.has-success .input-group-addon {
  color: #3c763d;
  border-color: #3c763d;
  background-color: #dff0d8;
}
.has-success .form-control-feedback {
  color: #3c763d;
}
.has-warning .help-block,
.has-warning .control-label,
.has-warning .radio,
.has-warning .checkbox,
.has-warning .radio-inline,
.has-warning .checkbox-inline,
.has-warning.radio label,
.has-warning.checkbox label,
.has-warning.radio-inline label,
.has-warning.checkbox-inline label {
  color: #8a6d3b;
}
.has-warning .form-control {
  border-color: #8a6d3b;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-warning .form-control:focus {
  border-color: #66512c;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #c0a16b;
}
.has-warning .input-group-addon {
  color: #8a6d3b;
  border-color: #8a6d3b;
  background-color: #fcf8e3;
}
.has-warning .form-control-feedback {
  color: #8a6d3b;
}
.has-error .help-block,
.has-error .control-label,
.has-error .radio,
.has-error .checkbox,
.has-error .radio-inline,
.has-error .checkbox-inline,
.has-error.radio label,
.has-error.checkbox label,
.has-error.radio-inline label,
.has-error.checkbox-inline label {
  color: #a94442;
}
.has-error .form-control {
  border-color: #a94442;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
}
.has-error .form-control:focus {
  border-color: #843534;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 6px #ce8483;
}
.has-error .input-group-addon {
  color: #a94442;
  border-color: #a94442;
  background-color: #f2dede;
}
.has-error .form-control-feedback {
  color: #a94442;
}
.has-feedback label ~ .form-control-feedback {
  top: 23px;
}
.has-feedback label.sr-only ~ .form-control-feedback {
  top: 0;
}
.help-block {
  display: block;
  margin-top: 5px;
  margin-bottom: 10px;
  color: #404040;
}
@media (min-width: 768px) {
  .form-inline .form-group {
    display: inline-block;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .form-inline .form-control-static {
    display: inline-block;
  }
  .form-inline .input-group {
    display: inline-table;
    vertical-align: middle;
  }
  .form-inline .input-group .input-group-addon,
  .form-inline .input-group .input-group-btn,
  .form-inline .input-group .form-control {
    width: auto;
  }
  .form-inline .input-group > .form-control {
    width: 100%;
  }
  .form-inline .control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .radio,
  .form-inline .checkbox {
    display: inline-block;
    margin-top: 0;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .form-inline .radio label,
  .form-inline .checkbox label {
    padding-left: 0;
  }
  .form-inline .radio input[type="radio"],
  .form-inline .checkbox input[type="checkbox"] {
    position: relative;
    margin-left: 0;
  }
  .form-inline .has-feedback .form-control-feedback {
    top: 0;
  }
}
.form-horizontal .radio,
.form-horizontal .checkbox,
.form-horizontal .radio-inline,
.form-horizontal .checkbox-inline {
  margin-top: 0;
  margin-bottom: 0;
  padding-top: 7px;
}
.form-horizontal .radio,
.form-horizontal .checkbox {
  min-height: 25px;
}
.form-horizontal .form-group {
  margin-left: 0px;
  margin-right: 0px;
}
@media (min-width: 768px) {
  .form-horizontal .control-label {
    text-align: right;
    margin-bottom: 0;
    padding-top: 7px;
  }
}
.form-horizontal .has-feedback .form-control-feedback {
  right: 0px;
}
@media (min-width: 768px) {
  .form-horizontal .form-group-lg .control-label {
    padding-top: 11px;
    font-size: 17px;
  }
}
@media (min-width: 768px) {
  .form-horizontal .form-group-sm .control-label {
    padding-top: 6px;
    font-size: 12px;
  }
}
.btn {
  display: inline-block;
  margin-bottom: 0;
  font-weight: normal;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  background-image: none;
  border: 1px solid transparent;
  white-space: nowrap;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.btn:focus,
.btn:active:focus,
.btn.active:focus,
.btn.focus,
.btn:active.focus,
.btn.active.focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
.btn:hover,
.btn:focus,
.btn.focus {
  color: #333;
  text-decoration: none;
}
.btn:active,
.btn.active {
  outline: 0;
  background-image: none;
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn.disabled,
.btn[disabled],
fieldset[disabled] .btn {
  cursor: not-allowed;
  opacity: 0.65;
  filter: alpha(opacity=65);
  -webkit-box-shadow: none;
  box-shadow: none;
}
a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}
.btn-default {
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
.btn-default:focus,
.btn-default.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
.btn-default:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.btn-default:active,
.btn-default.active,
.open > .dropdown-toggle.btn-default {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.btn-default:active:hover,
.btn-default.active:hover,
.open > .dropdown-toggle.btn-default:hover,
.btn-default:active:focus,
.btn-default.active:focus,
.open > .dropdown-toggle.btn-default:focus,
.btn-default:active.focus,
.btn-default.active.focus,
.open > .dropdown-toggle.btn-default.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
.btn-default:active,
.btn-default.active,
.open > .dropdown-toggle.btn-default {
  background-image: none;
}
.btn-default.disabled:hover,
.btn-default[disabled]:hover,
fieldset[disabled] .btn-default:hover,
.btn-default.disabled:focus,
.btn-default[disabled]:focus,
fieldset[disabled] .btn-default:focus,
.btn-default.disabled.focus,
.btn-default[disabled].focus,
fieldset[disabled] .btn-default.focus {
  background-color: #fff;
  border-color: #ccc;
}
.btn-default .badge {
  color: #fff;
  background-color: #333;
}
.btn-primary {
  color: #fff;
  background-color: #337ab7;
  border-color: #2e6da4;
}
.btn-primary:focus,
.btn-primary.focus {
  color: #fff;
  background-color: #286090;
  border-color: #122b40;
}
.btn-primary:hover {
  color: #fff;
  background-color: #286090;
  border-color: #204d74;
}
.btn-primary:active,
.btn-primary.active,
.open > .dropdown-toggle.btn-primary {
  color: #fff;
  background-color: #286090;
  border-color: #204d74;
}
.btn-primary:active:hover,
.btn-primary.active:hover,
.open > .dropdown-toggle.btn-primary:hover,
.btn-primary:active:focus,
.btn-primary.active:focus,
.open > .dropdown-toggle.btn-primary:focus,
.btn-primary:active.focus,
.btn-primary.active.focus,
.open > .dropdown-toggle.btn-primary.focus {
  color: #fff;
  background-color: #204d74;
  border-color: #122b40;
}
.btn-primary:active,
.btn-primary.active,
.open > .dropdown-toggle.btn-primary {
  background-image: none;
}
.btn-primary.disabled:hover,
.btn-primary[disabled]:hover,
fieldset[disabled] .btn-primary:hover,
.btn-primary.disabled:focus,
.btn-primary[disabled]:focus,
fieldset[disabled] .btn-primary:focus,
.btn-primary.disabled.focus,
.btn-primary[disabled].focus,
fieldset[disabled] .btn-primary.focus {
  background-color: #337ab7;
  border-color: #2e6da4;
}
.btn-primary .badge {
  color: #337ab7;
  background-color: #fff;
}
.btn-success {
  color: #fff;
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.btn-success:focus,
.btn-success.focus {
  color: #fff;
  background-color: #449d44;
  border-color: #255625;
}
.btn-success:hover {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.btn-success:active,
.btn-success.active,
.open > .dropdown-toggle.btn-success {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.btn-success:active:hover,
.btn-success.active:hover,
.open > .dropdown-toggle.btn-success:hover,
.btn-success:active:focus,
.btn-success.active:focus,
.open > .dropdown-toggle.btn-success:focus,
.btn-success:active.focus,
.btn-success.active.focus,
.open > .dropdown-toggle.btn-success.focus {
  color: #fff;
  background-color: #398439;
  border-color: #255625;
}
.btn-success:active,
.btn-success.active,
.open > .dropdown-toggle.btn-success {
  background-image: none;
}
.btn-success.disabled:hover,
.btn-success[disabled]:hover,
fieldset[disabled] .btn-success:hover,
.btn-success.disabled:focus,
.btn-success[disabled]:focus,
fieldset[disabled] .btn-success:focus,
.btn-success.disabled.focus,
.btn-success[disabled].focus,
fieldset[disabled] .btn-success.focus {
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.btn-success .badge {
  color: #5cb85c;
  background-color: #fff;
}
.btn-info {
  color: #fff;
  background-color: #5bc0de;
  border-color: #46b8da;
}
.btn-info:focus,
.btn-info.focus {
  color: #fff;
  background-color: #31b0d5;
  border-color: #1b6d85;
}
.btn-info:hover {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.btn-info:active,
.btn-info.active,
.open > .dropdown-toggle.btn-info {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.btn-info:active:hover,
.btn-info.active:hover,
.open > .dropdown-toggle.btn-info:hover,
.btn-info:active:focus,
.btn-info.active:focus,
.open > .dropdown-toggle.btn-info:focus,
.btn-info:active.focus,
.btn-info.active.focus,
.open > .dropdown-toggle.btn-info.focus {
  color: #fff;
  background-color: #269abc;
  border-color: #1b6d85;
}
.btn-info:active,
.btn-info.active,
.open > .dropdown-toggle.btn-info {
  background-image: none;
}
.btn-info.disabled:hover,
.btn-info[disabled]:hover,
fieldset[disabled] .btn-info:hover,
.btn-info.disabled:focus,
.btn-info[disabled]:focus,
fieldset[disabled] .btn-info:focus,
.btn-info.disabled.focus,
.btn-info[disabled].focus,
fieldset[disabled] .btn-info.focus {
  background-color: #5bc0de;
  border-color: #46b8da;
}
.btn-info .badge {
  color: #5bc0de;
  background-color: #fff;
}
.btn-warning {
  color: #fff;
  background-color: #f0ad4e;
  border-color: #eea236;
}
.btn-warning:focus,
.btn-warning.focus {
  color: #fff;
  background-color: #ec971f;
  border-color: #985f0d;
}
.btn-warning:hover {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.btn-warning:active,
.btn-warning.active,
.open > .dropdown-toggle.btn-warning {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.btn-warning:active:hover,
.btn-warning.active:hover,
.open > .dropdown-toggle.btn-warning:hover,
.btn-warning:active:focus,
.btn-warning.active:focus,
.open > .dropdown-toggle.btn-warning:focus,
.btn-warning:active.focus,
.btn-warning.active.focus,
.open > .dropdown-toggle.btn-warning.focus {
  color: #fff;
  background-color: #d58512;
  border-color: #985f0d;
}
.btn-warning:active,
.btn-warning.active,
.open > .dropdown-toggle.btn-warning {
  background-image: none;
}
.btn-warning.disabled:hover,
.btn-warning[disabled]:hover,
fieldset[disabled] .btn-warning:hover,
.btn-warning.disabled:focus,
.btn-warning[disabled]:focus,
fieldset[disabled] .btn-warning:focus,
.btn-warning.disabled.focus,
.btn-warning[disabled].focus,
fieldset[disabled] .btn-warning.focus {
  background-color: #f0ad4e;
  border-color: #eea236;
}
.btn-warning .badge {
  color: #f0ad4e;
  background-color: #fff;
}
.btn-danger {
  color: #fff;
  background-color: #d9534f;
  border-color: #d43f3a;
}
.btn-danger:focus,
.btn-danger.focus {
  color: #fff;
  background-color: #c9302c;
  border-color: #761c19;
}
.btn-danger:hover {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.btn-danger:active,
.btn-danger.active,
.open > .dropdown-toggle.btn-danger {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.btn-danger:active:hover,
.btn-danger.active:hover,
.open > .dropdown-toggle.btn-danger:hover,
.btn-danger:active:focus,
.btn-danger.active:focus,
.open > .dropdown-toggle.btn-danger:focus,
.btn-danger:active.focus,
.btn-danger.active.focus,
.open > .dropdown-toggle.btn-danger.focus {
  color: #fff;
  background-color: #ac2925;
  border-color: #761c19;
}
.btn-danger:active,
.btn-danger.active,
.open > .dropdown-toggle.btn-danger {
  background-image: none;
}
.btn-danger.disabled:hover,
.btn-danger[disabled]:hover,
fieldset[disabled] .btn-danger:hover,
.btn-danger.disabled:focus,
.btn-danger[disabled]:focus,
fieldset[disabled] .btn-danger:focus,
.btn-danger.disabled.focus,
.btn-danger[disabled].focus,
fieldset[disabled] .btn-danger.focus {
  background-color: #d9534f;
  border-color: #d43f3a;
}
.btn-danger .badge {
  color: #d9534f;
  background-color: #fff;
}
.btn-link {
  color: #337ab7;
  font-weight: normal;
  border-radius: 0;
}
.btn-link,
.btn-link:active,
.btn-link.active,
.btn-link[disabled],
fieldset[disabled] .btn-link {
  background-color: transparent;
  -webkit-box-shadow: none;
  box-shadow: none;
}
.btn-link,
.btn-link:hover,
.btn-link:focus,
.btn-link:active {
  border-color: transparent;
}
.btn-link:hover,
.btn-link:focus {
  color: #23527c;
  text-decoration: underline;
  background-color: transparent;
}
.btn-link[disabled]:hover,
fieldset[disabled] .btn-link:hover,
.btn-link[disabled]:focus,
fieldset[disabled] .btn-link:focus {
  color: #777777;
  text-decoration: none;
}
.btn-lg,
.btn-group-lg > .btn {
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
.btn-sm,
.btn-group-sm > .btn {
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.btn-xs,
.btn-group-xs > .btn {
  padding: 1px 5px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
.btn-block {
  display: block;
  width: 100%;
}
.btn-block + .btn-block {
  margin-top: 5px;
}
input[type="submit"].btn-block,
input[type="reset"].btn-block,
input[type="button"].btn-block {
  width: 100%;
}
.fade {
  opacity: 0;
  -webkit-transition: opacity 0.15s linear;
  -o-transition: opacity 0.15s linear;
  transition: opacity 0.15s linear;
}
.fade.in {
  opacity: 1;
}
.collapse {
  display: none;
}
.collapse.in {
  display: block;
}
tr.collapse.in {
  display: table-row;
}
tbody.collapse.in {
  display: table-row-group;
}
.collapsing {
  position: relative;
  height: 0;
  overflow: hidden;
  -webkit-transition-property: height, visibility;
  transition-property: height, visibility;
  -webkit-transition-duration: 0.35s;
  transition-duration: 0.35s;
  -webkit-transition-timing-function: ease;
  transition-timing-function: ease;
}
.caret {
  display: inline-block;
  width: 0;
  height: 0;
  margin-left: 2px;
  vertical-align: middle;
  border-top: 4px dashed;
  border-top: 4px solid \9;
  border-right: 4px solid transparent;
  border-left: 4px solid transparent;
}
.dropup,
.dropdown {
  position: relative;
}
.dropdown-toggle:focus {
  outline: 0;
}
.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 1000;
  display: none;
  float: left;
  min-width: 160px;
  padding: 5px 0;
  margin: 2px 0 0;
  list-style: none;
  font-size: 13px;
  text-align: left;
  background-color: #fff;
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.15);
  border-radius: 2px;
  -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);
  background-clip: padding-box;
}
.dropdown-menu.pull-right {
  right: 0;
  left: auto;
}
.dropdown-menu .divider {
  height: 1px;
  margin: 8px 0;
  overflow: hidden;
  background-color: #e5e5e5;
}
.dropdown-menu > li > a {
  display: block;
  padding: 3px 20px;
  clear: both;
  font-weight: normal;
  line-height: 1.42857143;
  color: #333333;
  white-space: nowrap;
}
.dropdown-menu > li > a:hover,
.dropdown-menu > li > a:focus {
  text-decoration: none;
  color: #262626;
  background-color: #f5f5f5;
}
.dropdown-menu > .active > a,
.dropdown-menu > .active > a:hover,
.dropdown-menu > .active > a:focus {
  color: #fff;
  text-decoration: none;
  outline: 0;
  background-color: #337ab7;
}
.dropdown-menu > .disabled > a,
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  color: #777777;
}
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  text-decoration: none;
  background-color: transparent;
  background-image: none;
  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
  cursor: not-allowed;
}
.open > .dropdown-menu {
  display: block;
}
.open > a {
  outline: 0;
}
.dropdown-menu-right {
  left: auto;
  right: 0;
}
.dropdown-menu-left {
  left: 0;
  right: auto;
}
.dropdown-header {
  display: block;
  padding: 3px 20px;
  font-size: 12px;
  line-height: 1.42857143;
  color: #777777;
  white-space: nowrap;
}
.dropdown-backdrop {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  z-index: 990;
}
.pull-right > .dropdown-menu {
  right: 0;
  left: auto;
}
.dropup .caret,
.navbar-fixed-bottom .dropdown .caret {
  border-top: 0;
  border-bottom: 4px dashed;
  border-bottom: 4px solid \9;
  content: "";
}
.dropup .dropdown-menu,
.navbar-fixed-bottom .dropdown .dropdown-menu {
  top: auto;
  bottom: 100%;
  margin-bottom: 2px;
}
@media (min-width: 541px) {
  .navbar-right .dropdown-menu {
    left: auto;
    right: 0;
  }
  .navbar-right .dropdown-menu-left {
    left: 0;
    right: auto;
  }
}
.btn-group,
.btn-group-vertical {
  position: relative;
  display: inline-block;
  vertical-align: middle;
}
.btn-group > .btn,
.btn-group-vertical > .btn {
  position: relative;
  float: left;
}
.btn-group > .btn:hover,
.btn-group-vertical > .btn:hover,
.btn-group > .btn:focus,
.btn-group-vertical > .btn:focus,
.btn-group > .btn:active,
.btn-group-vertical > .btn:active,
.btn-group > .btn.active,
.btn-group-vertical > .btn.active {
  z-index: 2;
}
.btn-group .btn + .btn,
.btn-group .btn + .btn-group,
.btn-group .btn-group + .btn,
.btn-group .btn-group + .btn-group {
  margin-left: -1px;
}
.btn-toolbar {
  margin-left: -5px;
}
.btn-toolbar .btn,
.btn-toolbar .btn-group,
.btn-toolbar .input-group {
  float: left;
}
.btn-toolbar > .btn,
.btn-toolbar > .btn-group,
.btn-toolbar > .input-group {
  margin-left: 5px;
}
.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}
.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.btn-group > .btn-group {
  float: left;
}
.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.btn-group .dropdown-toggle:active,
.btn-group.open .dropdown-toggle {
  outline: 0;
}
.btn-group > .btn + .dropdown-toggle {
  padding-left: 8px;
  padding-right: 8px;
}
.btn-group > .btn-lg + .dropdown-toggle {
  padding-left: 12px;
  padding-right: 12px;
}
.btn-group.open .dropdown-toggle {
  -webkit-box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn-group.open .dropdown-toggle.btn-link {
  -webkit-box-shadow: none;
  box-shadow: none;
}
.btn .caret {
  margin-left: 0;
}
.btn-lg .caret {
  border-width: 5px 5px 0;
  border-bottom-width: 0;
}
.dropup .btn-lg .caret {
  border-width: 0 5px 5px;
}
.btn-group-vertical > .btn,
.btn-group-vertical > .btn-group,
.btn-group-vertical > .btn-group > .btn {
  display: block;
  float: none;
  width: 100%;
  max-width: 100%;
}
.btn-group-vertical > .btn-group > .btn {
  float: none;
}
.btn-group-vertical > .btn + .btn,
.btn-group-vertical > .btn + .btn-group,
.btn-group-vertical > .btn-group + .btn,
.btn-group-vertical > .btn-group + .btn-group {
  margin-top: -1px;
  margin-left: 0;
}
.btn-group-vertical > .btn:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.btn-group-vertical > .btn:first-child:not(:last-child) {
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn:last-child:not(:first-child) {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
}
.btn-group-vertical > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group-vertical > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group-vertical > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.btn-group-justified {
  display: table;
  width: 100%;
  table-layout: fixed;
  border-collapse: separate;
}
.btn-group-justified > .btn,
.btn-group-justified > .btn-group {
  float: none;
  display: table-cell;
  width: 1%;
}
.btn-group-justified > .btn-group .btn {
  width: 100%;
}
.btn-group-justified > .btn-group .dropdown-menu {
  left: auto;
}
[data-toggle="buttons"] > .btn input[type="radio"],
[data-toggle="buttons"] > .btn-group > .btn input[type="radio"],
[data-toggle="buttons"] > .btn input[type="checkbox"],
[data-toggle="buttons"] > .btn-group > .btn input[type="checkbox"] {
  position: absolute;
  clip: rect(0, 0, 0, 0);
  pointer-events: none;
}
.input-group {
  position: relative;
  display: table;
  border-collapse: separate;
}
.input-group[class*="col-"] {
  float: none;
  padding-left: 0;
  padding-right: 0;
}
.input-group .form-control {
  position: relative;
  z-index: 2;
  float: left;
  width: 100%;
  margin-bottom: 0;
}
.input-group .form-control:focus {
  z-index: 3;
}
.input-group-lg > .form-control,
.input-group-lg > .input-group-addon,
.input-group-lg > .input-group-btn > .btn {
  height: 45px;
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
  border-radius: 3px;
}
select.input-group-lg > .form-control,
select.input-group-lg > .input-group-addon,
select.input-group-lg > .input-group-btn > .btn {
  height: 45px;
  line-height: 45px;
}
textarea.input-group-lg > .form-control,
textarea.input-group-lg > .input-group-addon,
textarea.input-group-lg > .input-group-btn > .btn,
select[multiple].input-group-lg > .form-control,
select[multiple].input-group-lg > .input-group-addon,
select[multiple].input-group-lg > .input-group-btn > .btn {
  height: auto;
}
.input-group-sm > .form-control,
.input-group-sm > .input-group-addon,
.input-group-sm > .input-group-btn > .btn {
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
}
select.input-group-sm > .form-control,
select.input-group-sm > .input-group-addon,
select.input-group-sm > .input-group-btn > .btn {
  height: 30px;
  line-height: 30px;
}
textarea.input-group-sm > .form-control,
textarea.input-group-sm > .input-group-addon,
textarea.input-group-sm > .input-group-btn > .btn,
select[multiple].input-group-sm > .form-control,
select[multiple].input-group-sm > .input-group-addon,
select[multiple].input-group-sm > .input-group-btn > .btn {
  height: auto;
}
.input-group-addon,
.input-group-btn,
.input-group .form-control {
  display: table-cell;
}
.input-group-addon:not(:first-child):not(:last-child),
.input-group-btn:not(:first-child):not(:last-child),
.input-group .form-control:not(:first-child):not(:last-child) {
  border-radius: 0;
}
.input-group-addon,
.input-group-btn {
  width: 1%;
  white-space: nowrap;
  vertical-align: middle;
}
.input-group-addon {
  padding: 6px 12px;
  font-size: 13px;
  font-weight: normal;
  line-height: 1;
  color: #555555;
  text-align: center;
  background-color: #eeeeee;
  border: 1px solid #ccc;
  border-radius: 2px;
}
.input-group-addon.input-sm {
  padding: 5px 10px;
  font-size: 12px;
  border-radius: 1px;
}
.input-group-addon.input-lg {
  padding: 10px 16px;
  font-size: 17px;
  border-radius: 3px;
}
.input-group-addon input[type="radio"],
.input-group-addon input[type="checkbox"] {
  margin-top: 0;
}
.input-group .form-control:first-child,
.input-group-addon:first-child,
.input-group-btn:first-child > .btn,
.input-group-btn:first-child > .btn-group > .btn,
.input-group-btn:first-child > .dropdown-toggle,
.input-group-btn:last-child > .btn:not(:last-child):not(.dropdown-toggle),
.input-group-btn:last-child > .btn-group:not(:last-child) > .btn {
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
}
.input-group-addon:first-child {
  border-right: 0;
}
.input-group .form-control:last-child,
.input-group-addon:last-child,
.input-group-btn:last-child > .btn,
.input-group-btn:last-child > .btn-group > .btn,
.input-group-btn:last-child > .dropdown-toggle,
.input-group-btn:first-child > .btn:not(:first-child),
.input-group-btn:first-child > .btn-group:not(:first-child) > .btn {
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
}
.input-group-addon:last-child {
  border-left: 0;
}
.input-group-btn {
  position: relative;
  font-size: 0;
  white-space: nowrap;
}
.input-group-btn > .btn {
  position: relative;
}
.input-group-btn > .btn + .btn {
  margin-left: -1px;
}
.input-group-btn > .btn:hover,
.input-group-btn > .btn:focus,
.input-group-btn > .btn:active {
  z-index: 2;
}
.input-group-btn:first-child > .btn,
.input-group-btn:first-child > .btn-group {
  margin-right: -1px;
}
.input-group-btn:last-child > .btn,
.input-group-btn:last-child > .btn-group {
  z-index: 2;
  margin-left: -1px;
}
.nav {
  margin-bottom: 0;
  padding-left: 0;
  list-style: none;
}
.nav > li {
  position: relative;
  display: block;
}
.nav > li > a {
  position: relative;
  display: block;
  padding: 10px 15px;
}
.nav > li > a:hover,
.nav > li > a:focus {
  text-decoration: none;
  background-color: #eeeeee;
}
.nav > li.disabled > a {
  color: #777777;
}
.nav > li.disabled > a:hover,
.nav > li.disabled > a:focus {
  color: #777777;
  text-decoration: none;
  background-color: transparent;
  cursor: not-allowed;
}
.nav .open > a,
.nav .open > a:hover,
.nav .open > a:focus {
  background-color: #eeeeee;
  border-color: #337ab7;
}
.nav .nav-divider {
  height: 1px;
  margin: 8px 0;
  overflow: hidden;
  background-color: #e5e5e5;
}
.nav > li > a > img {
  max-width: none;
}
.nav-tabs {
  border-bottom: 1px solid #ddd;
}
.nav-tabs > li {
  float: left;
  margin-bottom: -1px;
}
.nav-tabs > li > a {
  margin-right: 2px;
  line-height: 1.42857143;
  border: 1px solid transparent;
  border-radius: 2px 2px 0 0;
}
.nav-tabs > li > a:hover {
  border-color: #eeeeee #eeeeee #ddd;
}
.nav-tabs > li.active > a,
.nav-tabs > li.active > a:hover,
.nav-tabs > li.active > a:focus {
  color: #555555;
  background-color: #fff;
  border: 1px solid #ddd;
  border-bottom-color: transparent;
  cursor: default;
}
.nav-tabs.nav-justified {
  width: 100%;
  border-bottom: 0;
}
.nav-tabs.nav-justified > li {
  float: none;
}
.nav-tabs.nav-justified > li > a {
  text-align: center;
  margin-bottom: 5px;
}
.nav-tabs.nav-justified > .dropdown .dropdown-menu {
  top: auto;
  left: auto;
}
@media (min-width: 768px) {
  .nav-tabs.nav-justified > li {
    display: table-cell;
    width: 1%;
  }
  .nav-tabs.nav-justified > li > a {
    margin-bottom: 0;
  }
}
.nav-tabs.nav-justified > li > a {
  margin-right: 0;
  border-radius: 2px;
}
.nav-tabs.nav-justified > .active > a,
.nav-tabs.nav-justified > .active > a:hover,
.nav-tabs.nav-justified > .active > a:focus {
  border: 1px solid #ddd;
}
@media (min-width: 768px) {
  .nav-tabs.nav-justified > li > a {
    border-bottom: 1px solid #ddd;
    border-radius: 2px 2px 0 0;
  }
  .nav-tabs.nav-justified > .active > a,
  .nav-tabs.nav-justified > .active > a:hover,
  .nav-tabs.nav-justified > .active > a:focus {
    border-bottom-color: #fff;
  }
}
.nav-pills > li {
  float: left;
}
.nav-pills > li > a {
  border-radius: 2px;
}
.nav-pills > li + li {
  margin-left: 2px;
}
.nav-pills > li.active > a,
.nav-pills > li.active > a:hover,
.nav-pills > li.active > a:focus {
  color: #fff;
  background-color: #337ab7;
}
.nav-stacked > li {
  float: none;
}
.nav-stacked > li + li {
  margin-top: 2px;
  margin-left: 0;
}
.nav-justified {
  width: 100%;
}
.nav-justified > li {
  float: none;
}
.nav-justified > li > a {
  text-align: center;
  margin-bottom: 5px;
}
.nav-justified > .dropdown .dropdown-menu {
  top: auto;
  left: auto;
}
@media (min-width: 768px) {
  .nav-justified > li {
    display: table-cell;
    width: 1%;
  }
  .nav-justified > li > a {
    margin-bottom: 0;
  }
}
.nav-tabs-justified {
  border-bottom: 0;
}
.nav-tabs-justified > li > a {
  margin-right: 0;
  border-radius: 2px;
}
.nav-tabs-justified > .active > a,
.nav-tabs-justified > .active > a:hover,
.nav-tabs-justified > .active > a:focus {
  border: 1px solid #ddd;
}
@media (min-width: 768px) {
  .nav-tabs-justified > li > a {
    border-bottom: 1px solid #ddd;
    border-radius: 2px 2px 0 0;
  }
  .nav-tabs-justified > .active > a,
  .nav-tabs-justified > .active > a:hover,
  .nav-tabs-justified > .active > a:focus {
    border-bottom-color: #fff;
  }
}
.tab-content > .tab-pane {
  display: none;
}
.tab-content > .active {
  display: block;
}
.nav-tabs .dropdown-menu {
  margin-top: -1px;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.navbar {
  position: relative;
  min-height: 30px;
  margin-bottom: 18px;
  border: 1px solid transparent;
}
@media (min-width: 541px) {
  .navbar {
    border-radius: 2px;
  }
}
@media (min-width: 541px) {
  .navbar-header {
    float: left;
  }
}
.navbar-collapse {
  overflow-x: visible;
  padding-right: 0px;
  padding-left: 0px;
  border-top: 1px solid transparent;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
  -webkit-overflow-scrolling: touch;
}
.navbar-collapse.in {
  overflow-y: auto;
}
@media (min-width: 541px) {
  .navbar-collapse {
    width: auto;
    border-top: 0;
    box-shadow: none;
  }
  .navbar-collapse.collapse {
    display: block !important;
    height: auto !important;
    padding-bottom: 0;
    overflow: visible !important;
  }
  .navbar-collapse.in {
    overflow-y: visible;
  }
  .navbar-fixed-top .navbar-collapse,
  .navbar-static-top .navbar-collapse,
  .navbar-fixed-bottom .navbar-collapse {
    padding-left: 0;
    padding-right: 0;
  }
}
.navbar-fixed-top .navbar-collapse,
.navbar-fixed-bottom .navbar-collapse {
  max-height: 340px;
}
@media (max-device-width: 540px) and (orientation: landscape) {
  .navbar-fixed-top .navbar-collapse,
  .navbar-fixed-bottom .navbar-collapse {
    max-height: 200px;
  }
}
.container > .navbar-header,
.container-fluid > .navbar-header,
.container > .navbar-collapse,
.container-fluid > .navbar-collapse {
  margin-right: 0px;
  margin-left: 0px;
}
@media (min-width: 541px) {
  .container > .navbar-header,
  .container-fluid > .navbar-header,
  .container > .navbar-collapse,
  .container-fluid > .navbar-collapse {
    margin-right: 0;
    margin-left: 0;
  }
}
.navbar-static-top {
  z-index: 1000;
  border-width: 0 0 1px;
}
@media (min-width: 541px) {
  .navbar-static-top {
    border-radius: 0;
  }
}
.navbar-fixed-top,
.navbar-fixed-bottom {
  position: fixed;
  right: 0;
  left: 0;
  z-index: 1030;
}
@media (min-width: 541px) {
  .navbar-fixed-top,
  .navbar-fixed-bottom {
    border-radius: 0;
  }
}
.navbar-fixed-top {
  top: 0;
  border-width: 0 0 1px;
}
.navbar-fixed-bottom {
  bottom: 0;
  margin-bottom: 0;
  border-width: 1px 0 0;
}
.navbar-brand {
  float: left;
  padding: 6px 0px;
  font-size: 17px;
  line-height: 18px;
  height: 30px;
}
.navbar-brand:hover,
.navbar-brand:focus {
  text-decoration: none;
}
.navbar-brand > img {
  display: block;
}
@media (min-width: 541px) {
  .navbar > .container .navbar-brand,
  .navbar > .container-fluid .navbar-brand {
    margin-left: 0px;
  }
}
.navbar-toggle {
  position: relative;
  float: right;
  margin-right: 0px;
  padding: 9px 10px;
  margin-top: -2px;
  margin-bottom: -2px;
  background-color: transparent;
  background-image: none;
  border: 1px solid transparent;
  border-radius: 2px;
}
.navbar-toggle:focus {
  outline: 0;
}
.navbar-toggle .icon-bar {
  display: block;
  width: 22px;
  height: 2px;
  border-radius: 1px;
}
.navbar-toggle .icon-bar + .icon-bar {
  margin-top: 4px;
}
@media (min-width: 541px) {
  .navbar-toggle {
    display: none;
  }
}
.navbar-nav {
  margin: 3px 0px;
}
.navbar-nav > li > a {
  padding-top: 10px;
  padding-bottom: 10px;
  line-height: 18px;
}
@media (max-width: 540px) {
  .navbar-nav .open .dropdown-menu {
    position: static;
    float: none;
    width: auto;
    margin-top: 0;
    background-color: transparent;
    border: 0;
    box-shadow: none;
  }
  .navbar-nav .open .dropdown-menu > li > a,
  .navbar-nav .open .dropdown-menu .dropdown-header {
    padding: 5px 15px 5px 25px;
  }
  .navbar-nav .open .dropdown-menu > li > a {
    line-height: 18px;
  }
  .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-nav .open .dropdown-menu > li > a:focus {
    background-image: none;
  }
}
@media (min-width: 541px) {
  .navbar-nav {
    float: left;
    margin: 0;
  }
  .navbar-nav > li {
    float: left;
  }
  .navbar-nav > li > a {
    padding-top: 6px;
    padding-bottom: 6px;
  }
}
.navbar-form {
  margin-left: 0px;
  margin-right: 0px;
  padding: 10px 0px;
  border-top: 1px solid transparent;
  border-bottom: 1px solid transparent;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 0 rgba(255, 255, 255, 0.1);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1), 0 1px 0 rgba(255, 255, 255, 0.1);
  margin-top: -1px;
  margin-bottom: -1px;
}
@media (min-width: 768px) {
  .navbar-form .form-group {
    display: inline-block;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .form-control {
    display: inline-block;
    width: auto;
    vertical-align: middle;
  }
  .navbar-form .form-control-static {
    display: inline-block;
  }
  .navbar-form .input-group {
    display: inline-table;
    vertical-align: middle;
  }
  .navbar-form .input-group .input-group-addon,
  .navbar-form .input-group .input-group-btn,
  .navbar-form .input-group .form-control {
    width: auto;
  }
  .navbar-form .input-group > .form-control {
    width: 100%;
  }
  .navbar-form .control-label {
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .radio,
  .navbar-form .checkbox {
    display: inline-block;
    margin-top: 0;
    margin-bottom: 0;
    vertical-align: middle;
  }
  .navbar-form .radio label,
  .navbar-form .checkbox label {
    padding-left: 0;
  }
  .navbar-form .radio input[type="radio"],
  .navbar-form .checkbox input[type="checkbox"] {
    position: relative;
    margin-left: 0;
  }
  .navbar-form .has-feedback .form-control-feedback {
    top: 0;
  }
}
@media (max-width: 540px) {
  .navbar-form .form-group {
    margin-bottom: 5px;
  }
  .navbar-form .form-group:last-child {
    margin-bottom: 0;
  }
}
@media (min-width: 541px) {
  .navbar-form {
    width: auto;
    border: 0;
    margin-left: 0;
    margin-right: 0;
    padding-top: 0;
    padding-bottom: 0;
    -webkit-box-shadow: none;
    box-shadow: none;
  }
}
.navbar-nav > li > .dropdown-menu {
  margin-top: 0;
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.navbar-fixed-bottom .navbar-nav > li > .dropdown-menu {
  margin-bottom: 0;
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.navbar-btn {
  margin-top: -1px;
  margin-bottom: -1px;
}
.navbar-btn.btn-sm {
  margin-top: 0px;
  margin-bottom: 0px;
}
.navbar-btn.btn-xs {
  margin-top: 4px;
  margin-bottom: 4px;
}
.navbar-text {
  margin-top: 6px;
  margin-bottom: 6px;
}
@media (min-width: 541px) {
  .navbar-text {
    float: left;
    margin-left: 0px;
    margin-right: 0px;
  }
}
@media (min-width: 541px) {
  .navbar-left {
    float: left !important;
    float: left;
  }
  .navbar-right {
    float: right !important;
    float: right;
    margin-right: 0px;
  }
  .navbar-right ~ .navbar-right {
    margin-right: 0;
  }
}
.navbar-default {
  background-color: #f8f8f8;
  border-color: #e7e7e7;
}
.navbar-default .navbar-brand {
  color: #777;
}
.navbar-default .navbar-brand:hover,
.navbar-default .navbar-brand:focus {
  color: #5e5e5e;
  background-color: transparent;
}
.navbar-default .navbar-text {
  color: #777;
}
.navbar-default .navbar-nav > li > a {
  color: #777;
}
.navbar-default .navbar-nav > li > a:hover,
.navbar-default .navbar-nav > li > a:focus {
  color: #333;
  background-color: transparent;
}
.navbar-default .navbar-nav > .active > a,
.navbar-default .navbar-nav > .active > a:hover,
.navbar-default .navbar-nav > .active > a:focus {
  color: #555;
  background-color: #e7e7e7;
}
.navbar-default .navbar-nav > .disabled > a,
.navbar-default .navbar-nav > .disabled > a:hover,
.navbar-default .navbar-nav > .disabled > a:focus {
  color: #ccc;
  background-color: transparent;
}
.navbar-default .navbar-toggle {
  border-color: #ddd;
}
.navbar-default .navbar-toggle:hover,
.navbar-default .navbar-toggle:focus {
  background-color: #ddd;
}
.navbar-default .navbar-toggle .icon-bar {
  background-color: #888;
}
.navbar-default .navbar-collapse,
.navbar-default .navbar-form {
  border-color: #e7e7e7;
}
.navbar-default .navbar-nav > .open > a,
.navbar-default .navbar-nav > .open > a:hover,
.navbar-default .navbar-nav > .open > a:focus {
  background-color: #e7e7e7;
  color: #555;
}
@media (max-width: 540px) {
  .navbar-default .navbar-nav .open .dropdown-menu > li > a {
    color: #777;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > li > a:focus {
    color: #333;
    background-color: transparent;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a,
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > .active > a:focus {
    color: #555;
    background-color: #e7e7e7;
  }
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a,
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:hover,
  .navbar-default .navbar-nav .open .dropdown-menu > .disabled > a:focus {
    color: #ccc;
    background-color: transparent;
  }
}
.navbar-default .navbar-link {
  color: #777;
}
.navbar-default .navbar-link:hover {
  color: #333;
}
.navbar-default .btn-link {
  color: #777;
}
.navbar-default .btn-link:hover,
.navbar-default .btn-link:focus {
  color: #333;
}
.navbar-default .btn-link[disabled]:hover,
fieldset[disabled] .navbar-default .btn-link:hover,
.navbar-default .btn-link[disabled]:focus,
fieldset[disabled] .navbar-default .btn-link:focus {
  color: #ccc;
}
.navbar-inverse {
  background-color: #222;
  border-color: #080808;
}
.navbar-inverse .navbar-brand {
  color: #9d9d9d;
}
.navbar-inverse .navbar-brand:hover,
.navbar-inverse .navbar-brand:focus {
  color: #fff;
  background-color: transparent;
}
.navbar-inverse .navbar-text {
  color: #9d9d9d;
}
.navbar-inverse .navbar-nav > li > a {
  color: #9d9d9d;
}
.navbar-inverse .navbar-nav > li > a:hover,
.navbar-inverse .navbar-nav > li > a:focus {
  color: #fff;
  background-color: transparent;
}
.navbar-inverse .navbar-nav > .active > a,
.navbar-inverse .navbar-nav > .active > a:hover,
.navbar-inverse .navbar-nav > .active > a:focus {
  color: #fff;
  background-color: #080808;
}
.navbar-inverse .navbar-nav > .disabled > a,
.navbar-inverse .navbar-nav > .disabled > a:hover,
.navbar-inverse .navbar-nav > .disabled > a:focus {
  color: #444;
  background-color: transparent;
}
.navbar-inverse .navbar-toggle {
  border-color: #333;
}
.navbar-inverse .navbar-toggle:hover,
.navbar-inverse .navbar-toggle:focus {
  background-color: #333;
}
.navbar-inverse .navbar-toggle .icon-bar {
  background-color: #fff;
}
.navbar-inverse .navbar-collapse,
.navbar-inverse .navbar-form {
  border-color: #101010;
}
.navbar-inverse .navbar-nav > .open > a,
.navbar-inverse .navbar-nav > .open > a:hover,
.navbar-inverse .navbar-nav > .open > a:focus {
  background-color: #080808;
  color: #fff;
}
@media (max-width: 540px) {
  .navbar-inverse .navbar-nav .open .dropdown-menu > .dropdown-header {
    border-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu .divider {
    background-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a {
    color: #9d9d9d;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > li > a:focus {
    color: #fff;
    background-color: transparent;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .active > a:focus {
    color: #fff;
    background-color: #080808;
  }
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:hover,
  .navbar-inverse .navbar-nav .open .dropdown-menu > .disabled > a:focus {
    color: #444;
    background-color: transparent;
  }
}
.navbar-inverse .navbar-link {
  color: #9d9d9d;
}
.navbar-inverse .navbar-link:hover {
  color: #fff;
}
.navbar-inverse .btn-link {
  color: #9d9d9d;
}
.navbar-inverse .btn-link:hover,
.navbar-inverse .btn-link:focus {
  color: #fff;
}
.navbar-inverse .btn-link[disabled]:hover,
fieldset[disabled] .navbar-inverse .btn-link:hover,
.navbar-inverse .btn-link[disabled]:focus,
fieldset[disabled] .navbar-inverse .btn-link:focus {
  color: #444;
}
.breadcrumb {
  padding: 8px 15px;
  margin-bottom: 18px;
  list-style: none;
  background-color: #f5f5f5;
  border-radius: 2px;
}
.breadcrumb > li {
  display: inline-block;
}
.breadcrumb > li + li:before {
  content: "/\00a0";
  padding: 0 5px;
  color: #5e5e5e;
}
.breadcrumb > .active {
  color: #777777;
}
.pagination {
  display: inline-block;
  padding-left: 0;
  margin: 18px 0;
  border-radius: 2px;
}
.pagination > li {
  display: inline;
}
.pagination > li > a,
.pagination > li > span {
  position: relative;
  float: left;
  padding: 6px 12px;
  line-height: 1.42857143;
  text-decoration: none;
  color: #337ab7;
  background-color: #fff;
  border: 1px solid #ddd;
  margin-left: -1px;
}
.pagination > li:first-child > a,
.pagination > li:first-child > span {
  margin-left: 0;
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.pagination > li:last-child > a,
.pagination > li:last-child > span {
  border-bottom-right-radius: 2px;
  border-top-right-radius: 2px;
}
.pagination > li > a:hover,
.pagination > li > span:hover,
.pagination > li > a:focus,
.pagination > li > span:focus {
  z-index: 2;
  color: #23527c;
  background-color: #eeeeee;
  border-color: #ddd;
}
.pagination > .active > a,
.pagination > .active > span,
.pagination > .active > a:hover,
.pagination > .active > span:hover,
.pagination > .active > a:focus,
.pagination > .active > span:focus {
  z-index: 3;
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
  cursor: default;
}
.pagination > .disabled > span,
.pagination > .disabled > span:hover,
.pagination > .disabled > span:focus,
.pagination > .disabled > a,
.pagination > .disabled > a:hover,
.pagination > .disabled > a:focus {
  color: #777777;
  background-color: #fff;
  border-color: #ddd;
  cursor: not-allowed;
}
.pagination-lg > li > a,
.pagination-lg > li > span {
  padding: 10px 16px;
  font-size: 17px;
  line-height: 1.3333333;
}
.pagination-lg > li:first-child > a,
.pagination-lg > li:first-child > span {
  border-bottom-left-radius: 3px;
  border-top-left-radius: 3px;
}
.pagination-lg > li:last-child > a,
.pagination-lg > li:last-child > span {
  border-bottom-right-radius: 3px;
  border-top-right-radius: 3px;
}
.pagination-sm > li > a,
.pagination-sm > li > span {
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
}
.pagination-sm > li:first-child > a,
.pagination-sm > li:first-child > span {
  border-bottom-left-radius: 1px;
  border-top-left-radius: 1px;
}
.pagination-sm > li:last-child > a,
.pagination-sm > li:last-child > span {
  border-bottom-right-radius: 1px;
  border-top-right-radius: 1px;
}
.pager {
  padding-left: 0;
  margin: 18px 0;
  list-style: none;
  text-align: center;
}
.pager li {
  display: inline;
}
.pager li > a,
.pager li > span {
  display: inline-block;
  padding: 5px 14px;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 15px;
}
.pager li > a:hover,
.pager li > a:focus {
  text-decoration: none;
  background-color: #eeeeee;
}
.pager .next > a,
.pager .next > span {
  float: right;
}
.pager .previous > a,
.pager .previous > span {
  float: left;
}
.pager .disabled > a,
.pager .disabled > a:hover,
.pager .disabled > a:focus,
.pager .disabled > span {
  color: #777777;
  background-color: #fff;
  cursor: not-allowed;
}
.label {
  display: inline;
  padding: .2em .6em .3em;
  font-size: 75%;
  font-weight: bold;
  line-height: 1;
  color: #fff;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: .25em;
}
a.label:hover,
a.label:focus {
  color: #fff;
  text-decoration: none;
  cursor: pointer;
}
.label:empty {
  display: none;
}
.btn .label {
  position: relative;
  top: -1px;
}
.label-default {
  background-color: #777777;
}
.label-default[href]:hover,
.label-default[href]:focus {
  background-color: #5e5e5e;
}
.label-primary {
  background-color: #337ab7;
}
.label-primary[href]:hover,
.label-primary[href]:focus {
  background-color: #286090;
}
.label-success {
  background-color: #5cb85c;
}
.label-success[href]:hover,
.label-success[href]:focus {
  background-color: #449d44;
}
.label-info {
  background-color: #5bc0de;
}
.label-info[href]:hover,
.label-info[href]:focus {
  background-color: #31b0d5;
}
.label-warning {
  background-color: #f0ad4e;
}
.label-warning[href]:hover,
.label-warning[href]:focus {
  background-color: #ec971f;
}
.label-danger {
  background-color: #d9534f;
}
.label-danger[href]:hover,
.label-danger[href]:focus {
  background-color: #c9302c;
}
.badge {
  display: inline-block;
  min-width: 10px;
  padding: 3px 7px;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  line-height: 1;
  vertical-align: middle;
  white-space: nowrap;
  text-align: center;
  background-color: #777777;
  border-radius: 10px;
}
.badge:empty {
  display: none;
}
.btn .badge {
  position: relative;
  top: -1px;
}
.btn-xs .badge,
.btn-group-xs > .btn .badge {
  top: 0;
  padding: 1px 5px;
}
a.badge:hover,
a.badge:focus {
  color: #fff;
  text-decoration: none;
  cursor: pointer;
}
.list-group-item.active > .badge,
.nav-pills > .active > a > .badge {
  color: #337ab7;
  background-color: #fff;
}
.list-group-item > .badge {
  float: right;
}
.list-group-item > .badge + .badge {
  margin-right: 5px;
}
.nav-pills > li > a > .badge {
  margin-left: 3px;
}
.jumbotron {
  padding-top: 30px;
  padding-bottom: 30px;
  margin-bottom: 30px;
  color: inherit;
  background-color: #eeeeee;
}
.jumbotron h1,
.jumbotron .h1 {
  color: inherit;
}
.jumbotron p {
  margin-bottom: 15px;
  font-size: 20px;
  font-weight: 200;
}
.jumbotron > hr {
  border-top-color: #d5d5d5;
}
.container .jumbotron,
.container-fluid .jumbotron {
  border-radius: 3px;
  padding-left: 0px;
  padding-right: 0px;
}
.jumbotron .container {
  max-width: 100%;
}
@media screen and (min-width: 768px) {
  .jumbotron {
    padding-top: 48px;
    padding-bottom: 48px;
  }
  .container .jumbotron,
  .container-fluid .jumbotron {
    padding-left: 60px;
    padding-right: 60px;
  }
  .jumbotron h1,
  .jumbotron .h1 {
    font-size: 59px;
  }
}
.thumbnail {
  display: block;
  padding: 4px;
  margin-bottom: 18px;
  line-height: 1.42857143;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 2px;
  -webkit-transition: border 0.2s ease-in-out;
  -o-transition: border 0.2s ease-in-out;
  transition: border 0.2s ease-in-out;
}
.thumbnail > img,
.thumbnail a > img {
  margin-left: auto;
  margin-right: auto;
}
a.thumbnail:hover,
a.thumbnail:focus,
a.thumbnail.active {
  border-color: #337ab7;
}
.thumbnail .caption {
  padding: 9px;
  color: #000;
}
.alert {
  padding: 15px;
  margin-bottom: 18px;
  border: 1px solid transparent;
  border-radius: 2px;
}
.alert h4 {
  margin-top: 0;
  color: inherit;
}
.alert .alert-link {
  font-weight: bold;
}
.alert > p,
.alert > ul {
  margin-bottom: 0;
}
.alert > p + p {
  margin-top: 5px;
}
.alert-dismissable,
.alert-dismissible {
  padding-right: 35px;
}
.alert-dismissable .close,
.alert-dismissible .close {
  position: relative;
  top: -2px;
  right: -21px;
  color: inherit;
}
.alert-success {
  background-color: #dff0d8;
  border-color: #d6e9c6;
  color: #3c763d;
}
.alert-success hr {
  border-top-color: #c9e2b3;
}
.alert-success .alert-link {
  color: #2b542c;
}
.alert-info {
  background-color: #d9edf7;
  border-color: #bce8f1;
  color: #31708f;
}
.alert-info hr {
  border-top-color: #a6e1ec;
}
.alert-info .alert-link {
  color: #245269;
}
.alert-warning {
  background-color: #fcf8e3;
  border-color: #faebcc;
  color: #8a6d3b;
}
.alert-warning hr {
  border-top-color: #f7e1b5;
}
.alert-warning .alert-link {
  color: #66512c;
}
.alert-danger {
  background-color: #f2dede;
  border-color: #ebccd1;
  color: #a94442;
}
.alert-danger hr {
  border-top-color: #e4b9c0;
}
.alert-danger .alert-link {
  color: #843534;
}
@-webkit-keyframes progress-bar-stripes {
  from {
    background-position: 40px 0;
  }
  to {
    background-position: 0 0;
  }
}
@keyframes progress-bar-stripes {
  from {
    background-position: 40px 0;
  }
  to {
    background-position: 0 0;
  }
}
.progress {
  overflow: hidden;
  height: 18px;
  margin-bottom: 18px;
  background-color: #f5f5f5;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}
.progress-bar {
  float: left;
  width: 0%;
  height: 100%;
  font-size: 12px;
  line-height: 18px;
  color: #fff;
  text-align: center;
  background-color: #337ab7;
  -webkit-box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  -webkit-transition: width 0.6s ease;
  -o-transition: width 0.6s ease;
  transition: width 0.6s ease;
}
.progress-striped .progress-bar,
.progress-bar-striped {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-size: 40px 40px;
}
.progress.active .progress-bar,
.progress-bar.active {
  -webkit-animation: progress-bar-stripes 2s linear infinite;
  -o-animation: progress-bar-stripes 2s linear infinite;
  animation: progress-bar-stripes 2s linear infinite;
}
.progress-bar-success {
  background-color: #5cb85c;
}
.progress-striped .progress-bar-success {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-info {
  background-color: #5bc0de;
}
.progress-striped .progress-bar-info {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-warning {
  background-color: #f0ad4e;
}
.progress-striped .progress-bar-warning {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.progress-bar-danger {
  background-color: #d9534f;
}
.progress-striped .progress-bar-danger {
  background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
}
.media {
  margin-top: 15px;
}
.media:first-child {
  margin-top: 0;
}
.media,
.media-body {
  zoom: 1;
  overflow: hidden;
}
.media-body {
  width: 10000px;
}
.media-object {
  display: block;
}
.media-object.img-thumbnail {
  max-width: none;
}
.media-right,
.media > .pull-right {
  padding-left: 10px;
}
.media-left,
.media > .pull-left {
  padding-right: 10px;
}
.media-left,
.media-right,
.media-body {
  display: table-cell;
  vertical-align: top;
}
.media-middle {
  vertical-align: middle;
}
.media-bottom {
  vertical-align: bottom;
}
.media-heading {
  margin-top: 0;
  margin-bottom: 5px;
}
.media-list {
  padding-left: 0;
  list-style: none;
}
.list-group {
  margin-bottom: 20px;
  padding-left: 0;
}
.list-group-item {
  position: relative;
  display: block;
  padding: 10px 15px;
  margin-bottom: -1px;
  background-color: #fff;
  border: 1px solid #ddd;
}
.list-group-item:first-child {
  border-top-right-radius: 2px;
  border-top-left-radius: 2px;
}
.list-group-item:last-child {
  margin-bottom: 0;
  border-bottom-right-radius: 2px;
  border-bottom-left-radius: 2px;
}
a.list-group-item,
button.list-group-item {
  color: #555;
}
a.list-group-item .list-group-item-heading,
button.list-group-item .list-group-item-heading {
  color: #333;
}
a.list-group-item:hover,
button.list-group-item:hover,
a.list-group-item:focus,
button.list-group-item:focus {
  text-decoration: none;
  color: #555;
  background-color: #f5f5f5;
}
button.list-group-item {
  width: 100%;
  text-align: left;
}
.list-group-item.disabled,
.list-group-item.disabled:hover,
.list-group-item.disabled:focus {
  background-color: #eeeeee;
  color: #777777;
  cursor: not-allowed;
}
.list-group-item.disabled .list-group-item-heading,
.list-group-item.disabled:hover .list-group-item-heading,
.list-group-item.disabled:focus .list-group-item-heading {
  color: inherit;
}
.list-group-item.disabled .list-group-item-text,
.list-group-item.disabled:hover .list-group-item-text,
.list-group-item.disabled:focus .list-group-item-text {
  color: #777777;
}
.list-group-item.active,
.list-group-item.active:hover,
.list-group-item.active:focus {
  z-index: 2;
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
}
.list-group-item.active .list-group-item-heading,
.list-group-item.active:hover .list-group-item-heading,
.list-group-item.active:focus .list-group-item-heading,
.list-group-item.active .list-group-item-heading > small,
.list-group-item.active:hover .list-group-item-heading > small,
.list-group-item.active:focus .list-group-item-heading > small,
.list-group-item.active .list-group-item-heading > .small,
.list-group-item.active:hover .list-group-item-heading > .small,
.list-group-item.active:focus .list-group-item-heading > .small {
  color: inherit;
}
.list-group-item.active .list-group-item-text,
.list-group-item.active:hover .list-group-item-text,
.list-group-item.active:focus .list-group-item-text {
  color: #c7ddef;
}
.list-group-item-success {
  color: #3c763d;
  background-color: #dff0d8;
}
a.list-group-item-success,
button.list-group-item-success {
  color: #3c763d;
}
a.list-group-item-success .list-group-item-heading,
button.list-group-item-success .list-group-item-heading {
  color: inherit;
}
a.list-group-item-success:hover,
button.list-group-item-success:hover,
a.list-group-item-success:focus,
button.list-group-item-success:focus {
  color: #3c763d;
  background-color: #d0e9c6;
}
a.list-group-item-success.active,
button.list-group-item-success.active,
a.list-group-item-success.active:hover,
button.list-group-item-success.active:hover,
a.list-group-item-success.active:focus,
button.list-group-item-success.active:focus {
  color: #fff;
  background-color: #3c763d;
  border-color: #3c763d;
}
.list-group-item-info {
  color: #31708f;
  background-color: #d9edf7;
}
a.list-group-item-info,
button.list-group-item-info {
  color: #31708f;
}
a.list-group-item-info .list-group-item-heading,
button.list-group-item-info .list-group-item-heading {
  color: inherit;
}
a.list-group-item-info:hover,
button.list-group-item-info:hover,
a.list-group-item-info:focus,
button.list-group-item-info:focus {
  color: #31708f;
  background-color: #c4e3f3;
}
a.list-group-item-info.active,
button.list-group-item-info.active,
a.list-group-item-info.active:hover,
button.list-group-item-info.active:hover,
a.list-group-item-info.active:focus,
button.list-group-item-info.active:focus {
  color: #fff;
  background-color: #31708f;
  border-color: #31708f;
}
.list-group-item-warning {
  color: #8a6d3b;
  background-color: #fcf8e3;
}
a.list-group-item-warning,
button.list-group-item-warning {
  color: #8a6d3b;
}
a.list-group-item-warning .list-group-item-heading,
button.list-group-item-warning .list-group-item-heading {
  color: inherit;
}
a.list-group-item-warning:hover,
button.list-group-item-warning:hover,
a.list-group-item-warning:focus,
button.list-group-item-warning:focus {
  color: #8a6d3b;
  background-color: #faf2cc;
}
a.list-group-item-warning.active,
button.list-group-item-warning.active,
a.list-group-item-warning.active:hover,
button.list-group-item-warning.active:hover,
a.list-group-item-warning.active:focus,
button.list-group-item-warning.active:focus {
  color: #fff;
  background-color: #8a6d3b;
  border-color: #8a6d3b;
}
.list-group-item-danger {
  color: #a94442;
  background-color: #f2dede;
}
a.list-group-item-danger,
button.list-group-item-danger {
  color: #a94442;
}
a.list-group-item-danger .list-group-item-heading,
button.list-group-item-danger .list-group-item-heading {
  color: inherit;
}
a.list-group-item-danger:hover,
button.list-group-item-danger:hover,
a.list-group-item-danger:focus,
button.list-group-item-danger:focus {
  color: #a94442;
  background-color: #ebcccc;
}
a.list-group-item-danger.active,
button.list-group-item-danger.active,
a.list-group-item-danger.active:hover,
button.list-group-item-danger.active:hover,
a.list-group-item-danger.active:focus,
button.list-group-item-danger.active:focus {
  color: #fff;
  background-color: #a94442;
  border-color: #a94442;
}
.list-group-item-heading {
  margin-top: 0;
  margin-bottom: 5px;
}
.list-group-item-text {
  margin-bottom: 0;
  line-height: 1.3;
}
.panel {
  margin-bottom: 18px;
  background-color: #fff;
  border: 1px solid transparent;
  border-radius: 2px;
  -webkit-box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
}
.panel-body {
  padding: 15px;
}
.panel-heading {
  padding: 10px 15px;
  border-bottom: 1px solid transparent;
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel-heading > .dropdown .dropdown-toggle {
  color: inherit;
}
.panel-title {
  margin-top: 0;
  margin-bottom: 0;
  font-size: 15px;
  color: inherit;
}
.panel-title > a,
.panel-title > small,
.panel-title > .small,
.panel-title > small > a,
.panel-title > .small > a {
  color: inherit;
}
.panel-footer {
  padding: 10px 15px;
  background-color: #f5f5f5;
  border-top: 1px solid #ddd;
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .list-group,
.panel > .panel-collapse > .list-group {
  margin-bottom: 0;
}
.panel > .list-group .list-group-item,
.panel > .panel-collapse > .list-group .list-group-item {
  border-width: 1px 0;
  border-radius: 0;
}
.panel > .list-group:first-child .list-group-item:first-child,
.panel > .panel-collapse > .list-group:first-child .list-group-item:first-child {
  border-top: 0;
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel > .list-group:last-child .list-group-item:last-child,
.panel > .panel-collapse > .list-group:last-child .list-group-item:last-child {
  border-bottom: 0;
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .panel-heading + .panel-collapse > .list-group .list-group-item:first-child {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.panel-heading + .list-group .list-group-item:first-child {
  border-top-width: 0;
}
.list-group + .panel-footer {
  border-top-width: 0;
}
.panel > .table,
.panel > .table-responsive > .table,
.panel > .panel-collapse > .table {
  margin-bottom: 0;
}
.panel > .table caption,
.panel > .table-responsive > .table caption,
.panel > .panel-collapse > .table caption {
  padding-left: 15px;
  padding-right: 15px;
}
.panel > .table:first-child,
.panel > .table-responsive:first-child > .table:first-child {
  border-top-right-radius: 1px;
  border-top-left-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child {
  border-top-left-radius: 1px;
  border-top-right-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child td:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child td:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:first-child,
.panel > .table:first-child > thead:first-child > tr:first-child th:first-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:first-child,
.panel > .table:first-child > tbody:first-child > tr:first-child th:first-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:first-child {
  border-top-left-radius: 1px;
}
.panel > .table:first-child > thead:first-child > tr:first-child td:last-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child td:last-child,
.panel > .table:first-child > tbody:first-child > tr:first-child td:last-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child td:last-child,
.panel > .table:first-child > thead:first-child > tr:first-child th:last-child,
.panel > .table-responsive:first-child > .table:first-child > thead:first-child > tr:first-child th:last-child,
.panel > .table:first-child > tbody:first-child > tr:first-child th:last-child,
.panel > .table-responsive:first-child > .table:first-child > tbody:first-child > tr:first-child th:last-child {
  border-top-right-radius: 1px;
}
.panel > .table:last-child,
.panel > .table-responsive:last-child > .table:last-child {
  border-bottom-right-radius: 1px;
  border-bottom-left-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child {
  border-bottom-left-radius: 1px;
  border-bottom-right-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child td:first-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:first-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child td:first-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:first-child,
.panel > .table:last-child > tbody:last-child > tr:last-child th:first-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:first-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child th:first-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:first-child {
  border-bottom-left-radius: 1px;
}
.panel > .table:last-child > tbody:last-child > tr:last-child td:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child td:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child td:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child td:last-child,
.panel > .table:last-child > tbody:last-child > tr:last-child th:last-child,
.panel > .table-responsive:last-child > .table:last-child > tbody:last-child > tr:last-child th:last-child,
.panel > .table:last-child > tfoot:last-child > tr:last-child th:last-child,
.panel > .table-responsive:last-child > .table:last-child > tfoot:last-child > tr:last-child th:last-child {
  border-bottom-right-radius: 1px;
}
.panel > .panel-body + .table,
.panel > .panel-body + .table-responsive,
.panel > .table + .panel-body,
.panel > .table-responsive + .panel-body {
  border-top: 1px solid #ddd;
}
.panel > .table > tbody:first-child > tr:first-child th,
.panel > .table > tbody:first-child > tr:first-child td {
  border-top: 0;
}
.panel > .table-bordered,
.panel > .table-responsive > .table-bordered {
  border: 0;
}
.panel > .table-bordered > thead > tr > th:first-child,
.panel > .table-responsive > .table-bordered > thead > tr > th:first-child,
.panel > .table-bordered > tbody > tr > th:first-child,
.panel > .table-responsive > .table-bordered > tbody > tr > th:first-child,
.panel > .table-bordered > tfoot > tr > th:first-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > th:first-child,
.panel > .table-bordered > thead > tr > td:first-child,
.panel > .table-responsive > .table-bordered > thead > tr > td:first-child,
.panel > .table-bordered > tbody > tr > td:first-child,
.panel > .table-responsive > .table-bordered > tbody > tr > td:first-child,
.panel > .table-bordered > tfoot > tr > td:first-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > td:first-child {
  border-left: 0;
}
.panel > .table-bordered > thead > tr > th:last-child,
.panel > .table-responsive > .table-bordered > thead > tr > th:last-child,
.panel > .table-bordered > tbody > tr > th:last-child,
.panel > .table-responsive > .table-bordered > tbody > tr > th:last-child,
.panel > .table-bordered > tfoot > tr > th:last-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > th:last-child,
.panel > .table-bordered > thead > tr > td:last-child,
.panel > .table-responsive > .table-bordered > thead > tr > td:last-child,
.panel > .table-bordered > tbody > tr > td:last-child,
.panel > .table-responsive > .table-bordered > tbody > tr > td:last-child,
.panel > .table-bordered > tfoot > tr > td:last-child,
.panel > .table-responsive > .table-bordered > tfoot > tr > td:last-child {
  border-right: 0;
}
.panel > .table-bordered > thead > tr:first-child > td,
.panel > .table-responsive > .table-bordered > thead > tr:first-child > td,
.panel > .table-bordered > tbody > tr:first-child > td,
.panel > .table-responsive > .table-bordered > tbody > tr:first-child > td,
.panel > .table-bordered > thead > tr:first-child > th,
.panel > .table-responsive > .table-bordered > thead > tr:first-child > th,
.panel > .table-bordered > tbody > tr:first-child > th,
.panel > .table-responsive > .table-bordered > tbody > tr:first-child > th {
  border-bottom: 0;
}
.panel > .table-bordered > tbody > tr:last-child > td,
.panel > .table-responsive > .table-bordered > tbody > tr:last-child > td,
.panel > .table-bordered > tfoot > tr:last-child > td,
.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > td,
.panel > .table-bordered > tbody > tr:last-child > th,
.panel > .table-responsive > .table-bordered > tbody > tr:last-child > th,
.panel > .table-bordered > tfoot > tr:last-child > th,
.panel > .table-responsive > .table-bordered > tfoot > tr:last-child > th {
  border-bottom: 0;
}
.panel > .table-responsive {
  border: 0;
  margin-bottom: 0;
}
.panel-group {
  margin-bottom: 18px;
}
.panel-group .panel {
  margin-bottom: 0;
  border-radius: 2px;
}
.panel-group .panel + .panel {
  margin-top: 5px;
}
.panel-group .panel-heading {
  border-bottom: 0;
}
.panel-group .panel-heading + .panel-collapse > .panel-body,
.panel-group .panel-heading + .panel-collapse > .list-group {
  border-top: 1px solid #ddd;
}
.panel-group .panel-footer {
  border-top: 0;
}
.panel-group .panel-footer + .panel-collapse .panel-body {
  border-bottom: 1px solid #ddd;
}
.panel-default {
  border-color: #ddd;
}
.panel-default > .panel-heading {
  color: #333333;
  background-color: #f5f5f5;
  border-color: #ddd;
}
.panel-default > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #ddd;
}
.panel-default > .panel-heading .badge {
  color: #f5f5f5;
  background-color: #333333;
}
.panel-default > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #ddd;
}
.panel-primary {
  border-color: #337ab7;
}
.panel-primary > .panel-heading {
  color: #fff;
  background-color: #337ab7;
  border-color: #337ab7;
}
.panel-primary > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #337ab7;
}
.panel-primary > .panel-heading .badge {
  color: #337ab7;
  background-color: #fff;
}
.panel-primary > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #337ab7;
}
.panel-success {
  border-color: #d6e9c6;
}
.panel-success > .panel-heading {
  color: #3c763d;
  background-color: #dff0d8;
  border-color: #d6e9c6;
}
.panel-success > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #d6e9c6;
}
.panel-success > .panel-heading .badge {
  color: #dff0d8;
  background-color: #3c763d;
}
.panel-success > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #d6e9c6;
}
.panel-info {
  border-color: #bce8f1;
}
.panel-info > .panel-heading {
  color: #31708f;
  background-color: #d9edf7;
  border-color: #bce8f1;
}
.panel-info > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #bce8f1;
}
.panel-info > .panel-heading .badge {
  color: #d9edf7;
  background-color: #31708f;
}
.panel-info > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #bce8f1;
}
.panel-warning {
  border-color: #faebcc;
}
.panel-warning > .panel-heading {
  color: #8a6d3b;
  background-color: #fcf8e3;
  border-color: #faebcc;
}
.panel-warning > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #faebcc;
}
.panel-warning > .panel-heading .badge {
  color: #fcf8e3;
  background-color: #8a6d3b;
}
.panel-warning > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #faebcc;
}
.panel-danger {
  border-color: #ebccd1;
}
.panel-danger > .panel-heading {
  color: #a94442;
  background-color: #f2dede;
  border-color: #ebccd1;
}
.panel-danger > .panel-heading + .panel-collapse > .panel-body {
  border-top-color: #ebccd1;
}
.panel-danger > .panel-heading .badge {
  color: #f2dede;
  background-color: #a94442;
}
.panel-danger > .panel-footer + .panel-collapse > .panel-body {
  border-bottom-color: #ebccd1;
}
.embed-responsive {
  position: relative;
  display: block;
  height: 0;
  padding: 0;
  overflow: hidden;
}
.embed-responsive .embed-responsive-item,
.embed-responsive iframe,
.embed-responsive embed,
.embed-responsive object,
.embed-responsive video {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  height: 100%;
  width: 100%;
  border: 0;
}
.embed-responsive-16by9 {
  padding-bottom: 56.25%;
}
.embed-responsive-4by3 {
  padding-bottom: 75%;
}
.well {
  min-height: 20px;
  padding: 19px;
  margin-bottom: 20px;
  background-color: #f5f5f5;
  border: 1px solid #e3e3e3;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.05);
}
.well blockquote {
  border-color: #ddd;
  border-color: rgba(0, 0, 0, 0.15);
}
.well-lg {
  padding: 24px;
  border-radius: 3px;
}
.well-sm {
  padding: 9px;
  border-radius: 1px;
}
.close {
  float: right;
  font-size: 19.5px;
  font-weight: bold;
  line-height: 1;
  color: #000;
  text-shadow: 0 1px 0 #fff;
  opacity: 0.2;
  filter: alpha(opacity=20);
}
.close:hover,
.close:focus {
  color: #000;
  text-decoration: none;
  cursor: pointer;
  opacity: 0.5;
  filter: alpha(opacity=50);
}
button.close {
  padding: 0;
  cursor: pointer;
  background: transparent;
  border: 0;
  -webkit-appearance: none;
}
.modal-open {
  overflow: hidden;
}
.modal {
  display: none;
  overflow: hidden;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1050;
  -webkit-overflow-scrolling: touch;
  outline: 0;
}
.modal.fade .modal-dialog {
  -webkit-transform: translate(0, -25%);
  -ms-transform: translate(0, -25%);
  -o-transform: translate(0, -25%);
  transform: translate(0, -25%);
  -webkit-transition: -webkit-transform 0.3s ease-out;
  -moz-transition: -moz-transform 0.3s ease-out;
  -o-transition: -o-transform 0.3s ease-out;
  transition: transform 0.3s ease-out;
}
.modal.in .modal-dialog {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
.modal-open .modal {
  overflow-x: hidden;
  overflow-y: auto;
}
.modal-dialog {
  position: relative;
  width: auto;
  margin: 10px;
}
.modal-content {
  position: relative;
  background-color: #fff;
  border: 1px solid #999;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  -webkit-box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
  box-shadow: 0 3px 9px rgba(0, 0, 0, 0.5);
  background-clip: padding-box;
  outline: 0;
}
.modal-backdrop {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1040;
  background-color: #000;
}
.modal-backdrop.fade {
  opacity: 0;
  filter: alpha(opacity=0);
}
.modal-backdrop.in {
  opacity: 0.5;
  filter: alpha(opacity=50);
}
.modal-header {
  padding: 15px;
  border-bottom: 1px solid #e5e5e5;
}
.modal-header .close {
  margin-top: -2px;
}
.modal-title {
  margin: 0;
  line-height: 1.42857143;
}
.modal-body {
  position: relative;
  padding: 15px;
}
.modal-footer {
  padding: 15px;
  text-align: right;
  border-top: 1px solid #e5e5e5;
}
.modal-footer .btn + .btn {
  margin-left: 5px;
  margin-bottom: 0;
}
.modal-footer .btn-group .btn + .btn {
  margin-left: -1px;
}
.modal-footer .btn-block + .btn-block {
  margin-left: 0;
}
.modal-scrollbar-measure {
  position: absolute;
  top: -9999px;
  width: 50px;
  height: 50px;
  overflow: scroll;
}
@media (min-width: 768px) {
  .modal-dialog {
    width: 600px;
    margin: 30px auto;
  }
  .modal-content {
    -webkit-box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  }
  .modal-sm {
    width: 300px;
  }
}
@media (min-width: 992px) {
  .modal-lg {
    width: 900px;
  }
}
.tooltip {
  position: absolute;
  z-index: 1070;
  display: block;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-style: normal;
  font-weight: normal;
  letter-spacing: normal;
  line-break: auto;
  line-height: 1.42857143;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  white-space: normal;
  word-break: normal;
  word-spacing: normal;
  word-wrap: normal;
  font-size: 12px;
  opacity: 0;
  filter: alpha(opacity=0);
}
.tooltip.in {
  opacity: 0.9;
  filter: alpha(opacity=90);
}
.tooltip.top {
  margin-top: -3px;
  padding: 5px 0;
}
.tooltip.right {
  margin-left: 3px;
  padding: 0 5px;
}
.tooltip.bottom {
  margin-top: 3px;
  padding: 5px 0;
}
.tooltip.left {
  margin-left: -3px;
  padding: 0 5px;
}
.tooltip-inner {
  max-width: 200px;
  padding: 3px 8px;
  color: #fff;
  text-align: center;
  background-color: #000;
  border-radius: 2px;
}
.tooltip-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
}
.tooltip.top .tooltip-arrow {
  bottom: 0;
  left: 50%;
  margin-left: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.top-left .tooltip-arrow {
  bottom: 0;
  right: 5px;
  margin-bottom: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.top-right .tooltip-arrow {
  bottom: 0;
  left: 5px;
  margin-bottom: -5px;
  border-width: 5px 5px 0;
  border-top-color: #000;
}
.tooltip.right .tooltip-arrow {
  top: 50%;
  left: 0;
  margin-top: -5px;
  border-width: 5px 5px 5px 0;
  border-right-color: #000;
}
.tooltip.left .tooltip-arrow {
  top: 50%;
  right: 0;
  margin-top: -5px;
  border-width: 5px 0 5px 5px;
  border-left-color: #000;
}
.tooltip.bottom .tooltip-arrow {
  top: 0;
  left: 50%;
  margin-left: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bottom-left .tooltip-arrow {
  top: 0;
  right: 5px;
  margin-top: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.tooltip.bottom-right .tooltip-arrow {
  top: 0;
  left: 5px;
  margin-top: -5px;
  border-width: 0 5px 5px;
  border-bottom-color: #000;
}
.popover {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1060;
  display: none;
  max-width: 276px;
  padding: 1px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-style: normal;
  font-weight: normal;
  letter-spacing: normal;
  line-break: auto;
  line-height: 1.42857143;
  text-align: left;
  text-align: start;
  text-decoration: none;
  text-shadow: none;
  text-transform: none;
  white-space: normal;
  word-break: normal;
  word-spacing: normal;
  word-wrap: normal;
  font-size: 13px;
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  -webkit-box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
}
.popover.top {
  margin-top: -10px;
}
.popover.right {
  margin-left: 10px;
}
.popover.bottom {
  margin-top: 10px;
}
.popover.left {
  margin-left: -10px;
}
.popover-title {
  margin: 0;
  padding: 8px 14px;
  font-size: 13px;
  background-color: #f7f7f7;
  border-bottom: 1px solid #ebebeb;
  border-radius: 2px 2px 0 0;
}
.popover-content {
  padding: 9px 14px;
}
.popover > .arrow,
.popover > .arrow:after {
  position: absolute;
  display: block;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
}
.popover > .arrow {
  border-width: 11px;
}
.popover > .arrow:after {
  border-width: 10px;
  content: "";
}
.popover.top > .arrow {
  left: 50%;
  margin-left: -11px;
  border-bottom-width: 0;
  border-top-color: #999999;
  border-top-color: rgba(0, 0, 0, 0.25);
  bottom: -11px;
}
.popover.top > .arrow:after {
  content: " ";
  bottom: 1px;
  margin-left: -10px;
  border-bottom-width: 0;
  border-top-color: #fff;
}
.popover.right > .arrow {
  top: 50%;
  left: -11px;
  margin-top: -11px;
  border-left-width: 0;
  border-right-color: #999999;
  border-right-color: rgba(0, 0, 0, 0.25);
}
.popover.right > .arrow:after {
  content: " ";
  left: 1px;
  bottom: -10px;
  border-left-width: 0;
  border-right-color: #fff;
}
.popover.bottom > .arrow {
  left: 50%;
  margin-left: -11px;
  border-top-width: 0;
  border-bottom-color: #999999;
  border-bottom-color: rgba(0, 0, 0, 0.25);
  top: -11px;
}
.popover.bottom > .arrow:after {
  content: " ";
  top: 1px;
  margin-left: -10px;
  border-top-width: 0;
  border-bottom-color: #fff;
}
.popover.left > .arrow {
  top: 50%;
  right: -11px;
  margin-top: -11px;
  border-right-width: 0;
  border-left-color: #999999;
  border-left-color: rgba(0, 0, 0, 0.25);
}
.popover.left > .arrow:after {
  content: " ";
  right: 1px;
  border-right-width: 0;
  border-left-color: #fff;
  bottom: -10px;
}
.carousel {
  position: relative;
}
.carousel-inner {
  position: relative;
  overflow: hidden;
  width: 100%;
}
.carousel-inner > .item {
  display: none;
  position: relative;
  -webkit-transition: 0.6s ease-in-out left;
  -o-transition: 0.6s ease-in-out left;
  transition: 0.6s ease-in-out left;
}
.carousel-inner > .item > img,
.carousel-inner > .item > a > img {
  line-height: 1;
}
@media all and (transform-3d), (-webkit-transform-3d) {
  .carousel-inner > .item {
    -webkit-transition: -webkit-transform 0.6s ease-in-out;
    -moz-transition: -moz-transform 0.6s ease-in-out;
    -o-transition: -o-transform 0.6s ease-in-out;
    transition: transform 0.6s ease-in-out;
    -webkit-backface-visibility: hidden;
    -moz-backface-visibility: hidden;
    backface-visibility: hidden;
    -webkit-perspective: 1000px;
    -moz-perspective: 1000px;
    perspective: 1000px;
  }
  .carousel-inner > .item.next,
  .carousel-inner > .item.active.right {
    -webkit-transform: translate3d(100%, 0, 0);
    transform: translate3d(100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.prev,
  .carousel-inner > .item.active.left {
    -webkit-transform: translate3d(-100%, 0, 0);
    transform: translate3d(-100%, 0, 0);
    left: 0;
  }
  .carousel-inner > .item.next.left,
  .carousel-inner > .item.prev.right,
  .carousel-inner > .item.active {
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    left: 0;
  }
}
.carousel-inner > .active,
.carousel-inner > .next,
.carousel-inner > .prev {
  display: block;
}
.carousel-inner > .active {
  left: 0;
}
.carousel-inner > .next,
.carousel-inner > .prev {
  position: absolute;
  top: 0;
  width: 100%;
}
.carousel-inner > .next {
  left: 100%;
}
.carousel-inner > .prev {
  left: -100%;
}
.carousel-inner > .next.left,
.carousel-inner > .prev.right {
  left: 0;
}
.carousel-inner > .active.left {
  left: -100%;
}
.carousel-inner > .active.right {
  left: 100%;
}
.carousel-control {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: 15%;
  opacity: 0.5;
  filter: alpha(opacity=50);
  font-size: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
  background-color: rgba(0, 0, 0, 0);
}
.carousel-control.left {
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5) 0%, rgba(0, 0, 0, 0.0001) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);
}
.carousel-control.right {
  left: auto;
  right: 0;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.0001) 0%, rgba(0, 0, 0, 0.5) 100%);
  background-repeat: repeat-x;
  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);
}
.carousel-control:hover,
.carousel-control:focus {
  outline: 0;
  color: #fff;
  text-decoration: none;
  opacity: 0.9;
  filter: alpha(opacity=90);
}
.carousel-control .icon-prev,
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-left,
.carousel-control .glyphicon-chevron-right {
  position: absolute;
  top: 50%;
  margin-top: -10px;
  z-index: 5;
  display: inline-block;
}
.carousel-control .icon-prev,
.carousel-control .glyphicon-chevron-left {
  left: 50%;
  margin-left: -10px;
}
.carousel-control .icon-next,
.carousel-control .glyphicon-chevron-right {
  right: 50%;
  margin-right: -10px;
}
.carousel-control .icon-prev,
.carousel-control .icon-next {
  width: 20px;
  height: 20px;
  line-height: 1;
  font-family: serif;
}
.carousel-control .icon-prev:before {
  content: '\2039';
}
.carousel-control .icon-next:before {
  content: '\203a';
}
.carousel-indicators {
  position: absolute;
  bottom: 10px;
  left: 50%;
  z-index: 15;
  width: 60%;
  margin-left: -30%;
  padding-left: 0;
  list-style: none;
  text-align: center;
}
.carousel-indicators li {
  display: inline-block;
  width: 10px;
  height: 10px;
  margin: 1px;
  text-indent: -999px;
  border: 1px solid #fff;
  border-radius: 10px;
  cursor: pointer;
  background-color: #000 \9;
  background-color: rgba(0, 0, 0, 0);
}
.carousel-indicators .active {
  margin: 0;
  width: 12px;
  height: 12px;
  background-color: #fff;
}
.carousel-caption {
  position: absolute;
  left: 15%;
  right: 15%;
  bottom: 20px;
  z-index: 10;
  padding-top: 20px;
  padding-bottom: 20px;
  color: #fff;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
}
.carousel-caption .btn {
  text-shadow: none;
}
@media screen and (min-width: 768px) {
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-prev,
  .carousel-control .icon-next {
    width: 30px;
    height: 30px;
    margin-top: -10px;
    font-size: 30px;
  }
  .carousel-control .glyphicon-chevron-left,
  .carousel-control .icon-prev {
    margin-left: -10px;
  }
  .carousel-control .glyphicon-chevron-right,
  .carousel-control .icon-next {
    margin-right: -10px;
  }
  .carousel-caption {
    left: 20%;
    right: 20%;
    padding-bottom: 30px;
  }
  .carousel-indicators {
    bottom: 20px;
  }
}
.clearfix:before,
.clearfix:after,
.dl-horizontal dd:before,
.dl-horizontal dd:after,
.container:before,
.container:after,
.container-fluid:before,
.container-fluid:after,
.row:before,
.row:after,
.form-horizontal .form-group:before,
.form-horizontal .form-group:after,
.btn-toolbar:before,
.btn-toolbar:after,
.btn-group-vertical > .btn-group:before,
.btn-group-vertical > .btn-group:after,
.nav:before,
.nav:after,
.navbar:before,
.navbar:after,
.navbar-header:before,
.navbar-header:after,
.navbar-collapse:before,
.navbar-collapse:after,
.pager:before,
.pager:after,
.panel-body:before,
.panel-body:after,
.modal-header:before,
.modal-header:after,
.modal-footer:before,
.modal-footer:after,
.item_buttons:before,
.item_buttons:after {
  content: " ";
  display: table;
}
.clearfix:after,
.dl-horizontal dd:after,
.container:after,
.container-fluid:after,
.row:after,
.form-horizontal .form-group:after,
.btn-toolbar:after,
.btn-group-vertical > .btn-group:after,
.nav:after,
.navbar:after,
.navbar-header:after,
.navbar-collapse:after,
.pager:after,
.panel-body:after,
.modal-header:after,
.modal-footer:after,
.item_buttons:after {
  clear: both;
}
.center-block {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.pull-right {
  float: right !important;
}
.pull-left {
  float: left !important;
}
.hide {
  display: none !important;
}
.show {
  display: block !important;
}
.invisible {
  visibility: hidden;
}
.text-hide {
  font: 0/0 a;
  color: transparent;
  text-shadow: none;
  background-color: transparent;
  border: 0;
}
.hidden {
  display: none !important;
}
.affix {
  position: fixed;
}
@-ms-viewport {
  width: device-width;
}
.visible-xs,
.visible-sm,
.visible-md,
.visible-lg {
  display: none !important;
}
.visible-xs-block,
.visible-xs-inline,
.visible-xs-inline-block,
.visible-sm-block,
.visible-sm-inline,
.visible-sm-inline-block,
.visible-md-block,
.visible-md-inline,
.visible-md-inline-block,
.visible-lg-block,
.visible-lg-inline,
.visible-lg-inline-block {
  display: none !important;
}
@media (max-width: 767px) {
  .visible-xs {
    display: block !important;
  }
  table.visible-xs {
    display: table !important;
  }
  tr.visible-xs {
    display: table-row !important;
  }
  th.visible-xs,
  td.visible-xs {
    display: table-cell !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-block {
    display: block !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-inline {
    display: inline !important;
  }
}
@media (max-width: 767px) {
  .visible-xs-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm {
    display: block !important;
  }
  table.visible-sm {
    display: table !important;
  }
  tr.visible-sm {
    display: table-row !important;
  }
  th.visible-sm,
  td.visible-sm {
    display: table-cell !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-block {
    display: block !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-inline {
    display: inline !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .visible-sm-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md {
    display: block !important;
  }
  table.visible-md {
    display: table !important;
  }
  tr.visible-md {
    display: table-row !important;
  }
  th.visible-md,
  td.visible-md {
    display: table-cell !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-block {
    display: block !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-inline {
    display: inline !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .visible-md-inline-block {
    display: inline-block !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg {
    display: block !important;
  }
  table.visible-lg {
    display: table !important;
  }
  tr.visible-lg {
    display: table-row !important;
  }
  th.visible-lg,
  td.visible-lg {
    display: table-cell !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-block {
    display: block !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-inline {
    display: inline !important;
  }
}
@media (min-width: 1200px) {
  .visible-lg-inline-block {
    display: inline-block !important;
  }
}
@media (max-width: 767px) {
  .hidden-xs {
    display: none !important;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  .hidden-sm {
    display: none !important;
  }
}
@media (min-width: 992px) and (max-width: 1199px) {
  .hidden-md {
    display: none !important;
  }
}
@media (min-width: 1200px) {
  .hidden-lg {
    display: none !important;
  }
}
.visible-print {
  display: none !important;
}
@media print {
  .visible-print {
    display: block !important;
  }
  table.visible-print {
    display: table !important;
  }
  tr.visible-print {
    display: table-row !important;
  }
  th.visible-print,
  td.visible-print {
    display: table-cell !important;
  }
}
.visible-print-block {
  display: none !important;
}
@media print {
  .visible-print-block {
    display: block !important;
  }
}
.visible-print-inline {
  display: none !important;
}
@media print {
  .visible-print-inline {
    display: inline !important;
  }
}
.visible-print-inline-block {
  display: none !important;
}
@media print {
  .visible-print-inline-block {
    display: inline-block !important;
  }
}
@media print {
  .hidden-print {
    display: none !important;
  }
}
/*!
*
* Font Awesome
*
*/
/*!
 *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome
 *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)
 */
/* FONT PATH
 * -------------------------- */
@font-face {
  font-family: 'FontAwesome';
  src: url('../components/font-awesome/fonts/fontawesome-webfont.eot?v=4.7.0');
  src: url('../components/font-awesome/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0') format('embedded-opentype'), url('../components/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('../components/font-awesome/fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('../components/font-awesome/fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('../components/font-awesome/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg');
  font-weight: normal;
  font-style: normal;
}
.fa {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eee;
  border-radius: .1em;
}
.fa-pull-left {
  float: left;
}
.fa-pull-right {
  float: right;
}
.fa.fa-pull-left {
  margin-right: .3em;
}
.fa.fa-pull-right {
  margin-left: .3em;
}
/* Deprecated as of 4.4.0 */
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
  animation: fa-spin 2s infinite linear;
}
.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
  animation: fa-spin 1s infinite steps(8);
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  -webkit-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  -webkit-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  -webkit-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  transform: scale(1, -1);
}
:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical {
  filter: none;
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #fff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-remove:before,
.fa-close:before,
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before,
.fa-bar-chart:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook-f:before,
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-feed:before,
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before,
.fa-gratipay:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-pp:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-buoy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-resistance:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-y-combinator-square:before,
.fa-yc-square:before,
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
.fa-soccer-ball-o:before,
.fa-futbol-o:before {
  content: "\f1e3";
}
.fa-tty:before {
  content: "\f1e4";
}
.fa-binoculars:before {
  content: "\f1e5";
}
.fa-plug:before {
  content: "\f1e6";
}
.fa-slideshare:before {
  content: "\f1e7";
}
.fa-twitch:before {
  content: "\f1e8";
}
.fa-yelp:before {
  content: "\f1e9";
}
.fa-newspaper-o:before {
  content: "\f1ea";
}
.fa-wifi:before {
  content: "\f1eb";
}
.fa-calculator:before {
  content: "\f1ec";
}
.fa-paypal:before {
  content: "\f1ed";
}
.fa-google-wallet:before {
  content: "\f1ee";
}
.fa-cc-visa:before {
  content: "\f1f0";
}
.fa-cc-mastercard:before {
  content: "\f1f1";
}
.fa-cc-discover:before {
  content: "\f1f2";
}
.fa-cc-amex:before {
  content: "\f1f3";
}
.fa-cc-paypal:before {
  content: "\f1f4";
}
.fa-cc-stripe:before {
  content: "\f1f5";
}
.fa-bell-slash:before {
  content: "\f1f6";
}
.fa-bell-slash-o:before {
  content: "\f1f7";
}
.fa-trash:before {
  content: "\f1f8";
}
.fa-copyright:before {
  content: "\f1f9";
}
.fa-at:before {
  content: "\f1fa";
}
.fa-eyedropper:before {
  content: "\f1fb";
}
.fa-paint-brush:before {
  content: "\f1fc";
}
.fa-birthday-cake:before {
  content: "\f1fd";
}
.fa-area-chart:before {
  content: "\f1fe";
}
.fa-pie-chart:before {
  content: "\f200";
}
.fa-line-chart:before {
  content: "\f201";
}
.fa-lastfm:before {
  content: "\f202";
}
.fa-lastfm-square:before {
  content: "\f203";
}
.fa-toggle-off:before {
  content: "\f204";
}
.fa-toggle-on:before {
  content: "\f205";
}
.fa-bicycle:before {
  content: "\f206";
}
.fa-bus:before {
  content: "\f207";
}
.fa-ioxhost:before {
  content: "\f208";
}
.fa-angellist:before {
  content: "\f209";
}
.fa-cc:before {
  content: "\f20a";
}
.fa-shekel:before,
.fa-sheqel:before,
.fa-ils:before {
  content: "\f20b";
}
.fa-meanpath:before {
  content: "\f20c";
}
.fa-buysellads:before {
  content: "\f20d";
}
.fa-connectdevelop:before {
  content: "\f20e";
}
.fa-dashcube:before {
  content: "\f210";
}
.fa-forumbee:before {
  content: "\f211";
}
.fa-leanpub:before {
  content: "\f212";
}
.fa-sellsy:before {
  content: "\f213";
}
.fa-shirtsinbulk:before {
  content: "\f214";
}
.fa-simplybuilt:before {
  content: "\f215";
}
.fa-skyatlas:before {
  content: "\f216";
}
.fa-cart-plus:before {
  content: "\f217";
}
.fa-cart-arrow-down:before {
  content: "\f218";
}
.fa-diamond:before {
  content: "\f219";
}
.fa-ship:before {
  content: "\f21a";
}
.fa-user-secret:before {
  content: "\f21b";
}
.fa-motorcycle:before {
  content: "\f21c";
}
.fa-street-view:before {
  content: "\f21d";
}
.fa-heartbeat:before {
  content: "\f21e";
}
.fa-venus:before {
  content: "\f221";
}
.fa-mars:before {
  content: "\f222";
}
.fa-mercury:before {
  content: "\f223";
}
.fa-intersex:before,
.fa-transgender:before {
  content: "\f224";
}
.fa-transgender-alt:before {
  content: "\f225";
}
.fa-venus-double:before {
  content: "\f226";
}
.fa-mars-double:before {
  content: "\f227";
}
.fa-venus-mars:before {
  content: "\f228";
}
.fa-mars-stroke:before {
  content: "\f229";
}
.fa-mars-stroke-v:before {
  content: "\f22a";
}
.fa-mars-stroke-h:before {
  content: "\f22b";
}
.fa-neuter:before {
  content: "\f22c";
}
.fa-genderless:before {
  content: "\f22d";
}
.fa-facebook-official:before {
  content: "\f230";
}
.fa-pinterest-p:before {
  content: "\f231";
}
.fa-whatsapp:before {
  content: "\f232";
}
.fa-server:before {
  content: "\f233";
}
.fa-user-plus:before {
  content: "\f234";
}
.fa-user-times:before {
  content: "\f235";
}
.fa-hotel:before,
.fa-bed:before {
  content: "\f236";
}
.fa-viacoin:before {
  content: "\f237";
}
.fa-train:before {
  content: "\f238";
}
.fa-subway:before {
  content: "\f239";
}
.fa-medium:before {
  content: "\f23a";
}
.fa-yc:before,
.fa-y-combinator:before {
  content: "\f23b";
}
.fa-optin-monster:before {
  content: "\f23c";
}
.fa-opencart:before {
  content: "\f23d";
}
.fa-expeditedssl:before {
  content: "\f23e";
}
.fa-battery-4:before,
.fa-battery:before,
.fa-battery-full:before {
  content: "\f240";
}
.fa-battery-3:before,
.fa-battery-three-quarters:before {
  content: "\f241";
}
.fa-battery-2:before,
.fa-battery-half:before {
  content: "\f242";
}
.fa-battery-1:before,
.fa-battery-quarter:before {
  content: "\f243";
}
.fa-battery-0:before,
.fa-battery-empty:before {
  content: "\f244";
}
.fa-mouse-pointer:before {
  content: "\f245";
}
.fa-i-cursor:before {
  content: "\f246";
}
.fa-object-group:before {
  content: "\f247";
}
.fa-object-ungroup:before {
  content: "\f248";
}
.fa-sticky-note:before {
  content: "\f249";
}
.fa-sticky-note-o:before {
  content: "\f24a";
}
.fa-cc-jcb:before {
  content: "\f24b";
}
.fa-cc-diners-club:before {
  content: "\f24c";
}
.fa-clone:before {
  content: "\f24d";
}
.fa-balance-scale:before {
  content: "\f24e";
}
.fa-hourglass-o:before {
  content: "\f250";
}
.fa-hourglass-1:before,
.fa-hourglass-start:before {
  content: "\f251";
}
.fa-hourglass-2:before,
.fa-hourglass-half:before {
  content: "\f252";
}
.fa-hourglass-3:before,
.fa-hourglass-end:before {
  content: "\f253";
}
.fa-hourglass:before {
  content: "\f254";
}
.fa-hand-grab-o:before,
.fa-hand-rock-o:before {
  content: "\f255";
}
.fa-hand-stop-o:before,
.fa-hand-paper-o:before {
  content: "\f256";
}
.fa-hand-scissors-o:before {
  content: "\f257";
}
.fa-hand-lizard-o:before {
  content: "\f258";
}
.fa-hand-spock-o:before {
  content: "\f259";
}
.fa-hand-pointer-o:before {
  content: "\f25a";
}
.fa-hand-peace-o:before {
  content: "\f25b";
}
.fa-trademark:before {
  content: "\f25c";
}
.fa-registered:before {
  content: "\f25d";
}
.fa-creative-commons:before {
  content: "\f25e";
}
.fa-gg:before {
  content: "\f260";
}
.fa-gg-circle:before {
  content: "\f261";
}
.fa-tripadvisor:before {
  content: "\f262";
}
.fa-odnoklassniki:before {
  content: "\f263";
}
.fa-odnoklassniki-square:before {
  content: "\f264";
}
.fa-get-pocket:before {
  content: "\f265";
}
.fa-wikipedia-w:before {
  content: "\f266";
}
.fa-safari:before {
  content: "\f267";
}
.fa-chrome:before {
  content: "\f268";
}
.fa-firefox:before {
  content: "\f269";
}
.fa-opera:before {
  content: "\f26a";
}
.fa-internet-explorer:before {
  content: "\f26b";
}
.fa-tv:before,
.fa-television:before {
  content: "\f26c";
}
.fa-contao:before {
  content: "\f26d";
}
.fa-500px:before {
  content: "\f26e";
}
.fa-amazon:before {
  content: "\f270";
}
.fa-calendar-plus-o:before {
  content: "\f271";
}
.fa-calendar-minus-o:before {
  content: "\f272";
}
.fa-calendar-times-o:before {
  content: "\f273";
}
.fa-calendar-check-o:before {
  content: "\f274";
}
.fa-industry:before {
  content: "\f275";
}
.fa-map-pin:before {
  content: "\f276";
}
.fa-map-signs:before {
  content: "\f277";
}
.fa-map-o:before {
  content: "\f278";
}
.fa-map:before {
  content: "\f279";
}
.fa-commenting:before {
  content: "\f27a";
}
.fa-commenting-o:before {
  content: "\f27b";
}
.fa-houzz:before {
  content: "\f27c";
}
.fa-vimeo:before {
  content: "\f27d";
}
.fa-black-tie:before {
  content: "\f27e";
}
.fa-fonticons:before {
  content: "\f280";
}
.fa-reddit-alien:before {
  content: "\f281";
}
.fa-edge:before {
  content: "\f282";
}
.fa-credit-card-alt:before {
  content: "\f283";
}
.fa-codiepie:before {
  content: "\f284";
}
.fa-modx:before {
  content: "\f285";
}
.fa-fort-awesome:before {
  content: "\f286";
}
.fa-usb:before {
  content: "\f287";
}
.fa-product-hunt:before {
  content: "\f288";
}
.fa-mixcloud:before {
  content: "\f289";
}
.fa-scribd:before {
  content: "\f28a";
}
.fa-pause-circle:before {
  content: "\f28b";
}
.fa-pause-circle-o:before {
  content: "\f28c";
}
.fa-stop-circle:before {
  content: "\f28d";
}
.fa-stop-circle-o:before {
  content: "\f28e";
}
.fa-shopping-bag:before {
  content: "\f290";
}
.fa-shopping-basket:before {
  content: "\f291";
}
.fa-hashtag:before {
  content: "\f292";
}
.fa-bluetooth:before {
  content: "\f293";
}
.fa-bluetooth-b:before {
  content: "\f294";
}
.fa-percent:before {
  content: "\f295";
}
.fa-gitlab:before {
  content: "\f296";
}
.fa-wpbeginner:before {
  content: "\f297";
}
.fa-wpforms:before {
  content: "\f298";
}
.fa-envira:before {
  content: "\f299";
}
.fa-universal-access:before {
  content: "\f29a";
}
.fa-wheelchair-alt:before {
  content: "\f29b";
}
.fa-question-circle-o:before {
  content: "\f29c";
}
.fa-blind:before {
  content: "\f29d";
}
.fa-audio-description:before {
  content: "\f29e";
}
.fa-volume-control-phone:before {
  content: "\f2a0";
}
.fa-braille:before {
  content: "\f2a1";
}
.fa-assistive-listening-systems:before {
  content: "\f2a2";
}
.fa-asl-interpreting:before,
.fa-american-sign-language-interpreting:before {
  content: "\f2a3";
}
.fa-deafness:before,
.fa-hard-of-hearing:before,
.fa-deaf:before {
  content: "\f2a4";
}
.fa-glide:before {
  content: "\f2a5";
}
.fa-glide-g:before {
  content: "\f2a6";
}
.fa-signing:before,
.fa-sign-language:before {
  content: "\f2a7";
}
.fa-low-vision:before {
  content: "\f2a8";
}
.fa-viadeo:before {
  content: "\f2a9";
}
.fa-viadeo-square:before {
  content: "\f2aa";
}
.fa-snapchat:before {
  content: "\f2ab";
}
.fa-snapchat-ghost:before {
  content: "\f2ac";
}
.fa-snapchat-square:before {
  content: "\f2ad";
}
.fa-pied-piper:before {
  content: "\f2ae";
}
.fa-first-order:before {
  content: "\f2b0";
}
.fa-yoast:before {
  content: "\f2b1";
}
.fa-themeisle:before {
  content: "\f2b2";
}
.fa-google-plus-circle:before,
.fa-google-plus-official:before {
  content: "\f2b3";
}
.fa-fa:before,
.fa-font-awesome:before {
  content: "\f2b4";
}
.fa-handshake-o:before {
  content: "\f2b5";
}
.fa-envelope-open:before {
  content: "\f2b6";
}
.fa-envelope-open-o:before {
  content: "\f2b7";
}
.fa-linode:before {
  content: "\f2b8";
}
.fa-address-book:before {
  content: "\f2b9";
}
.fa-address-book-o:before {
  content: "\f2ba";
}
.fa-vcard:before,
.fa-address-card:before {
  content: "\f2bb";
}
.fa-vcard-o:before,
.fa-address-card-o:before {
  content: "\f2bc";
}
.fa-user-circle:before {
  content: "\f2bd";
}
.fa-user-circle-o:before {
  content: "\f2be";
}
.fa-user-o:before {
  content: "\f2c0";
}
.fa-id-badge:before {
  content: "\f2c1";
}
.fa-drivers-license:before,
.fa-id-card:before {
  content: "\f2c2";
}
.fa-drivers-license-o:before,
.fa-id-card-o:before {
  content: "\f2c3";
}
.fa-quora:before {
  content: "\f2c4";
}
.fa-free-code-camp:before {
  content: "\f2c5";
}
.fa-telegram:before {
  content: "\f2c6";
}
.fa-thermometer-4:before,
.fa-thermometer:before,
.fa-thermometer-full:before {
  content: "\f2c7";
}
.fa-thermometer-3:before,
.fa-thermometer-three-quarters:before {
  content: "\f2c8";
}
.fa-thermometer-2:before,
.fa-thermometer-half:before {
  content: "\f2c9";
}
.fa-thermometer-1:before,
.fa-thermometer-quarter:before {
  content: "\f2ca";
}
.fa-thermometer-0:before,
.fa-thermometer-empty:before {
  content: "\f2cb";
}
.fa-shower:before {
  content: "\f2cc";
}
.fa-bathtub:before,
.fa-s15:before,
.fa-bath:before {
  content: "\f2cd";
}
.fa-podcast:before {
  content: "\f2ce";
}
.fa-window-maximize:before {
  content: "\f2d0";
}
.fa-window-minimize:before {
  content: "\f2d1";
}
.fa-window-restore:before {
  content: "\f2d2";
}
.fa-times-rectangle:before,
.fa-window-close:before {
  content: "\f2d3";
}
.fa-times-rectangle-o:before,
.fa-window-close-o:before {
  content: "\f2d4";
}
.fa-bandcamp:before {
  content: "\f2d5";
}
.fa-grav:before {
  content: "\f2d6";
}
.fa-etsy:before {
  content: "\f2d7";
}
.fa-imdb:before {
  content: "\f2d8";
}
.fa-ravelry:before {
  content: "\f2d9";
}
.fa-eercast:before {
  content: "\f2da";
}
.fa-microchip:before {
  content: "\f2db";
}
.fa-snowflake-o:before {
  content: "\f2dc";
}
.fa-superpowers:before {
  content: "\f2dd";
}
.fa-wpexplorer:before {
  content: "\f2de";
}
.fa-meetup:before {
  content: "\f2e0";
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}
.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  clip: auto;
}
.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  clip: auto;
}
/*!
*
* IPython base
*
*/
.modal.fade .modal-dialog {
  -webkit-transform: translate(0, 0);
  -ms-transform: translate(0, 0);
  -o-transform: translate(0, 0);
  transform: translate(0, 0);
}
code {
  color: #000;
}
pre {
  font-size: inherit;
  line-height: inherit;
}
label {
  font-weight: normal;
}
/* Make the page background atleast 100% the height of the view port */
/* Make the page itself atleast 70% the height of the view port */
.border-box-sizing {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
.corner-all {
  border-radius: 2px;
}
.no-padding {
  padding: 0px;
}
/* Flexible box model classes */
/* Taken from Alex Russell http://infrequently.org/2009/08/css-3-progress/ */
/* This file is a compatability layer.  It allows the usage of flexible box 
model layouts accross multiple browsers, including older browsers.  The newest,
universal implementation of the flexible box model is used when available (see
`Modern browsers` comments below).  Browsers that are known to implement this 
new spec completely include:

    Firefox 28.0+
    Chrome 29.0+
    Internet Explorer 11+ 
    Opera 17.0+

Browsers not listed, including Safari, are supported via the styling under the
`Old browsers` comments below.
*/
.hbox {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
.hbox > * {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
}
.vbox {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
.vbox > * {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
}
.hbox.reverse,
.vbox.reverse,
.reverse {
  /* Old browsers */
  -webkit-box-direction: reverse;
  -moz-box-direction: reverse;
  box-direction: reverse;
  /* Modern browsers */
  flex-direction: row-reverse;
}
.hbox.box-flex0,
.vbox.box-flex0,
.box-flex0 {
  /* Old browsers */
  -webkit-box-flex: 0;
  -moz-box-flex: 0;
  box-flex: 0;
  /* Modern browsers */
  flex: none;
  width: auto;
}
.hbox.box-flex1,
.vbox.box-flex1,
.box-flex1 {
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
.hbox.box-flex,
.vbox.box-flex,
.box-flex {
  /* Old browsers */
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
.hbox.box-flex2,
.vbox.box-flex2,
.box-flex2 {
  /* Old browsers */
  -webkit-box-flex: 2;
  -moz-box-flex: 2;
  box-flex: 2;
  /* Modern browsers */
  flex: 2;
}
.box-group1 {
  /*  Deprecated */
  -webkit-box-flex-group: 1;
  -moz-box-flex-group: 1;
  box-flex-group: 1;
}
.box-group2 {
  /* Deprecated */
  -webkit-box-flex-group: 2;
  -moz-box-flex-group: 2;
  box-flex-group: 2;
}
.hbox.start,
.vbox.start,
.start {
  /* Old browsers */
  -webkit-box-pack: start;
  -moz-box-pack: start;
  box-pack: start;
  /* Modern browsers */
  justify-content: flex-start;
}
.hbox.end,
.vbox.end,
.end {
  /* Old browsers */
  -webkit-box-pack: end;
  -moz-box-pack: end;
  box-pack: end;
  /* Modern browsers */
  justify-content: flex-end;
}
.hbox.center,
.vbox.center,
.center {
  /* Old browsers */
  -webkit-box-pack: center;
  -moz-box-pack: center;
  box-pack: center;
  /* Modern browsers */
  justify-content: center;
}
.hbox.baseline,
.vbox.baseline,
.baseline {
  /* Old browsers */
  -webkit-box-pack: baseline;
  -moz-box-pack: baseline;
  box-pack: baseline;
  /* Modern browsers */
  justify-content: baseline;
}
.hbox.stretch,
.vbox.stretch,
.stretch {
  /* Old browsers */
  -webkit-box-pack: stretch;
  -moz-box-pack: stretch;
  box-pack: stretch;
  /* Modern browsers */
  justify-content: stretch;
}
.hbox.align-start,
.vbox.align-start,
.align-start {
  /* Old browsers */
  -webkit-box-align: start;
  -moz-box-align: start;
  box-align: start;
  /* Modern browsers */
  align-items: flex-start;
}
.hbox.align-end,
.vbox.align-end,
.align-end {
  /* Old browsers */
  -webkit-box-align: end;
  -moz-box-align: end;
  box-align: end;
  /* Modern browsers */
  align-items: flex-end;
}
.hbox.align-center,
.vbox.align-center,
.align-center {
  /* Old browsers */
  -webkit-box-align: center;
  -moz-box-align: center;
  box-align: center;
  /* Modern browsers */
  align-items: center;
}
.hbox.align-baseline,
.vbox.align-baseline,
.align-baseline {
  /* Old browsers */
  -webkit-box-align: baseline;
  -moz-box-align: baseline;
  box-align: baseline;
  /* Modern browsers */
  align-items: baseline;
}
.hbox.align-stretch,
.vbox.align-stretch,
.align-stretch {
  /* Old browsers */
  -webkit-box-align: stretch;
  -moz-box-align: stretch;
  box-align: stretch;
  /* Modern browsers */
  align-items: stretch;
}
div.error {
  margin: 2em;
  text-align: center;
}
div.error > h1 {
  font-size: 500%;
  line-height: normal;
}
div.error > p {
  font-size: 200%;
  line-height: normal;
}
div.traceback-wrapper {
  text-align: left;
  max-width: 800px;
  margin: auto;
}
div.traceback-wrapper pre.traceback {
  max-height: 600px;
  overflow: auto;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
body {
  background-color: #fff;
  /* This makes sure that the body covers the entire window and needs to
       be in a different element than the display: box in wrapper below */
  position: absolute;
  left: 0px;
  right: 0px;
  top: 0px;
  bottom: 0px;
  overflow: visible;
}
body > #header {
  /* Initially hidden to prevent FLOUC */
  display: none;
  background-color: #fff;
  /* Display over codemirror */
  position: relative;
  z-index: 100;
}
body > #header #header-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 5px;
  padding-bottom: 5px;
  padding-top: 5px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
body > #header .header-bar {
  width: 100%;
  height: 1px;
  background: #e7e7e7;
  margin-bottom: -1px;
}
@media print {
  body > #header {
    display: none !important;
  }
}
#header-spacer {
  width: 100%;
  visibility: hidden;
}
@media print {
  #header-spacer {
    display: none;
  }
}
#ipython_notebook {
  padding-left: 0px;
  padding-top: 1px;
  padding-bottom: 1px;
}
[dir="rtl"] #ipython_notebook {
  margin-right: 10px;
  margin-left: 0;
}
[dir="rtl"] #ipython_notebook.pull-left {
  float: right !important;
  float: right;
}
.flex-spacer {
  flex: 1;
}
#noscript {
  width: auto;
  padding-top: 16px;
  padding-bottom: 16px;
  text-align: center;
  font-size: 22px;
  color: red;
  font-weight: bold;
}
#ipython_notebook img {
  height: 28px;
}
#site {
  width: 100%;
  display: none;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  overflow: auto;
}
@media print {
  #site {
    height: auto !important;
  }
}
/* Smaller buttons */
.ui-button .ui-button-text {
  padding: 0.2em 0.8em;
  font-size: 77%;
}
input.ui-button {
  padding: 0.3em 0.9em;
}
span#kernel_logo_widget {
  margin: 0 10px;
}
span#login_widget {
  float: right;
}
[dir="rtl"] span#login_widget {
  float: left;
}
span#login_widget > .button,
#logout {
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
span#login_widget > .button:focus,
#logout:focus,
span#login_widget > .button.focus,
#logout.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
span#login_widget > .button:hover,
#logout:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
span#login_widget > .button:active,
#logout:active,
span#login_widget > .button.active,
#logout.active,
.open > .dropdown-togglespan#login_widget > .button,
.open > .dropdown-toggle#logout {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
span#login_widget > .button:active:hover,
#logout:active:hover,
span#login_widget > .button.active:hover,
#logout.active:hover,
.open > .dropdown-togglespan#login_widget > .button:hover,
.open > .dropdown-toggle#logout:hover,
span#login_widget > .button:active:focus,
#logout:active:focus,
span#login_widget > .button.active:focus,
#logout.active:focus,
.open > .dropdown-togglespan#login_widget > .button:focus,
.open > .dropdown-toggle#logout:focus,
span#login_widget > .button:active.focus,
#logout:active.focus,
span#login_widget > .button.active.focus,
#logout.active.focus,
.open > .dropdown-togglespan#login_widget > .button.focus,
.open > .dropdown-toggle#logout.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
span#login_widget > .button:active,
#logout:active,
span#login_widget > .button.active,
#logout.active,
.open > .dropdown-togglespan#login_widget > .button,
.open > .dropdown-toggle#logout {
  background-image: none;
}
span#login_widget > .button.disabled:hover,
#logout.disabled:hover,
span#login_widget > .button[disabled]:hover,
#logout[disabled]:hover,
fieldset[disabled] span#login_widget > .button:hover,
fieldset[disabled] #logout:hover,
span#login_widget > .button.disabled:focus,
#logout.disabled:focus,
span#login_widget > .button[disabled]:focus,
#logout[disabled]:focus,
fieldset[disabled] span#login_widget > .button:focus,
fieldset[disabled] #logout:focus,
span#login_widget > .button.disabled.focus,
#logout.disabled.focus,
span#login_widget > .button[disabled].focus,
#logout[disabled].focus,
fieldset[disabled] span#login_widget > .button.focus,
fieldset[disabled] #logout.focus {
  background-color: #fff;
  border-color: #ccc;
}
span#login_widget > .button .badge,
#logout .badge {
  color: #fff;
  background-color: #333;
}
.nav-header {
  text-transform: none;
}
#header > span {
  margin-top: 10px;
}
.modal_stretch .modal-dialog {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  min-height: 80vh;
}
.modal_stretch .modal-dialog .modal-body {
  max-height: calc(100vh - 200px);
  overflow: auto;
  flex: 1;
}
.modal-header {
  cursor: move;
}
@media (min-width: 768px) {
  .modal .modal-dialog {
    width: 700px;
  }
}
@media (min-width: 768px) {
  select.form-control {
    margin-left: 12px;
    margin-right: 12px;
  }
}
/*!
*
* IPython auth
*
*/
.center-nav {
  display: inline-block;
  margin-bottom: -4px;
}
[dir="rtl"] .center-nav form.pull-left {
  float: right !important;
  float: right;
}
[dir="rtl"] .center-nav .navbar-text {
  float: right;
}
[dir="rtl"] .navbar-inner {
  text-align: right;
}
[dir="rtl"] div.text-left {
  text-align: right;
}
/*!
*
* IPython tree view
*
*/
/* We need an invisible input field on top of the sentense*/
/* "Drag file onto the list ..." */
.alternate_upload {
  background-color: none;
  display: inline;
}
.alternate_upload.form {
  padding: 0;
  margin: 0;
}
.alternate_upload input.fileinput {
  position: absolute;
  display: block;
  width: 100%;
  height: 100%;
  overflow: hidden;
  cursor: pointer;
  opacity: 0;
  z-index: 2;
}
.alternate_upload .btn-xs > input.fileinput {
  margin: -1px -5px;
}
.alternate_upload .btn-upload {
  position: relative;
  height: 22px;
}
::-webkit-file-upload-button {
  cursor: pointer;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
ul#tabs {
  margin-bottom: 4px;
}
ul#tabs a {
  padding-top: 6px;
  padding-bottom: 4px;
}
[dir="rtl"] ul#tabs.nav-tabs > li {
  float: right;
}
[dir="rtl"] ul#tabs.nav.nav-tabs {
  padding-right: 0;
}
ul.breadcrumb a:focus,
ul.breadcrumb a:hover {
  text-decoration: none;
}
ul.breadcrumb i.icon-home {
  font-size: 16px;
  margin-right: 4px;
}
ul.breadcrumb span {
  color: #5e5e5e;
}
.list_toolbar {
  padding: 4px 0 4px 0;
  vertical-align: middle;
}
.list_toolbar .tree-buttons {
  padding-top: 1px;
}
[dir="rtl"] .list_toolbar .tree-buttons .pull-right {
  float: left !important;
  float: left;
}
[dir="rtl"] .list_toolbar .col-sm-4,
[dir="rtl"] .list_toolbar .col-sm-8 {
  float: right;
}
.dynamic-buttons {
  padding-top: 3px;
  display: inline-block;
}
.list_toolbar [class*="span"] {
  min-height: 24px;
}
.list_header {
  font-weight: bold;
  background-color: #EEE;
}
.list_placeholder {
  font-weight: bold;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
}
.list_container {
  margin-top: 4px;
  margin-bottom: 20px;
  border: 1px solid #ddd;
  border-radius: 2px;
}
.list_container > div {
  border-bottom: 1px solid #ddd;
}
.list_container > div:hover .list-item {
  background-color: red;
}
.list_container > div:last-child {
  border: none;
}
.list_item:hover .list_item {
  background-color: #ddd;
}
.list_item a {
  text-decoration: none;
}
.list_item:hover {
  background-color: #fafafa;
}
.list_header > div,
.list_item > div {
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
  line-height: 22px;
}
.list_header > div input,
.list_item > div input {
  margin-right: 7px;
  margin-left: 14px;
  vertical-align: text-bottom;
  line-height: 22px;
  position: relative;
  top: -1px;
}
.list_header > div .item_link,
.list_item > div .item_link {
  margin-left: -1px;
  vertical-align: baseline;
  line-height: 22px;
}
[dir="rtl"] .list_item > div input {
  margin-right: 0;
}
.new-file input[type=checkbox] {
  visibility: hidden;
}
.item_name {
  line-height: 22px;
  height: 24px;
}
.item_icon {
  font-size: 14px;
  color: #5e5e5e;
  margin-right: 7px;
  margin-left: 7px;
  line-height: 22px;
  vertical-align: baseline;
}
.item_modified {
  margin-right: 7px;
  margin-left: 7px;
}
[dir="rtl"] .item_modified.pull-right {
  float: left !important;
  float: left;
}
.item_buttons {
  line-height: 1em;
  margin-left: -5px;
}
.item_buttons .btn,
.item_buttons .btn-group,
.item_buttons .input-group {
  float: left;
}
.item_buttons > .btn,
.item_buttons > .btn-group,
.item_buttons > .input-group {
  margin-left: 5px;
}
.item_buttons .btn {
  min-width: 13ex;
}
.item_buttons .running-indicator {
  padding-top: 4px;
  color: #5cb85c;
}
.item_buttons .kernel-name {
  padding-top: 4px;
  color: #5bc0de;
  margin-right: 7px;
  float: left;
}
[dir="rtl"] .item_buttons.pull-right {
  float: left !important;
  float: left;
}
[dir="rtl"] .item_buttons .kernel-name {
  margin-left: 7px;
  float: right;
}
.toolbar_info {
  height: 24px;
  line-height: 24px;
}
.list_item input:not([type=checkbox]) {
  padding-top: 3px;
  padding-bottom: 3px;
  height: 22px;
  line-height: 14px;
  margin: 0px;
}
.highlight_text {
  color: blue;
}
#project_name {
  display: inline-block;
  padding-left: 7px;
  margin-left: -2px;
}
#project_name > .breadcrumb {
  padding: 0px;
  margin-bottom: 0px;
  background-color: transparent;
  font-weight: bold;
}
.sort_button {
  display: inline-block;
  padding-left: 7px;
}
[dir="rtl"] .sort_button.pull-right {
  float: left !important;
  float: left;
}
#tree-selector {
  padding-right: 0px;
}
#button-select-all {
  min-width: 50px;
}
[dir="rtl"] #button-select-all.btn {
  float: right ;
}
#select-all {
  margin-left: 7px;
  margin-right: 2px;
  margin-top: 2px;
  height: 16px;
}
[dir="rtl"] #select-all.pull-left {
  float: right !important;
  float: right;
}
.menu_icon {
  margin-right: 2px;
}
.tab-content .row {
  margin-left: 0px;
  margin-right: 0px;
}
.folder_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f114";
}
.folder_icon:before.fa-pull-left {
  margin-right: .3em;
}
.folder_icon:before.fa-pull-right {
  margin-left: .3em;
}
.folder_icon:before.pull-left {
  margin-right: .3em;
}
.folder_icon:before.pull-right {
  margin-left: .3em;
}
.notebook_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f02d";
  position: relative;
  top: -1px;
}
.notebook_icon:before.fa-pull-left {
  margin-right: .3em;
}
.notebook_icon:before.fa-pull-right {
  margin-left: .3em;
}
.notebook_icon:before.pull-left {
  margin-right: .3em;
}
.notebook_icon:before.pull-right {
  margin-left: .3em;
}
.running_notebook_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f02d";
  position: relative;
  top: -1px;
  color: #5cb85c;
}
.running_notebook_icon:before.fa-pull-left {
  margin-right: .3em;
}
.running_notebook_icon:before.fa-pull-right {
  margin-left: .3em;
}
.running_notebook_icon:before.pull-left {
  margin-right: .3em;
}
.running_notebook_icon:before.pull-right {
  margin-left: .3em;
}
.file_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f016";
  position: relative;
  top: -2px;
}
.file_icon:before.fa-pull-left {
  margin-right: .3em;
}
.file_icon:before.fa-pull-right {
  margin-left: .3em;
}
.file_icon:before.pull-left {
  margin-right: .3em;
}
.file_icon:before.pull-right {
  margin-left: .3em;
}
#notebook_toolbar .pull-right {
  padding-top: 0px;
  margin-right: -1px;
}
ul#new-menu {
  left: auto;
  right: 0;
}
#new-menu .dropdown-header {
  font-size: 10px;
  border-bottom: 1px solid #e5e5e5;
  padding: 0 0 3px;
  margin: -3px 20px 0;
}
.kernel-menu-icon {
  padding-right: 12px;
  width: 24px;
  content: "\f096";
}
.kernel-menu-icon:before {
  content: "\f096";
}
.kernel-menu-icon-current:before {
  content: "\f00c";
}
#tab_content {
  padding-top: 20px;
}
#running .panel-group .panel {
  margin-top: 3px;
  margin-bottom: 1em;
}
#running .panel-group .panel .panel-heading {
  background-color: #EEE;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 7px;
  padding-right: 7px;
  line-height: 22px;
}
#running .panel-group .panel .panel-heading a:focus,
#running .panel-group .panel .panel-heading a:hover {
  text-decoration: none;
}
#running .panel-group .panel .panel-body {
  padding: 0px;
}
#running .panel-group .panel .panel-body .list_container {
  margin-top: 0px;
  margin-bottom: 0px;
  border: 0px;
  border-radius: 0px;
}
#running .panel-group .panel .panel-body .list_container .list_item {
  border-bottom: 1px solid #ddd;
}
#running .panel-group .panel .panel-body .list_container .list_item:last-child {
  border-bottom: 0px;
}
.delete-button {
  display: none;
}
.duplicate-button {
  display: none;
}
.rename-button {
  display: none;
}
.move-button {
  display: none;
}
.download-button {
  display: none;
}
.shutdown-button {
  display: none;
}
.dynamic-instructions {
  display: inline-block;
  padding-top: 4px;
}
/*!
*
* IPython text editor webapp
*
*/
.selected-keymap i.fa {
  padding: 0px 5px;
}
.selected-keymap i.fa:before {
  content: "\f00c";
}
#mode-menu {
  overflow: auto;
  max-height: 20em;
}
.edit_app #header {
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
.edit_app #menubar .navbar {
  /* Use a negative 1 bottom margin, so the border overlaps the border of the
    header */
  margin-bottom: -1px;
}
.dirty-indicator {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator.fa-pull-left {
  margin-right: .3em;
}
.dirty-indicator.fa-pull-right {
  margin-left: .3em;
}
.dirty-indicator.pull-left {
  margin-right: .3em;
}
.dirty-indicator.pull-right {
  margin-left: .3em;
}
.dirty-indicator-dirty {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator-dirty.fa-pull-left {
  margin-right: .3em;
}
.dirty-indicator-dirty.fa-pull-right {
  margin-left: .3em;
}
.dirty-indicator-dirty.pull-left {
  margin-right: .3em;
}
.dirty-indicator-dirty.pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 20px;
}
.dirty-indicator-clean.fa-pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean.fa-pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean.pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean.pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f00c";
}
.dirty-indicator-clean:before.fa-pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean:before.fa-pull-right {
  margin-left: .3em;
}
.dirty-indicator-clean:before.pull-left {
  margin-right: .3em;
}
.dirty-indicator-clean:before.pull-right {
  margin-left: .3em;
}
#filename {
  font-size: 16pt;
  display: table;
  padding: 0px 5px;
}
#current-mode {
  padding-left: 5px;
  padding-right: 5px;
}
#texteditor-backdrop {
  padding-top: 20px;
  padding-bottom: 20px;
}
@media not print {
  #texteditor-backdrop {
    background-color: #EEE;
  }
}
@media print {
  #texteditor-backdrop #texteditor-container .CodeMirror-gutter,
  #texteditor-backdrop #texteditor-container .CodeMirror-gutters {
    background-color: #fff;
  }
}
@media not print {
  #texteditor-backdrop #texteditor-container .CodeMirror-gutter,
  #texteditor-backdrop #texteditor-container .CodeMirror-gutters {
    background-color: #fff;
  }
}
@media not print {
  #texteditor-backdrop #texteditor-container {
    padding: 0px;
    background-color: #fff;
    -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
    box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  }
}
.CodeMirror-dialog {
  background-color: #fff;
}
/*!
*
* IPython notebook
*
*/
/* CSS font colors for translated ANSI escape sequences */
/* The color values are a mix of
   http://www.xcolors.net/dl/baskerville-ivorylight and
   http://www.xcolors.net/dl/euphrasia */
.ansi-black-fg {
  color: #3E424D;
}
.ansi-black-bg {
  background-color: #3E424D;
}
.ansi-black-intense-fg {
  color: #282C36;
}
.ansi-black-intense-bg {
  background-color: #282C36;
}
.ansi-red-fg {
  color: #E75C58;
}
.ansi-red-bg {
  background-color: #E75C58;
}
.ansi-red-intense-fg {
  color: #B22B31;
}
.ansi-red-intense-bg {
  background-color: #B22B31;
}
.ansi-green-fg {
  color: #00A250;
}
.ansi-green-bg {
  background-color: #00A250;
}
.ansi-green-intense-fg {
  color: #007427;
}
.ansi-green-intense-bg {
  background-color: #007427;
}
.ansi-yellow-fg {
  color: #DDB62B;
}
.ansi-yellow-bg {
  background-color: #DDB62B;
}
.ansi-yellow-intense-fg {
  color: #B27D12;
}
.ansi-yellow-intense-bg {
  background-color: #B27D12;
}
.ansi-blue-fg {
  color: #208FFB;
}
.ansi-blue-bg {
  background-color: #208FFB;
}
.ansi-blue-intense-fg {
  color: #0065CA;
}
.ansi-blue-intense-bg {
  background-color: #0065CA;
}
.ansi-magenta-fg {
  color: #D160C4;
}
.ansi-magenta-bg {
  background-color: #D160C4;
}
.ansi-magenta-intense-fg {
  color: #A03196;
}
.ansi-magenta-intense-bg {
  background-color: #A03196;
}
.ansi-cyan-fg {
  color: #60C6C8;
}
.ansi-cyan-bg {
  background-color: #60C6C8;
}
.ansi-cyan-intense-fg {
  color: #258F8F;
}
.ansi-cyan-intense-bg {
  background-color: #258F8F;
}
.ansi-white-fg {
  color: #C5C1B4;
}
.ansi-white-bg {
  background-color: #C5C1B4;
}
.ansi-white-intense-fg {
  color: #A1A6B2;
}
.ansi-white-intense-bg {
  background-color: #A1A6B2;
}
.ansi-default-inverse-fg {
  color: #FFFFFF;
}
.ansi-default-inverse-bg {
  background-color: #000000;
}
.ansi-bold {
  font-weight: bold;
}
.ansi-underline {
  text-decoration: underline;
}
/* The following styles are deprecated an will be removed in a future version */
.ansibold {
  font-weight: bold;
}
.ansi-inverse {
  outline: 0.5px dotted;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  position: relative;
  overflow: visible;
}
div.cell:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: transparent;
}
div.cell.jupyter-soft-selected {
  border-left-color: #E3F2FD;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #E3F2FD;
  border-right-width: 1px;
  background: #E3F2FD;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected,
div.cell.selected.jupyter-soft-selected {
  border-color: #ababab;
}
div.cell.selected:before,
div.cell.selected.jupyter-soft-selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #42A5F5;
}
@media print {
  div.cell.selected,
  div.cell.selected.jupyter-soft-selected {
    border-color: transparent;
  }
}
.edit_mode div.cell.selected {
  border-color: #66BB6A;
}
.edit_mode div.cell.selected:before {
  position: absolute;
  display: block;
  top: -1px;
  left: -1px;
  width: 5px;
  height: calc(100% +  2px);
  content: '';
  background: #66BB6A;
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  min-width: 0;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell > div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #303F9F;
  border-top: 1px solid transparent;
}
div.input_area > div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area > div.highlight > pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the <head> if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  /* Note that this should set vertical padding only, since CodeMirror assumes
       that horizontal padding will be set on CodeMirror pre */
  padding: 0.4em 0;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only,
    use .CodeMirror-lines for vertical */
  padding: 0 0.4em;
  border: 0;
  border-radius: 0;
}
.CodeMirror-cursor {
  border-left: 1.4px solid black;
}
@media screen and (min-width: 2138px) and (max-width: 4319px) {
  .CodeMirror-cursor {
    border-left: 2px solid black;
  }
}
@media screen and (min-width: 4320px) {
  .CodeMirror-cursor {
    border-left: 4px solid black;
  }
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #BA2121;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #AA22FF;
  font-weight: bold;
}
.highlight-meta {
  color: #AA22FF;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #AA22FF;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #BA2121;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #AA22FF;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but FF barfs all over that */
  height: 24em;
  /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/FF */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area .rendered_html table {
  margin-left: 0;
  margin-right: 0;
}
div.output_area .rendered_html img {
  margin-left: 0;
  margin-right: 0;
}
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
div.output_area .mglyph > img {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 1px 0 1px 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}
.rendered_html em {
  font-style: italic;
}
.rendered_html strong {
  font-weight: bold;
}
.rendered_html u {
  text-decoration: underline;
}
.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}
.rendered_html h1 {
  font-size: 185.7%;
  margin: 1.08em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h2 {
  font-size: 157.1%;
  margin: 1.27em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h3 {
  font-size: 128.6%;
  margin: 1.55em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h4 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
}
.rendered_html h5 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
  font-style: italic;
}
.rendered_html h6 {
  font-size: 100%;
  margin: 2em 0 0 0;
  font-weight: bold;
  line-height: 1.0;
  font-style: italic;
}
.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}
.rendered_html ul:not(.list-inline),
.rendered_html ol:not(.list-inline) {
  padding-left: 2em;
}
.rendered_html ul {
  list-style: disc;
}
.rendered_html ul ul {
  list-style: square;
  margin-top: 0;
}
.rendered_html ul ul ul {
  list-style: circle;
}
.rendered_html ol {
  list-style: decimal;
}
.rendered_html ol ol {
  list-style: upper-alpha;
  margin-top: 0;
}
.rendered_html ol ol ol {
  list-style: lower-alpha;
}
.rendered_html ol ol ol ol {
  list-style: lower-roman;
}
.rendered_html ol ol ol ol ol {
  list-style: decimal;
}
.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}
.rendered_html hr {
  color: black;
  background-color: black;
}
.rendered_html pre {
  margin: 1em 2em;
  padding: 0px;
  background-color: #fff;
}
.rendered_html code {
  background-color: #eff0f1;
}
.rendered_html p code {
  padding: 1px 5px;
}
.rendered_html pre code {
  background-color: #fff;
}
.rendered_html pre,
.rendered_html code {
  border: 0;
  color: #000;
  font-size: 100%;
}
.rendered_html blockquote {
  margin: 1em 2em;
}
.rendered_html table {
  margin-left: auto;
  margin-right: auto;
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.rendered_html tr,
.rendered_html th,
.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.rendered_html th {
  font-weight: bold;
}
.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
.rendered_html * + table {
  margin-top: 1em;
}
.rendered_html p {
  text-align: left;
}
.rendered_html * + p {
  margin-top: 1em;
}
.rendered_html img {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,
.rendered_html svg {
  max-width: 100%;
  height: auto;
}
.rendered_html img.unconfined,
.rendered_html svg.unconfined {
  max-width: none;
}
.rendered_html .alert {
  margin-bottom: initial;
}
.rendered_html * + .alert {
  margin-top: 1em;
}
[dir="rtl"] .rendered_html p {
  text-align: right;
}
div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell > div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered .rendered_html {
  overflow-x: auto;
  overflow-y: hidden;
}
.text_cell.rendered .rendered_html tr,
.text_cell.rendered .rendered_html th,
.text_cell.rendered .rendered_html td {
  max-width: none;
}
.text_cell.unrendered .text_cell_render {
  display: none;
}
.text_cell .dropzone .input_area {
  border: 2px dashed #bababa;
  margin: -1px;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
/*!
*
* IPython notebook webapp
*
*/
@media (max-width: 767px) {
  .notebook_app {
    padding-left: 0px;
    padding-right: 0px;
  }
}
#ipython-main-app {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  height: 100%;
}
div#notebook_panel {
  margin: 0px;
  padding: 0px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  height: 100%;
}
div#notebook {
  font-size: 14px;
  line-height: 20px;
  overflow-y: hidden;
  overflow-x: auto;
  width: 100%;
  /* This spaces the page away from the edge of the notebook area */
  padding-top: 20px;
  margin: 0px;
  outline: none;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  min-height: 100%;
}
@media not print {
  #notebook-container {
    padding: 15px;
    background-color: #fff;
    min-height: 0;
    -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
    box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  }
}
@media print {
  #notebook-container {
    width: 100%;
  }
}
div.ui-widget-content {
  border: 1px solid #ababab;
  outline: none;
}
pre.dialog {
  background-color: #f7f7f7;
  border: 1px solid #ddd;
  border-radius: 2px;
  padding: 0.4em;
  padding-left: 2em;
}
p.dialog {
  padding: 0.2em;
}
/* Word-wrap output correctly.  This is the CSS3 spelling, though Firefox seems
   to not honor it correctly.  Webkit browsers (Chrome, rekonq, Safari) do.
 */
pre,
code,
kbd,
samp {
  white-space: pre-wrap;
}
#fonttest {
  font-family: monospace;
}
p {
  margin-bottom: 0;
}
.end_space {
  min-height: 100px;
  transition: height .2s ease;
}
.notebook_app > #header {
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
@media not print {
  .notebook_app {
    background-color: #EEE;
  }
}
kbd {
  border-style: solid;
  border-width: 1px;
  box-shadow: none;
  margin: 2px;
  padding-left: 2px;
  padding-right: 2px;
  padding-top: 1px;
  padding-bottom: 1px;
}
.jupyter-keybindings {
  padding: 1px;
  line-height: 24px;
  border-bottom: 1px solid gray;
}
.jupyter-keybindings input {
  margin: 0;
  padding: 0;
  border: none;
}
.jupyter-keybindings i {
  padding: 6px;
}
.well code {
  background-color: #ffffff;
  border-color: #ababab;
  border-width: 1px;
  border-style: solid;
  padding: 2px;
  padding-top: 1px;
  padding-bottom: 1px;
}
/* CSS for the cell toolbar */
.celltoolbar {
  border: thin solid #CFCFCF;
  border-bottom: none;
  background: #EEE;
  border-radius: 2px 2px 0px 0px;
  width: 100%;
  height: 29px;
  padding-right: 4px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-pack: end;
  -moz-box-pack: end;
  box-pack: end;
  /* Modern browsers */
  justify-content: flex-end;
  display: -webkit-flex;
}
@media print {
  .celltoolbar {
    display: none;
  }
}
.ctb_hideshow {
  display: none;
  vertical-align: bottom;
}
/* ctb_show is added to the ctb_hideshow div to show the cell toolbar.
   Cell toolbars are only shown when the ctb_global_show class is also set.
*/
.ctb_global_show .ctb_show.ctb_hideshow {
  display: block;
}
.ctb_global_show .ctb_show + .input_area,
.ctb_global_show .ctb_show + div.text_cell_input,
.ctb_global_show .ctb_show ~ div.text_cell_render {
  border-top-right-radius: 0px;
  border-top-left-radius: 0px;
}
.ctb_global_show .ctb_show ~ div.text_cell_render {
  border: 1px solid #cfcfcf;
}
.celltoolbar {
  font-size: 87%;
  padding-top: 3px;
}
.celltoolbar select {
  display: block;
  width: 100%;
  height: 32px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
  width: inherit;
  font-size: inherit;
  height: 22px;
  padding: 0px;
  display: inline-block;
}
.celltoolbar select:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
}
.celltoolbar select::-moz-placeholder {
  color: #999;
  opacity: 1;
}
.celltoolbar select:-ms-input-placeholder {
  color: #999;
}
.celltoolbar select::-webkit-input-placeholder {
  color: #999;
}
.celltoolbar select::-ms-expand {
  border: 0;
  background-color: transparent;
}
.celltoolbar select[disabled],
.celltoolbar select[readonly],
fieldset[disabled] .celltoolbar select {
  background-color: #eeeeee;
  opacity: 1;
}
.celltoolbar select[disabled],
fieldset[disabled] .celltoolbar select {
  cursor: not-allowed;
}
textarea.celltoolbar select {
  height: auto;
}
select.celltoolbar select {
  height: 30px;
  line-height: 30px;
}
textarea.celltoolbar select,
select[multiple].celltoolbar select {
  height: auto;
}
.celltoolbar label {
  margin-left: 5px;
  margin-right: 5px;
}
.tags_button_container {
  width: 100%;
  display: flex;
}
.tag-container {
  display: flex;
  flex-direction: row;
  flex-grow: 1;
  overflow: hidden;
  position: relative;
}
.tag-container > * {
  margin: 0 4px;
}
.remove-tag-btn {
  margin-left: 4px;
}
.tags-input {
  display: flex;
}
.cell-tag:last-child:after {
  content: "";
  position: absolute;
  right: 0;
  width: 40px;
  height: 100%;
  /* Fade to background color of cell toolbar */
  background: linear-gradient(to right, rgba(0, 0, 0, 0), #EEE);
}
.tags-input > * {
  margin-left: 4px;
}
.cell-tag,
.tags-input input,
.tags-input button {
  display: block;
  width: 100%;
  height: 32px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1.42857143;
  color: #555555;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ccc;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);
  -webkit-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;
  height: 30px;
  padding: 5px 10px;
  font-size: 12px;
  line-height: 1.5;
  border-radius: 1px;
  box-shadow: none;
  width: inherit;
  font-size: inherit;
  height: 22px;
  line-height: 22px;
  padding: 0px 4px;
  display: inline-block;
}
.cell-tag:focus,
.tags-input input:focus,
.tags-input button:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
  box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, 0.6);
}
.cell-tag::-moz-placeholder,
.tags-input input::-moz-placeholder,
.tags-input button::-moz-placeholder {
  color: #999;
  opacity: 1;
}
.cell-tag:-ms-input-placeholder,
.tags-input input:-ms-input-placeholder,
.tags-input button:-ms-input-placeholder {
  color: #999;
}
.cell-tag::-webkit-input-placeholder,
.tags-input input::-webkit-input-placeholder,
.tags-input button::-webkit-input-placeholder {
  color: #999;
}
.cell-tag::-ms-expand,
.tags-input input::-ms-expand,
.tags-input button::-ms-expand {
  border: 0;
  background-color: transparent;
}
.cell-tag[disabled],
.tags-input input[disabled],
.tags-input button[disabled],
.cell-tag[readonly],
.tags-input input[readonly],
.tags-input button[readonly],
fieldset[disabled] .cell-tag,
fieldset[disabled] .tags-input input,
fieldset[disabled] .tags-input button {
  background-color: #eeeeee;
  opacity: 1;
}
.cell-tag[disabled],
.tags-input input[disabled],
.tags-input button[disabled],
fieldset[disabled] .cell-tag,
fieldset[disabled] .tags-input input,
fieldset[disabled] .tags-input button {
  cursor: not-allowed;
}
textarea.cell-tag,
textarea.tags-input input,
textarea.tags-input button {
  height: auto;
}
select.cell-tag,
select.tags-input input,
select.tags-input button {
  height: 30px;
  line-height: 30px;
}
textarea.cell-tag,
textarea.tags-input input,
textarea.tags-input button,
select[multiple].cell-tag,
select[multiple].tags-input input,
select[multiple].tags-input button {
  height: auto;
}
.cell-tag,
.tags-input button {
  padding: 0px 4px;
}
.cell-tag {
  background-color: #fff;
  white-space: nowrap;
}
.tags-input input[type=text]:focus {
  outline: none;
  box-shadow: none;
  border-color: #ccc;
}
.completions {
  position: absolute;
  z-index: 110;
  overflow: hidden;
  border: 1px solid #ababab;
  border-radius: 2px;
  -webkit-box-shadow: 0px 6px 10px -1px #adadad;
  box-shadow: 0px 6px 10px -1px #adadad;
  line-height: 1;
}
.completions select {
  background: white;
  outline: none;
  border: none;
  padding: 0px;
  margin: 0px;
  overflow: auto;
  font-family: monospace;
  font-size: 110%;
  color: #000;
  width: auto;
}
.completions select option.context {
  color: #286090;
}
#kernel_logo_widget .current_kernel_logo {
  display: none;
  margin-top: -1px;
  margin-bottom: -1px;
  width: 32px;
  height: 32px;
}
[dir="rtl"] #kernel_logo_widget {
  float: left !important;
  float: left;
}
.modal .modal-body .move-path {
  display: flex;
  flex-direction: row;
  justify-content: space;
  align-items: center;
}
.modal .modal-body .move-path .server-root {
  padding-right: 20px;
}
.modal .modal-body .move-path .path-input {
  flex: 1;
}
#menubar {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  margin-top: 1px;
}
#menubar .navbar {
  border-top: 1px;
  border-radius: 0px 0px 2px 2px;
  margin-bottom: 0px;
}
#menubar .navbar-toggle {
  float: left;
  padding-top: 7px;
  padding-bottom: 7px;
  border: none;
}
#menubar .navbar-collapse {
  clear: left;
}
[dir="rtl"] #menubar .navbar-toggle {
  float: right;
}
[dir="rtl"] #menubar .navbar-collapse {
  clear: right;
}
[dir="rtl"] #menubar .navbar-nav {
  float: right;
}
[dir="rtl"] #menubar .nav {
  padding-right: 0px;
}
[dir="rtl"] #menubar .navbar-nav > li {
  float: right;
}
[dir="rtl"] #menubar .navbar-right {
  float: left !important;
}
[dir="rtl"] ul.dropdown-menu {
  text-align: right;
  left: auto;
}
[dir="rtl"] ul#new-menu.dropdown-menu {
  right: auto;
  left: 0;
}
.nav-wrapper {
  border-bottom: 1px solid #e7e7e7;
}
i.menu-icon {
  padding-top: 4px;
}
[dir="rtl"] i.menu-icon.pull-right {
  float: left !important;
  float: left;
}
ul#help_menu li a {
  overflow: hidden;
  padding-right: 2.2em;
}
ul#help_menu li a i {
  margin-right: -1.2em;
}
[dir="rtl"] ul#help_menu li a {
  padding-left: 2.2em;
}
[dir="rtl"] ul#help_menu li a i {
  margin-right: 0;
  margin-left: -1.2em;
}
[dir="rtl"] ul#help_menu li a i.pull-right {
  float: left !important;
  float: left;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu > .dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
}
[dir="rtl"] .dropdown-submenu > .dropdown-menu {
  right: 100%;
  margin-right: -1px;
}
.dropdown-submenu:hover > .dropdown-menu {
  display: block;
}
.dropdown-submenu > a:after {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  display: block;
  content: "\f0da";
  float: right;
  color: #333333;
  margin-top: 2px;
  margin-right: -10px;
}
.dropdown-submenu > a:after.fa-pull-left {
  margin-right: .3em;
}
.dropdown-submenu > a:after.fa-pull-right {
  margin-left: .3em;
}
.dropdown-submenu > a:after.pull-left {
  margin-right: .3em;
}
.dropdown-submenu > a:after.pull-right {
  margin-left: .3em;
}
[dir="rtl"] .dropdown-submenu > a:after {
  float: left;
  content: "\f0d9";
  margin-right: 0;
  margin-left: -10px;
}
.dropdown-submenu:hover > a:after {
  color: #262626;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left > .dropdown-menu {
  left: -100%;
  margin-left: 10px;
}
#notification_area {
  float: right !important;
  float: right;
  z-index: 10;
}
[dir="rtl"] #notification_area {
  float: left !important;
  float: left;
}
.indicator_area {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
}
[dir="rtl"] .indicator_area {
  float: left !important;
  float: left;
}
#kernel_indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
  border-left: 1px solid;
}
#kernel_indicator .kernel_indicator_name {
  padding-left: 5px;
  padding-right: 5px;
}
[dir="rtl"] #kernel_indicator {
  float: left !important;
  float: left;
  border-left: 0;
  border-right: 1px solid;
}
#modal_indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
}
[dir="rtl"] #modal_indicator {
  float: left !important;
  float: left;
}
#readonly-indicator {
  float: right !important;
  float: right;
  color: #777;
  margin-left: 5px;
  margin-right: 5px;
  width: 11px;
  z-index: 10;
  text-align: center;
  width: auto;
  margin-top: 2px;
  margin-bottom: 0px;
  margin-left: 0px;
  margin-right: 0px;
  display: none;
}
.modal_indicator:before {
  width: 1.28571429em;
  text-align: center;
}
.edit_mode .modal_indicator:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f040";
}
.edit_mode .modal_indicator:before.fa-pull-left {
  margin-right: .3em;
}
.edit_mode .modal_indicator:before.fa-pull-right {
  margin-left: .3em;
}
.edit_mode .modal_indicator:before.pull-left {
  margin-right: .3em;
}
.edit_mode .modal_indicator:before.pull-right {
  margin-left: .3em;
}
.command_mode .modal_indicator:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: ' ';
}
.command_mode .modal_indicator:before.fa-pull-left {
  margin-right: .3em;
}
.command_mode .modal_indicator:before.fa-pull-right {
  margin-left: .3em;
}
.command_mode .modal_indicator:before.pull-left {
  margin-right: .3em;
}
.command_mode .modal_indicator:before.pull-right {
  margin-left: .3em;
}
.kernel_idle_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f10c";
}
.kernel_idle_icon:before.fa-pull-left {
  margin-right: .3em;
}
.kernel_idle_icon:before.fa-pull-right {
  margin-left: .3em;
}
.kernel_idle_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_idle_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_busy_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f111";
}
.kernel_busy_icon:before.fa-pull-left {
  margin-right: .3em;
}
.kernel_busy_icon:before.fa-pull-right {
  margin-left: .3em;
}
.kernel_busy_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_busy_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_dead_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f1e2";
}
.kernel_dead_icon:before.fa-pull-left {
  margin-right: .3em;
}
.kernel_dead_icon:before.fa-pull-right {
  margin-left: .3em;
}
.kernel_dead_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_dead_icon:before.pull-right {
  margin-left: .3em;
}
.kernel_disconnected_icon:before {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  content: "\f127";
}
.kernel_disconnected_icon:before.fa-pull-left {
  margin-right: .3em;
}
.kernel_disconnected_icon:before.fa-pull-right {
  margin-left: .3em;
}
.kernel_disconnected_icon:before.pull-left {
  margin-right: .3em;
}
.kernel_disconnected_icon:before.pull-right {
  margin-left: .3em;
}
.notification_widget {
  color: #777;
  z-index: 10;
  background: rgba(240, 240, 240, 0.5);
  margin-right: 4px;
  color: #333;
  background-color: #fff;
  border-color: #ccc;
}
.notification_widget:focus,
.notification_widget.focus {
  color: #333;
  background-color: #e6e6e6;
  border-color: #8c8c8c;
}
.notification_widget:hover {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.notification_widget:active,
.notification_widget.active,
.open > .dropdown-toggle.notification_widget {
  color: #333;
  background-color: #e6e6e6;
  border-color: #adadad;
}
.notification_widget:active:hover,
.notification_widget.active:hover,
.open > .dropdown-toggle.notification_widget:hover,
.notification_widget:active:focus,
.notification_widget.active:focus,
.open > .dropdown-toggle.notification_widget:focus,
.notification_widget:active.focus,
.notification_widget.active.focus,
.open > .dropdown-toggle.notification_widget.focus {
  color: #333;
  background-color: #d4d4d4;
  border-color: #8c8c8c;
}
.notification_widget:active,
.notification_widget.active,
.open > .dropdown-toggle.notification_widget {
  background-image: none;
}
.notification_widget.disabled:hover,
.notification_widget[disabled]:hover,
fieldset[disabled] .notification_widget:hover,
.notification_widget.disabled:focus,
.notification_widget[disabled]:focus,
fieldset[disabled] .notification_widget:focus,
.notification_widget.disabled.focus,
.notification_widget[disabled].focus,
fieldset[disabled] .notification_widget.focus {
  background-color: #fff;
  border-color: #ccc;
}
.notification_widget .badge {
  color: #fff;
  background-color: #333;
}
.notification_widget.warning {
  color: #fff;
  background-color: #f0ad4e;
  border-color: #eea236;
}
.notification_widget.warning:focus,
.notification_widget.warning.focus {
  color: #fff;
  background-color: #ec971f;
  border-color: #985f0d;
}
.notification_widget.warning:hover {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.notification_widget.warning:active,
.notification_widget.warning.active,
.open > .dropdown-toggle.notification_widget.warning {
  color: #fff;
  background-color: #ec971f;
  border-color: #d58512;
}
.notification_widget.warning:active:hover,
.notification_widget.warning.active:hover,
.open > .dropdown-toggle.notification_widget.warning:hover,
.notification_widget.warning:active:focus,
.notification_widget.warning.active:focus,
.open > .dropdown-toggle.notification_widget.warning:focus,
.notification_widget.warning:active.focus,
.notification_widget.warning.active.focus,
.open > .dropdown-toggle.notification_widget.warning.focus {
  color: #fff;
  background-color: #d58512;
  border-color: #985f0d;
}
.notification_widget.warning:active,
.notification_widget.warning.active,
.open > .dropdown-toggle.notification_widget.warning {
  background-image: none;
}
.notification_widget.warning.disabled:hover,
.notification_widget.warning[disabled]:hover,
fieldset[disabled] .notification_widget.warning:hover,
.notification_widget.warning.disabled:focus,
.notification_widget.warning[disabled]:focus,
fieldset[disabled] .notification_widget.warning:focus,
.notification_widget.warning.disabled.focus,
.notification_widget.warning[disabled].focus,
fieldset[disabled] .notification_widget.warning.focus {
  background-color: #f0ad4e;
  border-color: #eea236;
}
.notification_widget.warning .badge {
  color: #f0ad4e;
  background-color: #fff;
}
.notification_widget.success {
  color: #fff;
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.notification_widget.success:focus,
.notification_widget.success.focus {
  color: #fff;
  background-color: #449d44;
  border-color: #255625;
}
.notification_widget.success:hover {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.notification_widget.success:active,
.notification_widget.success.active,
.open > .dropdown-toggle.notification_widget.success {
  color: #fff;
  background-color: #449d44;
  border-color: #398439;
}
.notification_widget.success:active:hover,
.notification_widget.success.active:hover,
.open > .dropdown-toggle.notification_widget.success:hover,
.notification_widget.success:active:focus,
.notification_widget.success.active:focus,
.open > .dropdown-toggle.notification_widget.success:focus,
.notification_widget.success:active.focus,
.notification_widget.success.active.focus,
.open > .dropdown-toggle.notification_widget.success.focus {
  color: #fff;
  background-color: #398439;
  border-color: #255625;
}
.notification_widget.success:active,
.notification_widget.success.active,
.open > .dropdown-toggle.notification_widget.success {
  background-image: none;
}
.notification_widget.success.disabled:hover,
.notification_widget.success[disabled]:hover,
fieldset[disabled] .notification_widget.success:hover,
.notification_widget.success.disabled:focus,
.notification_widget.success[disabled]:focus,
fieldset[disabled] .notification_widget.success:focus,
.notification_widget.success.disabled.focus,
.notification_widget.success[disabled].focus,
fieldset[disabled] .notification_widget.success.focus {
  background-color: #5cb85c;
  border-color: #4cae4c;
}
.notification_widget.success .badge {
  color: #5cb85c;
  background-color: #fff;
}
.notification_widget.info {
  color: #fff;
  background-color: #5bc0de;
  border-color: #46b8da;
}
.notification_widget.info:focus,
.notification_widget.info.focus {
  color: #fff;
  background-color: #31b0d5;
  border-color: #1b6d85;
}
.notification_widget.info:hover {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.notification_widget.info:active,
.notification_widget.info.active,
.open > .dropdown-toggle.notification_widget.info {
  color: #fff;
  background-color: #31b0d5;
  border-color: #269abc;
}
.notification_widget.info:active:hover,
.notification_widget.info.active:hover,
.open > .dropdown-toggle.notification_widget.info:hover,
.notification_widget.info:active:focus,
.notification_widget.info.active:focus,
.open > .dropdown-toggle.notification_widget.info:focus,
.notification_widget.info:active.focus,
.notification_widget.info.active.focus,
.open > .dropdown-toggle.notification_widget.info.focus {
  color: #fff;
  background-color: #269abc;
  border-color: #1b6d85;
}
.notification_widget.info:active,
.notification_widget.info.active,
.open > .dropdown-toggle.notification_widget.info {
  background-image: none;
}
.notification_widget.info.disabled:hover,
.notification_widget.info[disabled]:hover,
fieldset[disabled] .notification_widget.info:hover,
.notification_widget.info.disabled:focus,
.notification_widget.info[disabled]:focus,
fieldset[disabled] .notification_widget.info:focus,
.notification_widget.info.disabled.focus,
.notification_widget.info[disabled].focus,
fieldset[disabled] .notification_widget.info.focus {
  background-color: #5bc0de;
  border-color: #46b8da;
}
.notification_widget.info .badge {
  color: #5bc0de;
  background-color: #fff;
}
.notification_widget.danger {
  color: #fff;
  background-color: #d9534f;
  border-color: #d43f3a;
}
.notification_widget.danger:focus,
.notification_widget.danger.focus {
  color: #fff;
  background-color: #c9302c;
  border-color: #761c19;
}
.notification_widget.danger:hover {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.notification_widget.danger:active,
.notification_widget.danger.active,
.open > .dropdown-toggle.notification_widget.danger {
  color: #fff;
  background-color: #c9302c;
  border-color: #ac2925;
}
.notification_widget.danger:active:hover,
.notification_widget.danger.active:hover,
.open > .dropdown-toggle.notification_widget.danger:hover,
.notification_widget.danger:active:focus,
.notification_widget.danger.active:focus,
.open > .dropdown-toggle.notification_widget.danger:focus,
.notification_widget.danger:active.focus,
.notification_widget.danger.active.focus,
.open > .dropdown-toggle.notification_widget.danger.focus {
  color: #fff;
  background-color: #ac2925;
  border-color: #761c19;
}
.notification_widget.danger:active,
.notification_widget.danger.active,
.open > .dropdown-toggle.notification_widget.danger {
  background-image: none;
}
.notification_widget.danger.disabled:hover,
.notification_widget.danger[disabled]:hover,
fieldset[disabled] .notification_widget.danger:hover,
.notification_widget.danger.disabled:focus,
.notification_widget.danger[disabled]:focus,
fieldset[disabled] .notification_widget.danger:focus,
.notification_widget.danger.disabled.focus,
.notification_widget.danger[disabled].focus,
fieldset[disabled] .notification_widget.danger.focus {
  background-color: #d9534f;
  border-color: #d43f3a;
}
.notification_widget.danger .badge {
  color: #d9534f;
  background-color: #fff;
}
div#pager {
  background-color: #fff;
  font-size: 14px;
  line-height: 20px;
  overflow: hidden;
  display: none;
  position: fixed;
  bottom: 0px;
  width: 100%;
  max-height: 50%;
  padding-top: 8px;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  /* Display over codemirror */
  z-index: 100;
  /* Hack which prevents jquery ui resizable from changing top. */
  top: auto !important;
}
div#pager pre {
  line-height: 1.21429em;
  color: #000;
  background-color: #f7f7f7;
  padding: 0.4em;
}
div#pager #pager-button-area {
  position: absolute;
  top: 8px;
  right: 20px;
}
div#pager #pager-contents {
  position: relative;
  overflow: auto;
  width: 100%;
  height: 100%;
}
div#pager #pager-contents #pager-container {
  position: relative;
  padding: 15px 0px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
div#pager .ui-resizable-handle {
  top: 0px;
  height: 8px;
  background: #f7f7f7;
  border-top: 1px solid #cfcfcf;
  border-bottom: 1px solid #cfcfcf;
  /* This injects handle bars (a short, wide = symbol) for 
        the resize handle. */
}
div#pager .ui-resizable-handle::after {
  content: '';
  top: 2px;
  left: 50%;
  height: 3px;
  width: 30px;
  margin-left: -15px;
  position: absolute;
  border-top: 1px solid #cfcfcf;
}
.quickhelp {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
  line-height: 1.8em;
}
.shortcut_key {
  display: inline-block;
  width: 21ex;
  text-align: right;
  font-family: monospace;
}
.shortcut_descr {
  display: inline-block;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
span.save_widget {
  height: 30px;
  margin-top: 4px;
  display: flex;
  justify-content: flex-start;
  align-items: baseline;
  width: 50%;
  flex: 1;
}
span.save_widget span.filename {
  height: 100%;
  line-height: 1em;
  margin-left: 16px;
  border: none;
  font-size: 146.5%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
  border-radius: 2px;
}
span.save_widget span.filename:hover {
  background-color: #e6e6e6;
}
[dir="rtl"] span.save_widget.pull-left {
  float: right !important;
  float: right;
}
[dir="rtl"] span.save_widget span.filename {
  margin-left: 0;
  margin-right: 16px;
}
span.checkpoint_status,
span.autosave_status {
  font-size: small;
  white-space: nowrap;
  padding: 0 5px;
}
@media (max-width: 767px) {
  span.save_widget {
    font-size: small;
    padding: 0 0 0 5px;
  }
  span.checkpoint_status,
  span.autosave_status {
    display: none;
  }
}
@media (min-width: 768px) and (max-width: 991px) {
  span.checkpoint_status {
    display: none;
  }
  span.autosave_status {
    font-size: x-small;
  }
}
.toolbar {
  padding: 0px;
  margin-left: -5px;
  margin-top: 2px;
  margin-bottom: 5px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
.toolbar select,
.toolbar label {
  width: auto;
  vertical-align: middle;
  margin-right: 2px;
  margin-bottom: 0px;
  display: inline;
  font-size: 92%;
  margin-left: 0.3em;
  margin-right: 0.3em;
  padding: 0px;
  padding-top: 3px;
}
.toolbar .btn {
  padding: 2px 8px;
}
.toolbar .btn-group {
  margin-top: 0px;
  margin-left: 5px;
}
.toolbar-btn-label {
  margin-left: 6px;
}
#maintoolbar {
  margin-bottom: -3px;
  margin-top: -8px;
  border: 0px;
  min-height: 27px;
  margin-left: 0px;
  padding-top: 11px;
  padding-bottom: 3px;
}
#maintoolbar .navbar-text {
  float: none;
  vertical-align: middle;
  text-align: right;
  margin-left: 5px;
  margin-right: 0px;
  margin-top: 0px;
}
.select-xs {
  height: 24px;
}
[dir="rtl"] .btn-group > .btn,
.btn-group-vertical > .btn {
  float: right;
}
.pulse,
.dropdown-menu > li > a.pulse,
li.pulse > a.dropdown-toggle,
li.pulse.open > a.dropdown-toggle {
  background-color: #F37626;
  color: white;
}
/**
 * Primary styles
 *
 * Author: Jupyter Development Team
 */
/** WARNING IF YOU ARE EDITTING THIS FILE, if this is a .css file, It has a lot
 * of chance of beeing generated from the ../less/[samename].less file, you can
 * try to get back the less file by reverting somme commit in history
 **/
/*
 * We'll try to get something pretty, so we
 * have some strange css to have the scroll bar on
 * the left with fix button on the top right of the tooltip
 */
@-moz-keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
@-webkit-keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}
@-moz-keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/*properties of tooltip after "expand"*/
.bigtooltip {
  overflow: auto;
  height: 200px;
  -webkit-transition-property: height;
  -webkit-transition-duration: 500ms;
  -moz-transition-property: height;
  -moz-transition-duration: 500ms;
  transition-property: height;
  transition-duration: 500ms;
}
/*properties of tooltip before "expand"*/
.smalltooltip {
  -webkit-transition-property: height;
  -webkit-transition-duration: 500ms;
  -moz-transition-property: height;
  -moz-transition-duration: 500ms;
  transition-property: height;
  transition-duration: 500ms;
  text-overflow: ellipsis;
  overflow: hidden;
  height: 80px;
}
.tooltipbuttons {
  position: absolute;
  padding-right: 15px;
  top: 0px;
  right: 0px;
}
.tooltiptext {
  /*avoid the button to overlap on some docstring*/
  padding-right: 30px;
}
.ipython_tooltip {
  max-width: 700px;
  /*fade-in animation when inserted*/
  -webkit-animation: fadeOut 400ms;
  -moz-animation: fadeOut 400ms;
  animation: fadeOut 400ms;
  -webkit-animation: fadeIn 400ms;
  -moz-animation: fadeIn 400ms;
  animation: fadeIn 400ms;
  vertical-align: middle;
  background-color: #f7f7f7;
  overflow: visible;
  border: #ababab 1px solid;
  outline: none;
  padding: 3px;
  margin: 0px;
  padding-left: 7px;
  font-family: monospace;
  min-height: 50px;
  -moz-box-shadow: 0px 6px 10px -1px #adadad;
  -webkit-box-shadow: 0px 6px 10px -1px #adadad;
  box-shadow: 0px 6px 10px -1px #adadad;
  border-radius: 2px;
  position: absolute;
  z-index: 1000;
}
.ipython_tooltip a {
  float: right;
}
.ipython_tooltip .tooltiptext pre {
  border: 0;
  border-radius: 0;
  font-size: 100%;
  background-color: #f7f7f7;
}
.pretooltiparrow {
  left: 0px;
  margin: 0px;
  top: -16px;
  width: 40px;
  height: 16px;
  overflow: hidden;
  position: absolute;
}
.pretooltiparrow:before {
  background-color: #f7f7f7;
  border: 1px #ababab solid;
  z-index: 11;
  content: "";
  position: absolute;
  left: 15px;
  top: 10px;
  width: 25px;
  height: 25px;
  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  -o-transform: rotate(45deg);
}
ul.typeahead-list i {
  margin-left: -10px;
  width: 18px;
}
[dir="rtl"] ul.typeahead-list i {
  margin-left: 0;
  margin-right: -10px;
}
ul.typeahead-list {
  max-height: 80vh;
  overflow: auto;
}
ul.typeahead-list > li > a {
  /** Firefox bug **/
  /* see https://github.com/jupyter/notebook/issues/559 */
  white-space: normal;
}
ul.typeahead-list  > li > a.pull-right {
  float: left !important;
  float: left;
}
[dir="rtl"] .typeahead-list {
  text-align: right;
}
.cmd-palette .modal-body {
  padding: 7px;
}
.cmd-palette form {
  background: white;
}
.cmd-palette input {
  outline: none;
}
.no-shortcut {
  min-width: 20px;
  color: transparent;
}
[dir="rtl"] .no-shortcut.pull-right {
  float: left !important;
  float: left;
}
[dir="rtl"] .command-shortcut.pull-right {
  float: left !important;
  float: left;
}
.command-shortcut:before {
  content: "(command mode)";
  padding-right: 3px;
  color: #777777;
}
.edit-shortcut:before {
  content: "(edit)";
  padding-right: 3px;
  color: #777777;
}
[dir="rtl"] .edit-shortcut.pull-right {
  float: left !important;
  float: left;
}
#find-and-replace #replace-preview .match,
#find-and-replace #replace-preview .insert {
  background-color: #BBDEFB;
  border-color: #90CAF9;
  border-style: solid;
  border-width: 1px;
  border-radius: 0px;
}
[dir="ltr"] #find-and-replace .input-group-btn + .form-control {
  border-left: none;
}
[dir="rtl"] #find-and-replace .input-group-btn + .form-control {
  border-right: none;
}
#find-and-replace #replace-preview .replace .match {
  background-color: #FFCDD2;
  border-color: #EF9A9A;
  border-radius: 0px;
}
#find-and-replace #replace-preview .replace .insert {
  background-color: #C8E6C9;
  border-color: #A5D6A7;
  border-radius: 0px;
}
#find-and-replace #replace-preview {
  max-height: 60vh;
  overflow: auto;
}
#find-and-replace #replace-preview pre {
  padding: 5px 10px;
}
.terminal-app {
  background: #EEE;
}
.terminal-app #header {
  background: #fff;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.2);
}
.terminal-app .terminal {
  width: 100%;
  float: left;
  font-family: monospace;
  color: white;
  background: black;
  padding: 0.4em;
  border-radius: 2px;
  -webkit-box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.4);
  box-shadow: 0px 0px 12px 1px rgba(87, 87, 87, 0.4);
}
.terminal-app .terminal,
.terminal-app .terminal dummy-screen {
  line-height: 1em;
  font-size: 14px;
}
.terminal-app .terminal .xterm-rows {
  padding: 10px;
}
.terminal-app .terminal-cursor {
  color: black;
  background: white;
}
.terminal-app #terminado-container {
  margin-top: 20px;
}
/*# sourceMappingURL=style.min.css.map */
    </style>
<style type="text/css">
    .highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>
<style type="text/css">
    
/* Temporary definitions which will become obsolete with Notebook release 5.0 */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }

    </style>


<style type="text/css">
/* Overrides of notebook CSS for static HTML export */
body {
  overflow: visible;
  padding: 8px;
}

div#notebook {
  overflow: visible;
  border-top: none;
}@media print {
  div.cell {
    display: block;
    page-break-inside: avoid;
  } 
  div.output_wrapper { 
    display: block;
    page-break-inside: avoid; 
  }
  div.output { 
    display: block;
    page-break-inside: avoid; 
  }
}
</style>

<!-- Custom stylesheet, it must be in the same directory as the html file -->
<link rel="stylesheet" href="custom.css">

<!-- Loading mathjax macro -->
<!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>
<body>
  <div tabindex="-1" id="notebook" class="border-box-sizing">
    <div class="container" id="notebook-container">

<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Model-Interpretability">Model Interpretability<a class="anchor-link" href="#Model-Interpretability">&#182;</a></h1><p><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMX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AQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQIHFviZUsrlBy5FAcdWYF5K6f13bBuk4gQIECBAgAABAgQIECBAgAABAqMR+Nvd7Ol1QsjR9MmRVqQXPGabhQABAgQIECBAgAABAgQIECBAgMBBBYbwccighJAHFT1m5w8d334es2aoLgECBAgQIECAAAECBAgQIECAwAgF2vBxyKCEkCPsrMOo0tDh7edhXEuZBAgQIECAAAECBAgQIECAAAEC55bAovBxyKKEkBO/H4aObj8n3mzNI0CAAAECBAgQIECAAAECBAgQOAKBvcLHIZM6shBydgSNdomPCaSDLQQIECBAgAABAgQIECBAgAABAgTGIHBFKeW5pZR8HsoifDwU1oWFCh8X0thBgAABAgQIECBAgAABAgQIECBwlgQOLYQUPh5tjwofj9bb1QgQIECAAAECBAgQIECAAAECBFYX2HgIubX6tR25AYGEvcN/GyhOEQQIECBAgAABAgQIECBAgAABAgQ2JvBppZRLSyknN1XixgraVIWUQ4AAAQIECBAgQIAAAQIECBAgQIDAkQq8vZTyvFLKz5ZSTm/yysLHTWoqiwABAgQIECBAgAABAgQIECBAgMDxETi00PH4EKgpAQIECBAgQIAAAQIECBAgQIAAAQKrCPxtKSVzjuz131+VUp64ycerV6mcYwgQIECAAAECBAgQIECAAAECBAgQOL4Ce4WPQsfj27dqToAAAQIECBAgQIAAAQIECBAgQOCsCiwKH4WOZ7VbXJwAAQIECBAgQIAAAQIECBAgQIDA8Rdow0eh4/HvUy0gQIAAAQIECBAgQIAAAQIECBAgMAqBIXwUOo6iO1SCAAECBAgQIECAAAECBAgQIECAwHQEfstEMtPpTC0hQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6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AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Setup">Setup<a class="anchor-link" href="#Setup">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>conda install shap --yes
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Collecting package metadata (repodata.json): done
Solving environment: / 
Warning: 2 possible package resolutions (only showing differing packages):
  - https://repo.continuum.io/pkgs/main/osx-64::cvxcanon-0.1.1-py36h6440ff4_0
  - defaults::cvxcanon-0.1.1-py36h6440ff4done

## Package Plan ##

  environment location: /Users/wilsons/anaconda3/envs/pyjup

  added / updated specs:
    - shap


The following packages will be downloaded:

    package                    |            build
    ---------------------------|-----------------
    certifi-2019.9.11          |           py36_0         147 KB  conda-forge
    imageio-2.6.1              |           py36_0         3.3 MB  conda-forge
    networkx-2.4               |             py_0         1.2 MB  conda-forge
    openssl-1.1.1d             |       h0b31af3_0         1.9 MB  conda-forge
    pywavelets-1.1.1           |   py36h3b54f70_0         4.3 MB  conda-forge
    scikit-image-0.15.0        |   py36h86efe34_2        27.6 MB  conda-forge
    shap-0.30.0                |   py36h86efe34_0         317 KB  conda-forge
    ------------------------------------------------------------
                                           Total:        38.7 MB

The following NEW packages will be INSTALLED:

  imageio            conda-forge/osx-64::imageio-2.6.1-py36_0
  networkx           conda-forge/noarch::networkx-2.4-py_0
  pywavelets         conda-forge/osx-64::pywavelets-1.1.1-py36h3b54f70_0
  scikit-image       conda-forge/osx-64::scikit-image-0.15.0-py36h86efe34_2
  shap               conda-forge/osx-64::shap-0.30.0-py36h86efe34_0

The following packages will be UPDATED:

  certifi                                  2019.6.16-py36_1 --&gt; 2019.9.11-py36_0
  openssl                                 1.1.1c-h01d97ff_0 --&gt; 1.1.1d-h0b31af3_0



Downloading and Extracting Packages
pywavelets-1.1.1     | 4.3 MB    | ##################################### | 100% 
networkx-2.4         | 1.2 MB    | ##################################### | 100% 
certifi-2019.9.11    | 147 KB    | ##################################### | 100% 
scikit-image-0.15.0  | 27.6 MB   | ##################################### | 100% 
openssl-1.1.1d       | 1.9 MB    | ##################################### | 100% 
imageio-2.6.1        | 3.3 MB    | ##################################### | 100% 
shap-0.30.0          | 317 KB    | ##################################### | 100% 
Preparing transaction: done
Verifying transaction: done
Executing transaction: done
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[24]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>conda install graphviz --yes
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Collecting package metadata (repodata.json): done
Solving environment: / 
Warning: 2 possible package resolutions (only showing differing packages):
  - https://repo.continuum.io/pkgs/main/osx-64::cvxcanon-0.1.1-py36h6440ff4_0
  - defaults::cvxcanon-0.1.1-py36h6440ff4done

## Package Plan ##

  environment location: /Users/wilsons/anaconda3/envs/pyjup

  added / updated specs:
    - graphviz


The following packages will be downloaded:

    package                    |            build
    ---------------------------|-----------------
    graphviz-2.40.1            |       h69955ae_1         6.5 MB  conda-forge
    ------------------------------------------------------------
                                           Total:         6.5 MB

The following packages will be DOWNGRADED:

  graphviz                                2.40.1-ha626266_1 --&gt; 2.40.1-h69955ae_1



Downloading and Extracting Packages
graphviz-2.40.1      | 6.5 MB    | ##################################### | 100% 
Preparing transaction: done
Verifying transaction: done
Executing transaction: done
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[174]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>conda install python-graphviz --yes
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Collecting package metadata (repodata.json): done
Solving environment: \ 
Warning: 2 possible package resolutions (only showing differing packages):
  - https://repo.continuum.io/pkgs/main/osx-64::cvxcanon-0.1.1-py36h6440ff4_0
  - defaults::cvxcanon-0.1.1-py36h6440ff4done

## Package Plan ##

  environment location: /Users/wilsons/anaconda3/envs/pyjup

  added / updated specs:
    - python-graphviz


The following packages will be downloaded:

    package                    |            build
    ---------------------------|-----------------
    python-graphviz-0.13.2     |             py_0          18 KB  conda-forge
    ------------------------------------------------------------
                                           Total:          18 KB

The following NEW packages will be INSTALLED:

  python-graphviz    conda-forge/noarch::python-graphviz-0.13.2-py_0



Downloading and Extracting Packages
python-graphviz-0.13 | 18 KB     | ##################################### | 100% 
Preparing transaction: done
Verifying transaction: done
Executing transaction: done
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[194]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">!</span>pip install lime
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Requirement already satisfied: lime in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (0.1.1.36)
Requirement already satisfied: scipy in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from lime) (1.3.0)
Requirement already satisfied: scikit-learn&gt;=0.18 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from lime) (0.21.2)
Requirement already satisfied: matplotlib; python_version &gt;= &#34;3.0&#34; in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from lime) (3.1.1)
Requirement already satisfied: numpy in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from lime) (1.16.4)
Requirement already satisfied: scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34; in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from lime) (0.15.0)
Requirement already satisfied: joblib&gt;=0.11 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from scikit-learn&gt;=0.18-&gt;lime) (0.13.2)
Requirement already satisfied: cycler&gt;=0.10 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (0.10.0)
Requirement already satisfied: python-dateutil&gt;=2.1 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (2.8.0)
Requirement already satisfied: kiwisolver&gt;=1.0.1 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (1.1.0)
Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.1 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (2.4.0)
Requirement already satisfied: networkx&gt;=2.0 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34;-&gt;lime) (2.4)
Requirement already satisfied: pillow&gt;=4.3.0 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34;-&gt;lime) (6.2.1)
Requirement already satisfied: imageio&gt;=2.0.1 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34;-&gt;lime) (2.6.1)
Requirement already satisfied: PyWavelets&gt;=0.4.0 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34;-&gt;lime) (1.1.1)
Requirement already satisfied: six in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from cycler&gt;=0.10-&gt;matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (1.12.0)
Requirement already satisfied: setuptools in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from kiwisolver&gt;=1.0.1-&gt;matplotlib; python_version &gt;= &#34;3.0&#34;-&gt;lime) (41.0.1)
Requirement already satisfied: decorator&gt;=4.3.0 in /Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages (from networkx&gt;=2.0-&gt;scikit-image&gt;=0.12; python_version &gt;= &#34;3.0&#34;-&gt;lime) (4.4.0)
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[197]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">graphviz</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="k">import</span> <span class="n">Image</span>

<span class="kn">import</span> <span class="nn">xgboost</span> <span class="k">as</span> <span class="nn">xgb</span>

<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels.formula.api</span> <span class="k">import</span> <span class="n">ols</span>

<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="k">import</span> <span class="n">load_boston</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="k">import</span> <span class="n">tree</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="k">import</span> <span class="n">DecisionTreeRegressor</span>

<span class="kn">import</span> <span class="nn">shap</span>
<span class="kn">import</span> <span class="nn">lime</span>
<span class="kn">import</span> <span class="nn">lime.lime_tabular</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Data">Data<a class="anchor-link" href="#Data">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">boston</span> <span class="o">=</span> <span class="n">load_boston</span><span class="p">()</span>
<span class="n">bostonDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">boston</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">boston</span><span class="p">[</span><span class="s1">&#39;feature_names&#39;</span><span class="p">])</span>
<span class="n">bostonDF</span><span class="p">[</span><span class="s1">&#39;TARGET&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boston</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[161]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">boston</span><span class="o">.</span><span class="n">DESCR</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>.. _boston_dataset:

Boston house prices dataset
---------------------------

**Data Set Characteristics:**  

    :Number of Instances: 506 

    :Number of Attributes: 13 numeric/categorical predictive. Median Value (attribute 14) is usually the target.

    :Attribute Information (in order):
        - CRIM     per capita crime rate by town
        - ZN       proportion of residential land zoned for lots over 25,000 sq.ft.
        - INDUS    proportion of non-retail business acres per town
        - CHAS     Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)
        - NOX      nitric oxides concentration (parts per 10 million)
        - RM       average number of rooms per dwelling
        - AGE      proportion of owner-occupied units built prior to 1940
        - DIS      weighted distances to five Boston employment centres
        - RAD      index of accessibility to radial highways
        - TAX      full-value property-tax rate per $10,000
        - PTRATIO  pupil-teacher ratio by town
        - B        1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
        - LSTAT    % lower status of the population
        - MEDV     Median value of owner-occupied homes in $1000&#39;s

    :Missing Attribute Values: None

    :Creator: Harrison, D. and Rubinfeld, D.L.

This is a copy of UCI ML housing dataset.
https://archive.ics.uci.edu/ml/machine-learning-databases/housing/


This dataset was taken from the StatLib library which is maintained at Carnegie Mellon University.

The Boston house-price data of Harrison, D. and Rubinfeld, D.L. &#39;Hedonic
prices and the demand for clean air&#39;, J. Environ. Economics &amp; Management,
vol.5, 81-102, 1978.   Used in Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics
...&#39;, Wiley, 1980.   N.B. Various transformations are used in the table on
pages 244-261 of the latter.

The Boston house-price data has been used in many machine learning papers that address regression
problems.   
     
.. topic:: References

   - Belsley, Kuh &amp; Welsch, &#39;Regression diagnostics: Identifying Influential Data and Sources of Collinearity&#39;, Wiley, 1980. 244-261.
   - Quinlan,R. (1993). Combining Instance-Based and Model-Based Learning. In Proceedings on the Tenth International Conference of Machine Learning, 236-243, University of Massachusetts, Amherst. Morgan Kaufmann.

</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bostonDF</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[13]:</div>



<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CRIM</th>
      <th>ZN</th>
      <th>INDUS</th>
      <th>CHAS</th>
      <th>NOX</th>
      <th>RM</th>
      <th>AGE</th>
      <th>DIS</th>
      <th>RAD</th>
      <th>TAX</th>
      <th>PTRATIO</th>
      <th>B</th>
      <th>LSTAT</th>
      <th>TARGET</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00632</td>
      <td>18.0</td>
      <td>2.31</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.575</td>
      <td>65.2</td>
      <td>4.0900</td>
      <td>1.0</td>
      <td>296.0</td>
      <td>15.3</td>
      <td>396.90</td>
      <td>4.98</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.02731</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0.0</td>
      <td>0.469</td>
      <td>6.421</td>
      <td>78.9</td>
      <td>4.9671</td>
      <td>2.0</td>
      <td>242.0</td>
      <td>17.8</td>
      <td>396.90</td>
      <td>9.14</td>
      <td>21.6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.02729</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0.0</td>
      <td>0.469</td>
      <td>7.185</td>
      <td>61.1</td>
      <td>4.9671</td>
      <td>2.0</td>
      <td>242.0</td>
      <td>17.8</td>
      <td>392.83</td>
      <td>4.03</td>
      <td>34.7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.03237</td>
      <td>0.0</td>
      <td>2.18</td>
      <td>0.0</td>
      <td>0.458</td>
      <td>6.998</td>
      <td>45.8</td>
      <td>6.0622</td>
      <td>3.0</td>
      <td>222.0</td>
      <td>18.7</td>
      <td>394.63</td>
      <td>2.94</td>
      <td>33.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.06905</td>
      <td>0.0</td>
      <td>2.18</td>
      <td>0.0</td>
      <td>0.458</td>
      <td>7.147</td>
      <td>54.2</td>
      <td>6.0622</td>
      <td>3.0</td>
      <td>222.0</td>
      <td>18.7</td>
      <td>396.90</td>
      <td>5.33</td>
      <td>36.2</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.02985</td>
      <td>0.0</td>
      <td>2.18</td>
      <td>0.0</td>
      <td>0.458</td>
      <td>6.430</td>
      <td>58.7</td>
      <td>6.0622</td>
      <td>3.0</td>
      <td>222.0</td>
      <td>18.7</td>
      <td>394.12</td>
      <td>5.21</td>
      <td>28.7</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.08829</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>6.012</td>
      <td>66.6</td>
      <td>5.5605</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>395.60</td>
      <td>12.43</td>
      <td>22.9</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.14455</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>6.172</td>
      <td>96.1</td>
      <td>5.9505</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>396.90</td>
      <td>19.15</td>
      <td>27.1</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0.21124</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>5.631</td>
      <td>100.0</td>
      <td>6.0821</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>386.63</td>
      <td>29.93</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>9</th>
      <td>0.17004</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>6.004</td>
      <td>85.9</td>
      <td>6.5921</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>386.71</td>
      <td>17.10</td>
      <td>18.9</td>
    </tr>
    <tr>
      <th>10</th>
      <td>0.22489</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>6.377</td>
      <td>94.3</td>
      <td>6.3467</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>392.52</td>
      <td>20.45</td>
      <td>15.0</td>
    </tr>
    <tr>
      <th>11</th>
      <td>0.11747</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>6.009</td>
      <td>82.9</td>
      <td>6.2267</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>396.90</td>
      <td>13.27</td>
      <td>18.9</td>
    </tr>
    <tr>
      <th>12</th>
      <td>0.09378</td>
      <td>12.5</td>
      <td>7.87</td>
      <td>0.0</td>
      <td>0.524</td>
      <td>5.889</td>
      <td>39.0</td>
      <td>5.4509</td>
      <td>5.0</td>
      <td>311.0</td>
      <td>15.2</td>
      <td>390.50</td>
      <td>15.71</td>
      <td>21.7</td>
    </tr>
    <tr>
      <th>13</th>
      <td>0.62976</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.949</td>
      <td>61.8</td>
      <td>4.7075</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>396.90</td>
      <td>8.26</td>
      <td>20.4</td>
    </tr>
    <tr>
      <th>14</th>
      <td>0.63796</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.096</td>
      <td>84.5</td>
      <td>4.4619</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>380.02</td>
      <td>10.26</td>
      <td>18.2</td>
    </tr>
    <tr>
      <th>15</th>
      <td>0.62739</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.834</td>
      <td>56.5</td>
      <td>4.4986</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>395.62</td>
      <td>8.47</td>
      <td>19.9</td>
    </tr>
    <tr>
      <th>16</th>
      <td>1.05393</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.935</td>
      <td>29.3</td>
      <td>4.4986</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>386.85</td>
      <td>6.58</td>
      <td>23.1</td>
    </tr>
    <tr>
      <th>17</th>
      <td>0.78420</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.990</td>
      <td>81.7</td>
      <td>4.2579</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>386.75</td>
      <td>14.67</td>
      <td>17.5</td>
    </tr>
    <tr>
      <th>18</th>
      <td>0.80271</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.456</td>
      <td>36.6</td>
      <td>3.7965</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>288.99</td>
      <td>11.69</td>
      <td>20.2</td>
    </tr>
    <tr>
      <th>19</th>
      <td>0.72580</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.727</td>
      <td>69.5</td>
      <td>3.7965</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>390.95</td>
      <td>11.28</td>
      <td>18.2</td>
    </tr>
    <tr>
      <th>20</th>
      <td>1.25179</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.570</td>
      <td>98.1</td>
      <td>3.7979</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>376.57</td>
      <td>21.02</td>
      <td>13.6</td>
    </tr>
    <tr>
      <th>21</th>
      <td>0.85204</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.965</td>
      <td>89.2</td>
      <td>4.0123</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>392.53</td>
      <td>13.83</td>
      <td>19.6</td>
    </tr>
    <tr>
      <th>22</th>
      <td>1.23247</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.142</td>
      <td>91.7</td>
      <td>3.9769</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>396.90</td>
      <td>18.72</td>
      <td>15.2</td>
    </tr>
    <tr>
      <th>23</th>
      <td>0.98843</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.813</td>
      <td>100.0</td>
      <td>4.0952</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>394.54</td>
      <td>19.88</td>
      <td>14.5</td>
    </tr>
    <tr>
      <th>24</th>
      <td>0.75026</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.924</td>
      <td>94.1</td>
      <td>4.3996</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>394.33</td>
      <td>16.30</td>
      <td>15.6</td>
    </tr>
    <tr>
      <th>25</th>
      <td>0.84054</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.599</td>
      <td>85.7</td>
      <td>4.4546</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>303.42</td>
      <td>16.51</td>
      <td>13.9</td>
    </tr>
    <tr>
      <th>26</th>
      <td>0.67191</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>5.813</td>
      <td>90.3</td>
      <td>4.6820</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>376.88</td>
      <td>14.81</td>
      <td>16.6</td>
    </tr>
    <tr>
      <th>27</th>
      <td>0.95577</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.047</td>
      <td>88.8</td>
      <td>4.4534</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>306.38</td>
      <td>17.28</td>
      <td>14.8</td>
    </tr>
    <tr>
      <th>28</th>
      <td>0.77299</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.495</td>
      <td>94.4</td>
      <td>4.4547</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>387.94</td>
      <td>12.80</td>
      <td>18.4</td>
    </tr>
    <tr>
      <th>29</th>
      <td>1.00245</td>
      <td>0.0</td>
      <td>8.14</td>
      <td>0.0</td>
      <td>0.538</td>
      <td>6.674</td>
      <td>87.3</td>
      <td>4.2390</td>
      <td>4.0</td>
      <td>307.0</td>
      <td>21.0</td>
      <td>380.23</td>
      <td>11.98</td>
      <td>21.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>476</th>
      <td>4.87141</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.614</td>
      <td>6.484</td>
      <td>93.6</td>
      <td>2.3053</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>396.21</td>
      <td>18.68</td>
      <td>16.7</td>
    </tr>
    <tr>
      <th>477</th>
      <td>15.02340</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.614</td>
      <td>5.304</td>
      <td>97.3</td>
      <td>2.1007</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>349.48</td>
      <td>24.91</td>
      <td>12.0</td>
    </tr>
    <tr>
      <th>478</th>
      <td>10.23300</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.614</td>
      <td>6.185</td>
      <td>96.7</td>
      <td>2.1705</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>379.70</td>
      <td>18.03</td>
      <td>14.6</td>
    </tr>
    <tr>
      <th>479</th>
      <td>14.33370</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.614</td>
      <td>6.229</td>
      <td>88.0</td>
      <td>1.9512</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>383.32</td>
      <td>13.11</td>
      <td>21.4</td>
    </tr>
    <tr>
      <th>480</th>
      <td>5.82401</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.532</td>
      <td>6.242</td>
      <td>64.7</td>
      <td>3.4242</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>396.90</td>
      <td>10.74</td>
      <td>23.0</td>
    </tr>
    <tr>
      <th>481</th>
      <td>5.70818</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.532</td>
      <td>6.750</td>
      <td>74.9</td>
      <td>3.3317</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>393.07</td>
      <td>7.74</td>
      <td>23.7</td>
    </tr>
    <tr>
      <th>482</th>
      <td>5.73116</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.532</td>
      <td>7.061</td>
      <td>77.0</td>
      <td>3.4106</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>395.28</td>
      <td>7.01</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>483</th>
      <td>2.81838</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.532</td>
      <td>5.762</td>
      <td>40.3</td>
      <td>4.0983</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>392.92</td>
      <td>10.42</td>
      <td>21.8</td>
    </tr>
    <tr>
      <th>484</th>
      <td>2.37857</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.583</td>
      <td>5.871</td>
      <td>41.9</td>
      <td>3.7240</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>370.73</td>
      <td>13.34</td>
      <td>20.6</td>
    </tr>
    <tr>
      <th>485</th>
      <td>3.67367</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.583</td>
      <td>6.312</td>
      <td>51.9</td>
      <td>3.9917</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>388.62</td>
      <td>10.58</td>
      <td>21.2</td>
    </tr>
    <tr>
      <th>486</th>
      <td>5.69175</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.583</td>
      <td>6.114</td>
      <td>79.8</td>
      <td>3.5459</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>392.68</td>
      <td>14.98</td>
      <td>19.1</td>
    </tr>
    <tr>
      <th>487</th>
      <td>4.83567</td>
      <td>0.0</td>
      <td>18.10</td>
      <td>0.0</td>
      <td>0.583</td>
      <td>5.905</td>
      <td>53.2</td>
      <td>3.1523</td>
      <td>24.0</td>
      <td>666.0</td>
      <td>20.2</td>
      <td>388.22</td>
      <td>11.45</td>
      <td>20.6</td>
    </tr>
    <tr>
      <th>488</th>
      <td>0.15086</td>
      <td>0.0</td>
      <td>27.74</td>
      <td>0.0</td>
      <td>0.609</td>
      <td>5.454</td>
      <td>92.7</td>
      <td>1.8209</td>
      <td>4.0</td>
      <td>711.0</td>
      <td>20.1</td>
      <td>395.09</td>
      <td>18.06</td>
      <td>15.2</td>
    </tr>
    <tr>
      <th>489</th>
      <td>0.18337</td>
      <td>0.0</td>
      <td>27.74</td>
      <td>0.0</td>
      <td>0.609</td>
      <td>5.414</td>
      <td>98.3</td>
      <td>1.7554</td>
      <td>4.0</td>
      <td>711.0</td>
      <td>20.1</td>
      <td>344.05</td>
      <td>23.97</td>
      <td>7.0</td>
    </tr>
    <tr>
      <th>490</th>
      <td>0.20746</td>
      <td>0.0</td>
      <td>27.74</td>
      <td>0.0</td>
      <td>0.609</td>
      <td>5.093</td>
      <td>98.0</td>
      <td>1.8226</td>
      <td>4.0</td>
      <td>711.0</td>
      <td>20.1</td>
      <td>318.43</td>
      <td>29.68</td>
      <td>8.1</td>
    </tr>
    <tr>
      <th>491</th>
      <td>0.10574</td>
      <td>0.0</td>
      <td>27.74</td>
      <td>0.0</td>
      <td>0.609</td>
      <td>5.983</td>
      <td>98.8</td>
      <td>1.8681</td>
      <td>4.0</td>
      <td>711.0</td>
      <td>20.1</td>
      <td>390.11</td>
      <td>18.07</td>
      <td>13.6</td>
    </tr>
    <tr>
      <th>492</th>
      <td>0.11132</td>
      <td>0.0</td>
      <td>27.74</td>
      <td>0.0</td>
      <td>0.609</td>
      <td>5.983</td>
      <td>83.5</td>
      <td>2.1099</td>
      <td>4.0</td>
      <td>711.0</td>
      <td>20.1</td>
      <td>396.90</td>
      <td>13.35</td>
      <td>20.1</td>
    </tr>
    <tr>
      <th>493</th>
      <td>0.17331</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.707</td>
      <td>54.0</td>
      <td>2.3817</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>12.01</td>
      <td>21.8</td>
    </tr>
    <tr>
      <th>494</th>
      <td>0.27957</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.926</td>
      <td>42.6</td>
      <td>2.3817</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>13.59</td>
      <td>24.5</td>
    </tr>
    <tr>
      <th>495</th>
      <td>0.17899</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.670</td>
      <td>28.8</td>
      <td>2.7986</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>393.29</td>
      <td>17.60</td>
      <td>23.1</td>
    </tr>
    <tr>
      <th>496</th>
      <td>0.28960</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.390</td>
      <td>72.9</td>
      <td>2.7986</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>21.14</td>
      <td>19.7</td>
    </tr>
    <tr>
      <th>497</th>
      <td>0.26838</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.794</td>
      <td>70.6</td>
      <td>2.8927</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>14.10</td>
      <td>18.3</td>
    </tr>
    <tr>
      <th>498</th>
      <td>0.23912</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>6.019</td>
      <td>65.3</td>
      <td>2.4091</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>12.92</td>
      <td>21.2</td>
    </tr>
    <tr>
      <th>499</th>
      <td>0.17783</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>5.569</td>
      <td>73.5</td>
      <td>2.3999</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>395.77</td>
      <td>15.10</td>
      <td>17.5</td>
    </tr>
    <tr>
      <th>500</th>
      <td>0.22438</td>
      <td>0.0</td>
      <td>9.69</td>
      <td>0.0</td>
      <td>0.585</td>
      <td>6.027</td>
      <td>79.7</td>
      <td>2.4982</td>
      <td>6.0</td>
      <td>391.0</td>
      <td>19.2</td>
      <td>396.90</td>
      <td>14.33</td>
      <td>16.8</td>
    </tr>
    <tr>
      <th>501</th>
      <td>0.06263</td>
      <td>0.0</td>
      <td>11.93</td>
      <td>0.0</td>
      <td>0.573</td>
      <td>6.593</td>
      <td>69.1</td>
      <td>2.4786</td>
      <td>1.0</td>
      <td>273.0</td>
      <td>21.0</td>
      <td>391.99</td>
      <td>9.67</td>
      <td>22.4</td>
    </tr>
    <tr>
      <th>502</th>
      <td>0.04527</td>
      <td>0.0</td>
      <td>11.93</td>
      <td>0.0</td>
      <td>0.573</td>
      <td>6.120</td>
      <td>76.7</td>
      <td>2.2875</td>
      <td>1.0</td>
      <td>273.0</td>
      <td>21.0</td>
      <td>396.90</td>
      <td>9.08</td>
      <td>20.6</td>
    </tr>
    <tr>
      <th>503</th>
      <td>0.06076</td>
      <td>0.0</td>
      <td>11.93</td>
      <td>0.0</td>
      <td>0.573</td>
      <td>6.976</td>
      <td>91.0</td>
      <td>2.1675</td>
      <td>1.0</td>
      <td>273.0</td>
      <td>21.0</td>
      <td>396.90</td>
      <td>5.64</td>
      <td>23.9</td>
    </tr>
    <tr>
      <th>504</th>
      <td>0.10959</td>
      <td>0.0</td>
      <td>11.93</td>
      <td>0.0</td>
      <td>0.573</td>
      <td>6.794</td>
      <td>89.3</td>
      <td>2.3889</td>
      <td>1.0</td>
      <td>273.0</td>
      <td>21.0</td>
      <td>393.45</td>
      <td>6.48</td>
      <td>22.0</td>
    </tr>
    <tr>
      <th>505</th>
      <td>0.04741</td>
      <td>0.0</td>
      <td>11.93</td>
      <td>0.0</td>
      <td>0.573</td>
      <td>6.030</td>
      <td>80.8</td>
      <td>2.5050</td>
      <td>1.0</td>
      <td>273.0</td>
      <td>21.0</td>
      <td>396.90</td>
      <td>7.88</td>
      <td>11.9</td>
    </tr>
  </tbody>
</table>
<p>506 rows  14 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Methods">Methods<a class="anchor-link" href="#Methods">&#182;</a></h1><p><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMX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AQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQIHFviZUsrlBy5FAcdWYF5K6f13bBuk4gQIECBAgAABAgQIECBAgAABAqMR+Nvd7Ol1QsjR9MmRVqQXPGabhQABAgQIECBAgAABAgQIECBAgMBBBYbwccighJAHFT1m5w8d334es2aoLgECBAgQIECAAAECBAgQIECAwAgF2vBxyKCEkCPsrMOo0tDh7edhXEuZBAgQIECAAAECBAgQIECAAAEC55bAovBxyKKEkBO/H4aObj8n3mzNI0CAAAECBAgQIECAAAECBAgQOAKBvcLHIZM6shBydgSNdomPCaSDLQQIECBAgAABAgQIECBAgAABAgTGIHBFKeW5pZR8HsoifDwU1oWFCh8X0thBgAABAgQIECBAgAABAgQIECBwlgQOLYQUPh5tjwofj9bb1QgQIECAAAECBAgQIECAAAECBFYX2HgIubX6tR25AYGEvcN/GyhOEQQIECBAgAABAgQIECBAgAABAgQ2JvBppZRLSyknN1XixgraVIWUQ4AAAQIECBAgQIAAAQIECBAgQIDAkQq8vZTyvFLKz5ZSTm/yysLHTWoqiwABAgQIECBAgAABAgQIECBAgMDxETi00PH4EKgpAQIECBAgQIAAAQIECBAgQIAAAQKrCPxtKSVzjuz131+VUp64ycerV6mcYwgQIECAAAECBAgQIECAAAECBAgQOL4Ce4WPQsfj27dqToAAAQIECBAgQIAAAQIECBAgQOCsCiwKH4WOZ7VbXJwAAQIECBAgQIAAAQIECBAgQIDA8Rdow0eh4/HvUy0gQIAAAQIECBAgQIAAAQIECBAgMAqBIXwUOo6iO1SCAAECBAgQIECAAAECBAgQIECAwHQEfstEMtPpTC0hQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6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AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Global-vs-Local">Global vs Local<a class="anchor-link" href="#Global-vs-Local">&#182;</a></h2><ul>
<li><a href="https://towardsdatascience.com/explainable-artificial-intelligence-part-3-hands-on-machine-learning-model-interpretation-e8ebe5afc608">https://towardsdatascience.com/explainable-artificial-intelligence-part-3-hands-on-machine-learning-model-interpretation-e8ebe5afc608</a>
<img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMX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AQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQIHFviZUsrlBy5FAcdWYF5K6f13bBuk4gQIECBAgAABAgQIECBAgAABAqMR+Nvd7Ol1QsjR9MmRVqQXPGabhQABAgQIECBAgAABAgQIECBAgMBBBYbwccighJAHFT1m5w8d334es2aoLgECBAgQIECAAAECBAgQIECAwAgF2vBxyKCEkCPsrMOo0tDh7edhXEuZBAgQIECAAAECBAgQIECAAAEC55bAovBxyKKEkBO/H4aObj8n3mzNI0CAAAECBAgQIECAAAECBAgQOAKBvcLHIZM6shBydgSNdomPCaSDLQQIECBAgAABAgQIECBAgAABAgTGIHBFKeW5pZR8HsoifDwU1oWFCh8X0thBgAABAgQIECBAgAABAgQIECBwlgQOLYQUPh5tjwofj9bb1QgQIECAAAECBAgQIECAAAECBFYX2HgIubX6tR25AYGEvcN/GyhOEQQIECBAgAABAgQIECBAgAABAgQ2JvBppZRLSyknN1XixgraVIWUQ4AAAQIECBAgQIAAAQIECBAgQIDAkQq8vZTyvFLKz5ZSTm/yysLHTWoqiwABAgQIECBAgAABAgQIECBAgMDxETi00PH4EKgpAQIECBAgQIAAAQIECBAgQIAAAQKrCPxtKSVzjuz131+VUp64ycerV6mcYwgQIECAAAECBAgQIECAAAECBAgQOL4Ce4WPQsfj27dqToAAAQIECBAgQIAAAQIECBAgQOCsCiwKH4WOZ7VbXJwAAQIECBAgQIAAAQIECBAgQIDA8Rdow0eh4/HvUy0gQIAAAQIECBAgQIAAAQIECBAgMAqBIXwUOo6iO1SCAAECBAgQIECAAAECBAgQIECAwHQEfstEMtPpTC0hQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6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AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Model-vs-Agnostic">Model vs Agnostic<a class="anchor-link" href="#Model-vs-Agnostic">&#182;</a></h2><ul>
<li><a href="https://www.slideshare.net/0xdata/explaining-blackbox-machine-learning-predictions/">https://www.slideshare.net/0xdata/explaining-blackbox-machine-learning-predictions/</a>
<img src="data:image/png;base64, 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ZB8BBBBAAAEEEEAAAQTmJEBgeU6rxVwRQAABBBBAAAEEEGgEHOj48MMPq3fffTdvzz77bPV///d/efvRj37UBpbPnj2bezkIYkSPUZaX9d4nRQABBHZdQO+Hfm+M5zr0Pukyffz1Nddc027/7//9v+pb3/pW3q6++uqV8dwvjk8eAQQQQAABBBBAAAEEEJiDAIHlOawSc0QAAQQQQAABBBBAYETgzJkzlYLLH330UfXcc89V//M//5O3//3f/60UUPam7mUww8ETlyt1mdORw1KMAAII7JyA3wt1YvE9MJarzvtOjx8/Xt14443tdu+991b3339/dd9991VXXnllb6zYX3leCCCAAAIIIIAAAggggMCcBAgsz2m1mCsCCCCAAAIIIIAAAoWAA8cff/xx9cILL/QCywo2K/CsNAZJPITLHBxR6jKnbkuKAAII7LqA3wt1nvE9MJarzvtKtel7le+4447qzjvvzOndd99dffnLX67uueee/NHYe42nel4IIIAAAggggAACCCCAwBwECCzPYZWYIwIIIIAAAggggAACIwIKfji4/PLLL1f6COwf/vCH1U9/+tPqnXfeaTcFnvWKwZKYd6CkbJM78QMBBBBYgMC698FYJwrvKz158mSlYLK3u+66q9KmQPOll17ayuk91/3aQjIIIIAAAggggAACCCCAwIwECCzPaLGYKgIIIIAAAggggAACpYCDw0pfffXV6qGHHqoefPDB6uGHH65ee+216vXXX8+pn1pWu9gnjqeAh+tiOXkEEEBgCQIx6Dv0Xhjro4eCx/roa28333xz+7HYJ06ciE3JI4AAAggggAACCCCAAAKzFiCwPOvlY/IIIIAAAggggAACCHQCb7zxRvWb3/ym+vWvf53T559/vvL2wQcf5Ceb1wWWu5HIIYAAAssTiIHjocCyRGIbC506dar69re/3W7XXHNNdfXVV1dXXXVVdezYMTcjRQABBBBAAAEEEEAAAQRmL0BgefZLyAkggAACCCCAAAIIIFB/xPXbb79dPfbYY9Xjjz+e06eeeqp68skn8/bee+/lp5EdLHGKHQIIIIBALTAUNFZNfL90m6NHj1YXXHBBdeGFF1ZXXnll9cADD+Ttu9/9bnX55Zfnj8C+7LLLcj2+CCCAAAIIIIAAAggggMCuCBBY3pWV5DwQQAABBBBAAAEEFivgoMe7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AggggMAuCMTAzFCQRfWxjc65bKd6PYl85syZvCmIrI/Efv755/OmQPM//vGPvL322muVtldffTU//aexPJ6P5eM53QVnzgEBBGoB/71rL/6Nx/Ihq9h2qN5lGmeo7dj4sdx5pQosa7v44osrPY3s7ZZbbqluvvnmvOljsa+++upKH4GtoDMvBBBAAAEEEEAAAQQQQACBYQECy8MulCKAAAIIIIAAAgggMCuBGIBxUCWegOrdRqnajLXTx8Rq05PL/uhrBZD10djannjiiTbArO9e1lPO8WNj3T8eL86FPAII7K6A31ec+kz3834Q+7qfx3Ea2yjvfadqp/clPamswLICxl/+8peru+++O6c33HBDpe3666/PdceOHau0qT0vBBBAAAEEEEAAAQQQQACBYQECy8MulCKAAAIIIIAAAgggMBuBMvASAys+CbdxqvLYznnXK9WmILHSt956q3rqqafy9pe//CUHlv0Esz4O2x+frSCzNz35XL48fll+PvZ1jod5/PNxjhwDgcMW8HuJU8/Hf3tOXT6Uln3VpuznNkq9qd1FF12UA8THjx/PTymfOHGiOnnyZHXllVe236Os71PWR17rKWVtaquXx8w7/EAAAQQQQAABBBBAAAEEEFgRILC8QkIBAggggAACCCCAAALzEhgLuJRnUbaL9TGg4nZKvb3//vvVSy+91NtefPHFvP/KK6/kj8TWU81vvvlmpe9e1vbBBx+sBGo8Xjz2pvk4x9jH841lMV/226t97EseAQQ2Fyj/1sZ6bvo3ODSe+6puaNOTyVdccUUOJOujrRVA1qaPu9ZHX/ujsC+77LL8pLLa+ynloeONnQPlCCCAAAIIIIAAAggggMASBQgsL3HVOWcEEEAAAQQQQACBnRJwoEWpAyNOyxN127K8bB/bKa/vXlawWB+NrSeU9f3L+o5lpX//+9+rp59+utKTzAo26+lmBZjVTuN60zja9BS0X+VxXR6Pr7KynfbLNuW+x/Lxva92Y23dhhQBBNYLlH+TZevyb2xd+7Ktx3Ifp/FvVx9zrfJyUxD5xhtvzAFkBZJvu+226tZbb81BZQWTT506lTc92exNY/FCAAEEEEAAAQQQQAABBBDYW4DA8t5GtEAAAQQQQAABBBBAYNICDsoodQDG6bqJu5/abNJe7RzYUfD47bffzkFkBZQfe+yxvOnjsRVs1qY2au/vXFZwWh+PrS0eW+P6pXm4zmk5t7jvNuof8x5Pqdp7UxtvsQ15BBDYn0D8O4w9x/4O1Wasj/u7b2znvFO19Xcn60ljf4ey8/rOZAWTtd1+++3VXXfdlTcFmfVdy24fx/PxSRFAAAEEEEAAAQQQQAABBNYLEFhe70MtAggggAACCCCAAAKTF3AwxhPdT8DEfd3H+x5rLNWTy9r0FLM+Ivv555+vnnvuuerll19un2Y+ffp0fmpZTy7H7Z133snBZX9/s46h43vTHLyNHX+sfGj+Pjelrnc6Ng7lCCCwXsB/V7HVJn9XQ/08RqyLf6+qd1BYgWF9J7I+wtqbnkT208j+2Gt99PV1113XbvouZQWkvQ0d02WkCCCAAAIIIIAAAggggAACwwIEloddKEUAAQQQQAABBBBAYHYCCurEwIxPwMGeobqyjfbd3nVKy7566vijjz7KAWIFivX0sjYFk/3Esj4qW9+77O9g1r43fWezn2TW8RzscTDJQWfPxenQXNxHdbGd9v2K8x9r47akCCCwt0D8m1Lr/f5dxf7OK415jalN7wf62OoTJ05UF198cQ4o+7uTlTqArGCyvl9ZH3ftYPMll1yS26tvHFtz9n6Z1z4vBBBAAAEEEEAAAQQQQACBVQECy6smlCCAAAIIIIAAAgggsDMCMdgTgyjlCbpdmcY+zjstx9C+nmL2dy8roKyPxn7mmWdy6qealeoJZgWn9fHYOqaeRnRw2QHndcFlHUvziHPROJ6/6nkhgMCnIxD/7nyE/fztxf7+Oy5Tjasx/X4Qn1K+6qqr8ncm33TTTTm9PX3ktbY77rijUiDZ352s95X48nuEUs/BqdrFfOxHHgEEEEAAAQQQQAABBBBAoBYgsMxvAgIIIIAAAggggAACOyxQBnvWBU7c1mlkcT+nrosBGpV9+OGH7dPL+o5lP62sVE8yO+iswPIHH3yQN/VxkFlpfBra+0odaHbquTjV8Yfmvq5cdbwQQGB/AvFvbj893c//EYnS+BHXCgiX+w4S60llBY1PnjyZn0jWR1v7qWV/7LVStfMYGt8vvzc4VbnnU+bdhxQBBBBAAAEEEEAAAQQQQKAvQGC578EeAggggAACCCCAAAKzEXCAJAZH4uRdr7RsU+67n/t4P6Zln7Kt6hUAdsBYH3etALI+KtvfsazvZHbeqcq86Yln9Vew2eM41dh6wlmbgstxPjEf56y85+lUZevaq54XAgisF/DfU/m3VO7HUVSnTYFfB3+PHTuWvzNZAWFt3tcTyv4Ya32XsgLKqtdHWmvz9ys71UdfK6/vYNbYCirrWJ5nnEfMr5tvbEceAQQQQAABBBBAAAEEEEAg3U9J/8g6BwQCCCCAAAIIIIAAAgjMSyBexo8FRtzGadmu3N+PgMdU6nGUal+bnyp2EDgGhJVXUFlPNL/55pt503cza9O+gsveHHBWqgCzn2DWGHrFYzsfz8PzUZnyeg21yxX8QACBjQX896QO+pvy35XTciCXK1XwVwFkbQoWK4Dsp5EVQNam4LE+8lpPJmtTvYLN7qcxvPnJZweTdQwfz/NU6jKn5RzZRwABBBBAAAEEEEAAAQQQWC9AYHm9D7UIIIAAAggggAACCExSwMEST24oUFK2cVulQ+1j/V75sbHXjes+SvU0s55k1vb222/nILNSbarzU8oKMGtf6UcffdR+ZLYDy/Fcxo6t4/nYPq+xtq4nRQCBcYF1f09jf1sqd50CwvqIa6UKFvspZD+V7KeXL7/88uqKK67Im9r4Y7HVT2M5kKyZxjn5OGW5zyjWu4wUAQQQQAABBBBAAAEEEEBgbwECy3sb0QIBBBBAAAEEEEAAgckJxCCKJjcWKCnbrWu7yUkOjTfWb2hO7u+PulbQOG4KKDuArKeTlVdbpfGpZ48zdmzKEUBgGgJ+H3CqWfkJY38ctgLGfhLZwWOlDjgrVb0CyvFjrjWmx43vCS6zwFhdLFfbsp/7kyKAAAIIIIAAAggggAACCNQCBJb5TUAAAQQQQAABBBBAYIYChxEQ8TGVOgCj1OVijHVmdVvXK9VHZStQrOCx80r9EdpjeY3v4zn1ccp9lcdjx7z7kCKAwCcT8N+d0zia/+acus77SrU50Kw0bg4iO3Vd7O8x4/Fd77qxNPZRm037jY1HOQIIIIAAAggggAACCCCw6wIElnd9hTk/BBBAAAEEEEAAgZ0ViEGR8xEQ8fGU+nhOh+oM7zbad7sy7zZO3XevdGy82M9jOo115BFA4JMJ+G/QaTma/u6G/vbcXmlZ733VuZ3HdZ1Tl4+1c/1Q6vE9ltOhtpQhgAACCCCAAAIIIIAAAgik/yA3/UPqHBAIIIAAAggggAACCCAwT4G9Luc3DZSU45T9ynppxTZD9WUb7cd2znscp2q3n5fHUR/nh8YaKtvPcWiLAAKrAv6bizUu89+c06E2sUz5sq3Hcur2bqe0rCvbeL9My34es2zHPgIIIIAAAggggAACCCCAQC1AYJnfBAQQQAABBBBAAAEEZi5QBkfK09krWLJX//2OV7b3vo/jNM4r5sv23lc61M71Htf7Q+m6/kPtKUMAgXGBvf7mDurvzcdR6rzG3mT8TdqMnyE1CCCAAAIIIIAAAggggAACUYDActQgjwACCCCAAAIIIIDADAVisCVO3wEVp7Eu5h2ocbqu/bq6OOZQ3uM71Vhj47nN0DhjfYbauiyOt01/j0OKAAK1wPn+m9Lx4ub3j03+njdpw7oigAACCCCAAAIIIIAAAgjsLUBgeW8jWiCAAAIIIIAAAgggMGmBGOApJ1oGVNx2rLzsH/fLPrFuk7yPPdR2aOyh9kPthsYbKtN4n6T/0JiUIbBkgU/zb8p///6b9b5SH9d1e63Bpu32God6BBBAAAEEEEAAAQQQQGDpAgSWl/4bwPkjgAACCCCAAAII7ISAgy7xZMpgStlmrL4sj2OWeY+5Vx+3K/vH/b3GiG3JI4DAfAT097+fv+/y/cJ9Ve46lzmNGm7jsrJNWa92ZRv3JUUAAQQQQAABBBBAAAEEEOgECCx3FuQQQAABBBBAAAEEENhpgTIo80kDKTE4s26ssXblfIS/bpydXhxODoEdFRj7+x87XbdX6vcDp65zX5d73+m6dmWd+4yN5XpSBBBAAAEEEEAAAQQQQACBdN8m/aPqHBAIIIAAAggggAACCCCw+wLlpf9BBFI85rqx3EbCsV0sL+t2fzU4QwSWIRD/zuPf/9jZx/ZuE/u5Ppa5XUzXtXNdbL/XeLEteQQQQAABBBBAAAEEEEBgqQIElpe68pw3AggggAACCCCAwCIFHFCZShBlavNZ5C8FJ43AxAT8vqBpTeW9amJETAcBBBBAAAEEEEAAAQQQOBQBAsuHws5BEUAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgfkIEFiez1oxUwQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQOBQBAgsHwo7B0UAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQTmI0BgeT5rxUwRQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBQxEgsHwo7BwUAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQmI8AgeX5rBUzRQABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBA5FgMDyobBzUAQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQGA+AgSW57NWzBQBBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBA4FAECy4fCzkERQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACB+QgQWJ7PWjFTBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBA4FAECCwfCjsHRQABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBOYjQGB5PmvFTBFAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAIFDESCwfCjsHBQBBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBCYjwCB5fmsFTNFAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEDkWAwPKhsHNQBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAYD4CBJbns1bMFAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEDgUAQLLh8LOQRFAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAIH5CBBYns9aMVMEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEDgUAQILB8KOwdFAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEE5iNAYHk+a8VMEUAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgUMRILA/hAldAABAAElEQVR8KOwcFAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEJiPAIHl+awVM0UAAQQOQODcHmMc2aOeagQQQAABBBBAAAEEEEAAAQQQQAABBIYEyvtO3GcaUqIMAQQQmLMAgeU5rx5zRwABBPYlUF7cj3Xmon9MhnIEEEAAAQQQQAABBBBAAAEEEEDgUxcob+Hs81aNuu+zyyc8pXLCcbjzO5N4ZPIIIIAAAgcvQGD54E0ZEQEEEJiggC/wnY5N0Rf7TsfaUY4AAggggAACCCCAAAIIIIAAAgggcOACY7duNrxVE7tv2OUATsFHdeohPQOnLidFAAEEEJirAIHlua4c80YAAQT2JeALe6frOutinwv+dULUIYAAAggggAACCCCAAAIIIIAAAgcusNdtmz1u1wx136PLAZ2Cjjx0dA3PfaYDQmYYBBBAYBICBJYnsQxMAgEEEBgSGLsgV9t1/yw4N3Ip7/GclseMYx5pjhDLyvZj+2Pjj7WnHAEEEEAAAQQQQAABBBBAAAEEEFiqQHPvJd5Oifny1ky537DFLptKdkOt651aldVdx3QoVyp1XjOIjZx3qnpeCCCAAAJzFCCwPMdVY84IILAQAV+MO/Vp+yLcqcuVOqhc9nGbsXLXxzG3DS77GE49NikCCCCAAAIIIIAAAggggAACCCCAQCfQ3Ic5F+7HDN1OCdW5b7FfdvF+0aw7bC93rgkBu5crm95xbq5S2g7ufkrrvEvUqG3W5rqSOBx5BBBAAIF5CBBYnsc6MUsEEFikQHdB3j99X4A77WodVvaFfFfjXHdp75LV1OP64t/7qy2HS3wMp8OtKEUAAQQQQAABBBBAAAEEEEAAAQSWLZDuueTbJ829l3W3UuLtmZhPgLFbzBfNRqjHAstqnkbYKLDso9ap9+oRPIsyHZkOxQgggAACkxYgsDzp5WFyCCCwbAFdhsdLcWsMX4ivXrq7vdI4TszHNsp77PjflHZlZevh/Th+zA+3phQBBBBAAAEEEEAAAQQQQAABBBBYpkC655JvnTT3XtbdRvHtGacBrOym/YFmoYeyXa8jId9vlEbZKLDs8bpHHjyOH1voZrT3zNyXFAEEEEBgegIElqe3JswIAQQQaAR0gd9d5HcsvgB3utpq9TJel+9DY9WjdiN1R2kv+Mf+ARGbDubT8fLA48cd7EYhAggggAACCCCAAAIIIIAAAgggsAiBdOMk3zZp7syM3ULxjRunhc1Yt6JZ2I09/MRyqG6zmt/IQXvFuhPlMZ3WgxBYbjHJIIAAAjshQGB5J5aRk0AAgd0U0IV4/2K8Pk9fuddp2aLcr/v4HwnDtR6x75hKc/Ph2n7bsb00QO4+fNyxXpQjgAACCCCAAAIIIIAAAggggAACuy8wcO9l6BaKb804LWCGuhRNil316HqNDJvaaH4jtaG4Dip34/XHdsMyLabELgIIIIDALAQILM9imZgkAggsUyBekJcC9cV42aLcj73Gnlj2ZX3bdmWQlRZt070zzWCfZIi9D0ILBBBAAAEEEEAAAQQQQAABBBBAYH4C7T2YcOOkLUunk4v3vrcSu2yG0PUIRw5dQ+lYYFmtm2bd08oq7MbumoTx3EmVvBBAAAEEZidAYHl2S8aEEUBgUQLn+hfj+dyP1BfjZU25XzqVveIlfW47OMBKq3LYDfYHB96gH00QQAABBBBAAAEEEEAAAQQQQACBXRcYu/cS7qesNAl1e/G46coY6qjKsiLuh7zHGTheHXsebhBGGDjWwGAUIYAAAghMWoDA8qSXh8khgMDiBYavyVc+hWikWY+vfyFf/LMhDhDzZafeiOwggAACCCCAAAIIIIAAAggggAACCHw6AukGTb4vE2/UxCONlYc2scnaezyxUvm4PzJeLB5priZrqsIIZBFAAAEE5iJAYHkuK8U8EUBgeQLx4r88+3RVHqtjvmzq/XghH/NrB+o19EikCCCAAAIIIIAAAggggAACCCCAAAKfqsAR3+1xGo82VBbrm3xsNnqPJ1Y477QYM45XVo10GSkuerOLAAIIIDAXAQLLc1kp5okAAssTWHOx7v/c002crkOKF/JtPnaMeQ/UNlRB2aBX6R57p2W3cliPoHZjdW5Tpgfd56DHK+fr/fN1HB9vKD1fczjo4xz0eEM2Kjtfxxk7/vmcw0Gf60GPN2Z0vo4zdnzWaJ1MXccarTda57OubmzUKfcZm7PKpzzvdXNbVzd2vlPuMzZn1midTF13vtZ13UzO1xwO+jgHPd6Y0fk6ztjxVX6+5nDQxzno8caMztdxxo7PGq2TqetYo/VG63z2quuNXN8U6X9/sRvUdRpu8DV0P2WwsQuPhFswdZlreuMPjRsaDH0d8+A4oQ9ZBBBAAIF5CRBYntd6MVsEEFiSwLqL9eaq3E2cruOJF/I5HzvFfBwkdmr/iaHGrnAaO63JjzUvjx/bjdWNlevwm9Ztcpx14216HI3hY52vPuW8ffyyPM5tXR3zls7479Y2PuV4rFEmbv9WSh/t22gb7236lHPw8cvyOLd1ddvMYZs+5RzmMu8lnStrJIHx99R1ddv8nmzTp5wDf0cS6d6HlR9zHSs/6D7leKyRRFijWqFz4PexFtnUgb+j2msTh01NNaLH26aP+sd+Hqss1/4mdXGsqfUpz2mT8yn7xHM6X+dazuGTzlvjtS+HlMuTUYOuLB4yd+2q2pFyZqVhV3Au/wJ1++64UjI2tjuktAwur4wR2pJFAAEEEJifAIHl+a0ZM0YAgSUJjF2wh6tyN3E6xhO61P/eLDuU+xqo7eRKp65wOnbUonxdcw/dO27aGStXu03qymNOqc9cz3Wu897md2Gu5zrXebNGWrnw3lvv8l5XOGzze7JNn3ItNvnfj7KP9t1vmzmcrz7lvD3nsjyez7o65i2d8b/lbXzK8VijTNz+fZU+2rfRNt7b9Cnn4OOX5XFu6+q2mcM2fco5zGXeSzpX1kgC4++p6+q2+T3Zpk85B/6OJNK9Dys/5jpWftB9yvGmvkaab3o5rNzHrOvqn92J9Ci74tg4rEOvdWrjp5XL8rp7r3Rs7P6ResHlXv+iHbsIIIAAAvMTILA8vzVjxgggsCiBdMVeXrQXV+RldfiXQpZSfdGl21/tXOu2ncoGcb8etS4pjzCwSKFJyA403GdRO9d99JtCnynMYYxsm7mNjaXybcabQp8pzGHMdZu5jY3FGq2Tqeu28d6mz7qZbDPeFPpMYQ5jrtvMbWwslW8z3hT6TGEOY67bzG1sLNZonUxdt433Nn3WzWSb8abQZwpzGHPdZm5jY6l8m/Gm0GcKcxhz3WZuY2OxRutk6rptvLfps24m24w3hT5TmMOY6zZzGxtL5duMdwB9NET56oLLqlltMRoSzk2Luy+93W6nHrXbL+eg/bZ2dQpDzXOZnlxu+422ogIBBBBAYG4CBJbntmLMFwEEFiTgq3Wne526L9f9z4rx9m650mLlUKkgN16pCP+c8WjbH9cjeD7xaGN1Y+UaY6yuLFdbH6usGyvfpI/abDqej7OfPpvMoTz+Jn32M4dt5r1Nn03mPcVzneu8WSOt3Pj7wrq6bezOV59N5s3fkZTG37vX1ZV226yrxne/sfHK8k36MG8JHMy6ahzWqDNY51r+rtrt0+7DGkmANaoVOoeD+H2MrmPjleWb9FGbsp//XsbKP+0+m8y7nNsmfZi3BMbXe13dNt7b9NnPHPx7up8+aut+5fzGyjfps585+Difdp9N5l0axD7K6xXnWwaXY3/nnda9w8/4udRFo/oYXWE8pkfoapvf4aFGbjyWxkHG2lCOAAIIIDAbAQLLs1kqJooAAssT0NV6vGKP+bGrcpfXaewR/dwqlrX5tlPK5IZtQdtEma7UAeXNjjl27Fjejd3/x3cs1xw26dOf68H22XQO28x7mz5zPde5zps10srF94L+39e6um3szlefTecd33827aN2sV88p7HyTftsOod4nE37bDqHeD6fZp9N5z21c53rvLdZ17me61znzRpp5fjfo1ph3GGb35Nt+qxbizje1N6j49x0DnF+sS6Wz/Vc5zrvuA6skQT6v6faj0bxdzWWl/1i3WH02XTecW6b9vk0z3XTOWw777guXd65Oo1jKx/3Nb/6lUpz86a2aOQR1Tbmm85tErsdWdew7VFk4gBFFbsIIIAAAvMTILA8vzVjxgggsBgBXa2XV+zaX3dFvlrXjdCv6+8VqPkw7um0aNObnYPL5Yy7ozjntBwtlscjjpWr/1hdLFe7Tcbbps+mc4jH/zT7zPVc5zrvbdZ1ruc613mzRlq58ffAdXXb2J2vPpvOe2rv63Od9zbrOtdzneu8WSOtHO91tcK4wza/J9v0WbcWcbypvUfHuekc4vxiXSyf67nOdd5xHVgjCfR/T7UfjeLvaiwv+8W6w+iz6bzj3Dbt82me66Zz2HbecV26Y7n0XO89ysdwqvYrvx1+ajk08mh1+/7vj8ucdnd8mpHbzmFANx5KN2w21JUyBBBAAIHpCRBYnt6aMCMEEECgEdCVenu1vk+Vsav2unxs1H4vt3I6PAXX+p823u9a16N6bKddfZ2L5XGMsXL1GquL5Wq3yXjb9Nl0DvH4n2afuZ7rXOe9zbrO9VznOm/WSCs3/h64rm4bu/PVZ9N5T+19fa7z3mZd53quc503a6SV472uVhh32Ob3ZJs+69Yijje19+g4N51DnF+si+VzPde5zjuuA2skgf7vqfajUfxdjeVlv1h3GH02nXec26Z9Ps1z3XQO285b4+sV16fb60rj+F2+y63+lnSj1EfofnajdmV1znd76r129LZDW1J27PY3aNI1JocAAgggMHUBAstTXyHmhwACCxbQVXp7pf4JHXwVX6frRnXL7tjrWq+26rf2aEfamzMuKU8olscxxsrVf6wulqvdJuNt02fTOcTjf5p95nquc533Nus613Od67xZI63c+Hvgurpt7M5Xn03nPbX39bnOe5t1neu5znXerJFWjve6WmHcYZvfk236rFuLON7U3qPj3HQOcX6xLpbP9VznOu+4DqyRBPq/p9qPRvF3NZaX/WLdYfTZdN5xbpv2+TTPddM5bDtvje9Xt0bO1Wk5drfvnFOP1P8d6UrrnEcvy9Vr5Ynl3CiNnzutHmdljA2arPShAAEEEEBgsgIElie7NEwMAQQQGL+s72yaNm669mK9q3Tzbpx+rmvZLx/b83hO++260brcWIu63OMMtd+mbsp9dMZj8xsrn2sf5i2B8fVeV3e+fhemMIdtznWu817SubJGEuDvv1YYd9jmb2KbPuvWYpvxzlefuc57G5+5nutc580aaeXG35vW1W1jd776MG8JTHtd183vfP2ebHOcuc57Lucq3/rlGXtf6VBZ/I8MfBfFaexb54dHcLuh2q6sP2qz54/Z9hBl2u9U1rKPAAIIIDBDAQLLM1w0powAArst0F2y6zz7eyppr8l7Vb2d1X5H2l4aYt2ouV4/2h7l0G2LfiY3azu5rvvvWl3l1C16qQYZajBWrs5jdWPle/VR/WHPYej4e817v30Oerxtvfc7bx1Hr6F+53MOQ8fXvMbmMFa+rs+6um3GO599NPcho/M5h6HjH7TpQY93Pn1Yo/G/16msK2vEGul3QK+x94ax8oPuc9Djna956zh6Df3vwfmcw9DxNa+xOYyVr+uzrm6b8c5nH819yOh8zmHo+AdtetDjnU8f1mj873Uq68oazXuNtH5+5fcj/YHXry6n/WbvXPcG0L19dbm6Z7mfSgeK6rYeOR4t5j1id1yX9FOPRooAAgggsOsCBJZ3fYU5PwQQmJXA6qX78PSPtA2bTP6HRWqb/6HQVvY7h39E9FuEil6P9PHVueFYfa9xtxOa94+z9t8x/pdMPU4Yw/92yhWxXAXxALFurHxdn1gXx4rlym9at80czlefded0vuawzXHivDddh9hH+dhvmzmcrz67MO9ove581tWdL+9tjrML82aNtIr99wXtj/0+jJUfdJ84HmskDdaoVug7HMbvY7kW52sO2xxHc3U//o7q36BNHexWrnc0Leu26RPH23Rusc9BzGGbeW/TZxfmzRppFfvvw9of+30YKz/oPnE81kga812jevb1z/aGT/xFahrkIpfHRXfeaRww5EerPaZT9Yn5MEb7j2oP5jS2IY8AAgggsMsCBJZ3eXU5NwQQmJ3A2GV7eSLtvzN8od8GlteMEK71V1uFyvZgWwaW1T8MF48VitujtBk3HGo0Vufy4ph5TNeV47l8Cn2mMIeD8NF52PUgxvNYU/CZwhwOwpQ1kkD3e6r8mOtY+afdR+P7d/+w5uDjH/S5HvR4h+XDGkmg+z1Vfmwtxso/7T4a37/HhzUHH/+gz/WgxzssH9ZIAt3vqfJjazFW/mn30fj+PT6sOfj4B32uBz3eYfmwRhLofk+VH1uLsfJPu4/G9+/xYc3Bxz/ocz3o8Q7LZ2prpPn4lW/4xAVsKnJRLDdemXqggdRNe1Ues0x7jZqdOIDzTofaU4YAAgggsIsCBJZ3cVU5JwQQmK2AL+P3OoGVwHL+V2vsHfNptH19FHb3j4Ije31XzrqJdsOsa0UdAggggAACCCCAAAIIIIAAAggggEAW0P2c4p6OHybI9elmS1sdb7ykfNwd0uzVexCn6hDz5QDu3H3lWf+AdV+36vceLu23YQ8BBBBAYC4CBJbnslLMEwEEFiFQXsJ7v7wE7weW3apME1mvY7fjlh2q6/ppd5yu5b5yHm5fnWiMAAIIIIAAAggggAACCCCAAAIILFFAd2zCXZs9g8oDN14GirJkrzwex8dT2mvULIDLHFT2fj3Teq8bo6tVd+85bYYkQQABBBCYrQCB5dkuHRNHAIFdFPBluM8t7sdL8C7gqxZxc88mjZ3ai/neP1FSw9jI+TrtjlOMu59dD7mfPrRFAAEEEEAAAQQQQAABBBBAAAEEFiXgu0BO08nHwHL7qXK+0eK0QBop7t3+6d1LCsdrh4qD1Plz7QAOMLeNNdFU243T9XbOaexDHgEEEEBgjgIElue4aswZAQR2WqC7DK9PU/vx4lyl+XK8/ceFWnhTbfNqr9mdqdPuHwIrDXsd62O4jdNydi4fSpvj+vC5yX76D41JGQIIIIAAAggggAACCCCAAAIIILDLAsW9k3z/p7m54uBybrJ638XFSnu3Y3o7qjubWqhV7tFglr3cSXelYr5pHnrX9626VmrhHjHXz3fjkEMAAQQQmI8AgeX5rBUzRQCBhQnUl/bxAt8AvlBXXb25bXnR3vVWjWvLNI3SNDzSfBezW/T+faGdtsJzUZrKuwPl43j3iDq0fepS18URyCOAAAIIIIAAAggggAACCCCAAALLFujfMWlvpwglVzUlCi6n/e5eTqpXVV2cy90890g/cqpx8ku16d5SHiDlVz6urhmo6VXfhaoHiXekmsGaRDX5qG0vVeT7Qm1Dz8JpW0EGAQQQQGBGAgSWZ7RYTBUBBJYmcK65JPd51xfo+eI/F9X/EOhaab9/ye4L/vqfELpw98V7SFM3j5xL0w/XthXOrPxjQxMJA+Q9967TOlatvGbqI6kfLwQQQAABBBBAAAEEEEAAAQQQQACBMQHfYcn1+WnlVKLbMLq94lssqSjfe6mrqrOqT9XNswNt2h2jCQKfO5vu/zSDtPd7mkHynaGUT6/63lLTMg3qwzpVG5XGmrqnalTnvTKt6/mJAAIIIDAvAQLL81ovZosAAosSiGHYeLle53XBXuf0s6v3ZXouST/qmnQZ739lyNAfnWRPd0//kHB/V3X/CawbtTUh47q6t0fJe70BPefQlSwCCCCAAAIIIIAAAggggAACCCCAQE+gfzsl7eVbL3Wa77s0++3tniboq2LfpdGAub43soPAKU3B5frlHj6q0nrzPZ6uV9OlaeqAcp3W47isCyt7PPVtOjbDkCCAAAIIzEuAwPK81ovZIoDAogR8UV8GY7vymsP7fZxzzWciKVVQOf8XokpzUDn1UTcl7fW8/6mgcTym01DWtlfZ0Cs1UDe3c5qbxvGG+lKGAAIIIIAAAggggAACCCCAAAIIIFALNPdYdDslbfnOTUrzPR7deMlRY6epvokit3dfmu6dpu/9KK239oGC9maOx0tpPqzS9K3M+fhVTnWYXJvT/piaZT5+cz+qnm09Rh6w7lln+YkAAgggMDsBAsuzWzImjAACyxHQZXj7T4GBXFfXmXRlCih7y4HldNV/9MjRekgFndVUaf6XgEZw35iG/Eo7HzX/K6LZaRq5m/vk1IXut1eq9h5gr7ZTqt9m3tv0mcI5L2neSzrXuf5usUbnd+X+P3vvwmbHcVwJVjfeJEFJpCTqYUmWZcszu575/z9h7N1vdz6Pveu1x2PrZdl6khJBgAC6sXEi4mSczKq63bh4kBfIIqsyM+LEicjIrNu3KlF1j8n3MTavt1fb3t6muN+mvm6P9uuVHpPvY2xeb6+2vb1Ncb9Nfd0e7dcrPSbfx9i83l5te3ub4n6b+ro92q9Xeky+j7F5vb3a9nZKcQ/3Vyx03MJZ8ICx3duJhwfsHo/fNzFsW2DG3R2013d5IicggXpjYdnvEcGv8DkyLLCwzN0Xlg12Dnjjijra8bADfIAr40XdN5bZnMXMwMzAzMDMwEllYC4sn9RwzWBnBmYG3q4MxJd9XgqwhRz4v/2kAN/RW2IozC/xdlGA/6CPL/NW4kLBYSgLTz9RptyJFeNEzdu1KhXcACcvxCPoOrrRBjy0G3V78i+DzZchhhfJD+I/pXwf09c5RsjA/vl1SHdMvo+x+TLEcEzctEH88zxa5+DLNK5zjJCBOUY8Z7+o8xVj8EXHsOf/OrEB80Xl7kXiHmM+1NdDutcVw4v4mWOEDKznKWR7ed2Tvyob8I5z8nXHMPp/2X192XyvOz9zjJCB9TyFbG8s9uSvyga84zx+3TGM/hGTbhlPvWIu0mftuI1jd3h8ITkXlvEQAfqE0uRunQvNwRT+qpeUxuJyGOA+EmJI7sEeKuj51DIYAfHdCcgV3N14G8jvSbW8RzzwNreZgZmBmYGZgdPLwFxYPr0xmxHPDMwMvDUZiC/j/sUeX9at3/FFHkvF+EJvX9r9uzi+9Ie+vrgbwg0vDWs4r0MGnFunPutAEeP5JTf0trkfVLKNqm9wTA7KtNzAq9r5kpwXTM4HEGz3dEni9IzhKpuB71p+XoINwmq+GHf2q8kHP1s2kCFH17IZ+I6xQf4zzIw6/HexDX46XVoBAqJjYnhdNptxzzHyEbzqvJxj5Gnan9/zPPIEXWueRCrbvLuWzfAZdIzN/Ky7Yg6buuV1jtHh7yYvYz5u5Puqz2EMyxwjycEwDl1+Bl3L2yA/ZNPp0LBtjtH18nBMvo+xQTTNLkKbY5Tfa6+aqy1vz3FOHGMzxwiTVObpK873HKP4ILhWHviZ4ZP0NY4R/GEecLO6NptYz+V43hhzyRdsz25YFYvKXGDGHDs3GtjEHnWShRSOoI3bQXGvKfhgDw22KBEScHhgGiXvQ0VpPO2eEoNnyRjB03OaYG4zAzMDMwMzAyeYgbmwfIKDNkOeGZgZeFsygMXe6mt8p8dv2sQisL/9yNTxmuvAcdGYJS4SnuFr/6Xtz3L3CwcQ525yv3yA3reU2/d9/8rP7/1NZ5VOIVzOGSz7x46wYLzRAUm76LP6nhy4Pd2e/Lo2wH3RMaj/a8dtY6HpfdE8HBPD67KZY4QM9PMU7b0x35O/Shtw63z4ImJQ/9ftKz7H5nnUj911c3dMvo+xmWOEEZljFFno8/BFfM6MY/FFxDDPo5gNmgcdhzlG6/xAojnay53KX6UNuNXXXmyvMgb1f10/8+8RMtWPHdp747cnf5U2c4yQ3TlGkYU+D1/IfBzGYjMG3F+xTW8GhSTPLVyoxB4Q1O01076ojMVlLjCb3BeZsdAcOxeWWcISG8r4GTVUUmA3oOKJ6EBlVK6G3wYD3CGxsOz3osbYA5BA9WrGc5sZmBmYGZgZOMkMzIXlkxy2GfTMwMzA25CB+C7Or+/4Uh+9joVl/CtRXA6EHKpQX1oJG+xYKI798unj5fLpk9gvrLy8sHXmCyufZhntsKPPRmoVbFtyeKUv6lkONhkhI4W2be2CKvn0xo7r6McsqKMNSsgoB+m1bRyMQ9pE1Y+Nz/jRJfqBkjrG4H17zhiOsWEMSAfHo8UAmW2MDfwa9zE2ytf8gOg5+9riRkC5OV9yQcS46afZQJl21EGEjTZjX1XXbI6Ie44Rkmx75p/5Zk7nGGGm1cb8vKr52PI9zyNP+l6+MWU5ZzlXOUp7NtBT12yO+MyYY8RMR8mcjufEHCPLj53HLT9oIik555A96l7KfAThc/4dnWMUOeM4eArnGLXFwvlZhxlRW5snNkdwqrX8APKc5x5MyPdSzv/076FcMYe/DHHzc5A5eNVxz886y7DNkefJ9xwjnKSRN8xP5o7n60s7j/zDJIbH56kf0jfqstuNonNbTD6/eWs5v5G71W9k++zspsGx2IzS7hZ5rLhr5HeT8j4T5OYu3QZ9+qBr9Nc2h+CQG+5TBTII6qllIqzkzSwvSchScLM6MzAzMDMwM3AyGZgLyyczVDPQmYGZgbctA3v/yNO/8NvXef8ub4czu5iJr+SQYGGZTyZf2Ld+26395OGD5cmjz7x8/PnD5cnnj5bHjx8uTx9/vjy1BecLW3i+sDIvE6LEdYHVsLFEzet2QVCXAZDY7hdVVqIaKLcta1jExUsqqgCFMLYLNIh5kYZ6kHstmhXFvo0hecEHI+XbkwO3p+vkDsQhtk4nsWncb1NfkZWXmm/NqXHv5buTIwix63Qin2OERO3n9JBuN6cH+DobJ8chtk43x8iTMs+j/rMESdmbJ3vya9s4EIfYdvn8jx1RfXy7Ngbf0+3J4WFP18kdiENsnW6eR56UeR718xRJ2Zsne/Jr2zgQh9h2+eZ55AnazY9p93R7chDu6Tq5A3GIrdPtfGYAOc+jPgfIyV7u9uTXtnEgDrHt8s3zyBO0mx/T7un25CDc03VyB+IQW6eb55En5RQ/MxD4Fxq33XPxewZ+sPs9tQDsd35cbPPr/NwXlM+svHHr9nLr9r3l9p27y62795Y7d99Z7tx71/Z3bE359rLYfmaLzlaxq16zfZavy+aTzlaGN1OR3wfQsJzKWSoO68S89+OlGcdpQJSTGCiNvRwIEzKLmYGZgZmBmYHTysBcWD6t8ZrRzgzMDLxFGYgv9PHFvvsebjnwr+k8OBCXB3xCGQvKWFy2p5GXp1ZeLI/++PHy6A+2W/nw0z8sDz/74/LwwR+XR1hwtkVm3598bliQgocXMxDFpQKWlLvLA7+IwEUBpLb7FQQuJBBLIeO3m3EtAezWwrLJGzz5ULiQupRD7LpUo+0C+PdGHJyPgj3dnhwUe7otOfAZH10mRZMT0uQUkM9KcKAgF6sosalu00+CNnX040zCdYUN1ORz/xSQD8IDcW/agMM21wk5q52OftziBWxgDwd7fBkoY8hmbwOhAVyXXKRFiU115Ork2djUmfGm/AobqGnn/ikgH4QGcB2ACTpoAw7bmk02aNPpDLQpf14b4DO+Tb7rxA2MGbe4B5sM6bCfBO3FsCm/wgZq2mVIfQxXxL1pA1LbXCfkrHY6A23KE7Sp27IBHuAtXcoJQemxUUAbCA3rug2bZnfIT4IA4aZ8m3IAGUMaqQ1EtHM5BbSB0ADPZQMO25pNNuin09EPhLYdbQNjONjjc+IX6ytctPj2/CToZfYVlOTLbvR9hdAAGtuVNgDY1myyQT+dzkCb8ue1AR5Ee3weTPnKZm8D4YG+woXbHfKToM0+mfGm/AobqGl3TNybNiC1rfUnG/TT6Y6Me8UFUgj3+DJQ2mWzt4HQAK5LLtKixKY6cnXybGzqzHhTfoUN1LRz/xSQD0IDuA7ABB20AYdtzSYbtOl0BtqUP68N8BnfJt914gbGjFvcg02GdNhPgvZi2JRfYQM17TKkPoYr4t60AaltrhNyVjudgTblCdrUbdkAD/CWLuWEoPTYKKANhIZ13YZNszvkJ0GAcFO+TTmAjCGN1AYi2rmcAtpAaIDnsgGHbc0mG/TT6egHQtuOtoExHOzxOfGL9RUuWnx7fhL0MvsKSvJlN/q+QmgAje1KGwBsazbZoJ9OZ6BN+XVteC8m4jy3+yhn57YjZPeP0p5SvmFPKd+46U8q37IF5XvvvLfcexf7/eXd97+yvHf/q1Z+dTm7dbfteHL5GRaVuVv7zJ9mtieaPei8k2N+urs65tu7JP2K6KJPIYZR3A+CtNu6G1okYdkhZ2NmYGZgZmBm4EQyMBeWT2SgZpgzAzMDb18G/KLBv9Dbl/j8zs2yZYO/mwywP51si8kon+Ep5M/9SeTLi8+Xh5/8dvns49xtgfmzTz9ZHvzxk+WRLS4/xtPL+RQzF5WxMI0LBV9UjuuDaMOxLyDLRUD7l9lx6YFLEb8cAYFbZWHB47+8JIEyt+RyvIkaNQR7OtpaKbCuseI7xkbIpSpMrYsMdRVD609n1cG6xiuNWzqx8jPotuK+ygZd3LNr8sHPC9sMfM2P5PuquLdsYC7UXWPFN/hqfEKwshl0L2Qz+EfzWnyD3Suz2evr4P9Q3C02sUFVqLvGKt9id20bAUr1sB8BSlW8hzkErU8CRBVb00XTjwI7HMMxNkIuVWG6Ou6tmEHQ8UkDVWxbdgLrCFY2ApTqcTYRjh+v8vPCcQ++Wg6kE1fF0GwGri62gW/LBniBdY1VDIOvxicEK5tB90I2g380r8U32L0ym72+Dv4Pxd1iExtUhbprrPItdte2EaBUD/sRoFTFe5hD0PokQFSxNV00/SiwwzEcYyPkUhWmq+PeihkEHZ80UMW2ZSewjmBlI0CpHmcT4fjxKj8vHPfgq+VAOnFVDM1m4OpiG/i2bIAXWNdYxTD4anxCsLIZdC9kM/hH81p8g90rs9nr6+D/UNwtNrFBVai7xirfYndtGwFK9bAfAUpVvIc5BK1PAkQVW9NF048COxzDMTZCLlVhujrurZhB0PFJA1VsW3YC6whWNgKU6nE2EY4fr/LzwnEPvloOpBNXxdBswEVw8OIf6HNxuRaWn8Wi8q145fVte0IZC8rvvGf7/a8s73/1g+U921HeuPPucn73XS/x9DJeje2vx17s1djnqNuTzFhc9sGLJ5n99hIiYRcsPg+xixPx4d5PlF4HnkG6PA+8keUlSVgqcNZnBmYGZgZmBk4lA3Nh+VRGasY5MzAz8NZloH0f55d5y0B9ac90+CJyPKH87PKJrS1/7vuFveb6gT2d/ODT33v5+acfL7F/sjx++Gm8Fttejf308aNYfMbrsO23l2NBOJ5Yhof2tHJe22RhgUQk7VIgn1aGzfjEMtqxAc3F5RStCmCIV+WeHJg93Z78kM0h3TF8X2abU+3rqcZ9zFw41b6eatxzjDBy+5+ph3TH5O512cy4kYEv97geiu91zZNj/Jxq3G9TX+cYIQPz/I8s7OfhmHPiGJtDY3EM3+uyOdW4j8nPqfb1VOOeY4SR2/9sCk3eBEqc3C2xV2Cf2RPLZ/bk8o2b9irsO/dsx6uw7TXY9vQy93v25PLd92y//zV7Nfb95aYtMt+68569PvteLDD7wrItMtvrsH0/s9di+y2ZfHrZpB4Dhqttcc8mRKhnu6oN6RUH2oELzCXscbM1MzAzMDMwM3AyGZgLyyczVDPQmYGZgbcuA/alPL6eW89bBd/p89s6FnN9YdmeUr603RaVL21B+dnjz5bHn/1h+c2v/2357a9st/KJvfr66SNbULZF5WdPHy2LLSIvthB9ZnZ4SvnMnlD2ndxe5mWC/r5QCyWePfYxcRgDjH+xyieWgyEviAB2GKVuLQfKySWqdjU16mgD7J5uT/6qbcDP+PZiGOXXsXnVcTPm5/HzJsc9xwiju39+HdKNuXtVc2v0g5joa9RR/qrjPsbPmxz3OA5vcl9PdW7NMcLIzc+6yMJ+HsZ5Mj/rImPMw5gfaPd0lAMz2lG3J3/VNuD/omOg/+fp63XiHnN6HZvnieGYuI+xeZPjnmOE0d3/XDikG3P3qubW6Acx0deoo/xVx32Mny9n3OwJ77i0nySz1d5nuTAbt2hsAdjaz2whGL+3jKePY7+1nNtvLp/ZYvPZrTvL+1/7xvL+B9i/ubz7la8v977y4XLv/Q+X27bIvJzZ7y8veGIZC8v21LI/uZxPLSM9GFf730c1Sy43R5zQ1JjL8wZuXQfwhAU5SzdrMwMzAzMDMwOnmIG5sHyKozZjnhmYGXg7MlDfz/27ujfzcHaWTxXjd5Tttdd49fWzJw+Xi4d/XC4e2W8n/+F3y89/8j+Xn//0n5dfWHlhi82XpgfmxnKx3LJrhtt2vXDrxtlykzt+tycvCqKUL/6ecbaZfmm312HbZYLFWDx+2YBrkbre0H6RKhCtVWCIxI8jSLAnP2Qz6sg1ytHe0+3JD9mo7m2K+23qK8ZY+3vMPDnG5kXnlsasXGN/DumOifsYG43hbYr7berrOO+OmSfH2Lzo3JpjhAz2n4Fo743FnvyQjeqOyfcxNvCpdsfEfYzNi/b1VOPWXGsOxv4c0h2T72NsNIa3Ke63qa/jvDtmnhxj86Jza44RMth/dqO9NxZ78kM2qjsm38fYwKfaHRP3MTYv2tdTjVtzrTkY+3NId0y+y8bf85YLsZeX9jNltqh8iceIfSHZ/FqJO0KXJoL8qTWeWuPJBfZleWLyJ7b6/NT2D7/x7eXrH313+fq3vrt89RvfXe5/8zvLfSvv3v/AGGxhGU8sby0uexp4Z8fOImsjQkqihARblGcOGvMHvcmSD61uOrtgHmYGZgZmBmYGTi0Dc2H51EZsxjszMDPw9mTAvpvza3pU+GXdLyEsD3aBgVdf2xPIz54+XD63p5Q/+/jXywPbP/39r5bf2ZPKv/v1L708M9y5LT5jv2mL0rewqGz7Tdtv5O6/22OO4jIAvnhBMJY6BNBllFZFi6++9npCUScsRUPhCJG1nptsT7cnB811ddfxM/IdYwMO2l03NrV5GTHQ/8h1yI/qjon7GJsxvmPiPsbmRft6qnHPMcLIvdrPDPBzTh6T72Nsxj7R/yjX2EbdMTbK9zbF/Tb19WXMky9ibs0xwsjNz7rIQp+HL2I+jmNxTAzH2MAv7Y45J46xOdW+nmrcc4wwcv05jjbn/ajbkx+yUd0x+T7G5mXE/UX09VTj/uLHyBeWkT7bYlE5yrjhYku6FqIvKpse5UUuLl9wgdnKJ5dnvsD8jr0C+933P1jesf3+Bx8tX/nGd5b3bX/nq9+w12a/b7u9HvuOPb2M31zGk8v+9LLdJIKzXNzG7NGF5ciQS02DDXWLGgXsvEQdG3iy9HaIWJ3lzMDMwMzAzMBpZmAuLJ/muM2oZwZmBt6CDOAfpGLzf5ia38zjX4XiN5Vjv3xiTyJ//sBegf3p8uCT3yy/+/efL7/9j58tv7dFZfym8qMHn9j+8XLr7GK5feOZPaFsi8r2bR8LyjfPny32sLL9kk6+vtrk+L4fe1wYeABxFZCakBw6IkbyAIe6b93FBYUsG4oCKzUGEWcuhFmUL9MGtC+Tjwl41X29Ku4t/1fZQL9l90Xn502NeyvXb2pfT3VuzTH64j8frzon5hjNMeIceR2fM/S1Ne9e19//Y/xcFfdWf66yeR35fhV9PdW45xjNzzqek69jDtPX1rw75rx8XTZXxb3Vn6tsXke+j8nPmxr32zNGWFTW2YX7QXgdtv8PFZ9ktiqeVraHlP3pZS9t9RflE1ttfozFZbttdHbrrq0V226/qYxXYX/FnmDG4vL9D761vPOVbyz3vvrRcu/+hwDG7k8v68Jy/2wyVo89DL9XgkjNITevcqxYUiltqVI7y5mBmYGZgZmB08rAXFg+rfGa0c4MzAy8JRnw7+N24OIyvqyf+Rd4CO13kbHb7yNffm6/nfzwD8vFZ58sn/zml/ba63/yV1//5t9/upxfPl5u2O8onz97vNy7fWb7ue+37TXYWFC+aXxYVHYn9hvL8IEN3/HzWsXbIaEmywosMVG4rceaVkE5LEnOq4guabMxMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDOQ91CQCNw58SYPuFFj/6OJOzjxtDLbsQB8aYDHeCW2KfFq7If2y2mPnkZ5972vLl/7+rftldixuPyVj76/vP/RD5b7X/+u8eKV2PlqbP7Wst8Y6heWveVhMFCWDBZRYxvLkHYqEc3qzMDMwMzAzMBpZWAuLJ/WeM1oZwZmBt6SDPC6IUo7+qIyLhHs8sEWi/Gbyig//+Nv7fXXv1oe/v7Xyye//sXyq1/86/Krf/vJ8rEtMt+xJ5Rvn19aebnctfdeY2H5ru237LeUb+SiMheW41/Agt82v0jISpdvuTA4sLCMyxpBdgx1cTGIZ3NmYGZgZmBmYGZgZmBmYGZgZmBmYGZgZmBmYGZgZmBmIF8rLYnImyyxjMvfWPY7OX4HBvJnthCMBWf85rL/3rItLn9mjy5/9vmFlRfLjTvv2WuxP7QnlT9c7n/4reWD7/zZ8sF3/2z56re+v5zfuGdPNt+z8h27bWNPI5zhqWUr7e4OXoONDT7WC8vUoDRgBBh1iNrdIW/EgTeMRDSrMwMzAzMDMwOnlYG5sHxa4zWjnRmYGXiLMoBLhFi/xUKt/3tUK+1dRvYksj2q7OUf7JXXv//lT3z/xOoPbIH5U/uNZbwG+679PM49+0end2+e2Wuw7d+e2mPKt63ORWU8AY1LhXosOi9Rxi/5fvUwCHmxsLXAbNABzSuQt2j0ZldnBmYGZgZmBmYGZgZmBmYGZgZmBmYGZgZmBmYGZgaePwN6T4Wvx8ZtGNyC8dIpY9GXt2fw6rlYWH7mi8t4LfbDJ5fLo9wvz+8s57ffWc5uv7vcs9dif+NPfrR8/Xt/vnz47R8uN+33lm/a7y3fsPLMn17GojJ+c9mXkrubPLiXVJvWQ1qS6IUey27WZgZmBmYGZgZOOQNzYfmUR2/GPjMwM/BGZyD+7Sm6aJcG9pvKvqiMheWLR8uzy0dWfr785hf/svzyf/3D8st//oflj/aUMn5v+dnjB8vZ00fLO/Z08ru2oowSr73G66/borJdisTlQT5d7N/083IlvvVHbuuKwNv8l6rxr1BNOejDqLvmoKi376SzMTMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDOADPC2TNyqiXs1ePW1Lyz7P/A3jb2NLoBEx10kLChzx2uxP2/7udVjv/XOV5ePvv8Xy7d+8GNbYP6z5fZ7H9r+ge9ntgDti8pYWMYPqJE+S1trzo03hFju3SLi0ngzJMEsZwZmBmYGZgZONANzYflEB26GPTMwM/CmZ4DLyviCjv2pvQrJflfZyssntnhs+6UtIP/HT/9p+dk//v3y83/6++XBb//DfhHnYrl99tT2S1tUPrdFZSws3/AFZfvAt0sCvO7a+KzOhWX8C1T/el9XB7vJ9csFgP1qZhe2q2gXJLuIqZgZmBmYGZgZmBmYGZgZmBmYGZgZmBmYGZgZmBmYGXhbM5APAFj3z/I+DcpLPHNg92JwOwYryme2sOxqHEJod3uexfvu7OYLnl62h5Xb/pk1Pn10YbvdF7KnlvHEsj+1/N0fLu987dvLOx98y8pv2euw7xofFpXtFXj+Smy7e4T7QH7jCDFZ3TcPxGpRspVKKcKAy8uimNWZgZmBmYGZgRPNwFxYPtGBm2HPDMwMvKkZqK/iXFr2J5a5sGy/rfzks98vTx7Y/tnvll//7H8tv/yXf/T90Se/We7a7yrfu2m7vbUIr8C+e9N+V9lKLCLj95T9N5UtdbW4nJcA7cIg84p2heJCXRR2+KhP090ifQxmu/Cp2MgAkjeO1QasE40Jf177jmw2XnsG5vgdn3LN3Zsw7485/zV7L2qvXLM+MzAzMDMwM/DFZED/tiGCV/n3TX29Sj+vMZOtG9I3rzbFawxmuvriMoBBn2P+xeV/er4iA/EBpVOUi8vx7/vtbo5BoHe5VVCPBee4iwSG2M/sThKeXkZ5tjy031v+oy8sXywX9pvK73/9O8v9r3/Xyu8uX/32D+y3lm238sZN+53lZ7ao7AvLdnPJVpJ9qTuD0oXlWM+OmPW8SolxRHw4zoVlT8c8zAzMDMwMvBEZmAvLb8Qwzk7MDMwMvDkZ4NfvWlaOheUn/sTys2ePl0cf/7vt/+H7b//tX5df2eLyr372L8vTBx/7U8rv3bEnlW/Z7ynbDyjfsh1lLCzHF/q8JMiUmZ90Sc9Q6CKyX5HwAmKVaFolYNBTqxcYhDQdBW9A6X1CKqyynZHjO9n9jNF1yXeS3I3vc4TUuy3y1u+R6wpHV6ivzCPjqUjGAK5u43wYtyahAwJ2O0rA85eji46hBdJJdyfXHnywfinNvbhfZwy7HbEgtuLz2LYUSbSluqo/x9jsxm2K1TkhfWmfAeI0+rQRpREJzM8l+l35oCLLzm7QobnhbQNFUXYgjba5S3oVdyHJf7i8Lt+I28yRgQ7539ON3H3EG6RusMfWW7+M1p6nw3G/DM/FwXy3OV6q/doWOHO31adj+7PFhaCO5dMOZbhOtudH8a+ifh2/x/Z16+8r+lDPYL2KHh3JyflknWVOWr8h4CQ9gp58atq4VXiNOsNcQVdO6GGlaKZENIFWTLll6TZbCrV9gfrzUo99iPhC2nHZ+PXt7SDHYe5sxET9iPjoeRJ8xmSVPZ+dnysa1+GILF1B9Jxq5m93nj4X39WfFFch6jNoyIh0njFvh5YDkvhiqZpQbVPsSCu2ASABSdVB7qtch2GGOLB0zdGklFvR9+gtRNkfqHESHIyv90W2o32S4NTLg7ljzmIG+SebiSh9Zo8zt8XlXPl9hgVh2y/tqWO8uw6/t4yF5T8+vFge26LxLX/19YfLnfe/vnzzB3+5fPSnP7byx8vNW+8a8W3LJnZdWA5vWwvLbewYkI8FpYgWirR33TzMDMwMzAzMDJxyBubC8imP3ox9ZmBm4A3LAL90R1lHf4GRLSw/sd9W/nx58Ouf+f7pr3+6fPzvP1t++8ufL7+z8vLRp8v79276/u6dG/ZrOJf+CuybeQsPX+Ftjdk3/a7PVylxKXu8iE2TsKsrCLskYLyHbxLu8ZW1ejjduvdHEstrwpfSIyMX6qBcCQZPVyR4b1wGlq7ZuywHB7l2lDvizh8ah/Ko8VQ0K4pdgc7hEbQb365iZLheW/vQWVzVoR3Dq8w6Hy/Q2HHvjK8rhr3wD82ZveE7pj/H2OzFDPlubEio7c1fq0CsCmF3cQdsStAVWRN7RSx6xdByjkG22ZTBkOoGtDzvcRdiw/yA6Dp8ivH6jrNDfdgxkb+UG0HuEe5Nhg2KFxHtxQxOzcmL+LjKdsz3XkpWPDvAswO5O6ZPrypHR/d7lYjjBYf6NrI+b+6Ce9vqqsWg0fcrb8tckqq77aZT17heVIdyvJ2dw7xjfB26c6bsnaIzUZQqDvk5Ig1KfbC+H+m+mfbh2RA4+UIcrQGy+qzT/tF+9L77txdAJRgNd9qdiXVoz++O+Up8XXvN3YrkOQUvvw/Xi27v82T9HT+zMtB6cy9hMlmkapnpDQbKa2VuHV+adYnsp9OgKj8WQB9Rqfbkh//Kl9UxfXNuUhyIbT/qw9FV797EWiWsn3PaV0uu35OJJOOI3e/p2A8wX+biMn57OWCmPcdvJNudICvbwrItLj98aovNt95ZLm++u5zd/cryJz/+q+VP/uK/eHnrzn1jtUXls/ytZSNzjpxtvC0Ev9hYujpCC3l+ynJROcpDo+9m8zAzMDMwMzAzcAIZmAvLJzBIM8SZgZmBtykDvHzjMi/6fmHf1O2J5QULy4+WT37xz8vH//bPyye2//E3v1w+/d1/LJ/+9lf2wzkPl/fu3lju2+LyO/aY8g37Eo8d/zb13Kzx5Z8Ly/H93nzF/55g9cgoNPNx8SBXCWaM1t4FPW13L4LdlqjTLlu+LCGoM0v7F4TP0V8jJB+ttO2+VQBQC4gW2+WhsRktehc16vS/63LDyZU26Zz5632Hcku2G8PYGWvzhs7IoxwboVtuR4sN8muKdpk0iA2ulZ0J1ETrG+YvLFr532B81TFsuHRRmzMSgFcz6L3hO9QnoercHrIBcM+uI8kGYxxt4AN9Yr+abXOen9ytbQjgHZjCkRQQxTdS2ongQHWDdgMdwTD+HbeZq9KO3KUJF2N7xI+BjPrRHnhivDQA2+SiDftCOUrqVKb1kct1W0Sd0VWsCn7++nXYN+N+fle7Fsw1AKh7TFa5Tmzrk8LsMuCtxWXO+YTsxqSK68TxPHzkdpskR51+GD9xr7Kkz+bDAlnJTMlYvWzgqyvBVd8VaBE8/AtM6RdZZs8sYM0/4l/33aTPkYjIweG+PQedE7UYzbDj7xqADsy5AjBIR1QEO3KHtB15LjXBS6poF1o/D3AzDvaJi8pod1xoe59Mqn1LQy9C1byBWzmaolU2/vZSx8DYvqIkHHE0nxrnFfajunGMip12pmFHez2x5tD9v0D88MhPiEN9YdxRjsj67CmN1dKItuydtwsYYpmErjIQIWHPVqMl3cEyrEaGMnnGCVEi/87GGMOylIxCwm1K6lxghl2byWhoqySgshfK0aeabNfDmdOlce9bebc0qt/28EZLMZiRwo1uMl9WsmooVH191w7x0AAIAoPCfxDN22fL5xfPls/sddgPHj9bHl1Y2xaPHy93lgtbXP7+j//L8j1bXP6elbfufcVuHt1bzux12ctZ/M5yLCznHaWgD7/DfKppnBMge1KLyxtdm6KZgZmBmYGZgZPLwFxYPrkhmwHPDMwMvPkZiC/gtdBrTyzbK7DP7Cv/s4uHy29+8g/Lb33/f5eHv//18vjT3y+f237j4vHyri0s42nle/YObP6mcpS4tjjDP1z1CxXk0P9Vqbnqv+5ndoHb3BS9C+os68KiE59kQ3vPDtTFt42YpARVvzGSRqKiqSPYKO5CjjcJor1FSOuyJW8XlAkdKcQaM22iT9UzyJ3ZLla9HNyAgxEAy3rYxCUkZdSvbYKU1Oyrt+0gIUcMSYQcR58gKN8OUkWo42hk5GOpatgy3lV+TMAY3YbATtixRWMPZ/Jd05VzUCVRZ1TkrG2Z0oQYRhltansp86har5uRyiQyq44aRL1hQFdepn4M3MUbfBsD18U18BiNh4UyVC5xGajCtp/zMMGr47z0Y3/Ytdnof7NkkCbICDKuA34MeI4YEbj0u+tHc6AVm6vNCRza2ZKCsBWsybkY19kIhFW1LXrEXy1iIYueZY5XmNSmaaGLQWvkCtmWv0K7tjcoJaIyANSKQ933nSSQTtWUkU+cmMi0DZC+BqDm020zLuVp9QQLZalaLSrsl8ZKSGfPz3UJ1G0dHMg+RtNqjB0ZjMqa/prEscmZyqbLdsSbn7PNT6FaLAZEvfoXcxhteAgvQQprjAVtiy2dooBhKsrWaiarduAdNgqTKimytS70s7Cw8nelCXtZuGvKvi9DLNU0fJqErDQtMtNvSJsaFVAwd2y7UXIHQ3/2gtO/A8Fg2BTZKAbMVc11zFtMaxR4G5KTxwSK1LjZb8bsZRF4mIpn3B1fw1O7kU+oGI9VyySYqELJz2qyBSIs8k9WYyAPS9p428CjHPrypb1gzHHeMS/kow0IeyvaVXmVDe1Rsh42fvZ4FXFHH4YS8jSibeQMf0frcwUk0JMH40o+6GJzyRAD+UMHHP2l0YagabpK+AueYqs+R06jF+wLCRRPWYcxwHp0C+H21Yy+k2ijJHTLL/sfcaXvHgAAQABJREFUujhijtJmg+6AiGda5aGBfdUMrWJuvkvkcM7HTtyCT6kZ0x5G/H7EetkiJmuZfclg4P+bcJ1pcGxtiuy4CPYYw5dnIkEQMz6N2QPKuNhnUjX+1FOOMnTuTMUyD3YQjbQzKzsGMfjs2JrbkazaDWKRer1U5ri0fRTR6qBbgJOSaV+jZ/iMj1MhctP31/D+f5Q+0A7gzIvS1pRtcXlZHtkPL9tDy8uDJ+fLg6c3lsf2ZPIPbEH5+39p+4//63L73a8tZ3iSGa/EPrenlu2J52dneCV2LixreJ7XFEhQBcnzyHDHfjqc1NDNYGcGZgZmBt6SDMyF5bdkoGc3ZwZmBk4vA3H7BF/HsbD8uX0Jf7xcPn24/Mf//Nu2P/nj72zN+bNlefxguXX21J5UtkVl2+/awrJ9wPvTyriEOLerEOxYXMbVSPxLVlTzAh7ya211ecDL0qvMugvgq8AnoNcMRD1y53W7oEYJCfLOrPI6e7t7ROFasOogkla70QcOXh6izhsNqMcmVjvJ9yh3YBqD+kEfunbao79wgxKbl6nzfpuSrhRDmybLOchchT8jtArtmywdaTzaVY3BgwOeWzogVzap9RL2HR8DMHl3Q5fB01pwFHl5ALflv2y2CbXfOjE87patvg/KNIZTGe6itoYhaShVF0lbrfa5EM/oWSypcwidDvkWOKrKRwunwZxLV0rX5lwH9ilm3bTIN8IL+y7jLQp8xpKqCbOyrzGAOOI8gx/YjCGAH3C/IU5lZ09hOpain6sRqaPNnn4dnnxRVO6EalVV+76vfTzsEb1v5Wt8OqfnK9ejLbmB6L2WTfS32lrT/BCH0nfkSMFWp/9WGoB1gFt9sPP+pNI5M9+AaR7VTCAq9rrGrcoxXuVWvi5Oj1stS6vjEHGnt9GmTAygXBpd39eRm1ZOZYGjjLrmlajg8vM/feNcxIZ+8lxJlcuhRT7gl3kpNkCsRQOpQnMw37QBULaeuxQuz8EgBmXQ1N/KFiR0BujdhKUfTcH+lJeo6fmh49+xDdw9Lnjgx33AVzrpfEqDPhkv2qynaXIQWZzUX7fseRnZaN2jVNv9/RBzWDA6F5sAJXvCckw8beBDvW7lFBhskjqrVxBVCxwZAcF8JJQlUGfZKN/B4sfsA3DKjTr/8RR03IKq/FCOEjEjVo0dcsbCEjJuxLKkHMEgXrVh/JSzzcg9ZhCYIuIPNo/LqixpRx7+4yyU2OgzOOy3R0Mc+aExcF3GEmSFjhekXd+6RtmMNXJkSO6JrltpSvlk6ChoByHxDnAb1apZIR1RzZ2eDtxGpczsasji7yYo+bkp9BrEbp35ph3LXElLuyZt4804SAwExrghNWiMqrdDq7Yxtwus8fi5lw7yT463gN46jxLaCnJBwLhYNpAF494zKAnTfh8XuZdzL43ZT85p5fd6dafN+8CEAjSodXloEYYO+Latgg4N57O3jJCwKNsnZ0co0qSnFWBSr6rhpENpxaKDUXjSpfbVPgm8g5wjcb5tdW+VBxNgzmK/tMOF5faJDfjTZ/ZabFtc/uTh5fKJrTB/dnFz+VNbVP7BX/7X5U+xsPzeh/YW7Pu2v29PLd+1QbV34Z3dtHK9sKy3kjTqcbz2Ps+2+jFlMwMzAzMDMwNf/gzMheUv/xjNCGcGZgbe0gzU5QJehW0Ly/bU8uXFZ8sv/7//vvzyH/9v2//7cvHgY3tS+ZHvt84ubVH53BeW79zE13a7JLOLB5S+qGx5jIVlXFgYO64uuNnVwOoihLpWCt5l17S4GtY8nEpFM1EXvjli1t/ocmj0Qn+7f5ogXiySIyyUIxFFZUqNp7N0hfKn2crG5kSDtYqBg9klVqVvbycMCNgGMvjRZsy8uZSeHac2buf2QVh27InlUfmSKHDlteLPWIIugqNzlOkABSD0pxDGRxljDGwSl2vCoqRflY5YxYw6swu1HTd0EKq5g1IAuGrdPHVqM9KqjYat3Jon5zIS5VS7bb4wGH27nZJDkIMZfva8AFZsRLnI7EVFujZPgz5tzRBYzG21YX8cZROwPIUmYtvuqXdhNzumFUect+Anm/qK2GqxTMfE/QgX2txCnFmJTlDleaPfEBrA82CHqDbsXkXtGXdhowfhvbTrLNJ7+EVLLYsvasFXUuULu9Kx5vLRMJVdjkzGPl1aFKiPnKAhlZcGaO0RzADA68ktgc7bzfiEt6yiNsas+jGExj3wMWbYckFWeapXGXsqyRcxDN4a6SAXYuYXopoVG3lO4JhjRfr4IJD0y36Mi0d0j6hw4z/KkHaRRqeaQruz9+3I7RuQnhpFL2itmFtsagzNTxOmxNrlpimdos3TApDabATbcQBSBtp1rZPIWQzefJmCsqoEmj7BHh50pAMTURGpsqhf51jREx2sbPXlGs255FPNTBWByNgma/Q9pK51BVG0D3RJTU6CPqCu5TGYT6WkGUt4AC/4thaW6ZOLy+EgrP1oAHKxBEb7FTZxjLjNp4IT4DamiLjLiliWpQk/aI82kAGvNq0v1AHUtsyTtRFaxG8V9C/7SDlMGpcJ8dmAf3TChWUQQO94q2HRDhvazdCrLoG02zwSOjBN17eu0Zl1jdXfAtGS2vOjAQkGVUZHfFP79V9rSaVHan/JJWCv9hblE0rtao2OpdDI2mfaSHigzU8G+mQZHWWETVrjXiJnRzNiSGc0RdOCrrM89OyHj4kZAh6UYRh80iMTkxK2I1+w9kf2DdLgrrIhPTZrZUDuw/lDhMgYq9uYDlzoKwJa8YpM9bDVeNAmr/tsTE4Ldb/RkUjdzgMxofgNqGQoHKTlGEURi0WLLYw6Aomg+t8JT7qhfY3c4F4O7+GoVrtZWTRpNnDbx2/92CEWls+Xp6bEU8sff/bU9gt7avncn1j+wV/+lT2x/FfLnfvfWM7td5fP737Vnly+Z+OARWU8sWw7NgnA3YhjUQlQziEnmIeZgZmBmYGZgVPPwFxYPvURnPHPDMwMvLEZiC/kOOYTy7a4fPn0wfJv//B/+f4LK589/GS5ZQvO2G/feOZPKt+9dWO5zYVl+8bvF9b2RR/f9f37vlE6t19dUChXApnRXhLRpGoT0evMBy8um6JnbOITrWhGtM7u8FKZvWYJfY9XjdV7pdMxleSkj07ZC4tm5BN3oyraAjAWtqKsNhWwwc2IkcvDMSEuIRG/6v1f3adNfyPD8CnweWsk7DP8ewzO6ex2EFbnc4RKCXRZaEME3sprg3kFrIyr16DljiKWtdIlK1sJ0wEaCASjXkCM0UUJ7M3NOAUeNxthsHlcxxcEK/mOP78tUG63fWxJJc5Q75A0sRmgUzt90s+YpI4xtY54223TU1J5H/ukOkDnQ1ikHQqSqwL1FueogGrPyLDinzmPUDnbk8/5oy++cIb2QKs50CjChZ57ZQgb+u1s0IhADkXvJrTfjNsQns9ANi7vXfKHMGKiiH+S9hJePXDiSqMpyBEaHuPmcAuA4ixlGJoG/QIXy6YwkubfABwpysiF9hiLzwUCVY9xKAddTeBNTh+r/CQJx6QZ7FSK+9BnYKKMdJu3j1w54da1JfRIlGc8P8jmJgZspqZodckWuHzup/LqheXoB/wwDvr04Cq5Hnzz6f5by6E8uP22SiIlmqUT7uiNLNQER5my0RX8R18wG9eGnKM9WbX4txYSdp9loTwkHwTPuSpaXSOzOLp4t0aakbEMIvRHBruxjxX1Vjq3ruYL1BAVfZCVkmgzbqIybPsAK8nQFUserRBa39f6PNYc03d0JZgxPt0T+daOsyV9dwMYDH4082hV6XG4PCLrYgdvTK4wEKXHaH6ojviAz0jpiAorXZQcW3auon3aQQZOcd0YAfVdOKMdn6nqgzzjPzphvMFlOSAXvIhT4loHM4rxnKO9q7tGGmwVRg7/3FgX9y0HEUdpiG22qeoQAyh0hYBtg5i41UmapVsMSm/SJpNECPGYm14XPmJE1FV5ntCO5V5wSDU5Ne2wQ1gr+waCYY07goi/KRiTtWHwbfen9x8e8X2m+c4esm9oum4DA43zZZxeNzBK37Pe5qO1wZVDYKVbNN88j6mH79r4uRHckIc1ahot2hsbHNtWNtFWiceWqISr2jQhLY6GMl6pV3XTIz13MApPurTMMDnjBcCQiTbnJAleZRtUyWU/sWyLyrawbPPs0dNny+9tURmLyw+enC3f/4v/ffneX/xvXt55/5vLjXtfW87fsVdi33rHhgu/s5yLy8nlc46x0VfmPCHdCAyQTjcbMwMzAzMDMwOnlwH7O8A/L6cX/Ix4ZmBmYGbgTc5AfRnnE8uxsPzz/+f/XH5hO8rl8z8sd+0V2HfOL5Y7trB8x16BfefmuS0s26uw85LMLw355R9XJ/F/S11cC9jX/I1v+nEhWpE0I69sGCRgb7Fj00lPelKtvcxEJ+qSeMxUbyfadsOjTwPHQZAFgHJLgRsmhdqtrTFKVtqQVp/oEwiEXchyFXHbjZhUEuN4s8GrB9ll6tQGPjmPwTp2lT10W5vI5GAJG2z0AUD0I0v7CtS1A+48zSZlrTAFbZpso9LZjwEJwagiFW8GoR3wREofAlsCIKpHod06OpPEUAmSXLnhwJYD6cU18uB+NADx2d+4U1CMc0jMYBVsYfVzhtQ6fxwpQWBMYNONTdLhxgg5ykPUtvDk3rXZZTPLzCM4lLuLQPoNeM1uzge3DnvyCVmI9NyrSPdyAEZSeR2HnY2uIr0aXRjAG6SxJ4lecvAmlKnAETysVKxp6UUn9ZyUlvGUJGrXm2dl5bGYo55PPHd+a8SYNyJbf4zaUVR4W/zRsEReE3i0lVDnlsi9OhoOvGgGJAzpfm1mIyeEfT7AUo5725KLOQy6nFbmXNUdus++ogNDwyEeP//TOW+mj4tHYRDz023AkjbFZkImAgamaH3yemtB2za331ZJpA2eFSUfdAxsEDO00VX4j77BRD8P0S4NWtvbKtc74UW+g8P9dnQSmXyOQtrHQEtKw45SUHpd6Do3zjdK2FYWyo4rER1DCFbGi/io6esuHfrevFvy1Iry6Gt44NB7ng3A3rBEJsGBuaALyxy/FiEniztJbtTNmFxd6XKzBrkpUGADDbhJ5zap9BhN4TYBbza0FXGrKl7r7osojcFknY4YKxGPx4TS+2AVlLbzjRMmaRt4+MQyOVFiC67MQbZbIqxNHLDaGP+2aJ9WyXHjOGQaI/4kZ18E1qoerwFopzW183qColBto7MuFBOkihpUzajLQZNGvsGwZRc2OvfLUH2WNGqcy4ySZReoGIFL/bMOO88dsR3QtB5EsNMm/qb4yMpYR7TBt+6P08IHKa2qnxOaO/Yt4R5DRAAJN0NpbBAnt/uiHzc0iZWohp/0HGInbOPgnC6SgwBNqhDtgxisqszdSgE2jzFiQ9+z2TsqafpvKLXoxngg6FyXdSc+3YZNBo6L92347syOxZwJpM9SSUQzIZGVl5Z3LCrHE8u2sPzgqe1PfGH5T/78Py/fsx3l3a98tNx458Pl5rv2Smz8zjIWls+xuGxPLBuPz2nwRnBZMqoo6ZZSCY2iWc4MzAzMDMwMnHAG5sLyCQ/eDH1mYGbgzc5AfRHvF5Z/9nd/s/zs7/+P5ed//zfL2eNPl3s3Lmy/XO7aPyD1RWV7YvnWDVxWxEVc+9KPK4Aibcnz12OjtfFNnzdrG7irbBiYfrzZ0plsOekBb1Arks0sseQQsOwS70IiKxUcw5Um71jsX9gbx0Fl+aiaeqkoofc4CuihA+G7mgGbfckQmxWxrUw7hwNlFYji5hfncMioAyzMwiqOFt3IBbqUwQabxoP6qk8BW9mlOONi63DZfEeABR7iHNUAOsTjQ01uyJCFRgS6fK83NKqyYstgSsXkmoROUpnJi8I+Ywa1Umi9wcTVuAhCfMfZghRDAi22pjYZEbRvN0+bc8yFsFE70Lmt4Q5lb7RxO+FGm1uIGRGlWTJAazqug2UEgyLi6+cAZC2H5JQgQ1RjROuA9LnrIjTfGpLWFUdXCLVxW13x56np/47AIlFWeFedww6+iZAiKZUfxmg7R6cIg5LTixBZlWnrpchrxeW6/Ecrii93wU1di0dIPT9l0PoMCMdD4F4V+EacopWuVX9Htr6t8xxMjL1D5QBzbKHjmAeuHEs0QIU6j2qjdaiVG+2Kw2+LjlRuARw2cMUiABoxD1DBeR+Lyw6zQ0XnNmkLbR8poClpfAEuBljV5ugd5Yq7zKw29pzKfbIdjTNpXvX7l44zPIwxNc4kQPddxjLD6vibUSiDs4R6rkPax8AIKA07StOdBzHKykNDDZXRYlA/R7N8gZOxgkDr1Xa8Qakte5N5WCqBXcXKz3DmGCW03IGOLTjGfzgBKb8rWQC2FXerJ+dKS3l+vkHPU8DnggXDNrjJvPt3NAHNBoSysY8uSj4rnNhLYo0Hbcr2+NLUrcgdb8PJv/PkAxc4be8W5ZOAtjgrWRdTr7YYWgVhZ6AJbrYmruhTmQX7VNL+b7GbljLitra4RUsQNS4Qthgcsf85Q77RX29fbogvSdYsFOZBuYjPT/KVGQSKJyB6Fhr20sstsHBo3A41I9i1OChsPKaljDzpiH9XeG4y0uBzEMNtJfyTOkrBmaBaNSaIreSNyojqk8S5lDvrlLtXk4EHn70oufV9h161iUqQ86Uo6htYEg/lFq1DnKLY+LdBxMlUvvoeoHeqM3hrasR9QA3Si0+2NT4D1u7ZWI80C4dwurDs+TFDX1i2hF7YAD7EE8ttYXlZvvtn/2n57o/+0vb/ZAvL31puvff15eZ79krs2+/lovLzLSwj+RrrmzZGJzu5ZuAzAzMDMwMvKQP2Nz7+fdNL4ps0MwMzAzMDMwMvKQP1JbxfWP7p//jr5adYXP67v17ObWH5nVvPlndtv2uvv8aTylhcxsIyNlye+iWqk9mhSEPfrjYc7DI98EJQZVXfvjTgTYbCaW3bRhEnUR/zuAq6B2ivqfGyKVolx0jaPobhgLcbyFEX2RmAmkHUgKnvnbabLqnNgiRiTNGK0FyYTpBCFTcleXMDCuLcBna+h5S6wAepHVsXvZ4g1BubkYCnSaxOLspDW0eNSesNkXzF1DSZswYoBWtwLmrGQrWXGSN0uzGCJo1Jx3bHNTQ2/Q0YNvWmDWUsw+cQQMtsoDZvVJFgo9S+1k27Anb9ax1pvS8g46BKNOSIMgHgMoFTmqhRq12rb2mbslWIGkOgvE2CDlBar3U6o24JGhVwa6MFo05VfEBwYw4ARr3RGgAWbKv1SNu1zUbbbmcC2udfGbr3Enj8/Th320A6h1U7/8kjiLAnubf6g/NAREwTlKhZNB3BTePgphYxqo6Wv49oN+xAxc/lgcKbAU3LLAbz1g3aK1/z6UppjSSm70QCJW+U/VkPGOZIB3ciRsGS1spmXJ0hdF0UbaxdM2LTDxmbepA7pSuLG3Mo5lHIqEbJ/ujnE1Bb846+qywfviiSTecvUPVyVCTGzYrKpT10UG4gIOptHBQHmJuSo8m+QZmfdJGIQF99NAL48n0rtA2GgmmUvdQ1uNXQINDrnNL6hhOKzL5RmKy8ANC3aPLcZYS2Yxbe3ZMfNBrGZqMxhBKoyC2IS22j5Er5u5SUwHDvg8l/NGFCzG3Oc2AqmuLrvSWTASuG9OPGwcD4nduALkWgoTbbiBuiiD95GUOzKbnXmn3Ks+2tDEhFCJJtlsAyvmRphVMYkG/BuczkJLVztT4hd2kJmfcl234+UQmZxBEQMm4qAc9NSUy04jFZg4RV2ZIjIVu2ZezcHAvnaLzgWbO23q9VqzEFg9MRi7LjRzvnHMC5FcRqtKVSSlWVDVyoBgaqFYKsRv9Hm1C6JRMEUdb170PSmArz23gQNsq2YWZkDKEuTYmHqFMBZLPhJ7anzRk7Nw4NO3h/ln9gETKjYQlaPSGQM/EYdfpl6UY8wCLYesvyRSRL5XdLFRBkpaabYwlod09hRVBkERUJSw5JPy7ERNkje92ptsZb9S9lYdmScWmDdIFXYdtM8Vdh28Lyx589WT59fLZ854d/sXz7hz/2/d5Xv73cttdh377/zeX8ji0s+6uwdWHZyPxvfGZ/ZxB0THcgpzpEM+6ZgZmBmYG3PgNzYfmtnwIzATMDMwNf1gzUl/B+Yfknf/vflp9gcdn2G08+Xd67vSzv3j5b7t3CwnIsLt+6Ya/C9n83hMtFY3IyltFjvTjprkYlId1FoMiTYSWBwC9Ud68adhWbXF9KoaWx70V/SY6bBHpRPfbBhyKFXm9krTKapL/wU/Z5S2DfrPHwBopD6bSIjN80rZ2VgTfMeBsC1AVY9dfA0Mb9meT2IriBj736kF71PonVwVKe4gaM5Dv1EVt0IUUHx8A56TD7EZ6g0T6Wb7dxtfhHu23eQW8xnqaSCnUoEavfCIW+BRD8kbvIYadGA2AQNBsXumwUpSaHd09LVPEEt8w5N/XoB3A1CRm9NCu7Scb6eHMoxja4tL7uZGCcpwe6os0ZOqrwwvcYnOi3q0EEs5EyYti2Qtw93lqHfHOuW7nNq2xR36LrU9IjyIuS54lG39uWxlnMiGwdD7jQ104Z2HMuLIstYPTvJdppi3IvBhjRRUW2XyPnHsK5LD7l9Hu45gdxjd5CFmxqExIcFRHSFkOrmNyMe6+B3bLf9rN2xZvPmiP/FOsILL5sR2FRpIhlBucBMcYqGedG2Q1anwftutY1VvXbQm40TWLzpAl9zigfVUBrPYalzkW1Ub6NXrmIXC15HdCyXOF1mrLrxByCXtha1b8mskrvwloJ80I/U2nkBoit+Lr5sBM0zGDS+wuZUnNOeBwejlqUT/KFbU9cqOwOKTI2NunXSxeWZdX2zin0RVEdmzXEi8J2xLCOlApAKPF9ea3J5Sjm3AjoKsan5hDahIGJOHFh/o3PFL4bBiW25jcFIVal8qU2jRLlLI3PhFCzDR/YgPUYTcFYXcED4mN9VaZfyBW0QaRqjcHlLbZCObM1saAMOi/TT3iNvsAi+DguEQsxMMGGdrDHEYKoKbIJ3YaHQKQdhANMNDTZyWXvc7Tz2ebOcmwNEL6NNpNWqc2oEg/HztcMIpTCR1sx/G41dsgyHuDhGPHGUVXb6EKsLUqHWn+WJdsho85hjXv1h/w5p3MOhS8zHriHZut9y13nj9zMd50f/vYBU+dQBdBswQMKLaEM2sH7YKxanvGEuK4FaYT0s5rZwcJuKCfi6DeiQuqtDYMWC2C9SdKl0aYuIVqsfKjhSqmWJ1d/mQvLnhlLFWZhe2LZ6nhi+WNfWI7fWP7oB3++fMt2lO987TvLHXsdNp5cvnHnvs1L/L5yLixbNjm/PLEHUv/mjtDJTakZ8MzAzMDMwEvPwFxYfukpnYQzAzMDMwMvJwP1JVwWlp88WP7VF5ZtcdnKG08fLPfvnPnuC8u2oIynlm/mq7Dxr0j9gs7J7JCkfmmrFwBal/DnwrIkI6t6EcWLZagoRyo9zVbJdKdlFSrX63xc7m1tIY3bKcFdt3KUy22FgjFB7jckSQ6jdByYutmxijr7MfrVWEMX5L3P8qv2fsPEgNX3qjMeZzMjRubd0hu34pRVlORkGVFtH9c3lhTnrC5gSlcxKBx1cSrVDqUx+msbTYvSt0wemqj6jjqUaKO0rb+xFjIciS9J1fZsChG1DGGjUWM02mh7LwbPpi6CqCPpG7hUVb1WL6jvxONcNmvc4WjTDdFauSPR81xpvc5BGWz7fHtQA2Jo2oSJcS7Cfg6JZ+mcVLs5EuxrLsYsbF0gHZ9oICebcqB+KeNKe2DjNy0jE7RFGTZRwgX62foqfqDTjdwq26o3ri1lyjwe/TwxOReWHSIkUj3ACJVnZjSXzoV5WwiOphzLnvkSZVULZnkT5JA7XVjUE4LzGZY+rmqXneX8rbLcr2sdQafW3Gldx1I/h1UOIvr3uijB5WlAJ8S9Z0PaNbHA0A9Fl59Qbx41PgXYJ1CdFKqwuoTaaSD3GDtpNvaMRmwbIyhsNIXQ6GMzLq+PJbRqkHAUoOHu7UZm8jFujUHO/xwVmLcctPCkf0Jd4wgj99MsIGmbz9tUwb7n2LOBuSIbnVXERiBeFVVnsZc7N9LZGlb+qW46lOGi/m75QjJgGCP3F2XgiFfvkVNw+Xg4MOqOGvMrbe2rzwzpX/gLP5zrzh+h9QFYC7HqIrgCaK+yqpenLo1do9CoSZg+jGj7bjaMETgyY0EZ36cu7Y8PZaRnOsipsRIDrnFTXH9NZB5INhjpTKBfQHbgbu3xJkBtwo69cWgebI6kEbXsR5QmbQ6JMBFBxjL6EdXKtOyUF6EUdwYmRQtAZPsW2+gw1Zx2ZGiMHSGgC63YAy7nDvtgEMwcz0PCr/N3wt2QvvPJQKJEDgHz3XCIw83EBlX453UB6q4GsFWCT/vtPAFwJT9BXG52oYeqkO5L2tQleyvKtomk4kF5ewxPQOalcP1wCXtB1HS7LmaZmMR1im3bU5JaTurTzEZIvvNpug4tQIuJTZmYg7qw/OjpYk8r44nlWFj+5vd+tHzz+39m+4+Wdz/4znLXnlrGfvPufcvcLZufWFy231i2rRvLA6nXWA/AnHMeZgZmBmYGZgZOKwNzYfm0xmtGOzMwM/AWZaC+hPcLyz/5H7Go/K/2xPJNW2h+786y3McTy7bfXi0s2/OQ7eZ5XExspnDnW35/E2W03DbyC6BtlRHsKkbyL21bL6J4oUwZe+djZ40aw747KsdNg35bCUxdt1QCHwzK4xwbpl1s6cxlWrdxKdOelfGhLK97aBlhA4MVvojmDRrnMkVw9v4iF2HHOsroR2DJBwKXtNgsxlRSHhzrY/A1pjXAJb0/xrBrlU4ZwxYpINT7wrKR4allvToHP3zxiQZVM6IooYnNbVA1xXZ8nK1psFE0BMkbEQUV+4a5ixj7qHcGU8ZMzht3BI0xj+3NHg0c5LKSYxulKqJevRHdwSqj7kHsUy+Nlpyxq+hp18fnyTHjlnQnirkiEfdGjmkig/XWUNuoipC+hTHP67JtfM4eB6egkTVYRQn+6q/xmBB4lHhq2W3RDiq3DZuwhZgxbvl2s+RMit0C8TRHuyhCLDY3KCBj5E10qhlfIfdq47w0RpI0E3oJQXEHsNc2oxWPZ1bBZq5NdK5ch7L01k48ZJGH1KYRR46lRDJU08DNs56I6luNMVSVd/kboTSGIVP0s/rScYILhLKRG39/fEsitYOcf48CdOiof48CF5R2HJ0nDWNQVkAp3zK7djzuPBgijq1zPCNMh+h7ZDA9h1rD865AmwgfANZBw7obuX35jTnSkzqeds24xhE8SeOUOES4DdzkrssZwXEsb+0vV4cPG4oKTUnr0aAaY3J8Crci45iiN5t6SNNHF7sZRpulwSBLliEs5wA/FwYQF/OFDHT4FgikrSEYk6eYdt70Rp2T1Td4s81A8OTzqWhDlbbe2DzQUyirNRANtk2bBmjrbyUXTyzG+eKy/QYDM0I9eaLMoyk5JoPb1uTfghDY6JDQBdYgcVlQM2A3oM0mKqBe0bmsc+pgzhN0wLVmSNQ4r/QMYX/cDw3C/SoXLRbD+eep49OoKWE8ECXfdm+eF01857B5iIRt+9dwswduxzGMXIQt2H1eY+agke6u87m87b1CjFp/XrkLM2QsREcMubBsIHKzJFdpjCNjpaw1YQ0fJPeyWuDkPAr+0tFkLaEGZVitJBtGITJ8mkRbgGsqpe3rYhYKNV4pe9tTbHnabKRqoL0X2utxYRkAxbupGTDvGHe8BvvC9kd2m+kTX1i+WB48OVu+8T1bVM79nQ+/u+B12LGw/L4R3LQh3FlYdqceWnfQOHcgHX42ZgZmBmYGZgZOKwNzYfm0xmtGOzMwM/AWZSC+iOOIxeHP7eLz0XL59DN/Uhmvwm5PLNuC8rv2Omw8sYzfV8YTy/4by89iUZlXcbgpsHu5taOYC8vrCac3AXCzhm1NoY+dCcaLKbKpPG4AUXNF2Zzwllng66m1Ym5QgzBGoP1GisHazSU30blRHKnyfjBOluHZjgV3kftNEOrw3WKxBuBQ+w1UCYw0zT4FGtnKWTEnb/PkscSBzCJqVQTSGjsV3nZhP6o9GhTVVhyBBoY5bAvLkgegYA3R3sIyIiAHPQHvdZYgyroVthHpjTrQqCSCDEuoqlbxMwaaMoahO652e/NFns7WhFvRbfHQF8qOI9tuI3xbvG674ZGxQc8t7Lc02Re50aMovZFLrt0yO+K+rO48EjhvbLJ0HtMzPyw53vSz5qGmotOYodX+thAM1J+HMo5mg/DJQxvEFPPXLKlMfjRpE13PG7nQJ5alidrmKjpo0utUaCSBmBmzoL6I5Ocj2GnFkllCskqWNRJoWKZS8XU+QWDO+HqqYKrPfNEOfloyHVKRioXHBUZnFUhUMwJvaA/6/nRZ0GQab4xveNR6wGJWoT76Z4xwTbuIqdrEjCW5R/nY7s4nKFvslfmOiwE0IgbeBK3SspU2bK/6SgUsTdm76FtBLgaWmEBk2anoWP7mtui2Ky02hAKIUZBSdb01YwipRkzbHl8tjqs7SjH8wGuUhUWtGy8j1/Mo/I4eFeEMA2/gNeZA2VE+13VQRg9dnNnoZCBEf+yoflD3/piC/XI92jCxjaU2wIPPJpTYvFRgKlQUyJ3jGKwZBmedm2UZSnDX2JU2aoxslKO9HdU4SluW2k/UkQP8fclom0k8sWxPLfvCMsR1TkVklbtmdEVF/xawD4wnOHuC7V4GZgvfW2+3+rOsi8J6WKz0jfHxnjdVodgfV9Eg3W6NK3FCJR41XiNroD5GoNSVwJRgs152YxYM3ogKtSYxkKjdxNooOf0bjUMtcyhTyPNzzVuSoG8spRhq8Oe7ybVUWIzdemFZMXv1ikA6jM6bwnUuDhSqgbK8QiQ68geSrSp5b2DDpIGYPwqYa7ZZVlyUHCj3AtIBrklxgOjNUMX4RV+2Fpah6RaXs9sYCzyxfHF27r+z/PmFvQr7s4vlk4dP/TeWsaiMxWXs737w3eXu177ti8s37169sFyfuOnMg5C6+d0dRoXN+szAzMDMwMzAyWRgLiyfzFDNQGcGZgbetgzUl3N5YtkXlvH7yvE7y3gV9nv2UzfdwvKtXFi+vLSHle3qwRaY8TUeFxfnebNsdQGy8y2fF4/bud826m9mjJbbNiPqy9zmxbH3JJ/GG3vFi2296NM+qXy8+Fac1ntcMfjtoi6A0qmYcfs9BiNrN5ccrhd6YU8W+kWZUA0r6gRbi7xQwCdiaHFkELhRAz7cBFxtsKFTVzZra4340LnU5vaoDe5tqes6P4HeOpKZ3jQixfeetlHA0G0sLMerG5UHabH7oi1/PmYJgH336mHgUgc736WdVaMgihIpZRzYV9G2KnxjY/wsQ1q+hY6qGBsLYeRwAOJuyL6yxUWE+med+FYSvFFqThjXBsxi29aO556i1IaxkJuxot3NdVE4VybFz5cAB0XKycsSYWoeha6NGQjGfjPusC2tcgV3SWiDEn7YBsJ3E0SJzxp4ra3ZAGCb/s1wbNqGto5OkzYlvao2GlQwW2PkaPcfn4lEV1l8LqsmBnMzmE48GOkYVRaRu20uzrkaJXFpJhpOH882H/CdjcA6H32gvY3EqmOJyNRM65z3yI3HMMYO27T3EmS2KUdI1kdyrzW9pFswkEGCP81KxxfKJLJGl7wUd9YGSRuHwkTN0t4hpkioMVStWFmjU5slYegKqbqTaAcn8naIEQQtvqHuOjOmV7R103ky+ti16RRl5bmyYDt1OlvPrUJpDBpbdx55H8qX9kilsG//cGNQlEdPsbrqBBzzAJSV0vn8MxXnIec2MSx14MCE+UhGlvDT8OH0+kcJltUo9bPb2NOZ+7H6tj+NaAxh22Jv7EbrFpspPAeSB2LXr8KucwqRVeZocXXZnf/Za+9lpWRFst3TlsIV/iqBzuPipjRyXnLMKYyP/WcltSi9rnlTI9MDv7Uh902l9RW4lEHdrLr5UtIVQScIjhCt5klHosii6GwqtPYZrP0CneaNueD5Wazr2tjXNQLkkUP69FJioo3HYMHwVdiQBz8R22WXDoeIFZxxY8esDWn7rINedGs+AGwzI848b+4A3aPoNATnycOeXDFeF66VrsvQQeDa9IQlMqpxv2enL1xc9sz4+NXC8qUtLuNV2FhUxuJyPLH8w+Ubf2ILy3/yw8WfWLbfWcZTy21hGa/CXtavwq5P241AZFiO+RzeYJyimYGZgZmBmYEvSQbmwvKXZCBmGDMDMwMzA2MG4oIBx+GJZXta+ae5nz/5VBaWF39aGU8t37JXYmNBuS0s26Jb/IcLQlwS6uWIuZAv/BrHcQvL4Bv4nXTHiTo8hbp1jT3xUl71yvC996bcygIxKIlT2VZ9D7fJz+DSuzYj3pgDuIFQw4RZUZvOD/ruyoJ6jbwU80YcOaOsaHGjxm+eIEYoS2VNE6SYmRa1g6Od7FkA2+MYTXdricLrJ98tOo+bnuhb7suYpfYlXDsuxC0HvU30GmPje0WckZz5q7Npw+6jVBvUsUEeVSJdLLmCI8gkT2UUYNdG1blMz7IBrMJ46Vt1EYPZZRgsFTPWycNS9WqvdQQGF2qTLtU8+x8axgbAFhfk4+zybA3E5IFvZfZ6U2bunDMJqIMjtTQ1zkXG1N3gNB37yNKtlUvpncsdtL4TyhLw2CkJfBiMnxGps0LR6TJ4oLDgKaNFirNfah2Iyh8tygdzUZrr1BhB7yukIrMqZC6XuImIMmcCKQ0PeeNChQZNTk4TyOYw4SmVEJTQa5x3crZ2iJoLxtFx73N2MLJlomkVGDtSYLiQlcBrLgyZjlVDQS+55VizpHuUsAGHlxBkHdW9jX979vQq78+njLkBYpyjOzKHW0cMWMluVqi4TUoUwjpLBUau8i9vIxBnrVqxuMgN08CKBkPN2/L5kTE5pvlIIeIOExe4emi3uMvEa86XnYn6ANhrdjGYpfvzoDU1zdq5xSZ8iaBZhaYZGnGhRt34yU6rsqBkq2w5MXiOnvgyi3SHUVPPbbxh10hQTy8KTlHAavwJZVwbJlStyt52bcmQ2vlEgTG1GFes7G7PHjAdA+JI0OeG0rGUEGyuMg+9L/1uyTjbuKSgtygvxJeEpzgtKk8usSY1asN6oSmJ8pBNjxxaloCOswUcjKoLVZz71HrpMVvNy+KnbaMsldeCg/kQ5cATCWGc9Cx4qZJTRF2VMVEY7bTqjAtZNVqhq5wrFT/mEig4pxqdVfCPE5zH6lEWa8OBPsVRhKYh8x9xexQpJKL5NDn+ASl4lBdj4DtUqnCy/kB/DvMGailtttKmQdKEiZx/JmhmhtG6m4i9eFoBBRa6TpDOs2A+eulGaxWMYujgIEgN3pg6e44OrR4aMJnP/kyLF2aA8lU8scwzH7F0WzcsdT52mNmYGZgZmBmYGTjZDMyF5ZMduhn4zMDMwJuegbpY0CeWH/iiMl6FjcXlG7aw/K49sfzOrWf1Kmx/YjkWlmNhOJjwVb77bq8J3FEcv7Cs5G9mXS+Gx/TV2A19d+DupVeCi63jMXG0O6nZFD4IUp++IJNq1m0u6B0LqwPjlo2uj7PBmz688R6G+5HQmJ8Rzjs54BO4kwHb7AygevpnjKqLSNCnqPXHTWFCNoLojVvyVv3oogsjxthTiOUQiudgCJpoFxuAbXDC3G2s1KcZiPFXDxsIbdi7vPkkKjha9gkqdXqyQjbeFiYd42hmGevab5Dw5jnssLXS6o3DNf1hSI+gIxLyqBVtyOslAzdgVXOOGaBkyhR18qw1IWFuym+wwW7vMxRPiRDfeDMI9gmli1gakHmEDeNa8YiOPWucZgXOdGUlWYIPLeWjlnhT+0Y528WY+nTYfc6YijzeN3XkZhaNKZybQDowoduAQ50bjk2WNGnlyAUF+BqgOCAET336BCuxmi/KSDP6pyW6Oepg4/am6HmqRXtaR791/NasZcOoWBZvSAZbNEfIhulgRcSq1DHaonUeU6Bkfnw6iAPYxZjb36KUF1cIGtwVrbWKZ0ug5xKCKG6mIn3Q+UBSc6QsWwQmSmu38r6lfcNYm2FH2cfQJk3SK0eFomwhTXg0TI128LNfVRYP4o3Z3RjNiHWU1d+0SlIvXLRCJJAs2eyKsobYkeJXoSOyDUurCDqJwnNZMkJKwlTio6L13DibjAGKn66qwFAI8woJ37DYDd90br+m1egab8DsqE5dGILt+QMn4mAwB7nSsREWYudRJHIUr0gc7J13qC7CQUX7zrHI3Xz93cjFgLndcC6ZPMVW9sSO7EWk2iyLJ9SaPkh0PNmVnsik6s+bKaCxNcM2GajuibIV4ISEnTciByEPnhBLBpIeRHTNcnTFcwfy6jO9juhoO31C6OqwxZpntGN7RGrcK4wJ6Bexo86SPJDBDjwsXZedVXvIgSFr1KNddQf4gbYwYh3fDVFv7YTDPvpSc7g4iU6wF70MrcCnVVMXC61d0vRW2TFpEBqiBDYVa+bQbcph61sY11yCcG0BlEuHINbIFo6zvzUH+/zcWlDe6r+n0BKHshaWD/3G8o/sieV4Wvk6v7FcMza880npcayGodwKdcpmBmYGZgZmBk4oA/adJl6idUIxz1BnBmYGZgbeigzUF/H1wrI/sfx3f73gieV3bz6zheVluWtvJrpz64b/zvIte2o5XoFtLO2JWrmZMGZw51v+3qJImG8bedzbqtHr6bdrkK7uS8vJIaMGcj5F6k2TzpkmvLtCN4XTBYuqYrEnfal9EpevsKW/klMSZc9dur43kO/zkQM2XFwiGqXvriwWxhO2Nr9pAFdt06WgJowKCQbxqrlNbLBySCqWytEtrpkJ8+LWwk05bNknuFBOf3226XVh2fFpw99lhn3kElpswe4+rdUWVeifZUG1exZG3VaMuEvN/tGfUoEOW/TBbjsYqNlHSAHYOJKHZUBoFFwbZt088JgIMsfsP0Q+M5IOcs0zTeibXilnqbNLsfjs9KdRHGgo+nYiYdOAkpSxMB62m8905CymFDZC2mhD5y6s4jzejrF0uVsEA46cPy6WQ2FDGBZZz0sJlTUUO2ECcnhpfRBVm13RtfW5DKzv4BkcZTo289CcRkDdceSB0qktwJrtTZpUphH/7BNiEHGbg5CRq/RhhaNywVO/kd2kufjiNo0R6GKNlthA0LZRHnYuteqmVoTqhflu1ENF+yQUHYoc4PXcGbD5yAp47L0rLUfORZApWXViddp52m+0z0CDdPU0gT/34rF13hzh48qOaPyw82CDiJ+P0RqORguo72bUdcN05BnLYlnHBZ24dyh5w89aDxCY0Ccy0qfqUB+3ZyQ3RVkHamzTlj6I6uQWZK9XVGmUu8txCzyywPPPWVLnGqMKBDTJm4KOL9z7Uboq0qjqHKKSoVTU5ZN/y0dOYH23WJpd1j28JqSX9I+CDlXltmbkxqHoKUShdlJ3fGe0baNzQcy9quvHevfJx5HcIy3lYOh0prD/VYR6wFXqrv0Qqdn+2wKmcRzKsmotHHOB+la6gVauVTRbRmbg3GnY2SdeZR6Rx9AiWsfS+cko0qZTOVnEDNTKT+rpoLMdYiAUpXu08LxUhdUr6kExNNVWbVQOE8ZMOUvSua0JUfqOeraJQel2BgCf1yHMDjc7yGzjXCdOP4/09dJdvowVPNjCf1g3mclDUvOR/G7kB6KBrToM+VfRrNHITesQFaPXGq51NewGs4JZLSlG+3ToheoSLmph65Rdo7pglhxjkvRISqXbJXpza/Khep1b+p51SxxKX1i2q5QL48CrsD/+DK/Cfuqvwv7m9360fPP7f2b7j+w3lr+zYFE5Fpbvm+UtGwu74XR29auwubCMAdDxqtGHZm4zAzMDMwMzA6eegbmwfOojOOOfGZgZeGMzUF/CZWHZFpJ/+nd/s/RPLMfC8r1bZ/UqbF9YxiUndrxKG2myr/J5QeFXFZq5nW/5c2FZk7RRr0HaUIpold89wwKOiPGiurGvFBzkZMDdC4rciDfW0pfDxG9VDZ0cqHXy5n3gDhOFan2XT+KLmy28PVIWiAQx+J7uGVPcuGG/JDavdrdeStm61kdYgKwF+UpcAr+Fw9MrrthL6TW9Sb2mixtIjMJLjw2dLSL2lTejtxaWV08smz15WQvqjBn0DKiV5ZP+GQYz2dpGHmbhBXXUSCVMOW4BYF9YKk7r5GEZ7IXob56lPGMgyuNhw3T2f9vCfy07bMVD39HDZpqVsiUOCtTPzZPbtHjCs0uVTANKVsQBMeNxSMoCknMmbZUuKdq4I0K6aLymdX4D15kWcYNriw+85EGdGMfrKgGU3LwDgVTb6Ff0AdDKYsSAjpNfqWA3znvqkfPRxnXqmOAsI45BaM3gUkPpg92EUw3rHP8WgylQj51nDnzRImsGKAn0ulGTrIkFGzWBTr1JWVOWqKtFoSBlHlYIExRyqCtYnLlYjHZg7TMCUM83faUt7LhQh/jIS77ItzqSusRzqEp+xxghuVmGLf+ujPyGMpGOBOcA7LS+OZ8dFB7gr42BGsJluGl8qg7rMa6Q4tj3I3xQ1nKacLKgP6irH+rAWPUwdD4G7z4LEb6qna5aURpG5SltfW7ArIze2Y5YyWZcrLZ4k9/lMs4NBwfSAIX0qYvDYBVtabq5VGKvIT6yqy3/lo+ugOU/8BnHgfajDRx5z+jIPefB/VfgawhZ1aivu01nuGHjIj0jdjgMp9Y+juRWBc03dNH/PV+cGSTAeEYd4wq60Q3Gz2X0VaarGiE+riNRojk+KzUDGVkzLn4Q0B4wj41OV3aYW6Hsqc1zZxORBIafaUXmWsOjVN8N0ZO3fLqesTdw5jf9h2dRWrULrVe11iG7UceYKWdJMvhjF1hnSQxK8MCWfN4C0DbivWkgnWWsh9+clwCaIM2TIxDkq3/43eMQbCGdxu3jUIz063IZh7BV50Nd2FqA4pB9JKw8msRxJalcEV2l6oTeAGXPcRGrVi2UuZVGz9XgXhFYr3hTW7m4fNTCsv2+8oWNhS4sf/r4bPnIFpSxqPzRD+yJZSwsf+VbsbB8xxaWbVH52Zk9zbCxsIwUc+bqonLIawDeujGqrs/azMDMwMzAG5mBubD8Rg7r7NTMwMzAm5CBunDKheXLR8vl0wdtURmLy/4q7NvL8p7tvrBsv618239jOW41+E1CXKCCDIdGanp+s2e5kbS5sLyRFBW1fJZwJZL8tipBTUB7KnSoAlQaYrPk1TYAjS/RecXexGkSYpM20kKQLqAB6GVJgsLUZSlyq65vFoi+MzIS4YHdubGipF+reqho+55U1DdfwiPeVjE2PHkUrHWJEzHsbknIeEYcb1KPfgNXzOLOVOhsMZGbN6O5wEYbcKPOxWVYhiwQjcpps+WqNExn9FOerWaQsAgu6JIhYSFnDNFPxYYP3nynj1YmC0lp6WWYlh84TkAfQ5HQHhLUW9sM1Gb0zzaZYBl9sZoaOqCxFjxrwPrCctooEqKVn5HbDBTn6pSNzpyb9s2R3G6ELuXk9NKJmkHOlYQaoDSZMxPAjlvozU9i1/kBHqj+5r9zuLH9XQqSDuE8pkiVu6MN8DHveesK6sAyDjfAIeNqbak4H9rGFzE2iaOCq5dB4dhm41D3kzUvNG7G0P6RAQTDtpYMgCQkDmXEbGXnrOx6MS3dMAe2EMFXfQMLZP7dAQ3bdGxpqbJAxdG9EWQi8a6wxgkoucTMLdm/KGu+eCdWjnprOFPfa205DqpA04YlfLltCUDtIUSFoxEt9gXOy6fVNuxdJCr0M2BxpD04UW/c6b5Hhf/xGJiS0gdzW5r0YRGon9YPBqMGUq9/WxLA8tuf/zBRqjU6SYtAvKilMCW2aVuFnxMGaDLY6VxizgPgR8IlSZC7m+QhM9jAnSGA2UU8YPbAhDltWhPaP/nsvs8ktWNRx99ybC6noTVYlfAc575J4hI7GEjtRzVhxRq1EeftTmhRMJAisVqANlWO60hcso8NYlgohv2GTOVAk70rExTnkeXD2uSAjfPkADmUxlDmhtyq2MdVeIlDBOQIdYIMED6rTZvgtaOp6ENRsBvjha1jxYZzjLyNzAV6XkcOGs4q7iMFo6+4VtSIAlj+InblG313ul7ZVGsPVO1rSFWI9edNDEjki/lF7JG/snRv2RXPAcEZRtkwrgL47DAqL1OMeouG/ippGXqOS9oQX1Fpjf5Ypj+GowNHWZtUyeOmxUlYMVJipZqIOORlsemWxk5jWPu/91r2kpL0UshCmb00CqGBVV2gJTzlGju80zGqr+qimxsYZfcqbHlimQvLWFT+6Pt/LgvL31puXGNh2WPYiFNj3FBfFfrUzwzMDMwMzAx8iTMwF5a/xIMzQ5sZmBl4uzNQX8JtYfnyc7sZkgvLf/vffHHZF5ZtoRmLyvdtv2u/rXz7pj21bIvLN2+cLef2zR0Xqf4F3u76Pbu0PUnxL0lxswCl34zaSfVcWN5JDMU1SC7RC19CxjLGQ6QuYLsIvdZ0vN1AXJYJWl+Ym97vghSfWjq+C7Y5Gi7ezb5USuH0nWCjsWO6RtrEJDae1IkbX5oD1BEyF1TZJpnmQOvQk9vrTkqrKtVXSaM26rYpTKqOSOLi9Y08qnG7ZcusGwgDc7gOLSzj1cscduc0I5SMlxyQsO4zK8CBszrxFSNJHNiJo5HyTAEX0qEjly8qgzsHx+Vl5kDI6AGl15MTXAiaesRPbtfJQc+WxuP2vQ1zQB62hSrn+Th+jEKRVUcXr1pYps+yWtcYj2P3XI5EDZc3LJN25OpmnXHQzOfPEApdkANq5ph4ljQNG6CIzNynI/+7k/VCGC8MzRHjcR5rpLifP+kMWD6J5iID0z4hqyJ41bNLHBd9qTaNPWceS7KvIWFPAys9A4bDfGibd9JamtCm7Ctu5T5DHiwV9x5FRFg+6RIsfE0ntLEXHxIHGew9diuxKZ/nuqgDkEcXB9glO7A8r8Io8q00ZiUcAJO38XnHBSSJIFYZUdccuE4E/FyCvPlwEA7ip8lYCbQiSMtytFd+hM3QIcceXHWGggcy8qmvQjGedTn6A4I+RzS+8zX+9OsYEyrPaFdtmUsmFLaCWK35QJ1fTAd5Z4DGKuhk0TiBc3FE60cmDjrbiqb+DlJI0xafgVvdbSsLwe2UkRvzU9qQx9jV3w+10YVl+kDpNgZs9aDyI+3pp/qCXKcR8al07kFFSF/WeTZSOYcf0kLGrOcoEGMsfelKhriHjbAhZseZDqXvWVfryHdOAVOgjQ2UHAs6ZO6Ct8Yu2m7mB/1sYGjBW+PKNgxon65dQl+uJYmzx8HtDURV2ZqFCWlPOUpgo0/CEdUUVKM7x0iWajadG74oR5kB9Wd1AqCmUYmGGtkGMYlTvIfay9fI1ttn0AB18dWnUcRdbeXzfEMgNN5MJ2HbA5wpfUUhxvqZWsZJH6SBtjoqIdIKnPlWEdNC/UidBmkVzpJ4FcOqq3TWsbSG05Qvzp+mrw40EeLucWUv4SS+JSBzFGK1L0SvI1extxBOt2Kd5aeTf0JI58Y8XNVJNzUjlFxYvrRvpw8vni0fP4hXYX/6eLEnlf/cF5W/ZeU7H3x7uYMnlt//aLlx930zPvzEcjdoEpDGKl0QxKzODMwMzAzMDJxqBux75u6Vwan2acY9MzAzMDPwRmSgvoT3C8v/yoVlK29iYfnO2XLfdjyxfMsWlHVh2Rc37Bu8LyrbwvKlX+DapYksLCNZvGgZE6c3I0bdzqVoXFK+LVcNNUieHr3wXecrJXlR1+lbvnpC5asbCmLpXBhgkbUqHfVKd5XEqIe2BeDWnV9eqTdeG/meUjTras+81kMSfNFD1HHxTB+MBS5R1xK2kBGLNjeVaQwqJxaldwdQIzEAAEAASURBVEmBqVS511Vu9c5kgzxE1Z80l2JzZIPZHKp/GHFhmXmBDDHAD3a+QhOGyCM2cBAfJSTcHGjIuqmsWqIaQROE32hmFtyw7yu5Di4sJwiF9yV9MJ3JnuNcfQKY/BJW63Wzo9LAHV7sXU4D4lGaQhfKtdcK07qPhRlGKZr0B19dHD0kdEMsHD+BXkkSFOHJj8npMy5jYY7Bu4pXnHnMEhNvNNOGJU0cn6MZEVi4Yu+zTdrFF0LwuV1iYAsbcpDT4/bYOdujH4xjrwx7vdmZkiRmPL19SvEPsjSAHuQtdg0WqONvqcvQMd3YIZVJnWjCkiVyYzjX05nYoap9WLsNI1/cEiT9eMwZe3DhGNE4lwG33I7xMH5Y68Z4nMNAHReVMMg6eRhfTASxagqLUsTqU+hSrI5rbtGGPofoqLayEBRqf6obEZCivW7irkxGhu9zxwBok4s6+oNWeUve1xSD/GzlCD6UjT7B5PZr552T8hHAaO8blcZmdRn3c0E9rIIohrI3UIoDHsRqGhIjLqMuIRA3Zq+3luVBlWVGeePOuMmlf0OYe2D595weULqNKdvfcsiSDza+pwD1poSOfaITqB3UwWC12sIkwdBalX7RxD9G9c0hgktxFAQJ1Ku9XE06phEmMbBLwPtu2M7W5C3fqMNJ2qPueTAS1N1O7JE3ctGPmzN5aORWvEEQbT8S0p1fbUyo3eLMgFQ1xsO4IMcOj8DTs9q6KyrQ4N8fKkguGOcd2o3cPIrKWXjQuU1ZlOEEdnRX+mJb6wrVJq+I9qrFk9wuKD9RC1TkartPyPNg6i6ZX5YRB/ntk1ONnANzzYThMuHaGPwbMdn2v2DwEzqQwdaszJfUW6IM5eL0LR2AeMuii7nxsGIWSeXFiiCVhFsZOMYORRlJOEQC4Fuh+q6NHthtx5tS7ch1sqX1pz6drG/tg7gNw7W7pvlpC8v2OuxHT58tvx8WlrGoHE8s58KyLS5f+cTygcTrmB2AXbsvEzgzMDMwMzAz8OXJwFxY/vKMxYxkZmBmYGagy0B9Ce9fhf28C8t4chkLylhcvrQdl7q4MDnH4415+aUXLRrEXFjWbOzUOVB5pcTmDtqvBLcuquJasay9ZsCSoN5b+gW5XVG7VIF03l+xu5QMVJWZaez/alud4E7KWWN0AA82dK1lo4FQHVizdNE7xAUZblbpDTnEAlM3t2SRhqWpVhtR7GvzVR1zm8bRACY2oyZPZrQRpco7k9T0MhipJMm6QhlVEXauTYqIIfJAVpS+m9Lzh9IlwdVyZyD0SsMJW/fg4KppHFJ37mjDNjxH249KbgLy+Vimf4RGOWy0jrbzpp/wEf2CLraQwm7TtqFCS44Ul40oRh5iPZrmqAyqZsiuAUubJWYzit2HCZ1OlGh7c8MGbFdtzrvhjS5CnyzpXzl5fkDGOEY653Db/lOI/VQO8DAmRevU8LOLAcLAtuY76+u4a+6qDnb4vGAMAy2oNzfGGMpidD4I405x2Zqizv/yUpYFRS0QYVF1xTihCrJe3FTSB3PY2gCs4W7WfCZYYRDhyWWUuMHY+BKEIvbQ0LblmAbuqQ5b4lFGLlh53QAqawMpAHJESTTL9G/JYX5SsioYP2eoA0rY4ekzhObL/i+Zz+AOz2hA53UHUxpQiHhObMcaHmAVu6GFT9mI9FIVXVTVCHwQt3qpveY03SIUxDU/BnjmW9gyDvZxxEsCXaVh7wxD5JJEG51VDmRXIaxLhJ0+RtQYDECelm/4bHJog8WPBEOagWM8AwHD2MgVkDIiFnjspcHbDaxtwmYbVH4kHiWNxnnkurQJv9FQH5A0XCpa2zQuSoHaaV0Y6C3Lvng2BqhqI4SbLQh9oQ+qZ5yQse6U1oAN9/+fvTfvstw4rn1RU88DZ4myKFm2r/39v4X9t9/yfeut9yyJGkhJbJI9D9VV9fZv74hEntNVVNu+S2JTQFUiEzFHZAIHyMAAcsgAzrYZAm2ZjJghS6gm6T3c21aQlbnFQD3LS/sSW8MwSRiMA2bb2GqjGlP2rDYFwfaqv4nbnkKu4GoVlyqbJKjlNl3p6k1q40185R69E4Pm7WvHS/VYbmEu0dkyYuSOhQM1GpeiWytU1Z7o+mgWzIQood0FXbeu7l+CMmtgK1IEdWMXG/59pku2h7UlLVWrd732Quts9GU6G0ddwky2CmZzDzQzub1Ss1l6KjhrjEJVWNHtcsHZ5xu0vYh5pQfyJg9QaFY9QPYoRdCclqeNXbnheafX8onj0ZxUfiMOb+HgHJ/9xPK3z147ufz0tL6x7MTy9I3lkVg+UX8cK8hHDvwbsX4DEMO6j9i6guQtPNhItghsEdgisEXg+xiBLbH8feyVzaYtAlsEtggoAutJeCWWL14u56dPljmxfKQnlnlaeX5imaeWT5RNJqF8WHUnlS/OeT5JF3OVWKZm7rwnUPYD35MD+/BsX35pYLsvR10u5gcIXftudq6CIuQannWawJRj5iJ8Y8Jy4jD3pMBPC+zIFC/4oWQinsBWJZrGph5Mb1zIr5SxbayLpW1FccuMOyHwuhFm3vW9ueBZrSgtAjQrdbfBul34nckHIZAzl11GMPCndtvNYmziQqNnLSuwp0awPwVJ5QMMbou+2js2Bm3iQjdE9VWQ6AZbVpiHuM2vEZ8E5akoEZ+nQ3YkI2OVOHOlHSvKyzKpeUrcDtMcTxDFUuMpE7iGR+kO79gQU9tkXS1EBGxnc4yYwZZGY1ewZQHeN7gQk/hiMqLEVXun4xq/x7kn35sinakQ0/tKw6mRCH1Lhmm0y6pUBW1mAy+hFCgkO4Ro2ZHWGzE9tE0RlycpjWgmpJX4S1D6bQG6YuYQ+jdnRU0Si8PEEl40ViNlqSfy1i/6q2zpkTJxSc4+NIqQMe/HHcXmHXwiL9VGjXG/41NDB1e7U7a2kB2mVlVydzaH/63b9RXsDeZ3nHbHp/sBKE9M7iaWw9Ux6CgZ6tjEnpa1a91uTPZxozON6NhoY5Jr1Cw85oxYt9+RXciICKjW7WMDWyT1ygV2V2LTD+iefpgb13XzdN06+reh4dD3SLiMt+2iHvEXoduXMRgTmdYx2db9tlobKyxG530ss8jWDXC0w1K0JbyQ4Z2I5fQsb2JV8zKJRTGJmHnMsSdwR8oVfKhqtvk4a1jdSDHr6Xb3Gdtz+6p4QJcxth6TdsdcrPANLyZOFIZtwMqehrV/1NgwP7E8nCr/4Gl9XSNyZ2nBAlp2E5YM0879ZqLEb8SgZBQqLMOYHW2Xb7TOxrI96Q9aMWxYKXIl3es4bgGpbVbzTALhC+96fPE2cClpv5ofaesrya1wjatwsW+NCfTtgHUhM8DA3d7bF1YCYa05HBhTS9u1QypcU1B3u9017aR/4Fvod9ThFUEp/HO8vS8hct/GyQ0b2XhqtyV8jmNL6B4Ct+pXqwWgbMLsgJG9MplyJZ0p53bImngXswprW6Gb28jf5Sl5Zu1xIIoShX9j/JpxGhc7gmbBatfmDslQFWhUzO1BoMbMGcoZNGwqyquv82dK5Pf2LB94L7NVwLqHE5L+BIepy6zm/M76EnVmnwZAi3MvaOMSlu9U8a4i2++3td9xqfjsJpaXhcQyhcTyJz/7x+WTz/jGciWW39OrsEks96uwlzmxLIEYYuFaXRH82dYrSN7WjY1ui8AWgS0CWwS+ZxHYEsvfsw7ZzNkisEVgi0BHYD0JnxPLTyuxrO8s61XYnVi+p+TyjXoV9k5iWRNX+uSyn1TmaeVOLB8KrrcfOcGch7KmC942QPXVF5wQXX5pYLsvR02Sf/jNtf/2YiXEHJ6+VA9VkM3bkznr5XnJWgkiq2UWfJZ/WaSDj1RY5smTWZfFlbDZzllmeDV+im7mzwTJas00DyC7y9gS1tumFmpwFVOomypMLQHdtNuGtg8ZI6nSwCKynaMNYROYSSuMiIahp6zmgtyL+JvNr52HVXyGwR6qNwyb7dxpN32ETwJ2ELvySg+6mDjtyei2GU4nj+TLufb5hlObx3yXq2paZDgcbqwT3sO/gofs6j5CSPtr2ZcLGHEzenp6biYnyjtjbbJhxwIpmvm6T00+D8iJP83iksG2tQ2fpO3oEVPvr/uiZl8R03SGw6eCNsyx1qpn88qaiB62wLuDKUlN1hqyfdl61gF+9qntBG5J+6pAaNmXEajWtnNlmsyWvHZ2UE+Nlac0G2d7ZlRxWL+Etx0zyezPpCD+TN76Bp2WJywyVjmJY9aRmHa5KFpzrAyGlDgHqO3YsZGAWNAOY7FdBmvy9fd6junQtycBnejn2DDbTZtjWV7HG309+Qs9kNnuYVEJGduT4pY/gabmytFyjRTTihGkgwSyEC23a/M1Uhsz3O0dgUUtRGKR7Zlrn3xH3myD2o2j7nZLpIb8kPFYwKYJfSLbsCIx7Rpz7Fz37O6/ltc8ULRMYJY5iJp/XxN0Ihp0LS0CLgNbtgfaih3HBhkXvaVnJZkEV/NNU4IQfI3WLtslQ2HimWiLMLas/cJ27yNuX+o48U5IbP7cRgWMWvZdi9wgabeeUAceueuxCVyJq7jt7AlmhWc8tVwMrRte66ra6Eay0Usrqe35+GZU8cTuPWJ4BIKkwmops5o3rTbJ7mpWBGYKUDdb/z4p5NY37QfA5qVlVCCN2ufZsRmfxNSw5kc345njIEtsqnaq0Wftw2X9Whbvc+yCV0mhqwCjOjKLfaocG22Puh0wz7rR+Il1NNtXAKVy4N6msf97vWrdldeyjZdB1BTbpgb1emQyVWBpxpQW4q3Vq+8imXHRGFGtK1u7690xvOppW5v6rWInpnVkifMKpll22l6XqrTx5bvHwmr5d/nX9u/XK3frmW1YqVv2ahW45t6NePVw9fcqr6kNmW/sWUlWhZe19tUUzf54bHEmV+yvYLtMwzsNa7/f1onEh17Mud+ZJoLO/SrsZXn4vL+x3Inlf3CC+dYHP1luvPepy/H1u2LmG8tKLC/9xLKswBAL18r1mxbNtl5B8ibTBtkisEVgi8AWgXciAlti+Z3ops3ILQJbBP4WI5CTcE7YuZ/+pS40X+iJ5WfLr//9X5Nc9jeWn+lp5cXfWe5vLPO0MsllP7Hc5/ianFFe2a/D1rWdE8rUuQJYJ6n347wllvcj8vbb80VUuHIpNc+ZBDJTqh3gmGxpLBf5aUOgUogxUdasrkvIG+ZmqiCShoBBVZDI13pnbqQVDuo0eoK5aXsywlgLnC7ybVsL2KEUcN1eY7TDIJr41XaOmnCsIWkFpsbXVV7FRcRoS2EKd4RTKoAq3WImNLSWWMjWn00sF4u1dWBQUkuDTNYmNbLrMnrVHgTWpWN2GXsimuQR7XmvduJI8vYTy0hsvpIWJbXe0V0b0GGaa9o7HImWbRR85h8+l1+wGX+JgAa5niaWGx7e9B/t/SV0kl4GDL4InMhFMJAT2M1CeKwI0A5MDFiwLmkPskIYKlG79do7LQFtHZqddhGUNZHawrQV9IxNeyUpAWXPXLW+HVhJDP/Ku8qbqast5GxBoAUpxn3+/YnBVeqbkvBy5d9T1psKfPszS9jto1WL5cnq1GVxdV6PrFlObFjp4etXO1qGiFtmtyJVe4MFZa9Ik3YYul4to2WqAZptDNsEiZhB241ZAnGxT8XWY5TN85rsxaKWil87MTB/S1bdhBNobq6SZijt2arEY58i21Fg6oml1Xa9K2/XLNOId7AL4HbXQ3GkDbqCBzqIxu4PfI7fPh0c/Cb7uFrsTdMx7rrQrtA/x/y/mli2jh0novWqvugbCIYNIt9hHwg15E9LA9z+E/G0YQ7FlUIKPYud23Pic4bTbtFuT8gBH40g2z5UupRjHfeYsuuTSYSYY7APY3vlWo/hbWDrLStcYRp702xi9BeVhO7vCX1zmHlnYrF40zxq28AVFolNNLbcmOPbMkAgg3O4PTW21+KFKDWR43WvwjXjG+N6VgSgDG67G2T9lwhxrC/RH63WEJEDUMet2t4XmXhCs8YMUhdiUAyJSeSzHuJHIzJAzHHdjdQg3gWv0lYF0m3bBNm3eUf/ZAs2wpMlXGOzwVUPOGTauEzHHssbmx4he4y9udqx2mRc6aJtG9Sg7vG+1gIWzopngeEM2Gut9nzYId+l1Fbvsc281rZxkl9WjnGwUgoj4jf1TBS2KRINLYfHmCrS3mYzbRM21jVSfKNqoSapU+wgvdo3C7piNXMhe77OX60J1dpHbUXBc1LTIfOYApMyW7ZKNBQxM+gKGwe41Q5AGvvjsUWaXIG9gm1Pyru/2X6/rSeJDz1xdWKZJ5Y//uwflo9/qsSynlq+9eFPlpsklt//ybIllt820hvdFoEtAlsE/rYisCWW/7b6e/N2i8AWgXcoAr5w8lVDPbGs5PL5ayWWlVD+9b//2/rE8rUDJZaX5cbxwXKN12D7Vdi6cNCVA8llX0jgt2RdKEkDpK8Jqb/rwmS+4HwzdEPyDsryLkft0P1QNtYYrU53DC6LbU9EjUmK0SAi4qg+gZeJh1yqV10dlot99SPkNVPRYmJF29Jb8/SAJUtN6vQDgtJiDYZlAgXwxnp3Mg50azKpBbUNRhocSLSsOna3Y5/Jp5Woy7hyO14ArjIRm3ZMdIiv4wbN+QVTN7pb2ymA4rIxgR4c+Fm+QogZ+VKCDG71CCAxgs0YkZFQYClR2dhbz7Zb7oRvnI0veLk87N95xXAxoPdQ+3cmpcPhGMqQ8cQyPky6aNp2AV0DMAFbak708/hizA960TVun6fHwuoTFJGb1pv2AI92ahlj22zUgEOD7JbP9ryYPywCW4DRkTsQwTVjK+3t1ibjzTGcWAkLsyunt0TWmpp1rYNpPCotVQDqnXYRGQbhvLRtbatwOzER06wD1iGndDVFw3cn7FZut/qHY7bhDQ2lZWUt6taQzV09e3bvyO+NNnhXsKUapVahZk1rH7Wc1k/9JtbHVGOmWIXF4lExJ5SzvdrffVwspSG9gra2zXpsb47jTT9rLXd2UIFp3YKMbco1BjM+PkV3U8JGeySWkTfGE9ioWNXEzuZ3vSIH/YiECC6Jrumyakl7rhhp5knmxLGyCRgDZtB+/JszlPuxDpa18bOgQvWNU2wi2yRV0157tBhUEe++YQdobEo0ruSBL9JtSx9j4Z/7j+1e0N3yZr9pt6zZQnz0KWALcA10d0EfcrME723t/yu8/QKiYrKum3dCTaD95iyzBJkEO3rp9mzBm5YXgxDNSozyRD6wipePY9XG8Dl42m5d6Iaq9STZ01Iqxq2rmBx7K48FgCVxRyZyh30tHGAtnNOFT7xNWDjkA5pN3iNpMTt1nycCNP0kZx7jM9Ou7btabDaraUAZNgtoRQM2995khxTN/hQmcZeMlts14natGQrc6NjtQhPLnTiUQGTNyW3H+A1lUM3A7lPBhjEzfgB32VbiHfN6nM0SVsGXxG2HOxtDo4VMPDuIdTxfIuJK0P7vdRNaleS33T1eZzhtm6AGdVuw1gKWgNB5XSrWdmSGsMhN09dgA1aDKZwDWvLWah1zpWOQrjpX6j/TEstgr1brp/ZRowiGdG2vcV2piWFuTBJXEbfsNWZr/65+YOOQPgyexzzAlTM2r7IHi6XYZoGis7mo06YO70qRNzdpu64Rdu1p6tLD5pvmrkbQauMGNAxev4EL0b6/g/UdbjjS8jdzOKsjfy58K2VaDpmYqLnCffOJ5TO/Cvvjn/5i+cjJ5V8stz/8OyWWlVx+/9PluF+F/d9+YhmLe9zsW7dtbxHYIrBFYIvAuxoB/e5PVwTvqheb3VsEtghsEfgBRoALzhyidfqv7yvz1PKFE8v/tnyup5ZJLvMq7Dsny3L72rLwxPI1vZmI5PKxMspcOPDUpS8kaI/WJcFqoj1UX7DvgWvzcqbvuuC7XM47DPUFmj3eiUnHYMa0l0wU7Fz49syBCHqSAT6XmsjlAjDJDPeqxkUu7i1LtMhzbyB7p59D31MBXeeSMlqADebSq8rL5T3cWPhlZxGNetZvklXK5Kqowo+MUMzbaxs8i2nKz8aik7Zr2hFk+l6tExwh7CkQEsrnepUX9bqXoCeYw4Mzt9GQfBq9I6ulhP7wIuW0XNSeJc2+hnhdt532Q8yuhW54KBsavHVDw5STCF1DWELQ3YnlntyJmXnFI99XRv6QitFaPIYErM0xNptu2LRDA32iZr4JB1/zWMZeMsJKJxq2TdcI1cMWMPrvsdLw8LQFE2M1d2NvAYOoZQWwp3lW0FY41qJupxouUGTtyYAU4ZLVGFibHdhlE/lWLWSb4H5Bjpb2p3GBGqPxmLph6ZVstc7GdT3LBjbHZNe29qB9etOCyFzpVg+EmcEmXPn7WAc4ZCvOpG+sRGWSVejgMEpbhRpwyZh9m0WG9E0svB2fWQ688BDfNVGl7Rrfxl0y1tGwltWeoUed1P1bDqKqXXHb27MxK8Mu5X6HF4+rMdEbkRUqj0tbKCLDJIM6rNOviZGB0kSVQRHndfyMj6YUQaQ1Ufiztcc9o0pyg7p+84q1Mbu27IZh2iNsz8rTVlHvhHRGqN37RMtt39Oze8QlazexHJ14HK93o4IEKDp+3p76K+Nx8gMCLa2fmwN6aRuDbapgm+q74jjHYdZo26/Qk8ESz3YCKVDrbPsuq4tzQq1cbY8hU0wgXqnYmqQUAohjpG1/R5cIq5245Zd++CjEaCNOC2K6p2jnNzZnDHN8oYV4Pqb1uXP6bt7HTe2VLTbfCqNlHtkT3l1c7JcuDNIyeR3AFev5nHPWa3lStC8H8eO80u09itKPuvbVbVa9tKLanuM7o+akbkijyyrUtC0lo9VCEapCzPji2cWscQVuXgkbcohBCU9MVu7Zv1gDrpht3SRwsE3WtdHGTfBB2z6+EaE9itXny6QYNumapQ3nJLHH9CT8zzbnsT0TW50Ut1rGLMsMp922Ubdda90MTVdCBF49lszuoJXcFNHZ0mBpa1ZdJtxbTWQwrU7E2j3qP7M5s1tabMAqSh+j2zPXvd+JdO0Tzuw5lw8MKfjXHrWXkQtyjlBLf9PW3ditdJZf5A2lbvm51okPwef6x/uIlM/25TZde1vwltL2tBeSvzZnB5pwrWe6qV9syw5uYtkRvsLf5dZB//bK8flonT55e88cMjFR07dXJZY/UmLZyeW/U2L5IyWW9bTyLZ5Y/h8llldrpzPLtzd+o9wisEVgi8AWge9tBHSu/Obl5ffW2s2wLQJbBLYI/A1FwBcPvohQgkuJ5YPpieXP/y+eWK7EspLKJJf5xjJJZZLLvA67r0P6gvU7T+SvuEAja3EVar3U3e0UXzpczbRL/K5v+QKtL5Z2nQbasdjBwNMs+C8keNOrQb/70lwdSNKCi78ULtvpzb6X/dB8AnjCBRkUb6dlSOB9sZ96uUjS1JJF4BsQIKxTAirLQh7W9GDydmDj7EGEdmcwpGGYSQeiCINpaNfWM8mnueKCmMcwUrqYUMRjPmEoD1H2AdaJ34W+KXV4fGM5OFGhPj5eDvgY+aF2nvPXy9nLp8v5yyfLxasX5hivxZbc9AHKVvuwcxTr1sp17GYNnqVtHOhC9HbX8yBpnYwHvmt1cUCRzdo+kC/EhcnPA9l+cKZyTv8iKf2NzrwO2xawGgaNSSsRtY0Y2Xa4LkRTZKJVGP2D6oLYmT7xBrouPu3s8SRG069ot0qdkEjQUoPN7YGkITupYkoaQCehrUrgWoIcYoDubDRdEKgu9SY0qYXKNoualBWrbVIbjLFi6hqS4AXJP6ARw9mU4YfoAkdKWmWCRDRH9RkkWtBRzQBq7bGitrmQO5SEIMef1jKYLpVVWOGu0iQKo9rGbHqr9DZn13uaW0XVUIUS/yO1ZAtMa+2rxq8RmoW1pBnbMZ2Tgvs86xO+HC8Yf9J6qLb2Q2/LivPz81Holb7Rw/uotg3DXnUSNu90geDZz0G0t6n9ywADKGqcqHh0ZSbAbyzlqfkjpMeIxYjeY918wZd14zhj2cNf0ai9+ppjDj4OfyWrRmWsycB3e2fMRF1oypEZNNptaFGGtLCqaDVJ1ysEpj6CtYCpFkPrMW8LQC4IFUAGV9ufF5lEmA4dioFZWkbzuQaDnNRrFWLzoUX/RaG6cKnMbxkiyGgK5RTeaGgBvVPs8QctewddiS46V4XsNnXQ6cHSbGNHu8RQ7YztwVsErXcHPgHhhzQK1zgA0zIoC+8BXECqjO9ELzeD5Fwq51V1Y5n226PjE5VrLoc+F9Bv6/GRduk6x5IwpByc6jxcZXnF24NOl3P91p6pvtD+npsP2pCix0aBGHX7ccD+QS353UXAsd3HhkEw4X1wskGDP2TqDxpD0Nqv6B/EkKiwdEK3x03DwWEDhLaF9rQYN22bENoZ0cJaeNEHLMKmVT2OBYY1oxiQWXxz3RRdtynWD7AQjnkzCjySa+AFH6TVDkzQ3jZZhFlMmoKyADF0rXd8DfHKopbJ136hr4wHJdwqceVC07zMmLkN8862mHyM2QHaAJHuAGfx5loBoUcSHOYqUEvyflHi5jFuvOCrBAnQRpF6I+2iqCow6WvG1ZidfWhGR+8seUdY6Zw4JvTgAqaSc1uUCgMSGJs7C14X5xAQAmhzTE7N+UJfvx2enCwnN27odcI3dKmhX0mdr1/oGEJ9dnqqY0mOJ/4N1djw76jkI7NL1K09yPZurFaDaLXt8zEgsJWuaSxLHF33zTiHPj7qGCn7D9RejnT9ccR3dg+W1y9eLmcvXrieb9XFdkdAfrR8AbxY8ww0oLF79UzXMS+SXb8DzFjYYdoT+G5u9jX4/rT9d4XuMk8dGTFRMy4vTywvy0d6DTaJZV6H7SeW9bQyyeX/M4llj8bLzNtgWwS2CGwR2CLwjkZA5y7jCuQddWEze4vAFoEtAj/MCOSCQev5G8s8saynlT/nVdiqj071xDKJZb0O+2a9Cvua6jyxnAu6t7rEupKoLluq6kiH/HImk16OavYfTi1n913lkolJh4SM9TSRhOeAjJxwukCHgwv5cyabmIzQhOeFJjZ98adk4mu9uvnMSWXBwandkwXYwAV1X655WzBmHNLO1IanOJxUVvLR0gQXI69MP8wVuXgkaDo1gN+LGt1u8+ckYbwRpWzvxXTiGuLwDZKJrKkznRFOw1pJCQud1jSEA52icY5O/oljKWud7RZiHFOma5SYPbl1X+We60Mmeq5dWw5Uzk5fLK++/dPy8uGfltMn3+rJgX6mWZPHw5dYux9vTLN5+IkBGBjTgsAILW2biQE4ZomN8WakJVrxWy++Yfvhico114dKhB9pkoeaZPKFJr0vZP+iye6ezmKSyjIyQCKUNYZSYeNUg7APgq2JE8Gkvyc37ID9Y1wBt4jiRFi2OwTecjhKGQD8KTo2g0FaFtcWAGOOZSAN71XJgAyalm60QPt1JCMvyIhpqnDHpoZZrA/B6MBPx2HIDs/aoUEU1Grax8AQUHapZowglzrxBbfGYMiFqBfzl5AB1raWkGVsgiIig6TkQrlf4DVQAprPlkSs0S2HegWjqziawNRFo4BN3pR9IpQAY1TbRoHMPsmg2bF24G0bhCEafdHGGIxASYTMdmbcmKTpBAc3l2GjaLybCNm7C3QxjuMHx2U2teJGFO173JBywP6ntjJTYjxcXmuC+LUmiqkPpuMHbxRgf/TEMVI0OMgTHaruOKCOxclldFFkROJMTIRUcW0nbCEEVy6whIHaG1UjO5J9vBKyRfYNK/Ad6HjpJBt+lq/4C+zUfp66jq86XspnJE05sLIvfYMFLDbZ9rT5jqxtK7ARsWr0UohtaOS8OU5Knmg6bqa0L4iPxHBPaxtkptgmFHF24SYCbSPPdch8jERC6GI16/Sz6CHW0vGVai0IpUZelto0ZG1D1hSDpTjCWxHbOZaaoFWotg0ZRIO3dXTs2LYmrWwrDrG4KisEgya+pB5kLbAczuZunzlyCGha1TvHR8OLs/YJTBDVYGELCiSnNhpjIFsXIXsTHRmR7L8pZ8uxJtWPXK7fvL1cv3lnuXHrtibOby4+H9A5wQGJlDoQ8Ht68fTxsjx9tFw8e7ycPn+2vHrxfDklqaLfW7TVyIhd0tn29TeTh0G2MoFoG4fhBrRvcYJ4AzYHJ2v8UxfMtWh87siPthb65VCrSBIg4KoiDzqdVsZQUbYHwC1dPNEChHYJ6U4PWEJKZ20b3fqo3Z4lISyWpf/bnmJqOV3D2qjS1Zt2NOIsc5y0mC46V3Ols2yh6lLAaSy29Iw7pOxY32hDC2MlM1X3mYj9jyz9qd/aHkz0vlS2AkfCLGU4XjIGcxEJrAVdxextg7pbtCFcCI1t/ft6mgSbOC6EONV6LihpVoU3RSLGxLUAbFdzrbqPA0lk1W41Ejr0d+tNIcOPHZQZtSq7bRkEwAFHpVQJCFyFkCdxqoZ0t7smRQ4EITU9bCzDbtqiWWUbHdlSAB3yuWZz0Y527c6d5dZ77ylB9/5yck3n8bpxlXL+8vny8jnl2fJC9YFuVPHbhySln1xmN7WyYeju/trHUfs2rApPXK7+aoOp2ynIiEmpwPbYjw+6WV3Hwus6Nl6/dcvHRwGWg+vXfT31/Jtvl+fffrs8UznS7z7vgDpW4Qo1UlRXLCU+lk16gbHYnLYtoKx3aC8jmIm7vcPUwB9k/bYRaecdGTFR07dzYvnbZ6+XhypP6hvLn9R3lkks3yCxrO8sX55YbulVXxH+2dYrSPYEbZtbBLYIbBHYIvCuREC/9dOv/bti9WbnFoEtAlsE/gYisJ6E1zeW9dTyuV59ncRyvQp7TiyPJ5bzneWcuHNxV8sqsCFrPYhWUFpXMAlcl6n7DFdeOL5B+EMAOA6rIz0Z0z+t1IYpvomXJiIIqVbUzBF4YleTTWcCeCICXCeVNfFJMvT0QollJ5d5UjWJ0Qttu9uqLzoRgjXoAudiPE+TpRw6sXyqCQuSy5oI0MzFIQVbMKpL8XPJbz1MviBci0kEp87SmPjTUGq4ISMWJlcNtf2GQBvhjrB5gsrwVQlMYdB6Rx62aebFsZYY46wUBVnGU0qK6cXh8XLz/sejHN++vRze1ISyJk5OXzxZnn75+fL0i8+XF19/qQmSJEqYMLFIr2Jx7MH+NTaY6CeY8BfbK262TaY4CgJTN4x6hmNxTxQ5fsL7SUlsP7q+XByrHOnJByWyeNqKWhlxTVA989PWedJa0wb1ZDrysEsAmlnKBSmu+ANuP2SP4J5MhAUfPCGqJFr7J+QFCSRwJilebVi0+GDt7nMsvC0oQsIkSOiKy9uNjgGKu4RYptbg2HDsvMEECbagC42rJCwyn+hcCx+SxN56tHLsxRdui0CBAZmsj2x0ej9RbXlwlM7ictVyerLOZGDEZJtgRq9iaPmSEdnCWnZZVLLbLxsEvuRYWa8wRdJbd08ER1KshTR5hPJD242hhjZ8SLIS2wMfNrRsth3/ARduLw7xE6nxyXjbiK/hB8vSsiNj9cGxKFrTeMxhm/xgf/eY1NZkWOgiE9mJVWq2TQqLbcnk8vA1Xvs46F2l5DZtbvjJvujEqp5qPDzh6cZjvQHhRE8h6WkeJV5fvXq1vHz5Ug82vvI+2E/ycHw91KSxa9rSR39Q225sQhlGy7c+BngCXHD+Mk7an3aiDHVk8LKWGSyZyHO/dS0yxmB0Ix1A4k9imYMqFuLroY4xByrUPNWJv8BfvnxhX1/ydgfd3EJS+UjHHSaW2Vfin8RadulATRWDWYVi9JddCZNRHk+ici2440RgrCdjDN8IH6uqVFcbXuHH74Q5tWKxnqqRzZ8FyX7GmAq141Rk2W85RsKMfsLFfqUGMP3Tz0Z3DaUJRcNSVTZYI2ta5uP1BN5tpr92YdrCHnRpGf3Lzq3FcaCutsyurdjbvtspo6SjaJAw5MkvZNHHVhUkHF4UlXIxscM9YhvFIpFMWFxbfjbSBGlqAU0F0gu6GJnQee2Dlmg8Hgw0bsgWiKPGmRg5nyLt8Vpv/Eg5WW7fe2+5c//95fb9D5brd+4uR7fvuBzq6UJ1ogvnSufffjXKi8ePludPHruc6glm7j6ytY5Jxj122kaJIEZebJRXBYDCrmbbKHklZjAS5+LxJg2HPEWtNxNRz9GhT/rtAfAwDhmzGY8RLQb+3X+0+uYVxq371/iWGtfDET9skPhjmRuFDk88KVpUWtkgAeKlx2XX4Yb4zaVjGNttoImamjq/A7HLY1fjgOMavIa2Ye2AasdVWIaM6aAxnawR0nJVt37331BqbNEXY5SVMHwO8bqvBMXNOD6moFs2ul9ta6LaMRkm2/EhzTpNKQI0gMm+qQ0cgDEI++g2qDiXVpF5A4zGuK0tv7HZdkAnv7Tp84KcAcdO37QgXK4ZRGcBEqYaE3oZtkXBak4TiNqhq/hFTNljQWVs8bcAULFEKm23CMpubOb4YCkGwzzrCY7DBj61rxgCBmeHX6Ue8wQtq4lJbKT2UnSQkLCjsH+dKqH8muONruFuffDBcv/TT11u6HrjXDeoXDx/spzphpUnjx7pnpWU/I5qX5fsJGi1P0tNa0/AHGqpLjsK6XjTLvuwLbwVrTIXN1m6f6jxDzA1V4vtx00dE+/cv6/j43tOjh8qyXygm3HONJYfffGly0PVR7qmJKl8fECCOTHMrdHWZNm0LlvarDGOmmg4DaCpGnlVvcN0FdEPAv62EWlnHRkxUdO/+4llkstPdZ/Ux5/940Ji+ZOf/aPGrb6vrG8sk1w+vn5XzDytrmtO9TLLTp99R+hnW7+DzDK31RaBLQJbBLYIvFsR0HlTnxG9W4Zv1m4R2CKwReCHHoH1JPyqxLKeWPY3lg/yxPJfMrGs4I/Xyu11hO3+W7lqqAs0h0A+zxMdwPiJdSiYsGBmggtj/rnoB9dw1UxwqKdVC6/khJ9+0yT+hV7ReH58czlTIvGchCKX7EowanbRskTuSZAOOVMDbpdtXPR1Upl6ec1Trc90p/wzvTZZiQ/RH2oiwNMIomVCwpMqyEW48CxulxKRBKI6WLabfm1l0qInKxANdTh6YhjqhtFCRalhs1ClhXjpz3Ily1CtCC2T48ZpO/ENO2vwTNH4yQHF7VyJ5dsffLrc1oXyrQ9+vJzcveek8pESzKfPHy+Pfvv/LY9/+/8uz/74W9+FTzKexHIWC0NqbU+VbYj+QMtub0Cf7cQBuyKDurwxSX/TE7YkxNU7mhCn3w9u3FkOKdc1+X1ybTl2OVnO9bTy68ff6inrb5YzTVY5qUzil+Rym6rBMNq2aZhEtw978I1tF9Mpsgqw7cVWXv1J/EmSaRuZrqFFzvCzFNvt4SEEoShjjDYrPYgsk8QAZv+kqyQVoog825vYrbYKJ+mWU7NmVtNKjCYOkUjVqK6HEUiSfmQzCZzJ+kzaIyYBGlwGGVzGNma2rSdk0TESyxpa9lmrMqtkRYIjpyZ1x7sDUaqGD8DhctjUooZm+EtbxZONxZyoR777VXiW5qEdS2hlaRw2eTybYKLCl2i2T8SAeFHZV9cYAD+o4ATQMgyzDOgHfznk/b3HZJi8HrJsSo2DEtdkmUSNTJMJ3zGAlGMm8Wmn3dSqn3akPrquV+fyWsubN9S+rgTzNZXrYjxaXjx5qoTTk+X506dKtmpaWfshxxA/ycs48jY1E+BikXZ7Lx3WZSMEU+2C7mASO+nH/wSOCkYALKoJmFupg5riCwl0w0H6AM1FDzNWOQurRAjHGD21hJ9H11TjK2940O/T86fy0wm2J765JX5ypCV9l6nHlmoVgqGJpevR5vjEhlauTaCV/qfR5P5p340zvSiKeegxa/xGlPHQ0DAtymqBgAUeCYgM2aNAOxEk+olE+1Vo5sRy6CAUH8QIcUmF+N5vyti124Z0qLRYQJrfta6IvUmCfyrELf60TwbbfZMoFh0OTJWlNjmtyAgB1Fl8bDFxtKODxevy17IHPDZAYzbtXB6TJdJjfAiYpbUtFfmib9mpxcjxE8H1E+1+Rp4Wc4qwznBqIl2/5voExrk+hXGhc6vb732oc4EPlzvvf6Q3mPD7qqeVeSpPN43oCCop/N7plbUPHzixfPHwq+XFo4cZ90ow7ySWxcHezNh3XGVA27l2aflT8bGdDSqDGSf8sUn/OebI5phXxXystPR49H4sJvNLcRLLAgATnfHaQK4XgGWsx0mBu4oFFUeYRA/LaLhDgwfuwioqgxjKJl5o3VFty0QkHIv1aGVxjZa+boYoBI61KO2fuozfVsuwDnR5S7xuWAammwpQxLjuGOF7oVKbeGKyKK80npvSaiM/0m0TMt0nHE90XIWcc4qcX0imAJYQQy0k48VKtV111MVOQxMP9iGjmh/ysWOt7GpVLJoeCIvkVGzbVgRic8epQiqw/qxPdSNxIYJGbYsbWLhU6FoBGQfaRlfHDLR5ZwFiKj5DfRAJoPmAO87wN3kpsx4bnnHiPRtcnLE+Yo5Pjj21BEYm4tSyuthJ02OlaJowx5occ06Vaj3V1QOJ5dsff7K8/9PPlg8++2y5eVuJZd5+oPL6yaPl8TffpHz7jX5Hdb3BOYKUJbmsXRS7ohzPppbaGAjMhqa2XbYVq3OeQT0YjSva4oUyJU9ax4/D5da9e8tdJcXvva8bb+7dXw5v310OdPPNuc51vvnNb5dvfvsb18edWNaVFtdLfkOLJOYWmFJoS3dX+5j1OCm68i0c+5S7ctatHaYV/ANsvW1E2nVHRkzU9O+aWL5Yvn12pqLE8isllpVQ7sTy7Q/yxPINnljeEssdyq3eIrBFYIvAFoEpAjp3qrOtCbg1twhsEdgisEXgrx+B9YJhSyz/9XvjOyzgIm1cx1ZDP62e6KhO9ERH0wi289NbzLxi1RfyqvmOFUmKQyY3b+hp2tvv6UL+/eVAr272VL0SjCSYmSXwxI44manxxAP8/dNOjX260HdSWXTnzzWR8egbJSG/dgLyQgkPvit8wXd5Res5xuJvky0EbcKzxOQVa2DhmmYQaiKNBfQ62YFNKWDM0zolHPmZbBIX/xPOXJPqbrq2DS0PrVqQp4qJPz/1rbid6W5rXu91+8OfLHdUHyuxTFL5WK+qe/Xs0fLo8//H5dkfPtfkCJM8JIWIIbalIBq7SiWbWrxVNFIt300z+TAz2LIdByLFBlcTiUnTKLmsiZxr9z5Q+dB1J3sYJ2cv9Bq9r75cXj74w/Lq4dfqS/pThX6VDgpyW50bZVfiH/xKkWmshD4CMjFXfoNQsWxYEYyxLKp3JoeAWTGxCxmkkb2ytX2OMTzIt0ytXAPMMk+iAbE81VYTktWG4p1xIYncnpgrNjszfGXyFzKtOimsBzVKIbgSLpBjUEJaZnjDD0HLQH5PKjPBHN6yUBWt/v4xGmqklfTgx4Ybg8lbTAJ3ssHxtG6hLEyrsjt6PBLtC5Ot7ZJtimEDhnBAjg8bWIbMPQuRGyvTWukKahlAtUgAMtxmu3qxVBti5EQ0bEC8VZQPpp6iFeMio9bWI57W1zXo9fXUEQvORR3qY7QUk1g+uX1Lk6z3luv37y3HeoLnUAlXXqHL2xCePvh6efo15YFfS+9jB0/z+hircTRedcnxVmMCBfahdEk+oLx2u+2UT9oZIOOQ6vFT8VhdrOebxO9XWbvmGFQ3glSNRHiQJZIUtbMA1cKNLPk1UPL81nLt7l0/zXmsCeVDEunyVXe1LM8ePLCf+Hpx+kq+KJFuP2tiXFJKonVGOPJHazQcBsNpZenjSJPTP00CbvzWTQIzNsPRx2gkZp8kji1dtdurTDAOawV1xEeNtsqyKoYde+9jOi5YkoC2ywzlv9tSVrpHVLQ9jdYY1k5n68p17CmBM9UlINDYOrxwW9uiLe8twccz4ZBN8YI8DTrHVW3khG5QeL9p2TFf9ELHFNYrLfFPCYz13CfpP2u2rsEbYYWI7IyBtR0kAlWaHn3a4MlBfsW5sezoJjeT6Xdf9U0llLtwE0U/+XuucXxxrjeBqFzojSDL04cq37p+pRsqXqq8ePZkec0Ty1ZY/W5tWJJezjkV26tJ2cq6x5C3bDc9kng7QlpRdxEqpKOmoUJnug6edfoAAWWblQ1JJoeu498Yi0YkONj5G4ZiG1xZGgwo46kxqhGoJeQTU8GMXldNWPRmHauZzMAWp7qb6LM9lQWdx1LHx3IkgLrbLSB+pd/AdvyoWayH9lA4Rv2OvJbb+zY2OTZa+Vghfh2OE9M9eUO0NZYtQ/Gqm5uNkOubjoS3XAzjvzqU2rZA6EbsQHR8tRKv6N/IlE7baargtI4cG7K6D9Cl7WTk1qJGqRy60IkpIHo8maOY5nGIlPCDLPkAWUpwMNo2f9EUDrKdfkN5Oe3zHOE7di2daLnPJcPtEo2NiLVorVxr2wu6V9G6vtAxRgCONTzDe7qcqBwvdz7+0fL+z36mxPLPlFi+5aQyyeXXjx8uj/T7+fibB64PlFjmyd8jBSrJZc4TYiExI36OoX2ObvRTiB+2hc4t8ZJYThEqCzLUGvTmk49lO7/efXvYLT2tfO+DD12u66nlQ84BlFw+c2JZSeXPSSx/vhzpOlLvgViOdd2hqyydC8h+DfJETsqw8ZIFO/aX7rddeFFeIWel/bMEK+k73rosdt/lkiMjJuotsfxdkdpwWwS2CGwR2CLwX4mArnt9avJf4dlotwhsEdgisEXgLxCB9YJhSyz/BcL9P1aRS1mtaeintZNGPUFD7UUd2z+9ax/rIo8kpCbzSVr4CbEb+Z7V8R29fuzDT5cTnqx9/0cSkaeVnVj2RTvjQ0WXiWqshZ/3kSUiucjG2XKqp25e/On3y8s/fbG8UoL57PUrPe16qpvkmXZNKoGJUBYsjjs9mYHxgtUk8+wTcE9miKfPLKCrLAhQw8F5omGqzVdMfupLfDzV0fCOV/QxMScZXsW+CC7F2KGmV9DxJ1riyivF9RJwvQLzZLnz0U9VPnN9cvc9J5WP7txWYvnh8vBX//fy6Nf/W6/E/rWSJEpHuyiG2FWvMkRH93FMj38oPtR3V49U8AVcJqrB2zLHFBNZOoa442U0sgmHJ6iYINQTgrc++rGKnrb++MfLEQktJXgO9V3IUz318PT3v16e/u7XTi47oTwllpGG6F3xmkjUsOg4Ey0IMKUn2oDFakswSfyQP8jsEiaEwewCyItkKhT2lRgy54uMPO0X8iKMjZJqWwUkQWM5FhvZFi+gLRChJyObQcimN4WJJQg4NiAzm8NvSLyYUbplI7ReST8usaKvOjFsgXLEsYBAuPBEVLSo781fMoTq8SNqy71sDCEnhQby8DRWDlvZtuPRN/aHYkZvJ5exmbFIjdJ+Uso+SQF9w4JsXIG3x2X0B9m6HQeSaJIHPZyNY8vLG4DIhtbqtCq1Id+hL+QMwyYoZ5gBoW3/h1Bw4rF9XZve6ubQRWTJhaSTve6jkJsmr9LNsYSE8q2PPlL5UMnl+/rm4C3dBKTJYk22PtZrIR9/8cXy6Pdf+A0RBzq28uQy30709xN3Esvo06JYtg8cqecyO04XskdWV9o/fHR0KhnspLKPU3x/XfYqQeaiCWsnmRm32CI9R36tbo9rDGGxBtFmOvuabry5qSeWbn6oG1rk66H8PFCymcQyfj754veu+b57fNU33vXb1E8sJfmLzCzuhlrhx7qEokdTo1wLlW3Fqdpd2/8EwTH0+HQsItnHNzVJIjhxYkskDYGu6Gma2Cjh/COvl6LrzcaUSoPRmb4RsRD2WXE2XBTt58xjOciuJdstXWImXNO8Ue8R7W2KnJERQbZB4u2aVyMEO2Lbxo6b/eIgoTFFO6y9b6EiNqc/OpZW7b5CeI9tLMkNE+qLyh7A7bjbTOLoBmwSvcYDN/xk6Gqg5bO/wsEbALLgpFraNETy2J9e+7W0auuV9dfvfbTcuK99V/W19z9ern+QGtGvlCw+VdL4tW7WOtObQM71lpdzxrY+NXH4Sm8hePnUuFf6JirfWuYcCoUZ5yiuImHod1wEii1VC84yu+dtrfAm4wYHer/J2OzfE9fEaRRFwd8911tN4JFgxw4bvC9qf7eyyU7MlHFULB0+IN0HiIfNvyccN0QXPxLz5oXIpgjbvycWWiv75Dbc4sp/sBYyJEW3lUC62mfl4SgjcD/yhggaGNzijJ+YtN0oWRyEq0DjA3JRUbESKrGbyFHjzcigzRiLzMlm06yrEVfrFl2EFEHZw5bhkWZbQBW6pbtPRMjvPDhkU4h/4p21x4KMo7aYWlF5oSFcJ5WRa1kCt73hDLnX6FTBfs5haER/8UgmJL02Tobhi4ajbTGfaWoFkoVKbcuWFOQEgz9aLBidbGgRUIf7EAFmnGJPgRwFM0IIA8egjIP0WWQhrnksToDepgbfNg1BQoBjZRvU4HzdRTqSVL6Wa45Pfrx88LOfu5BYJqk8EssP/rQ8onz1lc8V/EppaUxyGfHyR8rxzfs+hpdO95Ha3n+p9ReaxOFIduhqJOd/2IojVcFjv9gWXd6MhP155wj1bX0m4N6HH7ncUGL5QK/GJrHMja5ff/65EsufL1//msTyKyWVSSzrGW2OORpRTizTF9LjpevapCpzJkia9fOAm7WslH2sasxuvXLswn94W2tE3s43R0ZM1Fti+e1itlFtEdgisEVgi8Cfj4DOUThF2pYtAlsEtghsEfg+RiAH6C2x/H3sm0tt0tUzF2z+aa1JgDHZ4lkAkPx7NS6o6WcnlTXxQn2kZOE1vZLRRZOfN378s+X6j1Q++okmFkTjiRlpIqGsC/kUteuV1pn9YFJBgpn0MRz82fLy6z8tz774zfL8y98sL3SH/JmeMnutcqbkMpMpXXwBqpVriRgTFdDgpyeZsUGA9kdtfBtnFkwkZZYLohUuAk8aQMi/6j4dcWJ5JGU1QVKTRFgSm1J38s8TFp4dkiB8nfT0hAs1KXM9T7e8UnKZbyve+ehneoIg5Zq+sXikp5XzxPK3y8Nf/oeSy/+h7yz/ckosK/Eun4+csCHhEpvbvvhg7XqL+ZETyySXiRuJ5bMzO2r77Ee1bL/b8hCEVvEzQFw60yyKellJq5Pl7o/+brnz45+4PuK1nfpW24ESy6/0GuzHn/9yefKb/9SNA0po8dRgFwlsPV2XSse3fXC80D4bkA26ySV8FWdtQIpMswCu/nL/li9jH/DEovpCdMTLYyoCxzo2RF7mCpkUQzfxpkFLatiWUtrMpJqPsVY0gD2mtE2NPbZDcGrrRpaFlpzC9diyY6axMPMlscx2y48M6ycODoTwRARzxJ/4ApOpjB/iAiEyHK/QQStQYiqnba/JMB5yGPwfn0xpsRCHnmAJ7nEnWuojxQWdvtEBfSrnZz6IlI6MOZFav2OCfRHlClwvbRcyY3FjprpkTZARa0vWqjQMn6ANrjDWuQoytOyoyvaO2NP/xYr50PQkMxvmKXzTuQZXzhMJQuh4qW0ZyFGZE8s33tN3WX/0yXLnk0+W62r7zRJKtvLE8sPf/G55+Nvf6pX6v9VTvHqakcSynnh0gqeTyuoDp20lOF0mzWW/dUkfhzVKDpbU/GssA9Ni27QCgjR/HkH69QFk5XxP9MpqyrGP8ef67rOTZLLl/LUSzUoyw8UxiuQyY2RdouVCOxhyeTKb13je+uRjfWdPb85wYvn2skg+Pj76Xfmq7y0f6OlO3oCRG1tiWZIyq3y31EGp7Vap7tGUujm6ljFaxKeamCGBtvcb9R99zf5FYp3+g2KWeCYaJ5fpa6HHuClZqrJYjzipRdcyjPSYLzqqooEwGgOzzxKADner7WlbwxbZLUtaEFDL3G7YpfVEaLMnGXEgfqIeC+2LCNfxHqnNZp8FQpbjChpeOZH9fo0pKAiJOzUy0OHxTNtCArMMKxG/EO4HE5g1diFPhsaWrEfsB69ohk7FVwaimindAABAAElEQVSTWO79FVwIkLXqZhL9tWLFWc65Pi9yWzfr3f5QN2lx057OsY71feVj1a+1nzz/Rq+61rnRS/2mklA+1/fDqQ/PXurzMy9dnwn2WuP99cvnGu4a71JMyZJja9uB6bhaLqQuyo43m81tq4mDx4ydQII5znT88LFdNeeKTrSLjpsR+1X1JJgvah/3fq59Xg7kpg+dPNrWUtzxbd3eHippiFq00SksfGUbFpmvVh4fWNr8tjgrehV6aKIaWQK0ANcQhIY6qCCaLNKKpjdclwAql9rGmF7QbSsEcLsR1KGPjRz/MUWwkpVjWOhXiWlBwnEaf0xuskQ26meOtQ3ZvDVsQ4hxaSDDdEWcXb76xDq1gsaEdbzROM8NF+m/8TuI3BKW2qq0ijyspq/dX8i0YGisYHVQNPa3ajbc/5DVbwnWIw91ffxgP0X+sCcuosAqYpwVVzyjBxkQ2GbzaNW8/PSVXsutfQTb/TshZPgR4V71sdZ9xnb7ULYmbvW7LB3mLXX4Y70ojDgTtO/0zUgsi/N0ub6cHlxTfU3nC58uH/z875cPVW7qDUnnegPCxZOHfmL54Vd/XLrkyV99q1iK8kppbEFv4ubzSY65PibjkpTmB9G2YCM0XHfARsydXE7m2zCBQaWInXYnlTmm1DPHflUy354nsXz/Q/3+v/f+cnhHb3tQcvlM5xlf//pXKr92OTp/uRzrOENymbc8Obncx5uEq4IpZXsL+vcXswjRrLEyVKZfEXusVyL26N79zcvi9l1ezTHdEsvfFakNt0Vgi8AWgS0C/5UI6DxZZynbskVgi8AWgS0C39MI+BJRk1IvdE3FkxNPl1//+78tn//7v6revrH81+y0/vHsOvMMumzjys0TrcIUEpwnHjC4GWgWCSAu6n0XvSbGjzVxf113hF/XBfx1nqr55LPl2ic/Xa7pu8CnL5QIfqmiWjOeGhskLNTWxbymbFRINqtGqAsTO0yhMN1xrsnSb5bnX/1B5Y9qP9SY0qsenWyAX5MQMoraRYYzKWE7tWp7hRYep2iNym1oUBz14m1hgw7O0mFaUUeB5XsCqiaxgXsSquiQbJWyKTEFIpiVSWbLC7Ro4ZHnYuCJ5VeaqnFiWUnl2x//3MnlE3037KQTy3rVJUllkssklo+UnD3iLnwlS/ppU+p58mb/VAofnCCHTj6kyCgHx5GzhQRpuLaG0062n+DJSZNcJml1S5M7tz/8xOVYSWU/saxX054+fbw8+fJ3esr6t5oU56kHxgDJZfV9B0ayLBftNNCvkuGq+DmuxJYeCj5V+nPY27aWMCo3LY9VeN1HwqSGqBiMJi5qsBSYzWGqNjIpSC17ipgKaxhXjOqML+lgMhO7B50JkT5koqZUGc6qPLMt1m+iyMNci9OKunm7hn+ecIYAnG0CqS3bimALSmy1Np1JjHMrttiIVdds/LAVctFB6sU8JZs4aHHiXXD2n4QmE842Qx3uZJDooE6/x0REDblg7ZCABY/0bLOeunQArcPIAZoaO9JnZaaJ/Ck+QMXSesE4pgL72KDaNrBaiezTiL3nVychzVM19tpmrZCPGI570QVOxyHBfHwWnLdLXNeroW8pyXrrg/fV1kSrjtlHKhd6GvLxl18uj778gwuvh87Tyjp+6LjMa6/5kAHHWfuFTtqT/dFjtMdS+xsIbopeC9ZSNPh9bFBmScKVYNJrua9p4veajmnXbt1aXuvJqDMdH1y/1LfYlTzjZiLNPOs4VU8tV+wwBclJKku+BvN1ybml7yvaVyWZuZEFfy94YvkPf1ieqFDznXdlr+OvJ5TZd22hTY/VazehCbVWXfrbR3CmbzgbKlQcIzg2dALANmuVMKbfGNOWXPzZH+jHlKBFO8kfxx5xxqjo8/EbmBb0t1xraAHYluCZdfyOigiLhjwLoEdbVsRFLrIL3nYFNA4DtdnQsiebllF8rmSPa60CrpFDrIYENbQRfNqgGg8iY0xAt1UN4iL0D0hkJPpz295bXuIo3chxiZbWFatW4W71CnoMo1bDxy83kljOU3kmhipE1GUsZ0a8k+U1+4q+rXxH51S3Ve58/Jleh603f2g8H+qtA6+eP9Wr3f+o19n/wedKF0okU7TT6FxAaWm/vUTnTJw3+WaNV7q/j9u+oioRXj3qMdWWue4N/DBn1dUvGbu4KsIp2ND6WAQftD5nlD+qTzhf1JOF19/7QPv/9eVc+znl7AWFp6/1lLV845yAfZJjUJZ1LHSrMajHCuAJdSj8e4F1wpsWe/QHefd/ZGdtMcbN0GoXbwRBJOoIsnDkW+v6ozqEDLndgL0NgsrtqhzHGv8dU/HFaoyoIlifd0SsKJADfloyqgWQLLPGyrSHPUjXhrdLWsuRuMQxMrAVP0E33GZabeBQsJQr2ZJYoMEY7ZWPjSLkr5O41OYdNpWsYot+1oIbVl5qw5LCnFDIULsi4vAhy4SlY7IJcFBu+DgJX8ei9A/GIgYdkrKISotEeenaHcQGRQzhS88GPCiLOVdEiOthVaLT9xLEGPBSx7YYIjmTqG7bb4ijLIllCeaK6vRA5+ZKKr9Scvnuj36yfPj3v3C5pbcjnT/RjSu6BjvVDSyPOrH84I+6cYVXSp/rBdpce+BHzhcYh97vqyZMxMwmedCyCbX+ZDeJZeiPdHzgfMbXcmJxfEylNttokJAcT2jrOKkIcKTIE8sfLPc/+nhNLN/VW0t0bbomln+1PPiVrpXOXi0nuh491nWpE8uSnKeWpcVGStn+MsGxZV6M2mFdKdyaeGe+q5XtUv0QttaIvJ03c0w9W1C/IS9eb99YfrsIblRbBLYIbBHYInBZBLbE8mVR2WBbBLYIbBH4XkSgLxlIFGpiaySW/1WJ5X/7byWW+zqsJQ83G1GAxnOJetXS3/Dax5tjktcSJtA+yzu33T5R8/RNFl3g+0ofoGBG9uQGOC53axKgWJwYUztJCxLLSS6faKLzpi7eKTfe+2g50WubTz7Wt4Df+5EmOx8vLx+pPH6iyU49IaabDg40NpJgzlRAvq8rfZotiHlJKjOd8urZ4+X5w2+X53oN9qtnTzUBofHFBARPsJXd1PjSkxFMChi1ujW27Re+qUEfM6nBwprEj33TRie3oLFs1T15k4mm8FWgIEriSGBPpsCnMhZ0skEtGpdCVpSzVURcRPO0kl7S5tfSkVS+/QnJ5Z/pe8XvKbF828nlUyWWv+0nln//y3wvTJOx3IXveCgT4yc/Jd1PItfkTdsyjIppw6JqpCpX2SCuDpYENBhZxBVZjCDmtujBC31b+6ZeRXfz3vuu/Y3la0ok6WklXtvJhPgzvU6PJ614OrILgj3ZhALJnOMDyDZYpzD0o4r7xLjq0ZIhUIwbcjLGDW9h1Frcz3Yk2yjq8RF8+2xhIZKzSRr0BC+TfMJridhIyD5TMA0udEEWE0TTNogPbkuYYMiLr+IRHKmuEeNSDdssYurip4G8Lsgai3c4+mpAym5ti9+xdx28t9Vs8tSTLuzaUzSZsdqEuDkOIsp+U7aWgt7H26j2FTRyuzdbB2L3F8eBeAhh0yTEYwYI/x0ohENTuiEecqHR/0BBNLZlBYTIpUJIrwVDvo8tiMCOJmpF2i5xltnmrMoizWxa2d6ShbA+VkFlXdJuc4XIzT8HyzXd1HHj7h0do5XA1Svpj5RsPVZiyq+H/krfS3T5WsdobvzRFLOOs07oSJ+eKfaxL+NcihnzuKg1vuQpRIikP9BRx5Cm1RFUvxm8flvK9QSx3l6gcnzzrl9bfUuvrr6pJ4xOv/nTcqo3VbjWMf/0xfPl1YsXToiRWI6/iYPjaWejG4Ou3bqpY45e/X1PvvJ9RSWuD+oby0/0Leku505WK8mmiXF+azi+WzbmEvw4iSJD2OY74sJ4ce0VCMjLBtoCxTah1PaxWFy9P0Ed+UAQYkGpGDP155sR0CmYh4sHing5yOqfxTj/OIWvb2CwDSEp/vxGAuLV4tAhB9vQPnzXBpDRy6XH4xZeBLAWXaEM6dU419pBWqhJOoKWj2ItVGj05sTXza6LvNWXAVNsRABt9oN44LhJsmuQFbvojO+sx/mD2uf6PeIpOp649cCA2DEeKt2whmEcOqInIHmEPYrz2HfUzliovmheic8SAKPxtfaTM/2GXly7udz99BejHOhNIInY4fKCJM8Dvdr9q98vLx490H7Lk7561wlJZfnAU3gUvYLETyrzRDDnT8Qi/ktftcuzNsS+9Aa0WGbr8KfbgWgLinnJduiB6xgoX858znikNwnotfw//uly+1PdgKjzx7OnT1X0mm6+Ay0/Xjz6ennx8Gv5oKcJNf59c4tEEsssskHNbLU9IjBNkRi79omP+WVQi4mVTV9etAqBG58xhH4BtXIFfgRSfd3wid8Celu1xzhjxLxaUaeyMy03IMZPYVuPEI4ButSvLadrDPNvZst0HX3u9IKjp48T1lBqQNsn1fhqn8ooHyewXbQDZ/o6vglhuXq7COMdXputAwu82Y9Um45EYmhss9HYWXHEP06aBPfiGt7atia1sVF/5aHR1gmEBkv5EdoBiqxJLnLmpdmBdd/SjtSSHWWGmt+6oNJS4qB0GbRQBtl1jJTNzUNdjDS7jJBIVsQptiYVsYgc9zn2pkNQLVMT+cjlXP1Mr92nfqWkMk8sU9/Vm4Y+/MU/LB/94h8XJ5Z5I4LKqfbNhzpvf/iVihLLR7o5S+8ZUZI25wy+SUn9x/kD48QL9aTbtmtcUIPi96jHTB+He38lRnIpdE0vRqeBqXVM8U040qjUtl+FTWL5vY8+0fXoB8shiWWVJJZ/6aRyEssvlxOeWOaV2ObkOMM+tf5Cxfh1bXcwuhZvV9tQAS7Dhq+59uuVYx/zQ9ue4/U2vs0xpWfy+6HfvS2x/Dbh22i2CGwR2CKwReCKCOhceZyiXEGygbcIbBHYIrBF4K8TAS4ZKHNi+ZkTyv+dxHJfYOPLGxcj03XYjOOC8KplTHbuEZjjSnl7xO/gZkeEmgt0T3Sq3ZMurvXT6k8aU4PjTxfPaeN02lzcM7HhWhfzucgjaaEnxPT0yW0lEEksH3+kpPKHP1mO7n+8PNM3uJ49eKAnah4sekxVE4V6ReP5c02gaPKTBIbKIU+q6o+n4+h37hpnop9E4yu9wvHFs2fLcxIMesIsiSZwGLMWkqd855ia2QqeXGPxhIRo86q1mkTXTIz9CwnkpjuTvjMx8ApST27UhBiJQsR6Yk0yfSqCftqCO2olA5wn7I3dX4Wnn1zLPLUYtXR/RKxkSKemVDXJo8lYTSTfUmL5Fk8tf/Lz5ZomSa45sXxbIX24fDs9sXzspHJN8sho5PqJZQn2aykroZBX/TlU9of5c2xPXMJnyyqO2Iht0FD3tr0Xoe2HQeVcPI67bL+uV+hd1yuwryuZdVKvuz0+Plb+6qVuFni4PNcTEDx15aQykVQfJIbRZYGIpZO0ZIS6GVurj2IXtjHKIWw7xUHnib9ljIlX/IFa/zadWBUdk1wkF6hRnbhEr4mzyoSYHtGGLuMjMmxCkWMP3+lk33E4EVhj0HGSrYwZ9gGjsMECYhu++InyGt+JD/6plG0wwivQ8Kkn6uKD7JLM+LfSuAUfGvXvZegX3MbHDmKADMeia3iww4WmaIFVgb0Fg6J4/7C9sRnDJSFyqN2Gz1ZpTMQwizQfNhS2argGm5qmBWSxiq8CjW32ARkaE42zzfAglP9mFsyCYlqEGRS7TWZzy04RR0QJsCz2hfSvj0Fqlzs1FqIEvn0fbEvZgEQPY9XYzYp+xUDba2J8ki6j0aNt/NS4Obl+bbl+47rKjeVE5fg6iWUldvUU75NvH6U8fJQkK8dj3nwgpcfq8GPJoN89njzWtV9oG7/4wzDvY2XgsAFcxd32klDWd9edWCapfP2Oy8nd95U00+vyf/ITPZH5yfLqD79V+Z1r3lLxUsd+ColgErtWo9p9yvHMcSAkRGlZrsnXG3ry+abKtZv6pvvJdSWwlciWr091k9Mz3ez0VOVMSXRl2+QXvz9KwCle7B/Id4wRhqMuWhUQLSPBrA1r1Srf4iXeISVe3q8FQKZlI1NLj2lke/SgA0HSz59lyKZEOONW3Si0cPhLXFXMIuH+3VOdsQbaPWOTEW3dwuMjC6+W7/gFp64pnAlqFSnZQA4KXavZdbDrmt/w4Z/B0Rn6+AbYsoPKcUUQb4rQONcixOeiQ2k3W4f1iaaP8/DyG87vee/zPmbBCD/x0z9Loo0KYsP5Q24Leq34vNbYOiMRS9wVO4dHMmZbkO9hoRWf2yCWPrZINircjxDQX9QqGQcZa9gwL5DAyU17JELO2Geu317u/fR/Lff+TuWn/5zXRvsJ31fL02+V3PnTb5ZvVZ4/+kpJZF7rWkWS6FNJsM8kb7ADGxwP4PLHpdqqEpoOsuHZwDT7YJr4Taz3l/gQKPHNP0kBpW2cXD5ebuoTGfd/8b+W+3//z3qDwv3l9cOHy5mOP68ffrM8efDl8uQrfQv9wRd+6vpYHUxRF9j2shA3pL3tkGugyxj3K/RyDr70v8aRCcID6WwrzLB4GQhiBVx/qq0TvWp4HAiIbBgJrfdY65AUcAhju+Wp9hgRzv6EzHSWXf6YDblgSn7aEpWTtdSij2/GWpe8hF2LtaeptsVoFXOIgQpURZY6dPCCzzEiItCT85AJhz9yhP2GzxPgw5lea37m5DJvmMg5ufmE934kmI9T3r/Ua2IiUo6LVPnYZbCE2TZiUG5QTe2pWb4LLTvxpW/wg8XjVuKy7wqpf3wfNTRs19rNqT32eSOwtpYEDaVmdUQRhK6qQTl2boDKcSnRFy14xBW9BzLbBqb22JZASOJf9YXR2CNi4c/1+9zH9jn2IjNvr9lmIfL8+vGGIWoSyjyt7MTyp3/npPJH//BPy627emJZN/dS9hPLh0os87RyXimdazOSypxn2y75jSvY3iv7UL9nBtexiX4a/Se+dZ8iarEXYVwf7T+xnG/SK7Gsm9Pe01uSSC7ffP/DJJZ1M+65jqdf/YrE8n/miWXd6OzEsq5Ffd0kqdzEgu1Zuq7NAZUBODS20zBILCtq5XdrRTRr1Vci9uje/c01Im/nyxxT+nxLLL9d3DaqLQJbBLYIbBH47gjoHEVnHNuyRWCLwBaBLQLfwwhweKa8Y4nlvWu6+UdmD/U9jPmfN6n9Se9kYoJJklzw1yQFP636d8JNSPxOSQS40GfxnKQwXOB7MoLJT23zbWWSyiSXb5JY/vDvlhMnlj9anvzpTy5P//RHverwiZ6meSrmZ5ro1Lf/nFSup8XQL7lOumpC2Fpk15le6fhKk6infCNQ3wb0JJTtjc09B4DVttmmpo3NLJB7ggwdTcQkF0itqIXyZHQm5jOJ6QkOwTPhNcmUQJsgHMx5Yi+TbcihzIu3YQCjf/TZz9INLbDgTG0ZPAfwuhPLflo5yeVrehW2E8t6Gu/02fzE8q9qgoTEMnGNAvxAavtGu+NAnblm+UTHmgVOWxSA1giIZWkDagiUTrQUSyaDMvHTCaxjPSF5pKTSob6nSLlQv54qoXz6XK+9fMWNBkxCpRAqy7BCDLKG0lhKvCUrG2Va+qWtVF0wj1/EYKdtNbPw0IQn8HVyEzmWVfJ6LIywlAjHJTtGyU7sUG31qgkrT46mxh2MUamJWE+kirhtc418YNa/O9lm26wYEojg0KKKCLI4krILduiBZkI7ekwUbiR4yeRpxbTkjCSMZQSHrLmgjcWmUmtyrmWa0iZ5VTE1uVCtCwn1h56QmqibRHVdWrpgBjcu/rJlehoidbwcC21YZ0mbeOO7yWO7cNaCMa0OA7qNKG0gYreslgJngYXY4KGHCiIpcDaRKddVwFZSJJFrcyJsxHIdm7JIOOtDJzrEQOHbxcd6U8DxtRPXJFsP9e3WA022vnz23DfvvHj6XAOVm310/OWJZfWjE1NlJmpxgLoTKNaGsRrLHYjoZ63FtiZOecOF9n2SZSe39Irqu0os39MbGD5wYvmekstJLP9ueanksosTy09k42MnlrHpUHdBEfv0aybpowxDlD9WAvlEr9u/pnKsNyTIeSeV+Zbzi+fPl5dV/EpgJdE58CFvuCAxSVID9Yb96P0ILcZE3ejDTixTuxNY6Z9NEvNO8Kl2TFyz0uLBJyrLo5Z0VcTWcYYmYOPqgK1+AlELvOLjGAOYOguIdA82UEzBOPFgXP3GfzObplalxKqEb5Vdz6S0IfdIdT1jiVj4/XtZbUMkN3wZJy3bQwc64mFREGJk7WMlEEj2aypiwH5GSTSghs0FHvmd42rkZP8JAd+7Rn7e7pEEtVUK7NrKTJJurPGNgcFHlyi8uGuh0eLxo7bt0XZEoRdstsol+axzK43bc91UdnDjznLvs392Uvm+EsuvOR/SE76v9YTvs2//uDx+8DsV7S9PHjip7KfvOLeSTPc5trWdHhixB40uWjk22vb+LLRr4FAU0rbJoYwtU2C4lpaXOjDWlj7qc/lzIX/w6ZYSy/d+rkT5z/9Zr8W+t7z6Vm+k+Yby9fLsmy/13egvVf9Br9lV0kf7O6/adbJKuoatZSdaGco+a1QdPP2QvmgrbI7ikO6AaxpX2io3aKm9+tf6kBdUZFiCDxrEqGzADhSYNjYUkyuf54S8opMx35Yg07qLn3GALMNBWYrW9gPextgEY2nZ0hVVuhA1AaFm26CC2zZzG8wxwvESOvGMT/mdAcfxI0lObuw0XElCEpwe74Vz7CTW+z615PVvSLuA1Wj2YUk1/PaFWIDQAkSS3WZVnjbaNaTEZd9V6Mexp2K6K2+WW/0iYYGuOAA2p2xKXyNdWouMmt+Q5urYYVT8wgvpKN8syjwSsx68S3SkxG/s0p8YLNNaKwoic+y6z0QU+bHDfYOZWpoXQUkq51qun1am5ollnlb++Bf/kCeWSSzr00SnepOAn1jWW0V4Ytn7qM4XnFiu/dRHUfyJNjx1y9taDfvxQxjbZuNBBgYN9Cmss7glZD7BoTGncXeqJ6791LLq23pK+T19gue+nli+yRPLul46vPuejqfHTih/RWL5l3q7k75Bf6Kk8kk9sZxvRGs8jw5IxFtv1/YFo2tpywzSxopqTMVhRTSr6kuBE/6H1Vwj8nZ+zTHl+L4llt8ubhvVFoEtAlsEtgh8dwR0Pt6nbN9NuGG3CGwR2CKwReAvHQEuGSjvRmLZFziXXNPNFz6XoP/SQf0f62t/qDOVoVqOeSqiavupn1cmYtLuy92asKiLXy6oIyff4yKpzDcAeZXhbSWVb/HKY73i8KQSy4f3PvK3LB//4cvl8R+/XM6eP1ouTvVK7NPHmgHRk8ua1Pd0gCf2M+mNxkz66jJSNp1rwoJvKp8pqUzbMzcywpMy4o6lshqYTxHihye7CmubhTNaExKeqGbWAjyVV+ATIcsR3KhQYRWE3mKyzZOHbMGr0hNmgDyZTEMLulkskwkftdtqJ5eLwhOOalsLdkgmTyw7sazvkPIKbJ5YpiSxfMevw+5XYX/7q//tbyzzOjruvqeO7uh0DGwJ9sXm2I5tsY95HYyPl1nb5wgq7sbjduwVk3yinRkx1tmShySveGJQr77liS4X9POk4Kleb0tRknlMGovTTzwjDbvAQJ/IWK4NKZtStYFrvVovmDYYuS2l54Jx3BOnUmS89HTyNUGRftGYb2eWsqUnJCtKsTEKaTXJp0aeVs5EGJNhiXtqx17U1CywMz5YLMX624bgiYoVTHywZ9yJSzriEfanWK5Vdv+1zhofwtFvmXAsP8Rr37DBdrR+amBYiSYEB2c7BE3fCSY4q/yZofiAq3jBBuxJHXohzFckJoYGfyIHDPKtYwWZwWpLgeUiWzRDpVrm02DAZ2KGzRm7eLW2PTlrenEjx86JQv8eS6Jd+2zVkeOYzRkr+sgJEERJ5nysgCjHBrSvcmy0QLGdyOML+psuCSR4DLHsyHeyU9sHSuYe6k0B3NRxoAlWEsoU0p1np6ej6GArRlmo2n0s3vYRY6OSWGEFvmiNPpUYmG1teRMZboveT2GiTzfLkFg+vHlfSTPdJHPvw+W+JrFJLN/VE8sv9bTyCyWWX/xRCWa9evOVvrn8Ut9cPtO3Y4+UZEpiWT2FDbKVWDC+sigW8vFIvuZGljwhzWv5mYB+LV8pp6ck0OMj8hIt2RpzTYsHPv5YDzj0rH61xu5DpHRyGcKm5dhGv/p1vmqv4wdlUNUvgQVKJ+NRUCKcY4c2WIyvpgi8abPSF+YRMOMq4xoi6DyuZL+Ps/bDVOVT7LtqvFqj5UY3etYF6Vn6OEgNtLcb3375GCjgKidxvQzSPcM+A5X3RfWj+9sOIwiF4KKJaDh2nVgWwv4L7+NYPfGJDB/vzCj5NYjRY70Sm/Fdsu0UOtBXetHNJnUtNqOcb5vaN9M1KbUIQrP2u33V/nqu3/0LlQO9Kv7+Z//i5PL9n/6L9gc9wf/okV4XrTd+KLH87JvfL09VTp8+8CtdSSxzDmBzbRv2SZcLq5g/bGJbxLabyMkXj1FgdXyEwOO7YoOMSIIvYyk1mF4aU0c1Xn+vcqFy65OfLnd/psTyz/7Jr8J/rlfUv9BbbZ5//dXy8qG+F63y4lsllkn6yBc/hS0nkOTjkWxrl9CmPKbeyEK99qmfkhUOK3xMwy+Iq8/iNF6bwgKDj+xeZ4xABR3xsRDL8o0IZRA3L9oOERhO34ILuSuPP7U6MtlWj0eoaUxuszj38R5rXVa7UqglSAGbPdqmdeHR15K6r22aYjp+H0WDj/mPjByrUEpc1xp9FU3IhQNvbo+d/n0CBiNVnxNQw4Q2IxBrKW44vr3/rfzpo9brY75lr5ySFimSz81RKAzXaruPQWWTE9visT22xk6Zp8cYMhNkcBi+LsFp2430KFjrECnnsZ1cjh/N61GEkYlZxUcmMEyz76ldZprJflh/fCrXpToxxwj28faY7W5jDz7mZpvY4OujUsAtG1yJcdwhodyFxPLHf/+L5eOf/6ISy18nsawE8yNeha1P2ZBg5tX7RzqfP9b3inkNNm86IX7sq30ub1tkQ+xirVJ0QPs30SS2HKgWnHI9V0XFvqHC78nrC73dSRp5aplr0ff8jWUllt+vV2HrieWRWP7lf/rJZRLL15RYphwr8NzA0r/RRDLd3aM8+lnjix0oUFkYkDbwLUtj4NGCw3/jyxqRtwuEI1YxZXxuieW3i9tGtUVgi8AWgS0C3x0BnXfvndV9N/2G3SKwRWCLwBaBv1gEuGSgfP8Ty764ueIaz7iK2RUkf7GI/p9Q1P5Q13SGe8kTHYJR42dPeBkZYqv3xEVdEHtyQG1qnod9rYkTar7ZOT+x3InlIyWWH335++XhF1+45una85cPVXjl6vM1sawpjUw9doJEBtgGa7TlnlgRkLOALpm8U5KCCQYBeQUcExTQMrmhFIonOOxIrbg4ZdKqE3z23gGAAKXM7FDPiwgMkmTVnqCRnoBIlgpPjEYRb7OoCV1/QwwBNS2eCVLrks2qsdvfJzOHLqI1ufz6QM/q+FXYSirrqWUnlv0q7CmxrKQyr8N++sUvnVDuxHImkkjUli/7dmrbk2CZg3MMBZiMj79xFPcULaNrol6IUCeqNR0vOXhCJDXpo+TV+QFPKfE8ANRZPJWliah+bWfEhoLJKE90WQ6TR46MGCM3NtJNGdEOIdItvmxS2zJtCTAVEXrCSwgm1pyU8owbIwJ+xkv5SH84bgme+cv2CZyYSDq8ocTMnshjrHhEebz1q+PBM2apsT3ywh2bsR1E2V2Se4zYVqGhgSsy1M+CWKZl57mLls84R633M9XAkUOJ99gZmhwT4JA4bKgCOTqBR2nhJDjumCP7h2jx3bIU9KHbMiJHTQR57deOq02fdjIDXjMWFTazf+ftA6ITegzpISr2mRd/4BUjvLG5NGobPYdH2htVGPZJCqTejQn2UxQ9CeJpxguI1c54ynGmxws6wa39Ff+R4UleWcXx58yEZY9Y2KR/ZI3bYIokUcJILfjinqehxX2q2litDJX89oFt70PWH2qOQnp8ULISI8cRYUriyEEV1dbfNiBdRTKo6Vvk9uQ89vCkOmhTFCnt+EPShduIdExTrY8fLwe33ldy+X0llj9a3tMkNuWuJoRJKD+n8NSynpBKYvmRnljWzUgHvKJbI1V1AhEv4wW6USz5NiSaPcFvmxV/xayLn34WKa+/tDfg+MO3SkQjq8cbcMa/WOyTKm1lgc9HQanHokzcxxSeVOY7t1jD8X1+la2PpLI1dmfvopstS3zIIrnMUlbioWSZ075gXx/r9e5Z2S4L1aGMN/cr8tGvcqC+tR3YIkG0cZixasdbEXXrpe428LEUUNsZ+yGj7TLo0mDM44N/e1XTXhf0s8VKdBLNyHMcBKLGryTy4j39aHJqlmEOfZgeARw/qaGXVMXAT+VX3L1foktKOxESGxCoQofTqk0rpW39U+xsRm0L7950DbP/Ycq/+gwb0W3B9JuwiZHs0M0fF0c3lIjVq9xv3lvu/+xfnFymfq5XRj/7+oHLcyVfXzz8UonYL3RK9Y0Ty34tLftHdg3X0qLFo8z6WVk/0LKN2ucpGidO9ACXXSRo+7hFupq+8EIFjfzA+sYECwLVGW3w8D11Ct9Wv/XJZ8vdn/7Tcvezf9L33u8sT3mzjb7Z+lTl9PEfRzlU8oek1RHnCpLm8zrZQ5863DKBWp/cVGJZ56PymTHSr2f2zW8cz+STj2v0GTzUcjjnkO6pdKdxJllXuGJakPyzQo4QMoQY0bYNgpPgNtz7IWN1XXo/c6zYH0Xv/ZJ2E7rOeHdiWXJQh9hWOz957LGOORTibEGqvZ3xaA+lw70hBCbzNgrkwJ9jSNsAHFmSlh0xG4GMtuMgupCKB/rCukZ/A9Toz8y4O9AtI3zurBq/bK7ouu1t7/PYgweKAbaqeOxiJHKoJlXs3+5rdYT9Nk1ox++g+o3fsMjCaG1ILvT0JuOriw0y3j1Qhto62wU3i4+7SJC+HEs4l4hlwGxkKNVufulhDAlvvzkuVEfD4pEFq20rf2wL4rCXRfyIE0P6XvFUG2rs4JccXxN/qNGZV5cz/hkV0HJ++npKLN/70adKKv+9y+3bt5xU5lXYr/nGMk8rVznghi/to3zXPfuo3pAiw2WN9OZJaGpMtI+Yig34VW3DWYUqIcc/aOZSNPB535AQas4peGqZcvt+P7GsV2HPTyzrZrOvfvlLJZWTWD6pxPJ1HVt8M470jVdhS4/3K9sTq6TSi6OOAbVgNYtB2lhRjSl+HPkbX9aIvF0g5pj2GOUGxe0by28Xv41qi8AWgS0CWwQuj4DOq3xGcTl2g24R2CKwRWCLwF8xAlwyUJjwfely/vr7+Y1lX9xccY03X/hcQfJXjPF/T3X7RN1tS5KDXPwzQcHSF3GDqIih4Ore0y6+OE5C2cll4U4qsXxbd4XzKuwklj9dSCw//OL3yyOVh7//3fL62TfLGYnlF0ksMwnBtAM1uj2BQKsu6qkH3CbIEiVbDzTp7/oa38+8sRxcu66kw5leqfxqOXt1qidgTzV5zESHLOTJuwi2LBKWfk5aF6dHemXqsb7HyfdHmWiREOVV+OZmnpD2t+L0pPShX+EsGtGj2xNIkulJG56m1ncYKbxm9kjfET5WOdBTc569Y9JMtLkjvyZseaW3+CjnsvWcJwZtc54bIB4sPNnn7xJ2YtlPLH+2XFecT+4osazvno0nln/5H8sTEsvi5Wllar4zyYQhtQLmBBp22R+9Fhd/DmWrplMySSN9HgWidU3/q3gCkZkpkk0U+Xqu76phM/bz5F++k61Y03dmy4SPPuiqJ5SYTFY/0XeKB/WFnkS6eKnXor966qeWPcmkPqZejvR0s57UWig8VankuozWcNC48/f70K8JwGM9mYg/mjDy5K6YLR8ZjClm6GTbhb7NeqFvOvON1vbhohJo2MtMHhNzDBPbAbu8sBjwWty2Z0YZZqgQ7B+Z+MyeZP8VQ098CXfBE6KKtwZIavkiw8u38ESDdNpm1Y7zOk6I9Zns9ziRTXDVVB27iScO5bz6Mzp4zbFjRp8q5iRDz3nqn7EnXj/RyTevFUNeTewxjV1akI2/3hccO8boK4VOsWTMqoDPZKdkyZdjvWqZb2gzvpDHtzQZ9/00LGPcSS3Huvf3xBZ7PGFcNTYxRqn5BrD7VzV+so+/1j6OXMad+859HVnuT/tAr0yL0KZg1Q3GeT9eI3vP2VeJBWOOfb2Kn/IV3L4hR7Hs/TlJKvpL+1v1DzXjzDjVjCli1GP1Qn10wTd/VfMmBr+NQbVfzaz96oBjg+T1yMAL97b3S/o4xxmONR6v6BLPhffLOnbRTyWBxCRPKRNHeGhfsE/RR0wqc/xRoZYQj0HHVnrZJzy+FZujen029QWxqrHl3ENNlMvw2E7fYI/eRuCxo/ErAxQIvZaa/fr63eXwlp4muv2BjmMfLXf06sq7+i7iLT1h9EpPQr10+YOTyqfPH+uV/7wK+5mOM/S7vrWs44fjrVi/Vklf21gNd55YVmzY7/z63fQpY9Lj5yVjiLckKFF1qAjIdr4PSj/7RoOy0+NAx16OOacqfIqBhPGJ4nhiWvZjjSGPG8VDA5QjN+P0Qv1IUeeqUMtGYsBvEvs4x1PqRFcVe7N6XPIpMkThUl/RX6rZzjFD45D9XDROiqGTYzxjEsWMkZKRY5mkyj/eCqFvSiwX+qSEAuZ9x09siw+DcxwUPwtyaqm8SG+6DjYRB7C21MYEYFWboVbI8pjEPsEiZ62bljhk7Iqh+pB+5O0Xjgk1Yziami1K2dL+wG+4j1+Kf36n9Bsw/NZ5h2iIk22nVj9HvvZLxoyMRX505DcNS7kJ5VAfHue3x0kx9lP1I8eEs5f6XIfK2YsX5QEqVilSo0Ve80+M+QeowvGXvvYr6vX69gN+N52EvbUcKbF8+0e/WO78+BeuXz55rGTyt3pa+RvdePFA5wBKxD75o/R+qzGmmy+U6CHZc64sKzfbnanm6f0TvwZfOjRe3ceyAbv5DU+MctzxuOyxiX0aSP4tI+baN/g987FHx3yORfpOiccVY8sxx02cY5zKD5+j8dYSbia5plfgq77x/o/1OuzPfLPc4bWb9uWZXoP9Qj69fvZAr/l+oC+mPFgO2Oe5oUR+sQ9xTKFv3cfRgib1HcdTnWOo5hxg3CCmfj6nT2Sbf/8T/NHvib9i7/2GPuU8SfW073FOmd8x+al4cUMa8YOWV+1TON6QuCOxTe1er33R9nDsVdxIIhLf/HbpvPHlc50PP1PRZwiQm+Fg/vyG9nEW2/gt17FNcSf+PpZLR0YYMUe2imtVHHv4vVft8x/GhM6D1EmVoOfYp03p9bELnxDDogb7cJoQpc1Y7cV7BZtN17VAgL13mVwr8SU+nI9qU7FI7DQeFbv8luT3iOPta/Xza8at4sb5NJ9xYN/rGy9ws+3DgD7PoGY/z77P+bSGhc9NJAc9avPbTsHcTixfcDyoWFFzfosczpd8NOJ3cRyVylHxzwv7yDi+6WZK7yv6neXYdUifSafHFkbl4Kw+1e8OY45jgMYN+yw3rfFb3scvfj/yW8LviI7dstyFY4iWNQ61n9JH/DZzHFOhVpB9LPXxlN8W9pHWKzFS7fLi7HB5qTveKHf0KumPP/ts+Ujl1q2bSSzrRi8nlscTy3+sJ5ZzkygR6H2PferCcSAW+J6+9nVH6cZ/hkg8kd/4xPGbuzPYd+Vvjk2KAb+dgvl3Cw77ic9cj+aGNVLbPLF8X+cTvA77xpxY1pjrpPJXv/zP5ZrOIXhauRPLjL5+5T5jG1OoWbJ2U23im/aMMwizVpRazb/Ls0PyN7Qxx/Ft3J5jyr61PbH8NlHbaLYIbBHYIrBF4M9FQNe9dRb15yg3/BaBLQJbBLYI/IUjwCUDhcn+dyCx3NHZvQrcuYDcQzXHO1n3BV3X7UT7SN3t8Uu7Q5wLeM2E+ML6tS7mmWqh9quw+cZyJ5Y/+FTJZSWWlTB4+MXvnFh+9PvfJ7H8gieWH2qYvPBFPE+fJZGaCQZs4Kc+JVbW/IEmQphU00SeypGSykf6Nt/R7fvLscrpC3138NkzJSKeSfQzDUFN1r16RiZqTHQwqcfEA5MQ1DxpffPeXdl9z5NPF/rW78WpJvo0EflSk8OU/5+98+xz40jydMH79vQUqZndndvd7/8hbl+vG7Mjetu+4f09T2QVGqRISWd+N6IWkIKJBqoKWZGRkVnxDzPhujUMn/VmG7tlJ343GbmBbuGPNTujbifHttrtrIlnf5PrlgGrAxDQ8IoRxYNjC4PBaIkRcRUGxXE2G9Nnag1LGvyBkoPkQ8DMGqsCWMa4A7BsSmxTYdd6RixTY3l4lV0CKl89+/ds8BZgGX4GuIyBR0BZ+4wGPQ1aYdDRwAXvHLMaVOWeBDwD7MnByMLI6mSIPmt41NCl4RjeSFN4PKXP04n9hsfUdKzkxrcwe8WgAThiFK+0IVscADRElzHELhmf2TVpL2/OGLebsLNpkJJVVUCnKlFMNSgMxaYDLdfF2rIp9SWlBals661W1qB2s63XLXFvwXMtbfYFQ5TA1pJUuguAqSDAlQX3saT1GMxvAdBq6wtjXUi3cpeEPxntwpTkh/HazI/4C7nNBZTuJcOip8LvZMzDANxowoduVqUWefA7+grPkWPnU5CGRi4cgLKGNWQBBuc8z2vgyu/RMAxrGsEKBwT7E73FeFjjdyR/L4zjjKmAyRyD65T5MUHe7KUy2kReG/Au+sExa4/VuC2joRV8SnwbpHrY8GzO2Et2V56pDerIepPrSNWmBn6ARwmj6qTfp/YnaVtpSxhpC2ePZIDk1hV0XuEEwbVsaxrrdfjQYM+8q9LXCrLqPU4Hg2w2oDY3fAjwDmcQDecbQJ6jCkNr0ihx+aTbwugenAqGaZBMhmD+xOhYYl5E2nbGy7mhw0yVNvExyZdS4jjJJg2fMBbScD+jTrG1gIfZZDhg/AQ/BYmJhoFZgu71uC/mAPOh1AFYRX/NqW88Dx0wDr2gDlqphzg/bth//B8dID9tGx3GrtcLEhBFedAHgBPGZZbXD7b1dsMQz31WqTfsWNdb8JP7izlvWlp0qmMjjW8Yo3wOh4mc89UFAiMaxRvtHjozUZyv/Er2gf+DNcET5hb8UH5m8GLG3LOtMv+rDfUo87V1kJW7J/DgOKt2j8CZD7ifA+4NngyussXgOtrlZICuoJ4stA59PkKO0O/zNBemXHcK30NPpVHmd+qhF7xfa7wLOKHAw8g+JoXw+Np7xblJnYWwSLUa68GmLjPHew7RogJ84/GUdWCWjVkLqshJq9XMWk1khONLgHWczLGMj3pSPc/cWaAfF8xXa8gv0ZGrfD0y9b+yquQZvSzTQrswWAXIJUChg4jrUx2dUWPM6FyST1vGrHCuUjZSBH0Ch2IQYlI5IAkMUVhX8hGeLoeuv6yNgi/I2FrgJBSIvVDQ7BMv39rmQxtTx79/9PJ3OCw/Le6G9+nT/MP8nE/mW/q19BvpCiGvnplzJ3pfZe1VZ9YarlWArBJjWmY8XSxirYIfqbf+Hvz33gDQ1up6dKj1uZ2TrrGuU8ValXcrmoprPLJXa7OfQEZXeGO4vus8pmxFRgXGtcx411rIcUuQm3FQ3pkz6iJB0cnVVbR+FjqO/gRP4k5jpHPG5j1WB4UeKoe+qXf3sgZUYdxL9W5E9pebfHbwIGvs3492wdyex7waIGNXyNcF8gYQC7C85F6XOGIskTsdcObTRbR15LXNfqHVhY/KqzpeuWD81Vkz1oa0tiiXjEAuB457cJW1JelHgGJ4VWOfU2P9kOK3rL16w+8z53V0iPnIuNTZm9W7EvOd+ykxjqWGe5fjrL5/At2Bj42kJ7inuSnvw/kQWZ1escFCJyG7GbRCB8zZO82dW+oXOmbfVMUNrl9Xf/g76vJcpgVSZ8h9ELxRLjfjwTyLEVHHcU7sK+FN2luy5jAGZfR/oR8n6MeYN67P8KgK6NmCp02ojk5zr7UAFGSrFOBpEbVaQR/V1BfoDUHhBCoLji+QlfNsCk0uzxkOQUx6FDxHeuiXOxQBSp15qpB7qNALrAGuT+7p0v4hrcaclKaww+v+QWJvqnPOlH2W2R/WRoHnei+i+PlN/wtuFuNuP/yIHiWe+W/+2rzlDf871rAjDYbn8TbR7d7INWTBgBnVLfjueuQepIH8hI5m78GbuNdJrm9tG/As9irIm3x0nU57K+5XGVbWaF0HnOPSkv1h4dDk+igo2or9Cfoc/VHifYnxSj3N+886voJP8srnh5gT7rdYm92Th96wjbPCzSuYkXMt3jteobuUJ9YOBpxW/ZU/P8Tay/4IxxRB8pKtOow+2q5hzGou6QyB7kLWXUfC+YC1z+cZSdmOX4qxogfp/+A6szdf85GZ0JXIMXOu4rMLf6tDYw+u80ToT/QPghvZnhDc4XieDScQbefoKDt++DA7fvQwa6PzrK+8ojTFnIjlm/MP2fUZdJ6A5apPVehW5XfzUmfIgyDX/fbmuUO59f515or9A+fFmQjSOvZT7qtmMQ6hv1njzVjifirI32KiFHtvtHrMFUsHCSzvHVFj+QvA8rnRys9S1HJthXzhqMbuOJxx3U8n1wb6okxzI3mvUt/yGwu5UcA3f6c38REnbX1VHPLJ+cUBXv9Lx25O+g2+iTH+37ivbZ46t3bA8v8G83aH7jiw48COAzsOfJUD7KViF/XVA3Zf7Diw48COAzsO/K04kB7DNGZizQj6VUcsb7Np6+lu+8Fn6+Pto7/x9/ldbZbT9Hjrp8mgxdAFE4oH/XS7RvAE6sdBGr4LUHnJ3wlYPsjaGPYiYllg+eg+wPJxApVzcHk+xDAhsAyVMG5Vy9a1ShFj0auc+S71YffM+5gMCDrcY9TVSIOBJoCfw7tZ7eAOdBeDGaDZ9TV0QxpFgInRNVEvGtGHBJXpnW96tlJGNa0NtTRA3MUAcecOQARGK4xvksbZAQDWsJ+oARDU8t56h/xuNxkeMW5r2Ozzm9IQoKJ7cJD1cqrSxxIAjgQakZiqEQwQTNBk0QfshEb0dYhBdgQJOmigMZWlhiP/lc8aFgtQuX0nj1jOgeUpwLKg8uUPpsL+gXMBSQSX4asgXRjzsL+VjJgpDJMYS5vWw+Z+NMSWuBcjibDyhYHVqBjeKBH0W+Mdxh6M9UuMvisNv9AQI9OAPtsKOEeqSgyj9lj5UJg01jZwLmhQQ9V0twIkVYx6FUgwuf/hVdDk6jTGxzGSmhidm70j2iNAIo2nGLMhjbYjQMWhNSYxvHUA2Dv7ezgG7Ad4WxLokaLbAo4YnwFRpldn2UwSyMZAFQAg1zDKusqx2Lfot4ZUTUYMarTefmF65H0uizEblFMP8w9/LCcjccKwyFwJMBJwyAi0GgbqJun5mnsJQAt+h2wAeslrjYy2GtUwnBkxEyC+xjTkUZ73iVAbXMNzWgFz68EZXWF/o9f8tsa6hnyT+C0BAAGYMuM7wWDqucrqivvuHRyGrHb2HX/klGNLjH9E7uSRToLKk2sM39cXkZJ4Imia8y9SknLrmrNbnVbWBejs4KTRADAt6azAWFsftG+KU8hW8LMC2FrmHgUvmJYYuOEVd4CZHaOzMosYYkzWWSDItO/M0xrkEIyJahtfAuBwLxoaUyR6DtY5bsorxxUvU3nG8PAr/rf5kmM4MqUv9WAM2wIJAthVwNMmv6d+cJ6ETAnoBYhKp70+v7UmsiocLeDtCrBnALDUv7qAz9QiBOyNyEH0XE2ZBlhoAro3BKsP72RV9JY0sVZq6C2A1HCA0AniJgCaBI7YOX6OKP4VzhW2naNjoolOqEfMnEJ2kt4CSOJ8AdORtVdpC1DZSGydCDo40OhE0+gA8GDkdbxNuXvz8TS7OT2DGCNkK9UxVi/DMR1SkE3B6DZAUPvgmPY4ztU4LynDTnkZHWA/xvg1YOoSWRkCmowATWyb8LbVxZEH4EwwudwFVJI6h8n4TX8E+MLpRoBdUERHn0Vq1zMA5BmAMKUUlmN0LrwewvOh/FY40v8BoHd7RHkikw1+r6STBbQGJI57/fAxWqO/wrGJudTAkUHgTRLIiFTdGORBxFgLRkH9/iicHXpcV2oC7pSQ1eADekfnG9ElW2tDT+jfhL7NBoBurEeWghAk14CtfteInUQJuURO1ZtF9gDBCFN6tpVDHLbKcQ/oQgFHIr+iPrYgi/fsb+YgC4MQnyWhYVZhgJfm/YtsfnmKHvwY60+KrsWZAeBNAMk5mOTNHnGK/PTF5Zw1n75+/Infe51ovZZ/x93l3eGD0FN8nqIOb/+O0/I1w2Ni3SOlqatJrL2sUcnpQCcywF/Ieer6Emurrb8VfYYXAMprABlphlNLH93fRwZHACKCH0a9u175Km6zDn/b7CekRucggYOAdA7pCiDRiHDbKuPdIFNIHao2+F3mCwMQuqhP2Y8B2Vn6798F+OEYux66tvhDiR+2MCNYmEDluF/mjrqmAxgi1VmbSwDK5Sby2+B+G8hA8yBaMwvotKFz1HrBGrG4pnVOIHOhr9HZ3OsUYC7RjL1ZF7CF/c4xaz66KDZY3hfXGqJPnUcD2gSuJNmUP+HwY/eROVNWV6j3HPrxYB8duc9+7yCb8Vvj03fZBJoz55cCVfDL8Wkf3Qvq0Ho/JZzGStxTmbYCwOw1Wbi4nxRNm1odc6A5xJxZs8dZs3ec9dFr7J1GtDpJqb8j0wX96955CD0glT77TkHKNHDhEDW6sA71x+CNakow1bGIf51zjJAOi4LDAsB19GMNPVcj2rHC+tj/eBZrmDrSeeMa6T6ujj7vHbKOwtcW+iaWTVUAIhH7Lt7bOpfDEYj1UacEboy5YkT9LOu/Yw8EDSDB0Jg39M8+RcYaRwRnojprqvtsyXWpxfpt/Vid1uRf6APvRaYQbWrU64r1wL2D7Ri5GF6Tapy5EDoo9t7IZ84LJ6+/7byPuZ9PjNSfEFa+T23RFJohzuE+VUFcIb6O83gXUbEBYJqumC0AJLCsc5T7NvdwdfcMEcme9gwD9OygPwxqqWuRsy7yphNDrMEAzK5Lrr+hb9kv9dkX9EkPP6DVgWTJ3sD5UWNzt8819uC9+5MKa09Z4jMYZ4fjJai8Ys+/JBvAjH35wLWF/daQfYauqFXAR/fmIS3wKuY098rthA4JWYT/MeNpy8i2c7eCnOtY0WYf0/JeWVtKdfQGjkzhCClvWMPdDK0BlNdTQWWeEZDvqXKeO0Usx+wLWPMWtO5x3Lu6h/KVxixxvtAlK5zQ6l3KTOSk41YQa4mOORE5Lajrmq0+gWxvrofZNc89NzfDcLo9un8vO3pwD0cqHDs3wDI1ls/eAywn0oFO3phO2l74XBR8QW4rzPmKfMCxtJU/c9hW3KfrZAGxCMd9hOAgRGv29gL8guvuGwbS5Rn3PohMDGYvCKc9TmNrxS0IOKbsTjpiuGbuoUOliFiG92Uoaiw/S6Dy+XOccLeA5ajjHmuyvM3HNR/f4HHqYfwbEp53efu7+Igb3/pqc5b82H75OF28tt4WH/1m28/58HM3us3THbD8c9zafb/jwI4DOw7sOPBLObADln8pp3bH7Tiw48COA//fORCPkvwqD5ffKLD8+UPPb+2BL91PfleFAYkRi094OOf/MAgoOmGsiDf5Zxq+4ykeIwiGk4hYjgf6HFjGcBERy4APgsopYvk4UmCbCrtPKuyosbwNLGOgEVwWwtx+FREvYeCid/ZL44HAWfJ6N1KmmzXuPMqaJw+zxsmjFKkHqCywLBA2w4gmCdIUgKVAyZK6hQtoCUDTBqDZu3cv24caGImXGN+XGEnngqYYVwZE8Q1u6p7XEAAAQABJREFUBgHAdgCBOgBCRtTp/a/nv0YkAT8pgGVAm15OFYyJa8CoiDQD1E3gOPeC4cSonIWEESsMJ5caT84A3AEdMHZUAKOMagmQUhMWhsMOgHL7JEUtNzBQ1TCMGbU8i4jlf8+uAJYHAMsC9RGxDFgiSKcRz9Yo4QDjAfw05LUAHyWNTXwRFKk3w0jJiAh0wi8NsFwywMwlBrtVgJ3DMNbfAFT0MfjYb2shBpAmkIF8xLkYo1uHGKVIe2nr71aNdMKoOCEq8er1X4NGZ+9uxwgZa+9jjD64l3VwGKhhmCrXAJwg7NWAyoNsBCgsUCpw1AY4si3AP8JCw9okPCEPBaamAMoCy7ZjwPAxBkOB/IgmVQa5Rw3qWggx9XNeMo4q+cpevPjMV/yb3vKX3LGhhYp6dtbVS1HKyEnwG6MaYFxLgD34rVwY0UKLQXFD/EakFNdCazShkY4SBrWbc4C/i0SE4eV1J402xBBHP+yLkckBjsC3FpSiVFK0ivzqUx9PWRUgUU67GGw7GMSjLwB6MDtdie+9rhGXAhSTGyKqmBMj5RzATN5pWJVntm3GtAfA7/WaGPAqGFLLEFZwaqu/y2usv2NZAGzF4BvpWvmNTRZquo/UJJAXPgrYbSLBMBLWMfLXD48DrBh8/JgNoRG80BEjgEevCc9uI+0YFf5PQ6cM+5/DlD7xOw+w9zrGaIwV7K8xNrWYWwnI0gAqoLVG76yZw1LIdpzONR0njLEl0+9jxA5QGSOorYZgo0TXkHOyCQAQwDKgRSN0lnrrQYqGE1yGAgwCABCo0YgaFuuQO34L+Y9UsrQd6hD37t5FdzHGXHtbb40BqUfQGHA5IiE1WHOPYaDXmQAgpMmYlwQoIaPUL968zS7JKGErUFYAy0bkRbpSjMACb50DgeU7zM+TFJGO/EZK72TdTawxoohxNtpeuR0Q0dQ/x7mAtiWYgFG/ze/XcR4p93JgmVrLOjY4z40Yj2jTPOJ0jRF5TXYLGMLn8lPHJCMz0bvongFggm1ar9J89Hf2AIR08hGULaGzjQ5fA1xfvuZe37yBuFfmWAEsNwEMu4y9ciwIIPgVQBj6pz/EaWAgASwjC91uJ+vyGw0i4UDpMgYXWTfan6nM3Ledot8ElsfMnalg380pY41xHIA5QAGkz0i4FBHrUHMeQFyR7tlI5c7hSZB1IkEkQkadU6Yz5UB+DHBC2UUe/df3he61XUc6ZIz08E+nmtnFu2x6DvjHXI6IaiLijDCN80PnxcRIcuck8c98yijy6fWjD+Jj77l4xZrByR4ZH+en+Il/bwPLzKA4MkD1WDfoN+vGOpwoajgXOYYA7JDRrynzg4AN6yv3HwRA4k9E2mnfqDuZj6TTYH3EKQdgURJUU45AG0MHRYS5v0+nnOe9O4+ZV4/R1ScBDoafACBdApYZK3UWDgj1rtHNZKEAHILJjDeZMdBB129eBd3QhtOCAFBoF36A94kv/KAv+umILbhnnceMxGqh57p37gc1mWvlFrq0iS5FBlk4GXJA2EonQCAjcQWXmQgwFF0BGek7Yk0eXUDooQCVibKfjmfh9HZ47052iM5Q1sN5SWcxeHRzxrrC+tKHrAWenJYEV9AtDJD7Bx1vagDuNYEqeNU6Yv+Q04ToxeG7F9nw7YsAfwWWl/CqjGNRR8AXfSfwW/ZeAJhsQ58x143sDLkwAjmIcVsyRt4X7UpnxAGOI5D11sMJj3VIJydlRxDLdv/h02z/wdPsgLai/ARQtohI5QH7i8HZ2wCX1ZeuWQKqvnOEJLMPNNHNUoP5XyPisXZ8gvPPcXb19l129e59tEaRWgpCYLnJ/D9AD0td9KqAcu4XFnwrnPoE0RrojCZkJo6STg2QkcPXb55nN6+fRxtpqkM0uCn2YTpmIXCxLuuwJdVxcnT/15Top45jUQ+eucDBXBsdIMkU1m/XH9vR5Qd0MHy4eB97Yvug3BqJyxskEHLuMBnSvttBDzHlO78oXvy1/adnck7as3NM6JHb81JELtoJ+Q5gmeMX6Lom+7Yea3oX3eZ9JH2LfLMXTaByApfV5QLC7vGM+DZDRsk9nrqSLkr+Zv8Chy720YLLASyz/iyJ7tXxSlA5gGX2yyXGt1j7dJiyf2X6traMDvvKFSSwfMOaJQ3YZ7gnL690iqOFscmpLn4Y+bsFUleOGde0reIsFWQ2DvZCLYn71Cl2nXszrgNQVhHAH/eBTjSQ9xKMUs7M9GKkvQDzHPmfD0h7zzOKa7TOhVH+gvlKFxi9tJ8pfh8PLTIcCKzyzEIbGUHQpbZlnksYgtgXxFgDzEcacAF6AP0+65wk+L9/chTUqHHn7P0El+fsI6+ZU9enCViO2srUdBdYVjacT+45zDakA1ktiP2veiOI9R5AOcppwMz0XAkblCvlh4jlEvPXTDA+H/XRaQLLcxyF12QwkEKHc3hyjOA34XkBLhcRy73PgWWOEVA2HfY2sNzQaUCg3rHN9bT89JVGOd5u/t6eAOmo9L3d94Ro00ebf7ePi8O2Dtp6uzn+t/rmcz783H1u83QHLP8ct3bf7ziw48COAzsO/FIO7IDlX8qp3XE7Duw4sOPA/3cO+MggfZvA8pceeH4zD3zcXHEvhZEoDPFaJHzxpQ/1BfBS8MI2DuFNvOegiEblhABkMIZsIpYxGLQFYgSBNqmwBZatsfwm2oVGQqLNUo1lIpYBPwWnNPbFD0Rn/E1/jZetBgreBjCL0UajiFGggmYda/Tde0Kdvu+wtVAHE/BsPiZNM8Dy+BxDIsaPGYb9uHd+w7ZCqssKBtsqBromER9tjKPtY6LnsOvMzt9jeIeIbhmTonbEtWwFUrpE3PQAzE3pGCk5iRzR+DfGaDeBTJnXII1iMyeNJsnQwYUxfBd14qwbGzVNMeqaVnGEwWSI8UpjsKDDeoohEBIU2Bjb+Z0AlU8e09fviODEwIuRTDIS7spU2M8Flp+FgcSU1EazaqdK4DSpcDFohTESg2SkpiTyqI7B2pTTevkv1ykuA05vxjgiFe07ZLR3qsUHWMv1hxjqBYsGtIL30WfT1WLUT8KEsQxgqn1EGj3p8CH9FVgmhSMGVoHKq1d/gf6cDU/fxin+thhVh+O7yFCX1tSkEdlE9KDSMtXg5jhjWK9z/YJWYdCD5/DdGpjW/NXwL1C8xBC1wMC6oB1iLBxBQ/puVLCpmTWMWXOTO0zgZJJ2JZDPfOXyGO/zf7TM8dKA5rdKVxg+8tY05fLbetimWK1jUK9BVe4jRSIJKGjiZoyQc1t5XEU+rN+qzRHLc5B15gZnid99WmsyalgLAv1IfQDMZl60Dx/A7wcAUkRuAQYGAVLNkTXlVPJ6DfijrFov1uiWJTJmG7WXBRTph6k5F0R8S6YjHCCjA8AH2zBuCiJyTIByyKLG36ayCSgilZCx/of32QDqv38f0dfkrCStKem8TRPNXWvM8xUACwZW00m2uUYbkFqqw78qJOg7x9B4Q1RgH0eV4dlpZD0QpDb7gUB4IkYCfhZ6rhjB+Bsmy2dftiniMaUxrmi0x3GkDphXA8SqAbKbetR2rjMINIPSlbka4+78qGHglqr0e2JkGDRhPiTnluTMINAVdXnhtxFn7buP0FvMZUCsufV+icyZQ6ZFHREFNEIHaVBW/xmJ6m/V2/AAYKcORbRagDqHMG620VsRlQ/gMstphTxFek76FsAy+i6AZfgr0Go6boHh81evs4vX0Ks3iFyqPVwyipfoPSPxWjghaBRvmNaW37edYfye4bUiKb2CenJVfW7GhTDU0jcNwkNIA73peCP9KTzQ6F4xWpmMBhWA5SqyEhGRgL+p5mhe0gA513lgnae/XpsmN49YNoJ/iJHbqLI0rsxJeNUCPDAif28DLOvokIDli7jXN9zr6+BdAtFXkd7a4z1PB6kyeqdEuu4SfJ9MSSNPFNkEBwKnZYPJWYfMhLGEx+oco8Jr8DLJTINhMWUvqX2RddP9ux6NL97GerQBBgQk0SMucwJkVUAiI9oa8KcOv5s4o8R6iuyn4DxAGaZLgGn5edZtrfO7dQAXf1tg2tTcRjUv+O3QewD8M4DtGeDS7ApgiQhq06umFKuAJbDN+9JInzMyZI+Pfv6VGM98u305r5NW5LP8Cw9LxDd85hHqSz9LKWTDrA8fSZ+MLOg4Fs5jrLeuuQ0ieI1mL6OnSoLqRqhxcspygB5xPKBUO9R1BH0ICZwbrTkGVBbkt3REEI4JkULcDvCS1/sPvs/2HvwOHXoPHRkqLrX0VNjG9a9kTe6CmCMpdbwOTAC0H96FI83NB5wW0I2xtwmgIt2peumWwf5qApQFlaUGEeqdI6Kmj3F0oz81ZK/KfHO/UqqSUSTA5Q5jOmLdN826ZShIjbuyPAJRmkTzC8QMAdhGzI05EZCWjJjPcCQ6Piby8H5Qk6hZIwJ19FlwneuzBCwLLrt3MNuJ+wd7K48lU8I32AcFSIWDVBMgVWocHhCtTKT26x+CpjgdydcUsVyLtajNvkkKoM1U49xXWUcJ5ZXruv55L/bFeyvhCFFeAf4D5i3Z3ywZM8k0zurYiYCbAC/jmyStlO0//n22/wiirSgb3J9RqPZnePYmgOUx0fquuEUa6AQqMwZ8qsOiEbQ6vbiGCSjXWAsq6IJLgOWCosQACLLgsg5QRw8fQA+JjjxxWjPsSIrENd1R2AoaVgATldEEhOmMkIDl/ofXrI2vkZ3XjB97J7kOP0yFX2OPWnOfRgaNKsCkkfo1o22Z22XW6KgzbmQ/OkEHAH+rYpQoThnR0oO0vyaDAvc+UQedv2FtgZ+ArkuzQrDPLLhIp3hvF/I2uLs9s/1y+8V3zmUFJch/+IgmneX3BdFPPjXmV37r3NSDv4LLkRWEe1XnssBE2QFLD0hVgMcae5E6FFHK6Af31mxQ0HekF+d5wAj1SIM9GrD+4mCBDBmVbVtlrkbpApwAjDBfcv4S/bGgteZyTT4LVnsLZiDxOYK9/JB9lnvEIXsd9+SRLWPaj94HsMx1PccyMwEu81eSZ66lPgbMNZNSHQfJ0GfqdvUXe7sFe5+FeytBfX83ruT+j/5AVR0KmEMLnGMW6BXXkDnjZ7aJ+TW11Pk8HEt0LnH/B7/jmYl72jwfsY42eGZpsA+0jVIC9KGqEymvOSDyQscS5FiXBG6He2NNZ7JPIVuj91tkZjDbgc9qKWJZYPliAypfAS4ry+qLCuByRKizJkWGJPa6De8ffdqAFzV+O8oK0Q8zQMzQkTOfg9SRISbuqRhv91OQvEhlDMhExZ7KZzkdpOY4DOu4F/o09n04wHDv7l9dP34aWCYV9vNnAMtkd6LGcoMay6bCjohlrhXOiSHM8JQ+JYkOluXv7ej23+m9/8bHG9m//dx329eJv/Nr+L44r7iun/1WX5/z4efus+CNravoLhX2z3Fs9/2OAzsO7Diw48Av4cAOWP4lXNods+PAjgM7DvxNOOAjg/TtAcs+QH7p9ZWPv3Tor/czhqS4j9Smfwtg2TZAWz621le8aIoHwGS0SH9rAClArGQMxXCGkSfAEgxwHYy/YQg/BhC0xjLpj6+JVL4mOszWiGW9zQUGsPxg0EiGrwJcKn5UI4OvZHa2DVjIDubRTBguMNL0MAQHPfyee8CwoEETC5vpRwfvX0AvqV0HEMfnAYrSFhGd7UM9+QFrAE1qRKkJqIw4fvQOwlA6A0SYQrYdDCM97qlnpKEGbgz/Atum5Vty3gIDyRIQpYKRpIzBxnaOgWqWk9EV1vuUTOUdNeIwMNmOAV1GGLHGRP1EpCLguwC8hj/vF0sLDbX8jomkAlRu01pjuU4URgEsX78QWP5PooaeJaAU43AFw5WGRsdLw30D0M8Um20MoEZnlan9VoFKRMTMphh5ZtSpwwBdjLdjIcjYwHBnbdioJ2q0TU4CYENBMMgoCkFxjb+Rnjg3JgpudOivZL9rGBOrGKoEXSecc/nij9nViz8RgQrIwysAKtoekdldQPSe90qEVNRnJoIQ5DT4vNQgFrwmdSSt0Q1zxn0OGjCjrVAHs0F6Zuv31YhEX2PAw3SNHADQvn+TDU1ZClkbEks2VjaMq4LL3LyyqIFtawbYtU9euTTyWZJQoVH5lkC8BJg0BajgtdGlAsvB7wpjj9F3Th09ZUPD/xLDYEHW4TVlsobQGqkHjcyJGq5YMocY8IanH5BN+E3kRlFLM2o+xoTBqIzBrnP8KNHRIwz5gHUYpaU11t4Fsrpk3kX9X6LDyhEVIu/gDmpb0phoJKaRNdYQXWNQ1Ew+xwgtYCJ40v/4DiBF46YRw5NII9zByN42KosIYyNxpQqOJkNA5eFHIto+fEjygYFwLWnQDuBc7qEOMAiGcZAx7pJJQOpBykzZ+4BmRN9dvn6VXb0hdSjXrWIUjBTstGXm9gZc5noxRuo0ATj+jlT+vClGVp0fqeGJODW7QI2+NkilKgUoDnBagi9a7K2tOwakGAtmYEhOdYd1FjF9MlHz9M00zwsAUAFFSXB4AFgw+Pgmoo+NitLoWiPSsvfgSda7D9GqUwUK7ZdR2H100AAdNAEYElRWb2nyjYwJB2RNgAQda8z/KnNaGQ6dhb6bokNMbVxE/hVGOMFPAeIewPKehnxk04jyEtcxPfT5y5fZ+YtX2RltyAZ62bFpYVDeo0zAHjLcIbJMB49ITQ8oNCKyaUhU05B2ha5JUg+ojKy26hWcFjQMr4icNF31BUDXeQAAptQOMhqTGssVIperHaOaBM0FnbgnMjmYbt+sDqsZzipzayqT+pa6yuuZn1mH1TICECDTEJJHEfUFn4123+MeBYkjjTT36v0asXz+8lWiV69i3gewjHxbh3Mv+AO4x72anrtkum76hghswBsGGX2D7OZ8nqHvpTmD2FIOmOtNWhRK6JsVRvcZwPLwAxGd0ISIwUgXzly0deyLWqxNwFSdKjSMC7bo4FCFnL8Toqanwwktdc/RHUuJjgmKdADS21ADR5KU4ty09i0i764iylNwbQ6wPL9xjQGYUE8LKpnWl3koUOLSLxCrJPpvCCT/KJe+oi3+SB8hI76Jo/n39kvfx9/pq803HhHf8HnIPUcJDgo0hXMTrWl/uzildJBTI7ZrjJvpr6vIhoDyemaZgAVyDt8leD+FIrpemRNwQoeZfrjGemuksEC65TFmrDnDC3TRJesWIHuAMtEnMvezHzj47g/ZweN/QGc/hC+cKrgMxY0iy7bqPMsrrCEzRySYjHWT8eyfkmKdtVwKhyXkyj2O60lydkkckCHxjkVDJyPXDXWfkcBGGNqXKB+Rp7EVYOZmAlw20nfK/Ig0uUQyrpkf5YxMEGvrr5IhAL0x0NmCMVduAyAnpbclP44eWS+VLC+W/QCAM02y5TiuAZQTnQZAJEgkkGQnBUclyypE5hEA4sg+ghNGXccf2hElLW5e/CXrv/hzONTE3lJ9DHDXBFhqkYHENqXlJfKc+yozF0vsLSTXvwkZFpRTU5eXyXgUmVuIEF1MLA1AP8emksdBApDNiFRBNwSC9Sntkfa/+4cs6Mk/wGv4KcA4oOwFe8EAlgFUx4x5ApWVdVe1QvbYw+LQYfRsV50BwF9hDlZoTaFrJoeLN++iFVgWVA5gGf148t2T7M5335H15j46ijk/U0ZgHOOZoumRWY/HwUEwMK177jWIyATYGrB/6kMD1oulEdsoBHW+QLcZIlKWiOPIAlJBR5oNRABaZ6Ql69KcueC+bcbirR4J8E4AD2q0iZSmFngdR4IlgOTs/HUiwLkE2FE2Bn6muatEsvdhbjpti0cB3sbf7m98FW36i39jjm/tiDguPsoPcN1N2iCBQsq7dXBNC91DzntH7EdxoijjQFHm/lh00G3MC4TX0ieR1l6+Caa6V6IDSCYDiGMcILvRwEZyB0jKfmbBPjxKKQAGm+3FqOxaOBkKxOP8hSOXjkKSjlNN9ITkXqBwNDM9/Jj6wUGAy5bwcU9ua4S3YDWX4kU/uV/BZXeO7iPUO1KDfZiZlJpkVaqyXrL6cy76jXuYAnpPAb2n6JBNdiau0WDMm9x/S4dA9Lp7tpXEHnVGtPkMx4CZzrKca51x2wQs8/ucr6OB5WZ8HqvBEzOjpIxOZAso4WzEWJTQBdZenwCeT2MeAd6jMwXvBXTNXrM2CwetNa2rpO2Wf+6PV+iVFTp0zlpufWVB5StkV+fCAJXVG+pfzota4K6FZIFoQU344e+X+X2zekzYS41GRNIzpx07AWWfQ3W8bbHeuZbaul91X7WELJkzPn2djT6+AmA+R1zZHyUFF4CymZ2+CCwjIykVdmUDKkfEMtc2WrkuMI6yj/IszD31NV2M16b1L/VN+viL/8YpyOet/N+++/y84rpx2e0vb0/54m986x9u3+ovuZfE06RTdsDyL+HY7pgdB3Yc2HFgx4FfwoEdsPxLuLQ7ZseBHQd2HPibcMBHBglL3DeUCjsedL7yMPeVj/8m3P0//VHsEpuX9xMmID6LKEkeggNYjod6viusSTxA+3TsqRqSEgjt38kQXLQJuDCaDsM2wHIb0DVqLGPQqAPECizfvMtT4dJaH2yF179klGFKCZoe6NOvpa6GKSoe0OPHoxMaZjUoaabVx94UrvsPiFB5+LtsDzL1sIZM02VP8Kjvv3kWNMQQk4A7jYHLbJ9owSAiBmtRf5PzAPLmGHn6edTNEEBowbELQkEELLuA5HukojZVZkNjv4Yf7tn00iHvIfNcPzfWWqvNqNowYhF1ITgs2NAE8LC+aZwLEGc7AVg2leQEA5aR0hMMgFNoPoZHGE2tvavBq3WEgQb6EbCMwfX6xX9m1wLL75/BVyNwAXoALTg5pZujNQqne/ceKSlJhYkBe42hCWs1Y1slGgBjW5DGuyQTIh4aiZoY55sYvOqAtFWMgRVAeEmjmzUVxxiWphh8ZqR5NTLPKBHBbI0wjkXn+AmG+u+gJwHiV41+CGD5PMBwAfEBhqIkY+m39+4+hd9PoKcY2zHyAioYaV5mzNcYuDTUCoAJPmlAlu9TDI86AkwFTDFWt/cxTOE0YArKUsNIDoxjpPMbCEq+AbyjjRrcGB+twy1IgFQhXbfAsvK/LZfxJ/84hzSC+YJNMU9sC2DZ+28dAY7C795dotwZexA8joOWGDdNT4pcmKJUo5pRZQLlNeSpA2+izittBeDQWoBl5HOMEc86lrYRDYuBb0bUt0CivZbfRvR1A5RPPE+ADOPF75dMv8jMEWA3UnuJAX8JqLBAVmeFcZq2jlwaTSTvqox5GUeCMkCEkS3X74iseku6VzIQLOFbigoaEi2JfNLHFuCcNe1a97+DGG8M4+NTjIE6TgC6GOli2uaFqU0BthC2IPm8BFC23u+KMd6Db3vIqSQ4bo1o69hOSFN58epldvnyRQDcRpoQlwkB9mEQlFLEiezwfhMlHXY7VuFswXcCTw3moDU1G4BYDXRC494jHE1OkA2MmdRttx3CI2kg4Ik+cE5GtDJ90jBu5FUHQEKYQn1gXJaRaNevn0E/4ESBQ00ICAZpZNOUrfuAyntQqoFNFgYMuaaxvX5tatRnRLcylzCc6hTjfeyjU/cBvfcF7BmXEkZx079by3dASnkjBp2PCaxPwHBklWDuq6cdT4H6PfoawDLAZRmdvUZmzp6/2FCkY8XI6j10AI0Eoo4ePkIH3oGn6DscI5hIGJZJh3lO5BIkkB3wE+fVmWPdDg4ObYz2vDdteqSfp586yKgTdMiJuosdABOoZkp+9GqTSEjT0M6JQJ5z3gJD9pKo35WgMgBaAMuAyytSYi/52+j7McbpCeA6SjLGRUBHsD9FLCOL6L0A0TEuEy6dnb0QROd+aXWOuAWW29k+/NknslNQswzoXe7ZHnNt9CjX5+ZDvzl3rGc9R++YYl4y8qoDQNKOusiC8KxF3H+5XmaeEkX6ljF6+wNzgbnD70oLqACVHWYjJvdP7tIHwEXBbYCWkv0GmBheEHl5Tl1p2rnAEjpjAQDSYN3rMY5d11/OL6srdWTBKK/TUiJBZagPDQCWWYdBJbh/nGoCWEZ3oEISsKy0Jc3HDSe97JvidftVAAXFx2rBpBHz8/nD63h4cUq0zEtbjcSRqp02QGWjCJnJKxydDu4+yA4A6mwF1a3ZHvXfWZsWzMnlgAg+2gl8mBjpT6tTjvpTZw+dqBqC84y9zlHWILdWvYD6NSDoFc4b1x9ehk6zl/7fAjA9/P4fs8On/4Te/i6AZVEjRJrv+QdaQzr0mApWWrNuGBHqmoFQRipea7NKJXSb3wksx36Gu5Y/wRN0QbGvWiFX4VSDjBmVWncOMBdsLVXhnDBLQElgOcDlVirlQFTy8PICXU6q/Yw0vZDzZADYHISuck6g+KPdg5/H3z0OaqLTAyRyngFEX6NrAlimFWARVHa1KsbJOyg3yUgBUNaJrCk437g+sE7Ymgb7+vkfg6ZETDvirucCXXXS3RfkvVgOwlYQLtLHow9dA3WqkXSoqQC4Jqch1nh4nCL/AaDYoxmBruOODlXOdfdW6pX9p/8j23vyP6Itwd855QDmlkZhbzIEVB4arXv1gXv7NGK5iKAVnOwdn1CHGuc7HEwEokJvMJfOX7/NzgNcBtgji41rocByi33Q3e+/z+58/7vs8P4D5hP3Dbi8Bly2X5LgsunGzUAhuW4KKgtQlrjPIQDZiGh6WwHNYl9uf9T3B3fJ3kIEu9klmOCR1n/KvU2kK1OCA7gJlE50nAMgb5DtgLFqQO1DSl0cktqfds3cX56/ypZnrziPUhIC7sjwhD1UzEYFUllGSI32t1Vei9kbX/sXb9L7zQGx1nqs5/naPHNwSVcvwWWXvyTnKVrY7EY9eL1HhL7OqGVkvczzQ4l9XswUjvc8HQ3myPQMx4M5fHQv797cvb7PGi3WM1PIp1rO7MvoeJTIYN0wDXhk/qEXPj0s2ReHQxTOUCPWc/e1bZ9dcCqoFfty9I2cmLK/nbonh9yTB8E3x46EOETUehTqkxs05bnrQ+wjGCfbJjqkBTXJqlRGp60YI2snz3FMGOMYOEIWJugSHWGDWABayFoHvuig6z7MfZf7LwQlm50SaS6xfkyY22PGbex+hHng3sJxMQJbBzJTi+tQZamgOvsG2zUdXY3pg3tPdKdOWWN5S9aCuqUu0J115mIqBWKpHdZNAWXGFNUUPA2dwR5uTuTwFU6O1li+gk+G6se+Wb2BU6dOiQ1I56jWvafQkwCXl+x5V9R91yHC3x8wpn3W+Tlzusg0YWYnnSm6jGmsw0aGc11pwvztvyEzgusojhhrHIqch0aZCygLLDvfdAxzXxY1lnPnkK8By+4hG4ypmRpMgx2laBRw7jvAX0Q6Rtq/Y8S//k9IP+emWeBxt+/8a/v8rwLLPz7NT34zr20e/JKbSjxNnHTPUDhLTnA+uRotIdKl84h958nfZXe/+312l7aDU22TzE3Ngwc4MaI3dUhzHWSV9LXRT/FHfPTFf7b7+ulIfvHw3Yc7Duw4sOPAjgPfEAd2wPI3NFi7ru44sOPAfzcOuA2XMML9CoFlnxJ9ONh+WHCE4u+vPDV85WNP+2Ze2w9R6X74l4dfn50LME9jTNiEcmtSHBcfxKH5sbmRCC6GQZjvI9KG1vqbGoo0ZrSIuNGYUcdDvUo6uNElNVkvqc+KQXxpSrk8+sxojXiIR14w10df0mjQMQzFRpFKK43ogIYLwIuI0sKAoykXt3jSQz8kipc0yxg86xhUBPA0EGm8G30wMvU1EWKAnpw74zpzDHf7AEf79yFaPfIxSWD0wnBDFOXw/SvOexlGi6VGbAw2RiN0AJYjilbPe8ADwa4AvDCCrLgn78vWmslzKFrT2wLUzfhNDbxGEkQ0AYasALEALxoYUOYadzDwzTD0TS6JSMUAKk2JsgpgGauOKQDbALSmwTYltumVi1TYMyKFr57/O0bd/9hELIeRBGOPAFpKpw2IhvHM8Yk0j0Q0YF6FeOAmBfYMo9dMoxf9TUaqJN6mWTW9ahWDk1EQTUFpgA9pCmgxg6aAYUaFa7S1/wLiIUz8dtRYzEHlAJYZowCWiVoW/L96kSKtBxj7kcgkj/y0oHIvyHuV30atEbEGH4zQtHarNWjltfyb2WJgWxg5iKGpzLhYH07jXB0gu4HxW/nQkWBE1O2IaOURtX+NYBNcjhTkGLcCCMCAZZv0hL1Kr3iX/xHGts3naVZpTtKIGoAJ7+uAG4JagnhVgFEENnit8TfkAhDc1lqUOjxE/U4Mg3UM7qYMbhCN0wRgamIgM/X5FCAh8Zt6x8Fv+G5qRIytG37nwLK8FmCucg3BCluBD1OCG+lpBJh8M1pNcEwHimSwJeIEY2vwTcBVngFWmY7a6PrBR6NwqdNIa9S0fJszbwSlBHXqGBWbGPI6j77POjh7tI7v43RAbUwAkBk6YIp8mJJTBwoBAyNORG5k65J6fEvm9Ir2ACP9PmQrEBuaG3nSoHpJ5oMrAO4BQHUVg6DAchUjfQKUNQymQUrncGH0PlM4kePDfCrIiKcW4GnbKGv6berTGvqrjD4bX1Kn+CrRFGPwFAOsadgD6MV46dw08tbar4XuqzcBtwAUbU3DP3j7nNryRKkyvwUBBQMFQ7rwpQNA3D2hFj19kJQXazsOkU9pcoVO4BxJHSTAsA8d3HuoBT90lnrL+r2htwDL5KvAcuIFIBh9XMC3AJYxNu8dGwWuIT4Z8cvo7BVglcDyqeCyYCsOG15DuK9zdJgdPwaMgrroKz7me3gIXZ9jXC6A5a3ITYKVKTmMgRse1AmFnQL8Tkc4L0CgygEImMnAmprlFuA2abAFliMFMECDfZuhs0O/ADTpjLRAVgSSV2RxWEf9VYElwJrQsVN0u9GLOfiLAbHFPI/oY4Bix7YAidbI9hmg8nnc6wvWolQzs8ycN2J5H2DpgHO6yEFJUDnohPXHCEHWD9OWM3cWAkTIv+l7BXldX3Q4MHrOqOsGgHADHZfI1N6AAKwrE4nIs4hWi4gxAHPlU91Bq3NCAKqAgOpqa1QiZIhwhfq31Ee/gGgDgEJv6GBjxHKLuRr1Yfn9BkBN45C0o6wt4/NUYsHU/zOApcUAfg5O0Z8Ay44z41Yi0tZlnykcLQ29yRUd72/f+Q2vTz5gln3yd/oDkfvkQCPv0idJV/q+iFSOeydKeU0kLp4sAMhGySeHnD3qDevEkbKNsB6j6+YAQjNoDqAmmB/R4rTKlECmKVitja48dZEnQQ6EB7llLwEwefn2GbVyE8k/wT/ncps5efD0H4O6rPOxDrIHEFyeM34LnOGiRd8tGX/XjagZz+glYJmoW8CeCX0zLW/MQ79DHxV1QPPtFTxkNVEpeXl+O81TnBAAA01Rr3OAmVE6RHR2IWtMKwfKgxlGTCtvdLTlEazjXs0oK5IZAW9WhRHlOQDd0VV4N3B/AFO0e/fuZUcAy0fM5QYlIhas3dIcSrXhccZDV6cay3kqbHVHaAKjMXsBuHdx+uoAVFVwyqnA2wrzZihQ//JPOLj9ObKueH+MMGOHIwnp5CtNQCraDil5uzEu9/gMxxjWFBA65hD16bkXdbpp881CUWSjiAhxIxZZnyMbg+OI7EaJAMY6xp11s0ek8h4R5z0ilwXRXHOmrDk67o0vccgiBbyOb+56ImqZNnjPJ8JignHK3T4ksFzi3srseVDm2TmpsM+IWD6HnO+Om3tnSzWcPHma3Xn6JObtWkeEQBqRVe7J8gZR5kA94ZqLM4rp53WNTAAWjnDKTBCpfeG3MizZH+tS99D5TWRgiX5ITpVlnIkAzAHkjFo3i4eOYRGxzL2YUUKqNZ1HOBLdAWCjXTP3lwDsy4vXsU4M2W+aLt3U4jCT8WIHQ+vcDX3gVHUY42Ztf/yiS/FyrfVtOHNxTuiP4FFcNdZe90dGKgsuL9TR6OW9Y51o2E+ibwWVy2SIKAHsLrin4J335v4usg2YvhtQkj1DZA1hzMMRif24rU5iZluJOszISIDKzFnLAcyYDxHpzpyY6QQkAXDGvpbxrbGORw1i9IW89rlg7p4FJwnnxwj5GZFpYkyNep9bQn7MHe09OS7QmjHTqcgyFa459QN0MHrYVmfN6Q1ZBm5wgGSsZ+xdZ8xb+xTPYOgC2xoONA0ilhvwoMEa5r61ifNClX3VAjC3oAF960M6sLg2JQZzPgBxF9mVBFerOMi5DugoNzPjhX24htBP9mEKGSWfsj2wd4GnNeSuLrANsFyFp5FdhBTiRiVHKuwCWGa+XgG6X9FygzHm6kGzMkVKeeZGZK/h/oMXjNGE3x7fAGjj8OGewIjp6ANOsLGnRhea4l2HGnW4rdH29ZZ7KsZEB613z3HSesZz3YeYYxG9zz0IHAou66hjxg+dsxKwnK//3NeSMSrqK9+mwiZiGXD5E2AZmQ/RR6htw1HWFvrSK58G8IAX41j8nY69/evz850/n66f+dVvT8k/+O00n/Pg5+4sWMFJtu4V1Nnu33fA8s9xbvf9jgM7Duw4sOPAT3FgByz/FHd23+04sOPAjgN/Uw74yCD9eoHlL7EnHnS+8iD3lY+/dJlf7WfbD67FQ5qd1fanMSNefgHxvMY/vrHxw/w47U68AqDhyxjl/AEv1VjuJkMAD/QBLAMq1wF7rTE2H6W6xzPaNWCABMLFxTAm5GZLHxmTcSu1K4wO65xMfxj10zCGzAHjNnWHMSTXNChRo7NOZHRLwARgoE0LAp2iDTB6TDGejQGGIrIMQ9/+gwQsH9D6mwIe0hSDiWlKxxr+iXLRphz3S2uN4A7G5i5Ry02NNQJuUNRLixSjGGitYdnHaBNAJ2AIfY1IaQ2N8MqIRFMVVwEBOkRGdgG2O9RYNW3fEgPLkj6M+f0+6VJN4z3BkORAhMEFg0mH6F0Bw84JUbwAjaaTFqSdkZ7v6tm/B+nJT7XcDWniKChq9mF401hk5G+Yw03NZ9pIQJEl/RRgTC9/VxnA8CsIBBml3XtI1PZDQF+oiCi0NcWk6SaNCpphcPdk+20twNRnIpYBxiPKKe/3BCOR0cpXRFsPAFw05SRxXAefC2C5juHQNLmmRPW1II3jAjDNdHzWWpxgXLWNKCKQLw2PGqc0XJuSsA5o1wGg6BD91saIafTshCjaCUbsKdeybtuUvhTRZ/IPiAo5S3Mj+sXvFn2LTvCPptSYIfm9+ofyUsiNEfSmPdeZwCjNAPJzfhfR8DpKhGEx7p2RwtBujVSPtw527wH8vm8q8fuAwIAZABpG72jkHCKn8ltwKxm+UsRyRIcDyttqJAyCBxH5ZTpMCVkPg62yiqGz0AVGS4WM0u8KqUobGCfbAKAt+FfFyC5ANTrDUH8G8DcA6AaYl3cBotD3CmSUSu+7v4P+Hp4/CvBaAFtni9EZgD5RNyNkZUG/E1IpiI8mICWz4LJA5+Gjx9kBUbK2RlGumbemwjRV6jVpta+J2rYueQWUs4oesU1pzAtpvx0lR9ExSePC72h8zKnN/fVI89zDCGmEY6QNx7C7Bui6RkZuPkrIW4AZzmcMmF6QPsWcxumiWQCJjJdR8p2cBNFHOKqMAV3GGPHNYCDhQxDgezOP0FVnhe5Cb5maeHqBPHJvEw2wRMdZ532GPjvAGebgPsAyrVHFkRZWvUW02wQQewxvHVeNuwUJKpukWmOcqUetA6qxNSK8jEjCgCy/T5+/TJQDywKtwp09geUnT4hyJDX94SF6iogjoo6WZDe4op9BRizDH+GZaimlCa0T0mUNYiO7wilIgIXxM5pIfYKAB4BYsnYsoJN6vIeMGd1vZHTKhPCONjkwFBGLKwAmDfuuHeEoAV9SNgrmEboq5hhtC3nfh597RwDLjHEAy8yFAJafPydi+XmA6fJRpyb51e60swP4Y8SyEehl+mT9Z1sN4Y7HhNb6pAsiX6WlEZR5HwQ7rBFd1IrucJ3uCQSoUyY7x8zxgUIuWCeGzgdIUCLp4hL3fpIdIvfWbLWmteFwa3UzwNH1xUV2E0A+uorfDBCIvuv8U3NdERxBBjv3mftGiDH3ok4oc9V2Dqi2GAJOADCtAVzKGPPLOncBGJgNpFgp0szx7+JdLu/530WT1GNxlPqweDlB8hcHFX8VbXzDwWEkzrmPogZUJdLa9Oikfe4C7qmzbSO7AuDXAl01F4CjjVTQY3iPrl8AaixZxwUUlIEAFgBTzEpyADDXQs75mdjbWFv+8tV/5fQXOgHn0VmSwLJRr/tP/jHWer+T99LkmrS4OE5JMe4CMsw9kObgnfLj8SHrOiEg6ymDQuJrAdRFJKgMkBlJ6Yb0xRxVChnHFRGnpmyvo0f3TwQ6WbuI3nMNxmMq2ht04BWOUdeQzkJmbBBYttapjig60Am4s/ikFNqA9j2cFQ4foVMBlnX4mBPxNyficHYBmIteNbOApFOVM8nIXnu/QHc4Qyroxd7930E4Dd19EmuUDlyS6/f16z9Df2FNwCEulCRnu0esdnEa6KJnOtxL7hwDWFoFBHNcFByBvyvKK1zruMQak8obqNeZ54yZacZT+ngd3ySUKC/TBZfRwWYo6T3+u6zLmtN7/PeAuaYyZp3CsWKCLp2S/j1qjJMpQ1DQ9d37jLTMcM4MODrcqV/37z0A0Afg5Nol7s2Uy6cCy2/fQ2TdIeW02SrKyJpp69WNJ5EK+y59ZGDRA4LeRhWPBW51EEJu58iMznDWNVZe5Kr73wCekRdlxmjNOk5oOpfpoOUcbsMz9aPZOqaAg9HGHGDfw15LYFHHo4Wyyr2YKr0Ery1bYE3twwc4FNCWRmQLARhdUuddBySBZetxCywrq+6FpeIRQJnlgiGnMZy8Tcte2tvFzOZ7D/FQv/OdeiGeK0K+0zxXjtwbLdD7BbhsuvGQb2TcqOMAllmPUN7MN+5NfQslUBkeWhdaAJHremn3SXWA6AbOP7atADJxbKU1ErwAlqecZymGqDuOfBdRrivmRzg+MK+cW/YhlajAmRHHUfdbSwDtBecMznBkc39LGuY1utz5EfXouWNlR8cEUF32EXfZT+DQwp5CR0gz7VSJwJ7iBDM4PeMayCRZApY415raeYn+kH9xQzRl9GCFOVuGdErsUoaiB7VwOjOtt5l1bK+c/znNAd893zlXZ29/wPH7OID2Tigz0SJbDSB1mbk7Irrd3x+wr1F/Ro1t+uC8CnlmvbYNUJlU9ck5CgcX9g0C3DoPblJhs8+4Yp5eMb9snY9p/WBvw/7efYY13V171RuuiWXk8Zq1yH3VNbwwBbu8XEExn0O4eGZARszQ0GAdaNC2AdbbB+zhoRWOjGOejcbvn0eWp3AQ4PnJttD9ai8dtASWdRRzHhXrv8CygLJpsM9f8KyEnBitbCrsAJbVdMwB78VxibFBrov3AsHpQ1qOSv8q3ekVrWOR/52+L07xqr/wtX2BX3jKt3LYL+ZBfkOJp4nbO2D5WxnlXT93HNhxYMeBXz8HdsDyr3+Mdj3ccWDHgf+2HCgev3bA8q9JBDT0FK/t9xpnNEjE1z69SRgPwkDEPwWw7AHpWI1E2s00hNPmBkcjj2qApeFhjjG0qZd+1BfDgHl4P+xVnrCmtlYCBHJgAHMMVsMNRS1RQ+L4bIVBboXhy1ZQZoBxbggZMRgW4kgziBGNKBpCOwApiKbBKLj38HFQle8XGFIWGHFMoTck9dtwRE3Q0YjU2QDL0AHHGj2SaqmlKEojWqyHqRErmRe811IAy22AZcE6IxqscazBxbpgk9NX2TSnCQDaWKATWuWgYRga4dW6YuQQhlAMZ4cYQA9I2XVAq7f/GoMZIRoAdxhXSWt7/eavREmQYo6X8KVRW12A5e7d72m/jwjSigAtJLB8+cO/ZVc//GukiKuRrrMGMFSHNOYVRj0HVkMvnY6rBtjGteOY/LgYZ47TAO6xgvgazUzqKWhy9P0foH+INqWgxkA1pMYrBsv+x5dBEw3LnG/PKwCkASxHOmyAZcB4ayzbdwHJAlgemgrb/0IeE7AsiC81MKpH/VX4LSoX6QCpWzsFTBvB5yHGP9u1soOACwgXAG0yPpJeFqDzANp79DtAO6NnIdqI/L3EmQDAwFSpAcrDN43OzguvFW0+TwRefRXTJVr4GfxCFjTwCjDZRr1Xxs2xU2YjHWTwGwMTl/Fa2J/TxThXlkUkLb+uId97PiIK6+gJsvLgKf0juhFaY5AbAFDJ7xtoRiSUYyy4bCpsZbQtsAzvjDopoo6tM2rE5PgjTgukXtcBYgJQbeRIOAHYBwmDbRCGUmtp9h7/Hr79HuAV4zZ8mzIPJ0aCAbYYMW2KSOuLx01xOw0BkafUKgWk0VC7wqljbXp0+t4nMr2PUbD/7kVEcBXKQTlbUu97gUF1RdrfI+pWHn33FKM9AAaGzxVzeMUYG/18QwTRDRGtRltZRzxI46isZLySdCv3qUu2ynqAN7RFyu2ltVwxAAsmHEJGiDk/NTLPAfRMfXr25k1QAOfIRQBIjFPB7+RwgUyjg+qkKd2/x/WoZWq7xPFhiiF6iqyOMeCPAAZMv2m69hqG1hp6QFJv9XBysS0rO0QVLfs403BsP4gIRMADAccDgCEBd43eY1N0YtQVJNARRjKKUlA4Gb4BupCLecxhdBjzx1rJKc1yMuSXvgQsA1p6DcGX3slRdkw03gnUJbJ7QcSVNIcElS+DzmAuoIigsgDX5vcTeGOaz3VE5NMCxgjURMpKwA+8EBSYAE68L519TIM+ItOEoLy1W031PWNuKuca4oto7FiFQs/EwDNjmbWk9bcVlBVY1rDcPhQgRlerP4hYPn3+DFBZYPlZRCx7Hce13QZYxhh/gEHcqO4yzkoBLtMOPhJNiSHfdoojStTcHCVgWWmItcu+EHGbwDzSaj94ECDe4WMcrIhuW+msxFjNyPBww9p0DdmmX09QUw9A4AiQSrlvkW1hDSCxQm4Wg2F2iRH/kihxyTS6pvAW/Et6xshNAGZ0xj464wDqMWej30a20u85pQoElpfDC5C8QThjBIAnSBegEpMjFJL8dNakV+jygs/Fh8V3YWn/7MP8z8Ixxz+336szfXnfsbYgn2wgAId02Eppk9vwoS3gRLsExJifAspDE5woxugs62pPBVq4jl2QjByc47hj20VvHT/4PjuBjJAtmc4fIJNkEdnl8z9lF9KzP6qNY40yXXYAy6ZShtqmjpUXrs3Ibp8SE0Hvfghg2cjnqLNs1Le6Hl0eYOpWGzepokc+XB90kKmgX2Ot4Bw+jnOcoxH16FxF98zQQXNBMyLWj8hOcIRe0BkE9Bv95lpSzS7fvaHe7+vs4jWpjZkbkbWB+efKEdhm8Jd/AHNYAMKJQ2A59Ac6pMb4qpemH9FPrKMCTeGkBcioJEZEJseoTYsxshTF3kPWUMioZRcs//M1YP9z/fa/gtw7yQv1h3qSRLPoICuZNnCYQLahI9aFuil+WbNdt43ivHjPPb17G05DOgoRxxwyWmSiKMDPgGfkHeuuzlvhQAYY20Heu49Ig8p6NR9NY74OkXsz1szDoYLoTuas/XJ9tw2OwU8jaE3HHDqWfWHniAhx707Z4r9TQOXTdx+iNfq0ggOUKdeNjDyCn9I+et81MEBVzonMHmRG6UNTM1YgM0bPGoEtKOnvS2adMHrdfUOz3SGNP1k0iFZ1n9kAWG6w7zQlftJBaS5P0fPTsWs34KcOBPQ1ZadB/1XalIkBXK53SQ/7mPrPicocvyTydoVTmllDAmwVWGY+Oe9v+evQ2jdeiml+T4511MFVhiH5onjb+tpIQxzP5yHj3Jd9y0lQeS6/kWVBR50mDnAe0bFqAyzjVCH4OVRv6fzHfnLG3kWy5EIMin1hDGpku6h2iGqFLPHS41q25IQJ5xnB5THOg5fvXpPl5E1Exd/Wk2et1akSfWHbIXtI2t/+AceCk3Bs1cF1ydzos2e6Ye+k06eZMpITm3tEnbaS/JTYe+0/SI5f7ilKOImUAIpL7KOGZG26ZK5esp/QIS6co8zqpYMUMhbzSFmjxMQKshV4P37MXIEEidVFoOLQMu1LXr+O1tTahf5p4hx1RB+OH5pC/R7rUb6Xg1c65F2iM8z44poq+I4Sg7imgp5TA142BJY7OAkTwd1hz9CGrLMcEcuMhyVNrriP5Fx2RtccZV7w0ij+w/uMK9lmjJwOJzL2Wq79H/n9U3hwSquTWKWMEyy1650PhYywkLGfYk/AvqCKs5G14ffv3yUjAOngWbemZmZhLIxYnvA8N+G5znrRaR1Ne+duHrF8QL8TsIwTMHuABCwnUDlqLHP/gsr10DemwnbnnSRWqQ4ZjzZujb/zF/fpK/1ra+/zv5H/28/jsPgn3d/t3z/5rrjATx70bX654eEv7H6wgpNsHZldxPIvZNzusB0HdhzYcWDHgZ/kAHsnt7G7144DOw7sOLDjwK+PA7l65uGMClU8iZmybpi9+Nf/mb3813+JtsLf3RqGvzo1SGmNnJBqUHqW2noo+0zbf/Ln1oPX9ufFNX7MG77ZPnDrgPwZceuT9HbrJ3703bf0Ac/sty/eb99XsaKG4TdnkfaFZGQoHpT5GyZ5GY93hHzA26Sy5ASB5ainFcAyBjHALcFlgeUlER6LGQZPWiNPcJVPBg0e5nlMDOLDjWHL90YKLIkUWAom8V6wdpzXWBOkwxJB54BPAKFWGKVNo9kjInVPYOI+v4vBMdU0I5qDaLkJxpeIWib6z/SuGg5tjSQZfCT1LNEy1uIzta91GI0CKu5TE5vptlMkKMAy0VB1jBR1vPjpdDZ+9ywbSQBmRqUYSRhRpBikg2kY2ATOVhhXVhiOy0Qk7RNVs0+EjRTGOn8N5grQXr0i8ufVXwCZ38e4OX4bYBlQ2chljc6CytKU/l49E1j+N9LEpYjlGjwUXE5jlo9dGlgulswg2v3iQT2fAHEsoxEgI8cEYEG/jX82Csyoh0NAzkOBCwDxFWDhiqhTyb5qfJMEluOH6X0RsdyN1MxPqNGMsYg+3wLLpMImYnkDLOcnymvTkQqOCmgGv+G5KTDHb4lYeAdhFI9oc3huWr8E7qS7WBteAa8lI533nwB00u89DM9Rv1WHA9McA96PifqV70vGvoj21rjkK7EmmU7Tlf1wS0cphvIK4l0O0icjcZLTlGY1xp8LRHRiPpfi+rxXnAV0lQP5LIgvOGYK6yPkRCeE/fsAtESzriWcK4yeucHIKU1HN0pPcC6AZUDlNnzr0Ca+pTTgMwys1nkdEtU+Ybw0chs1rMHb7icAiV4F3zD6Y5RsUnd0jzHfJ71o84D058E3UnDSjgHkTRFpmlEjP+WPL6Mm93L57lJfUINoKQdpjMTvk8bwhjp5pgVNziQJcEyRekS3AdIaqRxRy484n/7NMWIuTLkuQAugbLSVQEiAyqw3FX+DHmiodyS2X0nGc2CZbwWUBZcXkFGyR/4WYIdpsR12HQCMeLt8/z67/PA+u/jwgblZgK2ubcpFmkOCpGXSjpYx4ldxvEgGUNJ73r+HEVZAzJqIAmLn1D0lShWyvrbjVAEMKdPuAR71iJKzrdCnNXpyBZl2eUyWhxG6SzC6m+usLnprorMNOmtITWUjlpcY3dVba+ZBAQrbCgqlqGV0GBFQAlT7GFtTxLKpR1PE8sfnr7JTopWNXI4IJs51DqSIZeuyFhHL1HG1RiJkXdYbgOUbAE+jnzRUl4g+MmpSMEhwuwArBC4itbA6G1DBiHFqFiRgGSNynejtAlju3SWrAMDyOKK9AZYBqqaAyglYziNB6VtIfAx2CC+fOHsTuBzAMqCyIHpELOsEhP5YEwl4FtHKAMu0ptdNhuQELB9iwD8sgGVrfkbU8nFEht4IekFz9NtqgiPLBPk1glrJRyeETFRYd3CQWAEo6LwkSCy5x1nhaLAyQwKycJAyn1MAAEAASURBVIVjxnVOCeJKUJf3Lqi8AZYBlVeAynPkZgPkAyyblrSCA1Gchd7QwSEBy+q6HFgGYBNYi/TCtNZ5ThHL28Ay13G/5sLuHFW3FROoaBX4zYf+Ubz43WLSFx/lbXycf5ney6XbuemlNeGniFF0JABo69CUv0QYs2dwfWsgr5Z8mAHGRwpxnQyQ9Ugh6zrL2HltdbSkrAewTNsBWD6ktufhPdZLgOUiZbPp/C+oBSyoLMCsvjCFv3VBBZa76K3eY3QdKZvdN0TqXX5n8OE59AJ+PmePQOpgwMGgpbIOe4o1ITrkffIm/W8P+R30OzwUXJaVsaZ7DseouZLTC/VkGccgdFQNcOSY/cwxQKdzNoA6F21AnCv00hUAkSCRUbDhTBYcIAqXX0z7M36VCPCyWQFIQ91FtvYAewS/jLGcvAOcMTMKgL37liJzizwJonNeJyJM+aRC9OAevNmHjFwWcA+HERzohtTtvWHvcfNevf45sFwnljoBy8ePke1HOAw9fgpQhS5g3dApRUe8S0osSDdE1ydgWdmUM/KTniijMjV/uSeqA8SmEiMAsg+o5YojQYvWtL999HefiG5r1a/GzFlA5RVzNq4X4yWvcIUBxNMlRnBTEO8QCkAMB5uIjl7Ms9P3H7Oz9wDL70j7C/dqgJ+SkZGHOJAcQEZorpAV10LbITVo++hoAWbXukjpTbSy+vW2D2lWJG3GMxFrkCmMva77zBpybNYfFqcAyvusRX3m8oL9qeVXTM/OBTd7NR3C8NBgESZCFL0q2H2Ak5PtmmjtOU4Ec/Y7OiFZ937C3jocy0IWi16keWof43/5nrM99inKLzonhoMvihHh4/Tyg/yceHs7giFLBbjc5h5TRD6pxwtgGQDdaP0bwPibPCLfDAGm7rcu/Jqx4NeDvNcqwHKlRcpnQFCzXVhHXAcK16ElDpeuiWMdech8YTT8CKc0QUxWn3CeKEBldZHz//Apjnw4xZmCPvZbjif73D57+5ucVoyh8uga50xZuJ+ArAF/wD4iZVt5zDFs7HCmdT9hLfSrt28Bt9lrov9dIyWUCJS/uK1IQI88rgCrddQ9ZK4eoQMCWEZ3lUgbb6r/M0HlnGbsD0J3o791TDh5DLCMo8MhQGwMTihISlcA0guuX9IHswqVALVLa7McIOfyFMVkW0VfVI10BtTt4NzTQ2fssT/REWQbWNapzIhl20hN7u9wfucQZwvWPrMjxDxyKw1ZQuScMT1nXp4zJ6yDHcAy65j1kzdSxx6hQoaDMg4xZdq9e2k/dcCeqkSk9xxnvZkOMWRasM60znrjIQ4AaTVkD17GCc6IZc5jPU9lP9CD7Es3qbBfAC4//yGrsWepwwPB5chUxJim/YBynSQ7yXA+BbxFX3Gv6W3ME96mu/e7dCfp2/R5ulI6Ob0vvv1CW/zGF7761j/62Xv/wg0GOzjRVg31NWDZ2spFjeW2NZapr2yd5c9rLBfX2/zUV/j9eV+/ctjmMrs3Ow7sOLDjwI4D3xYHdsDytzVeu97uOLDjwH87DrAd5+EMqyt3/v8WWC5YGRv+rV3+9gPA1sfF4Z+0yRiy9dFXTvjKx1snfjtvNV5uXrz/0r0l24OGRF4cEMfkB5aKh2haL+VjsxQRyxgjfBSvYtC4jVgm6ghgsHHyGMMYNVYBR0yDPSWKREOidQCxiiXDBuYAoUsBCEFmZccrLjHELTAaaMQ1/WWR9tV0gckyG2gchgLqsgY1iT4kbSQGEOuQWmu5pLEH0vgTtThNxwpYk2p2WberHtHQ19RivoGMhjKSCyQDew+RYnGfyczQBiQX5BSsa5AK23qodaJKiHnIBq//K+uTAnIAaGfazrXGQ9pkqKe7ME0eLcuYLiA6RyppokCpQWtbxbAdqZsxtJoK++rFn6A/Ro3WGALHDPTRiOWUDvtTYHmG8eyaGsumww5gGUOR8KSGEkfy1mCTBrQYvxhDjkj3WXznbxlZZVo8PsPAtaLPRlGY0m6fqKAAxAFoTeEtCXSmiGVAQ4FO00rTZ/0ATTXYhWdd0nfbmpa5QiSe4HKkwgZUts5yApbpDL311UF2gt+01r5N9ZEBljFG9V/9NWiEUVwDrgYqPw+9E8KOHNN/oyIFsKoYxI2eNRJtH5B2QUSoQI1kzTzTMg9JdWg0U1WQUv6pwxJLbm1I/J16F10MzhbvErDsPcPPuHe+gY8JnA+IDVA5MIEYlbg433uMfC4bfaWxlv4WQH70G34fICM9UtuaCrogUzOGoRPAYypAy8/5uwEsk6ZUOTVdqWnAk6zCbwCam5d/hnd/AVimVqA8My299Sq9kVw5WitQBwgdIVrUFo/0sPBPwMfo/5npKUlVObogpTU1G03HbRRP8apTI9R0qb0HRtc/QrZNl0pqclOmvsNASyraG+bMjEgpgeWIDGSsShgzQT8DDBH82CcdsK26YILzhwCIdXe9X6Os1AmOU6QwxGiZJB2Z82bysbNPAn4FcBP1hqk5uiAqcEG7R2TREWCH0dFNdMaaOuNrQNwFDigCpjeAeNe0Gl+9iroqrplf17p+EaEKmFjCyUXjp6CytAbsXcDnBelmx+iWAWmUB/BPJ5eIjBYEgPYwiO/fUW+RbhwAwe8kM0Ok2uek1iUqrU6dw0Yr0QCj6jURfuquORG0JXRWieisEnpLjVVExBXAsvHcpm3dI01npMI2ihdQuQCWBZU/BrD8Cv1MDUnmgffaPSTVKxG3R48eBrAdNUQBtoxQGsKXAUZlI7AEpiK1pjWQkaeIMvQaziP1QBDnYTR23TB6SaegEuBHCQN23bSojjkkuDoBVJ5+eJ3aAD+sC2nEMobwQmMx0OqwkF3amDeh9TDK60wiiC6wTNRU2bIFAsukCj01WhlQOQHLrEOc6TU71IoVWD6CIhU20dxlwOUSfAoQ740RZ+gJxrXMOiEJYHCD6X9krliLFqxJBw+oZ2sacagOIFDUp5zhGHFFtgTrU9sGL9KoRbR2Sj2Ocwh6cgmovMJwvkBXhSFfYz7noPDQ8YyuPFZ/MF9dQ0yfH44gEbH8O9LOE5mYR/+Z8n9B+vo5Ectr5CXmTb5WFEorHAHUW0k15bJe8Dj+zP9JEyzm2vbH+fu0ZWB88nmYxih9mX+klCagiTvRaSlq91q/l72DJQysS2+r40/U1cR5y3sw0i30vnorZAB2cFGBBUErqbWPnHOtPfRgG3DO9abW6UZq4wQqJ3C5Cu8azKsm1AJMbrMmtx/8Hnk8AXwBvEbmbEdnLyEi6CFrGpeZI1GbOhxacKDi1uK+vFFkPVelOTfSd3GM+t5jOc7jbZW+fBeUzdCDU/SuZLkLIxalA6Iw12QtCGIPE6mwAZevIctoEDNJ1HKSYzVhYXyvdJznpKMlCrHN3O8BNjm/BJXGOPiMrFUKSLMAPFtCOhtt9Cj981qmwnZHUQH0O2ANPSBVeA8eBehOX2xNETwAdBeAn7OOJqDduW/GhEYClkt1HCaIIodsdSY1ra/OMJY4uAL8uxKMPScVtqPpWhz3lPRHTDL6FCyGecp8gzFVb1uPtnmXPSclRho4M437g+wGIE9nkDERy+RUZl+Hs6B60sHJ9ZKRygLL5JAAWLyT5itrgU48hMTD77THOftwmgVRFsE9ZYPsFJIps61dvQ91DvaZXzomune9QT/i1AFIPqAV/FdeSoLKRoiGjNgP54g6EX0In3WC6ebplHWoEzAV0F/jqNIn4vQGUNmWzcqGQtcDOlqGwpTg4UxAdHkZaplGGGe+FuUZ5qxBEaEuKGc2jZBta4cLlObOBLRpTqtZZXaSZf7lPfK6pRv4M708If9jMwf4xvd+7JWUo818d44ysgJ++8ik4HKL9agSpRm4V5ytLkPXJn2rA0+JdYWJmPPOn+XqrJGVFjraGt5tSloIgLKe6zyx5vg54Pn8Wmc0op9ZowbsHSZEjus0AcfRnT7vuMql+dfCie4ABzqdJts4o7DYwGPqCvPMcoPuSfQDuof1G/lRV0amFfYRS6jUIhMRe4mCyEWPvDFnoSE6W2Bbsja2cfzhrAYngrcFr+CNEdDut3V0O2RPYORxV+CdtasElcm6ccY6dPbqTXYOuDwlajecPMiy0iBi2Qj1E+jIPUjoDKK32dPosHGNo8MVoK5OWuVwALMfOIgwrmkI4auOCRKgbtffx7lParZwmtKpCh7OoUt4avaMCyicXkKz8ZxydLzJuuE88rfJzc+zAuUzmNtXpOO2NnNRPqNCpgXHRDmJPsADBjSoRKvOij0VKd3L7DMXrAeLszydO3vRIVmiRqyP6tAo60MrsHwQwLJOdHkq7ACWK5GpxDTYZiypRcTyj4Fl91BJdpW1jXhHHz/5BHYp577SvLHN5076eOvf4sjb6219md7eHvKjr771D5J8/fxdfJEFnOzn22vb5zWWN8Aymak6PK8LLDe2gGWfZRGq1IHtznzhB7e/Lnr8hcOKr3btjgM7Duw4sOPAN8gB1mtW7N1rx4EdB3Yc2HHg18mB0NAChBpcBZYHRCr/CxHL//P/OmJ5+4YLg6WfbS8KP7X53z5u+1qfv/+pa3x+7Lfwd/HAG32FCcX9aTwu/vKx3kdpaZtPmJjj+PRvOl5jiueFQYaLCBRYf1Vg2ajlSOFnGt4cWB5dY5jNKWpkYhywzrIRbgWAEUCEj40abGgXGG8jmtKoSijqEBO5uIlYCEOIRkuiTXLjYJe0bfuks5NMa6hBTiphoF7NE2C0wsCRzEgARXjKD0indvHuFUT0Dsa2KoaGKsC3tSc1tdkb2wQsGwn6JK6tkVpg2ZqN1y//mF0DBF8TaVzxnvisHNEAGBiC37dGNdMArkn32yXipwv41r33OwzebfiHER3DjRG0V8+I4oVGAGlhBIXbwLwBKrcBaE0tXUQsW2d5hiH3+rnnCCw/AxwVGE2EFZShYqBzfjmCRlCEsS//rDAqpXHH8M3nBdBpFNwao5k1Z6PGIgbl3gMAcShATkFdwF0B2n4Ylo1YThEMARhyvwLKPdN4Q6bCrsC7W2DZiOUELNu3eNHdtsDy8eNorX2bANI9jKAj0mcDvD/7U9Z/472mdJlRizEk17tAjrnvqA2JkUoZOHj6j9A/ASz/AaMvMpWTqceHpy+hVwEYpQjYnHeMvf8nyt/HZ/xGMCtxLB0gX+09vC2+pg8Cy1Fnks8XIL+WsBZgjs8BNfyugoG9QoS1YH5EcyLTRqxYm28PPu9DRm+vkV3l37TpAwz5N6Rnvf7wDD8IAFrvmeuWqVO8AWgCWFZOE42JVjL1+OWz/6T++LuQk8Q/DIt0uiBrEBdOEE0i9Q++/6fs8Pt/jqj9BMgDLAPOG6UmDQRbkAPFTPbUBYkibTzjx/lRCzwf84HRyjhOCHBbO9EolohaBiSoEH1UDkN6MtYbeSQJJg3fEi34DqcFoo800qsbTGMfwDL3noDMZJqMOWNf6IyG8AQ6CY6kmT8PULkR4PIe4N/x098RpfT7rIUOWxHpZvphUw8PicoeQNYfTRFGCVx28PNf4tqYqJkfq3KDeU2UKikgg6xpicPHEkeRJTpmjFG7T9rjAWRK7KjxzLmO9/7xvUgHqoG9LpCJvJr6FFSN9ZPoZevs0iZDtFqXersA7ReAr+qtOUBnDX1aMx01+kcjbRG1nNJgp7mgfjYVtuByRCwLLGPM39RYfvEqwGUdDUy1HMAywMTRwwdETRmRB9jCOBmlbXpLIwGtYWqrDJo1wMhi01WXIkqdvtJGf9LMiHmpMV8i3BBDOcAypPPI3gOBZdJnUiNyBqg8zcFlQSej6iYBLAsEM7IoVrVY/Bv6TIBOVxqM8oBERixHdDbG5YhYxhGoZIYJgMpTQOXTFy8+AZaN+uughwWVJWszC7qXGAdl8vz1i+z8JfTqBTJyndWWIwj5g9/pZV+wnyMHc+TB1gjs4yeAaE+fZg2cKlaWV5BPyNSloDIGecFldZUaXlnaI5XrSQ5Gt9vdSMNqWnSB5atLI50Fo88D9EjAAOOEHrHkgOmczVCwZ4YDone6pP0fASoHASrMWN/mAsvQCpDGtVdHGsFplVbMG1vmjF3aOMvQu41Oi5uNyZXeedNfeKX9GTzh0OIQ2+JMWyUjgGDGzFqkew/p9yOiYe99v9Gb6kedjm5w2upTHmLO2uLa6vqcIu3S9eW+Ossaruqvxp51TnGuOf4uHGJcd8KpiXTYASwTsXyBHrQWeBuHgpYEmNQkyrmJE0+FsR+Tdn+CE8DE9pJ09jjSTKhPC3KaZ0pwnUCS5Rf/OYpxr/xza6oo7ph753P/koxg9m/PkQ/FXmqG3p8ILNPWAUeOnzwNedgHDF6T8nUliIT+6FOr9AanAcmIypB8xtE54fUimwy8qO5R6xVeVEgxLnDaQbYl918jSm4McfAZw1+jMwXMXMu9RsiD14L/aoI5slmFJ2kt+KeU+UM9SZ/m9Cmcs2IdfYFuBgjMgTfvdhZpsJkTtOrakyAc6pipMSfMSoNsXgM6CX71kXOBP0Fl5VOuFlykZwGCuS+ztnMbeZec73VrEZ8kGgI4XQG6XQFQWmO5PNcRBGASp4RwZlKgWXvcP87QF7YC79G379nfEHW5RpdJS/TO+elZdnZ6HmQN3BZOJy10defQGuo4okQd3G42Z30y1b3tECB3iN4f0Lp/TU5rzjfXPCSWBdtyGO6tdN5bo1s7gsp59oom2RJ0VrJestkYdCbo52NeWU24noTOByup4rgVxF63Qr+C0F0VokwLsvzFiL3uiFTCMzJe6EwwxynQtVs5ZBuCLCuncjm16S19TB/F546HAxJjEv/cfnw7Vs4ILyIY5ArgOqwsRYLzmPftWI8EllmP4KNrkeveGnD87OVz9C3OP1B5PkTXcq/uy5EH96/xCjCX/X2T89g7mK1oH7K1rEmkeAeAFFg2MnsMzXBULTPuMW8ZhzRXnH/lyM6yj8Ok1DrE+SJ+xnFakuL9r5FlRT2kA1VyGhWQRUpz51adY46efL8h5+kSvb2ibMQImb5Bvp231sVOs4pfBVSVt/xK/JccrwSWqzgu4Mhp1o0j5i3rUQUZt5xDhSwOZ68BlV8ZtUxaa/YqpkN3r2Aq7DtPvsvuPCVTBnuRNU4xK+Zo6Ax+//rsQ5COYKYLTxkBuA/GJxFYOmDuskJZknILWST6+Slr2BMcbrj2bcTyZXZxlkBlSzSs3GQxvqbq76JnXPNOOC+AZRzpVuiKKIVCGZU+stentbayLgb2wyekNMvth/qrCW8T9YhY3uNepArPZ7GnIkuO88z9WR8nxyEOeymtOecWEcvI1UHsdQpgmecH9i5GKgsqn70gYpk+mE/BqGV1qHNT3RM6ECHbFvvUvyR6xRwo/ira0PEMaC6hxcd5++mn29eOAz79+rNzv+0/f3SvX7mdr7FAvvpyZAqnqa8By/cAln1eLyKWK2RvCFCZOfVLgOWv9fVrfYuO7f7ZcWDHgR0Hdhz45jjAfvfT7e03dwe7Du84sOPAjgO/VQ5sduQ5sIzRI4DlfzMVdgEsj/JU2ASnRSrs8pdTYXOtn9rIF7YFWbn5Wd5/7ZztY36K/V87/6fO+bV/VzyU2c+4v4K3WzcL3gUfBZZ//EqHJUNR8fCvEaEwhi6xwNRyYDnAZdLI1QWWAZdqB/eIQAFQOcegcIFhXXAYw6wRwQWwrAFRQ088NsZDOQYfjJwLjJy2RgxYfzhFOxPtwcvxtC8BKoexihqJgBPdA4wwh6Q/I0qpTgRSgyhLUwoLzFifN6M1heAKshVYvgLEuLLeIKlrqxitaxgZNLiEQYx7s03AshHDAMv8jmCZ4PKKKJSoEwxgJ8DseRoQBXeNiPAl53wgFlQ2zkwgp4MBu3OXNJ1EVUVEKdFptW4nokoFiBOw/Iab5BqwRiN/JweVb4Fl6rRuA8uAy0Ys34Kj3K/WMcaqaDXaxHuM7yXAiFRPt4ZFkc8lDEMpglZw2VMFlv3eGpWkmwTwbQfg+whg2YieRCMM7n2ilfoAnROAwBSJSt85v4hY7sG7KsYxQeUNsCwgTtTykFrBxUuuRcSy4LKR7wDLtTzydo6TweUPRDkDDNxgGI+U38iPRqFknPIqAsvKBpLFvQss7wMqB7BMxNViSGQWRr+FBnGj4fjtAUZxIxEDlDfNrAbtYn7IQv/wb/kZ0pd+J/6lw4UpyTYB93wjj3OSD4KIUVuW96Y0NMLQtIYBDHFdI5Y9R6NiESHePSFSHiOJ0cIJyDdqWWAZsAVeCy5rqFRMpBLgppHKiQC04HUCljsY/9/Cu/8ImvI+pU8lZTq8CwM3F9DYLTCTABrqTgaw/M8ACv/M2D8E2CGKjwhKAeYBUXyC8vIugGVuWfbUmjiZ0N8W0QIxD6nN2yCyq06rUXtAxPSAqGUjdzSILkypCk/q1lelnm0dMKSNIbVDatE2pGF48PoHgCVSeGNMjCgyo4Y0iNNnuIpUJwYU4JjjEsAY/dFxQsNxcjSgxRC8IGWxrcCyoPIx1GyRhhsDqEbQJTIywSgrmGmL8mFkkQkMoY62L6+rbnCsJGuod08AGuiz7VogEUcRgWVTYQewjCF0hCFY+fRcdWfv4AS9ZZTsMXwi9WkQRlQM1REJhCdCpJydch4ON0vaa5xOLtFb0hLHkjp6qw7YVgtAOPFD8FWzrfctMNTGIN3D0Cq43OL3CkN+AMt5Gmwjl9cA1OoxweUOOmkf4OQAMsVlhWgpI6ZM4z0jUmiGHNgK/M4A+6cYrJdG+qmvjSjFGQLhIFIPvtEahe1YqA/xQMjT9BbAsml6AbABaaamPSYddoDLAE+m6b2NWI5ZlsbA+eZYxOgEvMb1U8TynhFLGLk3EcsAy6bCLoBl2yX9NGLL0Wh3WtkxhvwELGOMBlAW6BBcPgNUPnuBMRqgY818qwPq1Fc6NuhskOQBiQNEA6gSWCY68+ARTgsAg1LDNKKkbl8hTzPk/hKj/BVkxFfSySli0fE5ecx5RKm2iMRckTZdWmCcvwZQvjbyDXDZMYpUpvC0CjhaA4yp8RsNU+k+JEPEA5yg7j1Ct31IRArduanZR0TRkyIWhoYBPQHLLDCFAqFFJEMn2XpPrsx+ffuKL2T6V19FJDGnbw4rDo+z+UMQpQCDjczU6Wf/8R+S0xLr9DoHSwJYZl3rv/trcv6B56GnGekEx6TfSNdS5wPKELEc6+Ux67XziXVHMqLzUlA5T4fdrFeR8XbWRc6b7Bt0hmuQZaHE3BsCxAwBOo08nd18SERd+RKgbLgvIDcpMwD84kbVN2Gi4N5u+ZXzSk7lDHA/xtLqGdE6H9QD6oMUsQzUAchYJ9Iuyc+TSGW8BCy1zvyK+TYAzOlDtoKW4SQAP9R/phd33VOP14jaqh/cR6eoi48Bz49oAU0Z/z7OPeriMfVK3V/htZX2WXY0+uo6msZI3lZNV4+D1j6ORmZaSXMfAA8dMGb9H5NFY3SBPgpg2Rmp5LjvQdeWJWosA1AVQJVjaB16U8SHfgQAvoGGgPn8KvdUgDwyL73c96fZiqsdwLI1jq2navroKo4BVfZ8kg48V69eZpevBJaJgF7AI6gMOOkYFevdgnmqE4h9s6a3YJj965GpwcjMFWDkkvaceXdxBph2Qd/cBwH6tohqF1juoOtdqxroDzNrTCl/YDsmutOyIKaclreuU1XuSe3ndldHsCCzUzDeK9cPSjPsk/p87wERovC7xBrFxiuAuyHg5IB+2AagDCBWlRAmHdPUAxXk23WjTDR1RUcpZRKeifvJB7N+jIlatQ72ikjzKGGBI6Qp2t1+CC4nGVYGCjlIb4sxUDg4zKFNL1sOTX/yhlfsl9KbkOtirRRYLpxJWqxHOjmpozfAMuDymprEpy8S8Hf6gv0szwuRrhhQUdAv5pY3Bc+yBg5YZLwoEbm8hyOPvJOMGo9xYCx0RnOPlJyf+iFXASAyCDH3QtoElu9F/fACWHYDnFJ+rwCV/5pdvyHTCnXEdWhj4889o3/cq+kARsaSMkDw4ZMELB8S9b5mXiyRQ2kssIxs93E0cB3z6YmVGZ6rw3wlTRbzzbtk3tXbpIFGviTlrIqMV3I6f/0WZycjlgWWyTaArlziPNvgOeJuASwT4bsCcFVfqDf6Mb9wRkGfuY927RLYdZ46ovbDds5cnTFnbXusIXd0BPlf7J1pl1tHcqaxA4VCrdy1UJS63W17Zv7/T5jjr3PGZ7ptSdwpiUutqCrsmOeJuAmgKMrtOWc+mC1ACiYKy0Vm5HrjjTfiyXcRQSOAZcaOjOUElt9H6ZnXe4U477uHlXnEerNg7zKqkeXNkNDVtN/SyCj8WpwzUGhowZHjfrgA7l0wN5eUfa6xi1Ob56oGzlxxpuJcNeFceMl5agiwrKjRxZKVI4Bl1irOOeG0gJNxRCwJxjJhxAWWnzO+IhS2OZYTXI69kF92bMR5MvRRVSuKzRGOtvLPzQ+w/mYLNu+51x+4/YXs9+rd22+tv/J38OxWO/+D9vyWCjZ1+beA5Qdff0c47A1gmf2v2auAZVZL728ZVLcfGz/88Vu3P/jJLv/4I9u/txrYamCrga0GPhMNbIHlz6SjttXcamCrgd+ZBjZP5IIysJUNh73KsQy4/BxwuUkIt0GnljmWW+ZXvg0sx+0t19o4639SkdoVfvNR6lJ9pvzp5zef+/fmZTaf+97fy6PcmJX2WSpFFxqS1GfIpxrtB+PDfAgDlN9OQ5HewwIF5liuQmETvrEHuCuorJG2RX64c8IHXiDnb98RbhGQBuaIhm3DSWpAFA7QlKDFKEJx8mMLmZm8bxkh6TCgYz0Jg06xd2mUC/CQK1i2MaZ1YdV0ARLNDbsL80jpHtzje2nJk0U7vSRPYwj5WjFQCC4r5h0TWJbFKTMiTIAYaDV0FMayIKkhCgNYxhgtY/lMcBSRtVxAZY2maqo8ZGsIKhdguW9Y6whZLLBMvfcAAGHVjc/IgyZjmetdA3ZrgcwwcwLLhpSmTUgwlvl8G9Z0hsLO7wgsNypg1LJCh+kyjWTcVCt47Tcw3ukMYG7sFkBgvc2kxFAbQDOGSrtZQ2N8X4MRgEkdQLwzuIuOMcAjS5wEwlEA5osA7cUvGP+R0cX7yvhHf/JbhsEWkC+hsFvU+RawTFsFd2OIhdUQYNmw49HeAixnW2Wvy7g9RUeXFbAccFLoW+OcjwSWI38n7U3GsuAoTKtgLCewPAVcNsyqIK0AaQDLGNra9H0Ay3ElruhF0UUBKv2FfOR7m0Y5DR8a2Sxte+Q+lU3Y6aFnALkA5QDnYM7VMQLXKR1hYU5T3443jJUCrQ3YSt0BBus99A17eYlBc4GBTr0XxvIFYP64ApadDw1+R11HjuWKsdyNsO2DAJbPfvzX0J1sHjNLCio7Zm1irAM8iTnF78/QXWEsB7AMyDwFFA1gGbC1gMqWmXdQHTG8AAy7AsTWG+N7H4bcjsZjDH0jwo5njuxnYXAfEx5xZLhI5u8ORqA+gLSha7v7hDd1XlAaHl4nAo27Gok10tcFQVgfBGhihsaiYH9UYgeFPu0++oPrF7BlLqiMMXiOMXj/IfmVH8NYRnYI4V1CVxq2cVIxumR1BZwBu8gyBwT/cv2AcDUua7RCZ13WhC5AVY9yCaggqDwnbHXkWDZsI4bea5mH1qmSHgZP81L3WLd27gIA0W99HE7arGXZMRSA7xOBQRiblkNzmiMXMM9lZwWwzLqVxlFaTN3USwGVBZgjxzJG3z0A1zDkA5iuGcvPg8UrsCxgXyIB9Ai9vUsf7MJc3oEtZajlyNuNrsIpQEcdDNoznB1mAMopAPM3GLtllaPDOeNVMNwygBQ0KMAcwLKhsCvGsqDyAezoAJZhK48CXH5JewWWAa1lX0UobPtY7akeZ45iz7gS5I7SA0Q0x6IgegLLsr0KsPy89pZw2ALLAiulJ2Su3sF4fQxQtG/4bPQfwDLsxPd8No3RT3E8AFiGMahBOoDl0DUVQOkBLAsuI4cAHLeAZQzqMsgMJ3/6njCiAS6zVsacd9FtkNMaYBvmtnk1ZWI6yFxP5rDWLwCVDM1uaRjR2BeZA+0O83SHMdfv1XrMmR5zrUfbO4ARl4RLvyQcsDITTCKsbOSZDaDLUZvgXewx1dxRr46fWO9Cx6nnUDJ/8876qc/83y+VR/XcPvFR3it/ly/rQLMkFLygWhuW5T6gsuvzgBD6AunzEeOJUjbskP3h6i1sWKIAsDIxPnV8cC7y4Pdc+QWUA7Si7B4QPhbHrcE9cu7qXAZIr7i/nRDx4gNiudNr1fYZ3/v7hFQGgGiTZ7XF2cGxeUHI2MtK5tcwPK8/AFidsL+OWTdTd7H2RBU2FJAqiapF5Xxm44sCKF23/IZpRgJUpu/jjAC4OAVMnLI+CSwbSt0c3fusoXOY0zNAV0vBRcPrDillGwu4Ofq9pnNdEQzu4QTWlb0VDK5j9MI6g8zJ0RuRI0y5QUqJBueYDO/NuSvqj0Yt2cPwWIiQ/W3A1L3H9BFitJUbALMRgM7I8pQQv6eyQ1mPuLYAd4wS2iX7cd5KFqSAm2kHjskj3sDxZH5KmGjEFAdD2qVcMz88DwrE2q5oFO3y4ay3lUqdeu0xT3XIEXxr4izT5GxmOcT54uQFwDIOITKWZbvK8m0yX+wGYSxL94KoG/WTsVzqNmC9m8M0LnJ6ypw9BaymbO2QD5xzbZ9zbp/f7R8fhZhixagawzcZXcNw2DJDjbBR4xzLaI82qRvXv6iH/d8ynQvhlOl32coH5KA+JKSy0X/i3OX+AjI8Bowb45xiKWO/nCgTpGQn4qBvJBRDhHvucD+a0a9TfnsK8DhhPzK/u5ELXJ/N9VzO1OHTxuCJMx/1cz1IgBklrR4VXMznHGf5sBX5WL9WXsmyOFG5zgllxjyljAgarFX7OPNEBA2A5gZtlrH8LsC/H6Ns4YQa4J8On/Sc4zIWFRwel4DKy66RKHAexJHngBzHlosKWB4T2SWAZSJFmD5DB6WcK9kXGYOEegFG6oBy8IWM5T9GWHxBZc+/ri0XgMoCy+ev/z2BZdce9iB1bASiZZuzHWc0w2AfMrbtvwX7/ZxxOD/FuYBxLRNfEVjG7dEZGhLKrJTnGpCvcl/M+dyxvcc6YMj1Fs9T7tZOXv9UOxFcphzjBOceLGO52+8T4QDG8mPONYTCDucIHBssDQUua/qCM5RsdR3H3C2da2UfdX5NcGRIYNnx+GWy+AGXdwGtM8IAwDIOFyfuYexHAsz2bV0GOeNuwJ5bInUYFnsVwp+Q2BPOUhPOsUrkGvfcjuSMTCVkXUxhpOBwCFO6O+BMSVnn3lFgeXH2C/dKrBmkF7lkvRgSQSfu16J3YU2jM/d/wWXX9ZIKwzWxgMqWLdaELuNK1nIA7YLK9K1z1Ec14uN5+afsZ/69+dy/V/fa1fd9LR+/NTv+c2+Xq3xupXOnPOzXzcftv9ZrStHh5mfL81j/GWvOk08xllfAsjmWcaaStfxJxnK5oOVGRUp917XefDs/uPHxzatsn281sNXAVgNbDXxmGtgCy59Zh22ru9XAVgO/Aw1snsLjuTfdGD5r/xlgGXBZxg038R7Y0yD1t3X28Q3d6hvx++Xoz21CecoHbr1VfSHe5o2Nj60u9ffypNyo2caU1LXmhACTbChvCBZ/ShHaT7TmxL1yWpz5XGXgq8rOLWAZQAlguQvbsgmoe/rTzylvzAdorjsMbUiDMGStehpENW7ED4g8+EP+aGW8CcO/N/zxGcIn8paMEz8a7ByNCQBHdXIX17sDQDsMf4BgGogOviJfGkzL1f0t37shL6wysgTIlWGrGH67sH1lsXnzGr9KKWtUUHcTWG4BBgdjuQKCL2DeZnjRZC3LGAyFolbNN4LKYRrDaGxIbdm4ll0Amx6gRxcZkxPOsNbnXPMKtoVAeBj5uFKCyl9HKbAsqCxIOwXoKGD0MIBlfk2jkayKpB1HWUDOOkZMQU6Z1zuIBkzDhddh89W7PQxEjhJu4a1/9Hfl6Y3hqNmGDUPutSayADgyP6J5Eq9hK53/DPiHCCz7NR8aOQWII+cvZTLHst6RY9nc0ALLsKYKsOn3guVcgdFd6pdtHURYdEFl22toVAGGAPMx1Ll2qHE7Owx0AKMakoKxDKicobD/TN5MwFEAHsMdmxu6AKRzQAtB5QBb6bFVfRyPMTXin/iF/Cd/TWOH64yGE8Pw+bel+XMbiiA+AL56lqXThZVTBwhSGkjo2vHuwFZx1BkLHSAI7CPCYDbId9fAAK6ulxhGF5QBLAMqJ7CcOZatpr8lqByCvrsAJjos6LggY/kMxrIykrFMG2W4yqJSc7ZGiTlFHWQt9yLHcurOsNapuwwlLlNZsEf9GVkgwRIM3NSh2T8klDcCODcghOEAg/mAsNZT5tsYh4kJcg3b5Or6pnZ1BYiEAXEfpuA+zih7zNdmTyC+G+HhrwCWzgGWz8ljPoalYihcjYAREpf6ojF+2/WpEhcGWxLdZd/QH85lxoMSQALGYMu9h19iDAZY/vrbyGm4JHdwDQm2JCCmOX0XACA5H5hPrFfl2pZpLEu2KZA6PhsY9mGjWy4uMCqfAJwALo8BhMwFeAWLaYRR36vEuKFsdHU02E0mHH23z5plSOAe4EXZwBYAyyPG6g1AsmHnbzAOX7NWXKOPJaCt/dhBHL8RJtphxLUzFLYsMQznMPtk8coS62GkFjRNYLmHAV+gVXD5GeFiE1gWXHZv7tIX5qE1n+kOrM6QQxxLdEZhjCqGNDfdwELmFGCg+bOnAMJTjfkAmmPmVrDkGGtliYfazvgn9zHSgZ0nqHwoY/k+DggCy5V4HdnQUwF5AGz3huKAlD0vSMN+xJxJUzlAawDLGfY7gGXW2Myx3I+2vqWdgssBLNOnzlpzLB8LLMOQ2ofV2Ygcy4LLR+hFhtNTvvtjgBYCHW1EkDNSBzDGBGINZWxoXeXgC0Nhm2NZxjI6Yu4aztgc5aeERD17R65JJIBlAQz6SBDhmJyaR8wVQ8VGKFwcTGTEXwoqEzrbMpmGgGSMzU6XNXZ/tzZgjveQFvNdabInn79+ibyIcs4+oUMXigyALffeBFhij3GvYQ55OnAZcl6Vfy2dVfkoz51vOQvic/mF1VecHT7iXy5o6ed9EvNG0NLx4/ooaEl+U0HLXUDLTTa8411w+frDK9a+i1jzEwRwPlY/R2nfC9/Jzu/B0t27T0jjB4S4B1huAga20Icsxw/P/y2AZcvdHZjlh/u1A2SH0NNNwELPLAvWbcMon71RXnFe4dwyYZ0lT69pF9pxbnHc5O8XjfBnttEn6tEKVg+X+KKE8rrvxtpE34fjC2eDGWuT0mWOHsFcPwJYNgz9DMbpDGDI8ppQslchsNdxjhAsE4j1B4SsgIm5HuGdKycVyy5Ofxm9Is8MnjGMtpLpM1iBK4e0crayugLxDc4GSgfQdsDapPTJY3zNWLwG3L6GSa9D3AQ29+SCMx4OJOojxHWXs8LScM6IuVptk2UDwHBK/nnz0BuJ4hoAzPQDN4CntqXkiacaVCT16Jo5Y7MVEBRYNlRwhry/F2uZc9ZQwc6RE+a4EsCyoW4BY13TilNk7NmcGRcdIgOwx/ZJSXAEKHlE3frMoxmOO3PCR89Yw88BsM6Zt+fnl4wj8hbDbtUBSmC5B7t5h/zKrV6bFA+Aj0TjsNQBTCcd0LRICdBk8OPWF2Mgzgi0wRE0t8+ZBwLMg4f8/tdPgvkawDLv1zlLOHaMBKEYySeiFaCFiKShAyGSUSF4DsDo/qWMAPJGgIiKYcsFuefXOLiEgw6/7loaumYlRceqOdcCzlCeR+JRRqvdUJ7bHzGLo/Rj2UX5esxz3q9GQYxx9e4+b5QhweUdzkE60uwT6rkHcNpkvWswRpecQQNYfvZD7d3TH2stmOaCf4rrNBdljvE7hhAHVF50dBjajzF1QN8dMr6WASwDKnPOcGyN2IMKsNziXItPM7KsTR1L6HeK9A4BlgmDvQ+43Me5pI7TM2Fkon0BKnP+OANYNkJAdIj3JwL43ncghvN3XFsHZaETCPNDcNlQ2JeV48QI/Qd4iTaijEUEvXLunlOfdJzgnpiz4R5rkvmCdwFHW+iqHcI9FfdSgsunr3HoAFgWVJ5PBZZ3AZbJsYwcPmAdI+y0YmQAw7IX1rQpZfztAJbpLPsm+opybE50ZCxj+f4XyVgGWO5XwPIy9najbsBWZp5ZhiMk47eB7OIscMyep/OIuaGNFJXnKurImNQZdx5Owo7fIq5d5WFdnCnpWtKks2TkN+w01n+dUQSWJwDLl5ynhszLIVF0vJP0e66EASxzzpENn8By7v8JLOOw8HyDsYwTvGMrzpTMhwb3TRFtip9ztFPEY7OGvlj+diiWh7dMn3psfCTf5nObr21e41Pf/xxfM2pJeayf+cq65RsfyVc/0ovvx3err7hauU+6Z/5NYBlQOYDlHoxlxgabGSXjav3zVubW3+szy8c1Ll/KsvyVF9j+u9XAVgNbDWw18DlqYAssf469tq3zVgNbDfz9auD2+bu6C+CG+zeB5atgKw869SoUdrKW//8By7eP/Ldubm6/teoTb15+463VZz7nJ+XmzTYqGpC0fmo20pCsIZEXeZObaN/zQ9XDtzQ0eXfnZ8N6FJ+pDCA81xCSwDIGtmAsw2oFJOoILMNc/PCafKCvX4fMYVcSO7FWh9WyBpY1r2kw4rbO3+BpgCPUwaqEgZEnllZEe9ecz1kKKCcbkRtGWAMpsKcN4YuR+hAG1C4gt49iIrgGCLuGpWo5ApwxBLYswDkAaeQW1UiH0aVc25vYXTygA+wUrMP4H3ljCTO8wFgZoC5G2hWwrPlMo9OG4jFVrIFljMbmfuwLLCMyiJRbwDIG32uA5chBS0Nt+YCwnoLRA6RTga1tAASZ1sGapg5rYDmNVlirMPpguUJPAfgBHhvGtgPjMBg3AEQ9DMagE8EUqcF4jTlj/WmHv5s3496QA9KSf63RwohGKcC5rMBlc+0GsPwTORsrYNlhEsBygOiwMNFdB4BHMNx6jwHzTwWWrbfhOPk1u98xsAdj05zMhs8ubW0BbAn+B7AMGH1Jfshk3Ca47PfjGpT2mUYkDZhNALQAlQGXD74GWAZQFli+xVgmrHMAy7Q5r7kej9bHtsQIitLnqZn8RYHLNMzZz4LKhuPTGC9DWRBfRmof42AYoum7Gu9pQF1SRlhFxtxSY5sjHvAzgGUMpw1YtU3DLMJmWmgQRiwzFLbAMnmHMaJGPfinuQEs7zBOZCsXcPkGMPkUxrLAcoTCrsZpjNWqRV4nmd7oDv11j2FQRRjxf8TwLrCcBmrzal69g50lk5AyGMvqiZrY5zQYJwXBLXOnfhFhKg1VaWjRKYbBAEcAES7IP3hxicF70agdPvwGQA22D6CF61E4OBCbM4Bl2UL094SxJTNPI6Bsy9R6aC3GjX0Va0jVPzSHN+2fBJXNZTln/i1k0LFe7D3QkP8tYMcTgGXYT7m40BcaQQGVCeVsKaBcRwqwnE4jcXV/AAnrMMOCeRMIEusHLKE5xlxZb+aTvsGh4ZpxNwYcUM9cjZJ2wo7EihylUQwOvvoz69afASseRN29vsDyjeAaYnkDoHxz/p71C6MuLJ4OvysD3b6MeWetqNYmsCxDLENhAywHiwdgmbmxYMwIKL9fAcvmAzWsNjAd12gJlBtZhLWjT7jZnSNDlwLk9GGAAtjVKRvo18C+MjANsSrLeAqQLksu64lxn7VWg3KA0O4p/G4dQMDclALLh78BLMe1BJbRn0B/5m9Fc/a1ul/NvRJmFXY2wLIAuqBTAsuC6PQvxvrCVk5gmevRr+4/u4SyPYZ9mMCyeRkFl/0ejOVngMpP0xg9v74IBp0pE24By4zZBJUjQG0FLK9DYWeO3ASWBZQ1yJ+9wzGAtSrX6TphfQGW792vHZFr2fVCNrfA+5I1wPC+V7AmFUN4G9GjAMsDgOXdPcI504Ya+VbxCOA7TXKDCiwjlDLbDQXckK1s36I9wRVWm9jjY+7QL45mx477pc8dq/6VZT73X7VPF0Tp3/Fh/+F/31s9on+q6zA+8ju8i4OTERaM3GAI/MHjf6gNAJf7D7+B+XoKWGl+YwQ2rODyiLyasmGLM1FJV2Ad/U0dt1wVLHeOWXMefoeYL/Uhv6PTFGsuuv7w4t8Bl7+PcrDbo79hGh4T5YSzS+lvIZcT8mqfvnwRZZOc2g2FiDvxK+hN/enQYsuiDtYj9OETq+Srq3dyWXDM8pl8h3/5P/Yq1yfqZlj6BU4mC4CqDk4ch19+iXwFQHNUm777uTYh0oTljQAsTD3DLMvibzKGE1hOxrLA8gxgefAQpiEMcEujDbRxnmjt7ODkcRqgcuy9Pz2NPa/NuuXa6tQMgIuywR5lSN4287zLWWHniye1/iOccHD+GeIcMWT8XiGTCwBvosBML99RH9KcqBMbyl5Wl1EaQs5Y9oAQGPlsXDgYvapNDFcMeCugrBiZQL16DVfVVFbq0f1VUFlA0LFjqNtD5oplA0Z6g7rWKS8FvQJYhrHMGiyg7HomkBbAMnPVseD6U98hMgCM175ON0QLOEB66GgGKDl994b6EdUE4OqSc8MQabNm9nG42kWM/BDRNWC9N9oNdPrX2unzv5Le499gV8qS5jcB0prsK7algUp8xIrD7we0h4PNjPntvrT3iP3oMfsRYsSOJZEKBOUEDpcwj92PLPkHoYxzAyVrgazoSD/g/oIsYPzf4MxywzntBlDZ/NmZTgOwW/CMMRx1chgiCSyzfnveZBAsHAg8yjoQz/lg/Gd32L/xqD4XXRRvrNcF+inDcae+BZY9k+n0oPPPPsCj4LL7UdP5h/NTAss/1N4/lbH8Q03GMlAn4B96ZIzGr3FdwUxB5XAMqIBlQWXB3SVrdIyrGFvslQDLNxH5Ykjo8DWwXEDl28AyjhM4DiSwHKtjAMo6tik60bnPh3MTZx2dWes4JrRMucJ83SdSRQDLrF1zAOUZjhc3gMuZW/gk0kYkK9bRnPt1nHXQrScax7fzT2BZUFlw2T2sDQB/G1jGYVfG8jV9DahsVItkLBspg3EEsDyHoW6oecsAlpkLsqZlLDsXXEOda5vA8khQOaRX2yfHsnnHDYedwDJpV9CljOWIuqEDB3NNkN/7C8U84YLKRxWwvHLWcxwz7uacZRaM23LuzbHsaSgGUDWmHJn+TRm6drxzRqZfF6w1C849huO+Yq24Yk5eczaICBi0ylVMYNloJbKW/0NgGTuFTmKOr3RWRB/O1TjDMdKpguP944djkC5aPTafM61+87H6Cp9ZPefTm9//zS9/Rm/E/r/RwNsqWb+xqSufr9/h+caX4ilv/hawPGT5e/D4D7VbjOUCLHMfEqByAZbV460fWivWeufPbvx4vF1GQX5x8+vrb2+fbTWw1cBWA1sNfE4a2ALLn1Nvbeu61cBWA78PDWyeweO5xnUZy1WOZUJgv1iFwv4bwDLH+s0bik8p8DdvwuK3bx/587NZwd/63sc3NJ/6zc/5taJPNVPE9ngLpe0ogJgKWM4brtRhaE3jkU+qIoFn3ueOW0C5SJsQbObwlJGZuQq/SGCZULgJKgNqAS4L3tUBlgWXmxGOU1NTGvbjd7Ji+YM+58UwMdAIqxivUBfr7U1mAZU1q7YAKFoYCWWU7ACIyXxSDHGX185GjGHWjPV4p7wB5LquZIrRwvDRIRgxvLYhei0NhR2MZcE6gFjZyoLL8w1gOUJhoxGNswnW8XtVnQ13WdhUggQCxBnumesZYjYAQMBW6hIgcQUsa6ELYJ/vCygH+5eyA+BRwG2B5XM+L/toSM7dMBaF171GVIzVCvoxXLn5imUu9vh+B4aFIZbb6G2C0WdCLldLjT6GqVtgFE2gLs28DYCAHUIz7wyOa31KGTlFrmAsXwAqCy6PMPyUR4Mw0FlnWcvWm/6hrTKQg7FMPunTFWM5eje6ai9AZcBlAOYuwI6gsuGzDS1ZclBfAjYG6xZ9my+4AIoOWdtcQjpnjuV/DHA5QmEDikaOZUBSc0OvQmGTe3QNVCfstxqTpUFR8gM80gShwbSIZkJB5WROCt4XfctS7vo3ItA8rnQ9Rt8CyrKLsAxGG5wNjnpB4h1CxPZhTPYwli9xfJAdbmmdz38GWKa/C7BsnSIUdjW2ZC1H/m701mG8roBlgPwIhY3BLtuL7vwyD8sAlhnzMpbXwPI/JbCs7mDcyn4qoHLkWJYBw7fD2AqYsAS4DbAUtoDASIAJlEsMmnPAgzmslyvCqJ6dwgIjvOh0Ua8df0F+QuTo4WPs5bCFWR8ETa6ILDCkrZfIdEge9GqOaUIsK1WucVW/RFFaRJvon5gDtMm2mQ+xhD/de5jAsozlLjo2BPZiDJg8HifTi7aOATVdbdAM8zlWncrgyG9YAQphEB8yXdI8zOd1BBD0Z37OuMYEY/8YY/+UNm0acg3h3wactdwxp/YDwCCks4fDR2xajC+MsWPm1URHGJnKhAc3HPYVbGgBQ0HlDoZ3dWNNaHKUCTA5Hg2FDWMZAOZWKGzApgXAXgGVLesY8guw3ESx5v5u4JzSgqHcAVRp8x3LOuMYpVESUh/grlOJAIXAp2Lo+giTK2ubOk9o+wxwZCpAwnpSZ3w0kA51OxTUAVzel7FM7mgZy2PKMeBZ5liGlQRjueRAVNcrPdJa+1agxnkvsLxXsRlXobCZg5ljmVDYAaI/jzo2ok/na8byHRnLhsIG6FD4XoTCfpasZUNhtwyHLLDMPiEoEHsT7Qa+ijDY9oS5PiMU9jdPat0OIZ8xghtxwFDY5lc+E1hGXKMdNbZlAFB1DLtf6QMyFzYcHiow3W8CRBjD8l+wVjA52BuAUkH/u12iC8BcbuKIMeP1KTJjDg3fk2MZsZStbCjgSEFBvYPfxTgRkNSOnmt9jh0gtxhDjmnXUyUeMczTyOr658v5Vj6vPhWDLz9Ku8qLtC+vlaXpFwR8dcCRsTz4+o+1XdiwOziXjABiBGOUEaFPBZUVGcNGWHB/df6Xh9MkQuxiPJYR6X69b8QSw9oSFjsNy4wP1t0P5Gs/QSz39vuEPseZgD7fIWKIjhINZMYB4wSm9+krgeUX/B7sdEMpk97F/dXfdle150oDo71UqLQ31yRfReJj1Wcp4hzlO84V+j/2DccB84mKAHSyVwAs78PgF+zchRHrnBj/AghridOGIXUNiyyYaB8qPiL8PX/NAXsGj74DrPyO8g+sL0QaYRwqY9bRsxd/ifQdVzgnqc8Q2lRYk4JuglueFZxPPZxJdBjs3v+KnM33CBP+C0JIfsoZIfoNF26ocIHleNDZ5l01ekWjD5N4B4bqQyISKIzvBeetEQ5lo59fsDZwHmNumKt9yprrqAkHkmgT+kNPinqyffaAjgKHsPsP75OXmLIeTgo4KgCGDwW8yK98+orIBzBFdaRIAdRissacc03bBbBjnW2R2mMH4G6AU8eANbKNY0bU6yfqR0j+m5tR7Zr5dwOI5/lvgLPi4D7hVnneJgS94o3LGXmrlVNEB44W8zSj4ORelcBytqPsSToRLIhKMKc0gsbh109g3ZIKgVDIU+a6TlxTfl+m8gynHVnLAsohtKvO8xT2J85tfAjMOUHmEnbYUuC5zvtKgnWOF/VMgW5VcfxTTfYy53Mc85ZvI/6bZY43+yqf8VZ5Eh/w9ehJ9t8sBZQDWGb1iRzL6Nx1egUscxYOYPkpwPIzcuEiTYFl1tpgLJdKed0KWF4CHMlYNgx2nDU8Z7AnhlMAznSGwr7WsQvRaSH2NGpmGfOOsWS0A+8T9pknhsPekbGsQyYOVbZCQPnsNX1LmU509KeLZjjR/RZj2fzKG4xl1jJZyyXHsruVa0g8UqHophrjvJOhsAWQI/B+AABAAElEQVSWCYWNtAgrbSjsNutCCYVtOOzcD6glZ8lgLH/jvkNkgAf3YSonY1nWcuZYNhT2+wCWPStEHdDpah/l9xNY7gW4LLB875vvaveefLcOhY1TiqDu6YcqnQOl6VsijQ4RDgJYDsYyKXCor3v2nDPVglDYMujHjOUR56Ale5TjVsA4zkzUo1JDNcb8C2FtUis6+0bEDfbf5Q25o7kX8Dw1HuHIxnktV2VWZtYt9aWzibICljm3zImSUdjKhsJum9ICUJkVMda/ZCuzrld1iZFexnT2VFbJ51bt49eqv8ucKW+XctU+vrh6zpu/ZZso3/vcSufMrQbaxlUj1i3f1JPP1+/wfP2F/C5vuop+zFg+vZ7VrljSHpBb+T45li37OIIbtWTNWMbZ9f8JWF5VdvWkrHq+sFnP1Qe2T7Ya2Gpgq4GtBj4rDWyB5c+qu7aV3Wpgq4HfjQbKTUCUm8DyVeRWXgPLw/+YsVxuP1Y3GeXC1Y1JnOg/OtavP4K6b7+3vmHz5vnj3sgvyrLafKvc0MS7m298/PXP5O9sT9XW0JCNilu/NCbbjrAqZVnUGWX1R16D7/G5Ai7H7X4YQsSQdgGWD8JY1IV9IFu5bUhbgGUB5bM3rynfYEw8I0L6RYDLYXjTHIDBIAy01iMe/I7GDscC/4dJipfSeO9blbGKd/RSD7CIsgsIsAPzrafA9jO3YAeWpYbDynLOnSmhIm9OAcbOkFMAGoyjb8lB+e6nYNclsKzBA7BNgAyQQokcyzBuBXcDWAasW4XCBhiVRXuOoTaM3rRJo01U3lZQd03QAh5T6mlONq8jA1qwVVapILFhKkcCy1wrcizDtrD9PuoYUwtb2VJguUUeVwHXCYaWAJbJl3j10zN+qdIphq80yaThWpBz7z4hiTHEGgK7aV44pA4bVq9/2TiWGjAT2ANkQw/m96M7YM72YAfBBMe4fEjfLjGcGuZxSbhHw5SeAyxf/PQDLKo1sFxvNgNYjraivzZjxLbKWDb8+Jqx/JJWVo3l2R65MQWVBZhlLLcwircIxSewfAoYLbgsY7nTEFRe1DpIjBnHDRLGevQtyGCIwsK6XQHLGGvnyDVhOIewlQVHZwDLhgMtRnaqcWtd8G/rqC5ibMZf/IMBMlnh9LGmugpYNmTw7j3CQKPvAMcBUcw/rIFjeAkDCrFU1xm6UjAfYJ8BA/4BobMPc1F9Ay5ggF3ClFkSxtZy+FZg+Sk6F1gmCoB1YZyZy7mMK9mvjqk2elPnASw7tlaM5UUCyxo3bZTXQDJPaQJ0K2AZtreM5ZmG7gCWZSyjtyoU9gLQSsOfoJ/mwQV5+swZKTBmeFENvoYY1Rgua8q8oFeEFz15j4HyPREDsC/exSh056vvasfkmJwCyE4BoC0F/2XEXwGmz5m3hvA1x+kKWMoO2VjCUEQ8Sl8JOqVzRYyLjZyf+w8xwD6WIfYdJHIcRYKRfU0UAOYDAOAlLKdLQByNnwLLYeC0hSyIJaqCWqvUF+uYAI+/VgdYbdBX9eg3QNYZuYgx7svYKcCGBl0BxD5rlmUXdmXniHULxqVADJdCmH8YjecYU2eI5SUsugvYfheATDJoZeORnTXW0lIvtfArYDlCYT+ADS1wmuEhFzDmAjglH6nhsBuEHm3jMCO4rI5d78O5h7kcYbsBQeqMTXOum4tW6THHdlmTdnECacNsji+wYOucMoZhLUPe/NpjwJlRAOyMAYCBek9mO2xI5vgBzPZDZP/+/QpEE0gDYAZY1nliBIgmG1r9yiNLk797gWrS4MjcY25ZmmtYNpyMZUMcy1YOxjJgeIT8Jv+q+aTnrF3ZpwsYWVWO5VvA8kGtzr7y4cUzWK4pRt0IYBmjtBEu1A/Di9KoFDJm26zzhsLGwP/Nk5AAlgUBAQNXwDLglwBzGPW5hm0wdKj5lY8ffZXAMvOobhh80hAIijIMEFrMXFsiljGymROCBLKYbwTs0NcN+4Kg/AgQYARz3PEog7KFlD039RgKDD36T7SHwRP7vD/F4E6nHT7HI16vpli8x2u31sP4jJ+LT/OkKuNz7iUpAstGz3BMGWa5/9UfarsCwUQRKCGWr9HR6Mz8vT/jDAawTMSKkt/YsZl97/XRC0BqAFeURik5qCKW9AxtPcWJDkbfbDSpnfz0vPbhzXPKF7W9g0Ht7v07tTv3cJjC+SZY9DhaOFdPACVPYHufAjDTo+wx0bPZ56xzyWqz16wFjyjWZ8n4s3qtfCQ/mDpMPctQdN/wfCCDVtYtQCzsR4HlPUKiKz1SGtxQ38xP/wKwEeAM5x5FoNC5YF+qa3o31vA5oNfeF3+M0L6WLecsQJl7slFazl/9W8g1UScCLGevt3REWR+Bmg7ONgPqMeBMt8PYbAO+tWBzNpnr5z+xBiGWc/bOxc1ZAD6eC1bjBSCnA2jbxhFN2QUAHiC7ALjm/L5+87R2hQgsy6KMnOycKVg40Ge1Lzl+coJx3qvaxjxvMJcPAakPAakPkGBHG16dc5vA8tkbnBk5dzr+01kQPdG+RbVfC+w6NmS0C0K4XxuSOdYLHDSucTy4fv0UeVabAI4pY8CxnSOccx4+pl++CSe9JhECGohAmcDj2csUHTjyPMGpgDkUzWA8+Mx2eCZ0vSJUBmCq4OiAdBE6RBC1AmkyPyKPNZEKZKdP2Hcn6MgygORwLqGnXAMQrhplMEHdr9hr5+43nC8UQTPXCMetoOhSibWESsX6o5493+dAKvM/xrcfibFMmcPMD/GoXnSN8K9qI4xr5IXcQUJst+01rL9l5lhmjMcaTWoGzobKKscybGWB5cyxDLCMfgOIdf2wFvS1+ZVDd5SZY1lG/FeETGZ+cLabwvA3fYZh1s3dnWGo8+wgeGg/GJnF+4gCLAsu7zDO18DyIvu1ApfX0VloGd/1jLNkT2yxB8qYPjDPMmcdcywvBJZhLl8DKl+cksoA9vKYuaszbQtnSEeBEaPiP8pybnUPE1jWwck84gEsU7aYh03Kk1evax9eIi9IK8KZzH5UepzzBJXvfsO55qHAMvMy5AxgGVAZOTecPo6A3qMorh32UQGXV8AyPN59HB0Ele8/YW3mfmPBPrJg7ZiS5uOMORZRNwCW1WPk9cZZbBem8PFj9j1yqZsbeoozxox0J54dL8mF7HnK0nOvK405lpPBba8i6CFW0Wr8xLi2ho5x5pRRI3R+oxGMa8c4c5ozlVGCiqyB5Qcxp8tZx74OYPk5EUie/xjAsmzlTuUk5tyQFe/Y8PGxbcDXGH7xWJX+VSZHtCDf3/y3vF19NabN6jkfLNfa/M7n/DxWg80GVo2ptLpqWtGLL/h88yub78X3eNNxGmd51m5DYZ9ez2tnAMvDCliWsZzAMlEngrFMGgycTjIUNuAyMy4et34oX/JffyfrmP+u31nv6762+fX1Z7bPthrYamCrga0GPicNbIHlz6m3tnXdamCrgd+XBlan8k1g+Rpg+X9+xFgmrG+nCoWN8Xkzx7LH+nJo9wazPOJZeSNe3Phj/THe2XidvzZv2DbDYpfbBy916+aRa21eYfP7fvZzfGzq0fqX9oXa0HHqNsxHvFmVvBiv+3melNsqjecivBqdEmZJuEVmy47AMgZH83cKKrcBogSWBZXPAlxOYLluvkLA5VvAMjfzYdSydtbBeiGG49O+EGJdfI/PJMsLM5OGIYxCyu6hYfUw+iGdQ3Il7t0FTLgLC4lQWBoqEY1pWDjAiTDGUF6R4+/sJ0A6ZIRXv8bAhqwOAbAAljFeYYzoA/TIvB0QwlrgXPZsAZZPgy0MYEcIxGKssUwNpn69IZYBKtApsGyI5z2Av4GsUtm4gn+7fUJ+/pKMZQBAcyyrd9tuqNlkOSe4ba5iv6MEYxlQWca0zM4wjPD7Gq1kHUW4P0w4fQx4Rxh7lD6Mo+XSG21MXPNG7fRdsuc0FE1hFcwx7oZgvBTMsB9aAEj3Af7SK/w7Ol5AlBhklNewSguwbMhbW+30bQgsV6GwLTuwwmQrtzHiB7BMOwXlMxR29jOVQjdPElwGWBaUbdpWwOUpBsPTp/97A1gGVG6k+INlzARjGQ2sgeV/BFxGCI0+E1QG4Jpj6DLHsqDy8P1zDN2nyS6i7zWwO9YY7TnmbAyPGJeW/Bf/O5lktjhWKDXVzQJYZjwC4ss80tCY+RIB0uj/2XRRO3n7FnkXpYwOw1ua93COssE/SJO4hH0ywEjybchdgKblDBCfvOSWlwLL5NM+f/NjAsvWAynA8sCxhbQZWwks7xJaHUN7AZYxugrQAFc5Avhyts0yQQ6dIJprxvKTf05gGb0FY5mygMpDQ2FXOfs0/qkq+ZDBiWSsH2NkFVQ+/uorVCUsGD9WG54Pax9+eYcw5tDJ3W/+EHKHnMcjQqOOMIKGwFS8kbF4BoBxA4jKghT5YSnTMJ51j/6q1ibVYR9lf5W1KsGSOUDdvAFrGYB57xH1AlQ+4re7AC9TjMFTjJ4j2NQnGIJPMQRbaqS3VQGeA+K5ChlKVBDX34hG84kEPWVDMbPQReaC5buuOzE+KzCMdTTWF/QReY8FfJH2PiGmAWIUDdYscC6w2c65xlTWLUoB5dM3z1lbGbc6RAAsrxi01INvOBwAmQSsmAeUGvJl8OyTSzSAZdaQOuDyEmb8e0DlkAIsa2gFXE5DPtey7raaNUwj/ALwzvy4S5xNLHcBBg/uwBz02kStaOz0YCrCHkQRY8aqMkEMBW7YyivmYBijI2Q6kRT4jqx2geU9gOUxoHmwM82RiWHc/Jg3GKQFljHlr0I4O3KjXpQFWA6QAGA58neSMzlBdNiotLcWwDKgssAysjAHKgp2hPRZf+/w+eO7dyrGMvoBLNAofYJ+AlgGYJ4D2spebRlWOoBlLuEijRh+uADLggt3CCEquBzAsvXHWWLC2DpnXGmYP/8Ao0y98nXbYajyY5h3zhmdDZZL9guEFgcjzLztMsNiU3beMv6SoZgOPq6PQ5yThuwjQ5h6M8INyxq3dF9rAS7Jss49gmWLX3WN40L8jiPGZuT+HuFZHdqxb+Y4z/f8jPX14bjI5zHXGCepiuoacUn+qcriFGaZqRlIrUCfBLD85Xe1PmzBHozYK8CKIjKWx4DLClRbNLEMZyLnmr/N1pQloIYA/EJwg3D6h98QUv7Jnxlbd1nrcexAJsPr2glz5wTmr+XB0X7t7sN7tXtIj/7P8w0OAqzJCSoDLr95VeviwKQTk6UgiIB+AniphWie6uDhnu3DZcGKRRmvpG592ijrFMpyjsY8pWwQQaQFANvEGc7ILwKwsmi71O0KkHP4+sfaFYCnaTsW7NPme60DqkQ/Ohb47eIYNEcP++RqN1/7/ld/Cn1bGfvJNBRGGLl480M47TQZF7ZLdm2s3bFmJKv04K6hps0nzLrEmGzIpMcJJ3JQA75byuI3Ck19AiufM4E9Y78INvUOYA0i3f37pMMAyL0LO5izyIQ6DF/+UBviIDYi+oK5opc6qglMB7DMXmIZA4pRShmOhDoQIE2AN8NWG+ng8OEXoejYD/jhIbltz2BTn/2MUwKgYoBXAJP2m/u0a68A8y5n1MHdr5h3MtxwiGTd8Hzi5y4JmT58jrz6AUeDDOGrU1CfdW7/i29Zr4hywZrqw31gxlpiuoYzIqkoRgcw5737gP3juLCLfBbnVl7VuUZ2eoTjhqm+C0N0n71+nzVAYHPIOeHyrVEHSHtwPUzBOQU0LcBy8yoHGMaFM7Q1V4cWbXj/SN1Av4YDivOez7RQo/un63mmJDBCjb3lGoTYFn43x6dxC3jw2biHiNIX+EwWfiuelbkfe2F8gLYyxv2g13YsuM7p+BH7B2UCyzKWBfcZVzr/BLDcIQR2spVXwDJ7keCfAL3XiwdjQKaywLIhzU21oRw8+pL7i8vIkW2e7DGpKK4CWAagR3cBrMd4Zy92P2OM2g86GOwROr8Ay3Gf41ih5uEwgCPGqTmWcRSLa1gTwW3OOALLTSKOeLY+FFhGlqz1c0LWL5ArxqP5jS9Y10bUQWdIxRD26UxY9Qfzbs7Y9H7G+4ID7qUEl2X+Giq8iZOUpaDy+xcvAZYJJc85lqrEvBZYvvvNY3Isc+Z69ABwG0c0ZEH7LwGUzz/guPqefYH1w3sUI/3Ywuij6H8Zy8lWHtcIhQ2wfP9bmKBPCrDMfkV0ggCWGZNntMeoGzpJLHXqQJfmWL7zOB2qdJab4Dw5vbhizcEpFD2csOeZm3mh450nE4Fl6qJOQ6+OsxhD+Y9nEEYQ3aFDgPVl/4oTjb+aY9HPm07F/OtzygCWWTddt5KxTEoJ9vEZdZSprAgwB2OZaBSCy3leyzrEfHVoc71qtFmZePiyL1bbZb7mxK4eq/FZXqhKP7K61uZz3t+81kdf+2z/vG1vWTdjUz8baou1caUfPr75XtFPriGMiAIs38wBl2EsGwobpvItYPnIHMsAy4bC5m4HT0jK/yywvK5veXarbuXFbbnVwFYDWw1sNfDZaoCzLSeO7WOrga0GthrYauC/ngbK6owhxTDYhsNeAN49NxQ28vx//0/CH5dQ2NimCOHYwfDcgUXRovTgrqFifYDneXXNcmOxbvT6U3xl47HxOq9ufu/XNzrl+hs3j1xr8wqb39/4kc/saWkn1aZxpX2hNv7RrKBRyUeUlT7LbrsG3tGTn6tEc3zc6FEKLGcobEImAvAGsAy43BBYfl0xljHQLmRXAiwbDrsBQCb4qbFAg9H64Si4XYkYF1XFNSdoDhdcXph7VoMy5a6gMgzRfaRNyGHuKBGNzRigwlCJIYmywbhrMN4sb8g9dvkLjGVkzPMlzMsI74yR0JtXeUCWJRS24K65BmXcKnOMlecAymcv/gpj+d8x9pGzEwN+I4yYFezBIFZPgpyaRFAWxisMk4TpPqBs9QBhDFHZhaFCuNizZ38BpCbHMmwLHza7jsFJEFpwVrazzN9NYNnPn/M9geUw0FR6LaC7pTkEDzV8EaauDxA0B8xbTAAyx7MK5BDsOOFvjbuwlRWATkEA69+CXXYPYDmEm3g+mEZkyusPsJcIg30B2Gko7DA0or06RrLCVrb+m4zlzLEMIL8BLGeDDfudOZYtI8cyRrYMhX2JfjIv8yVGPsFRjWOYmqlhNWoYOv4VDHH0vQqFHTmW/xSAsuCychOhsG8zlhMMtO+queJQjLGXA7CMTUtaGHMmxiJGyGTjJHNugJH4AGBZnRsCe0kePGUKay7y0wHmW0ZuZQzEoMph5BVYFszv9PcA8clvh84DWA5QGZ1TXsIyOwcUEFweE14+5iTVbMFYzhDrsuEB8jE0JkN8NxjLZ08JmS5jOYDl1Jss+9IyGoTe0nRnfl4Zy/vkWJbx7RyY6XQQ4DLAMoDyJYxlAeYCLAfoQj2EqwX6GNzBKjtQF7DKzDldB8isw5K9wSB69o5cnzCWBdsPMagffgHTkM9dE0EgRMbR+dvI3Tkhf+cygCXXDIXK2jdI1l81uEbxWnmwrtg6JdhArBtzDKezhiIjR8YyLGnCPcpYDqcDxsUYY+iHd29r79+/rX1A6gC3CUtn2MZi7HTMxaNav3LFADhizgcLUFABibHJZ7K6/CU4iBHWcNCuVwfVutWSvQbgvaR+SwxhwUQSx+KLTdct8ng2QQeuMJgLLl/8/Apm9wcAHZiLCmsqXwrxN+0D1x1L1+cEsWXxasgHAMbYumDMFMbyB4BlryFQrSSIlteLdmKAjygOltYfIM82dAFgdwjZbuh2c9XuELq3h3R2uskcw4FjavhugPshwP0QkNW1sEHo30YwlgGWBYhWwDKAMqDymGgSASwHYxlDPcCTwKKiUTn1meBiOhmlUT7yd0Yo7LvkKk7Qoj4w1yuMZQDlCP0dwPLYkRF9K2P5SGAZxrIssQyFnYzlEwDlZCw/BVg+TxCfcNiuFVygqgk5lumzaV3ueDtYa4LK5qjMUNgwlgWWMfSfYliPUNiUoBMMGBhfrB97GMJ1wlBkgU9ZmycjwL4Ja4M1xVHIMlnprD4Y2wWZInqEDC72rxEOMiPYoK4LAueysi3N9ZrG89xv1V8Y5lFirGP8ldfOfT5AVgce4ykcshxXtDXHvL9tu/mbMvqhGt/lNa6yes8P+Bv57SxdB5qEUW/SJ23OCf0vAS+QLvtEAZWv0I+M5UkBlgEugYJY8+MEEPW1zkoJq23ZJ9LDHkC1Yoj5EU4sKZcwB98C7Mvee1s7vHNUu/fFg5Ben/MCa7DrsVEZzn7GEQc5+0UnnFnsMzrixHzemGOVGqJ16iEe8STfiadxkCzvFv2quwpYxhnJFabFHOoAwiqGnu7j5NBnHLdx1LiECXv54vsol4Y2BphRjK4SJ6LQP9dzzjO3ZszPw8c6UyGP/8wwA3SH4aeYm/3y5x85L8DKxSlMNms4zVB6pjLahOWODiOuTzhJ9QG36jg7NUipoTPK6ctnCMxvZInDj0zCBhE1GGyxXjFaOGNxjWADwwiGQdZlXvWOBc2P6Vf6gJDRF4C3I9YHHSTqjGEd1QQy7dW4EM8KmzKcRzjPzZAGwPIRAGxEw2DfWAL+1qbOBUDhU4HlX2qnb8lHzVoTDiA6gdhvrQTA6pQDAOU9nBB08uvpwIaePY8tqMcl9Qpw+eX3DIt5gsvobpcQ2AeEbFdMcRFpQ5hbgnWefy6IIuK+3KIdMVbdA6rRn4ODswmvMAtjXRYUBWUNcDSAZdpkWGfn31BQWQEUHOGUI+PWUkBZ58dgYqOn3Heck4wxxQnn2lCNUyqZ6ybvCTA7h53awZa1DG2jccZj7KEFXPZSnJmjP+yT6JfSCt90DNtNXi8lX+PFWFz8Ja5b/YbnULi6tFtg2f3oXuxJsR/hdCi4vOAsbE77988JV//sxwiFbZqHDmdrVyh+MSTO9YJGCkx/mcoBLAMu32YsvycUdjomyRau255oE2Pd+gguIz2A5QiF/SvGMiHOK3a/ZTCWqYfnbNftBWcco340cGAtjpuWS85JC5yoFNexs3c4jSIj6hIOB4wCwV21mLrz7MWYcHxTry771SHgqDnEB8yZBumGGtxnWX549QqRtcz+z++gei/CdwCWZSw/Btx++IDUCzhwIZbnnGOcD2eIkX9adda0GIms71X/W06bu6wdRAdCIsfyY/cwcqvzuwvyqC9wCJkiAtQCy6eMTaPsyCBXHwksfxOsZRnLsysZy6QAGY44S+FMSU72D4LRsI4b9Ksh6lfAsnpVI/G//WxvZ+1ijav2au8Zc7cqo4Flg72xSGEsm/qj5/7POcexpXPvhxcJLLuf6yDWxk6hxN7I74dzoArl/6jBR0aA8mcprSMjv/qwz7Pevl4eMSX5Y/XO+uPxkc1rle987uWmTtZtSQ3Q/LV+qzfV0Uo/G+9v6sb1yZ73LC9j+exmFqzlFWOZqCeCyzoMyVjusve0XB8CVK6A5Vs/wg9t/B31yqpVtcpi4yObH7/1me0fWw1sNbDVwFYDn5cGtsDy59Vf29puNbDVwO9NA3Ey1xL+CWAZcDmB5cJYBjwBVG4D8il5eM/bsvL8t9W3cdQvdwPx4Y3X+XvzpuRjYLnc7N26Fbx1c6NB67dr8Pm8kwqKpvDPWtP5etxDV+0sN8VpqMgWFmDZ78X7WpJ47k2eBilhE8O2aShS9BBvV6GwA1h+I7tO1vIrQL0ElmUUNADIBIg0NaXBiMtGlar6Rl0rLVMhf916CfSGIQwjzJJQzjIGsB4DYGIYkvEBe6VFOEvzpM7NmWq+OQxJYbyhFKCUxRlhpDH0X2PsuULGp+Qeuwa8oI5zQm7Gb1TmC3M2BfMWsC6Ac5ktGMIWGOwElM8x+l7AbDEstAJ6SFu4AoNMsfbBHqbFho49woB+iGHyiBvhJgbOYIkwB64BjM4Bqc3TV4BlNaCRUYB2cD9DaHcCWBZs3Q3GaobPJsfyT8+ixqEhfl/wR+BdVkYf0CLy9wEs20/TMPgQ2pgwdecwCc5PAfkwyMqgjVx9GC/tjzThk8MaEOCuICdiyOJgFmGAlWkk8/cCI7XGapnIEWbRPgtgOXNDC4hHvc1PDSg/hvlQwn5fkcfQhz2vmM969w7gMmUH1kMJnz2jX/I7/wp763uMQWmcs/QRQ5NS44PmKsOCygI7+vafYa8BkGJgz3DHsPgw+AmIR0jnEgqbbxbwpcyBKB2LXFzxYY+WupbxaH68JWBl6BvAbfDQfIkCyzAWAVRlSCvT4VUA+WfoXAaHwEAabg2LSN1hqcq8EFgOUBldHz/6mjdggjFnNMBfAuqeBbD8QwBIUSt+X8byLqz6PrrOkOnJDjfXsqGwzwWWCd0eOZZpaxo4E7n0Gs6xwgcRoOiQa1Bgef/xP8E0+wJQGaBKcJncdpdvyXtMfs4LgGWdMcJUHiCqc5S5idQBFszpuwdTzbIJcNIAMBPsHwOWDU8M0ch8A3Af+Jl793AQOQbweMVYesn1X2b+TsLXG2qVuIph0BW0XeXBQ1fZKzZg43n0kH1V1ilnBaC5wF+dcLfwtfcewg4F+BNc7gH+R45lQ54yNt7DeHsHqPQe0QAabiEYY21n5v905aPDHAjVI8G6nDH+WoZVRL88crw4RvhUrFkAyBikD+6zZlXAewOj8hy9zAEUF4DtMthllGm4XeXLhlF3AzB0JfgO8D7h+Zyw/soCh51gUrLOWRajeTCyNOQfY8gnpO0Oa3QAy7xWgGVBZQFmwZ3MR0pb7U8kAAo1SZ8GQ5/1KNhe1FfjfEPGFgCxErmcyZNsSOvdg73ajAgGc+o4uwDMIizoBTm1Lwjv6noosOx3BGjMryz7cM8cywLKb2GpU44Jv2lo5xFrtSyn4lSgboUZnJ/OxgRqNNUTCpv18QDQQoZ25FjGsJzA8g5MJduZ4LIAUowKQJh+v1c7YuwdCixH+GyAd8Am9RSgMiCHgIfsTPMyyhAXWM7uzzWeVwNYFmA+BBzSIH/3McAyTkMLQI2SYzkcSzCuGymigUG+wfqs7AkkEAb3iJCqbdbba1he1+fkqYZpOwEwm4bo3FCNMfcXAKZcG4x8ADMXcHnOPJnjaBDrOICMpeCha5uOJOl8xFyh8s6Y2IEDtGZsOofo31zruH7pf0s1zfctg5DIx82pnT3Av7FY5jXj5dI/VR9Za99VGoIxrItNxkAngOU/Ai7/sdYDWDaUsWDMEOBCpvLkXHAZ8FFgmUobscDft95haKbsAHqm7MGIhWFLSO0+oKFOLMMPp7A+T1lvCEsLsHNFvlXLowd3WGMfEYkDQzQ5qsOpDNB2Stjys3fsxZwLFNeb2GsoY7yoQ3QQ6zb1sEX+G7tCtDVeiNfUp48Yp0U/vBZ6o5yid2WCdGBX78i0wqGnh6Nc7+iIklQQ1E0HNp3Hzp/9lVCwOAoA4GZ0lXVdqBEjM0FqGcuHRJo4/Ma975+pHmCzZyIcmwSWh28JQ/3Ls3Cuyj2I/mWMLNtESkCWREzYAdwOpyDWKFmldUC/ekeHkjpzglzViGUwyWHwC9R4Lc9Ozgt1v8vZyfOTUV86OJ2YT90yneg469CmGxyddMaLNtmuGF85xvMc5hhlGNM2QWUjA5gL++jrx0TCIAoLc2Zp5A/Oe4rA8gmOQafIDX0pY9lxHPMmcnuT35tyj/PU/kOiijx8ghMWwGaL8wLnMRnhgsoC30OAZUOjG3LX0LvJhv9TMOI7rCtzxosyhYl6iT6VISL7W4c3JcaKg4D+Vi8lkoxAeQDLgMuWOqPJVlaMUnPFGLwCCLwGkJPpmgKwrI5o0yawnDOLEcj8KP+F1mLgsRcxZ3TIEThz7lgPH44ZNZPziLnP/lTA5RjfgrAKY971Itvit3jwj2WcrbnSav5HZfLN4phoPzKLAIVyje7D9o79iHV6xVjmXL3g7B6g8nNz2gsskweXtVZwOcBcruOvu/8IKi87hLAXWP4SpzRFJwMcHVY5lmEsm0bBPWRC6HiB8tgj5+6P7Cbo2RDJOkCYX3n/EesQILNh40laH/o8f2nYeMbqy79yPvas49jkfM066TybITkeE1AVWDa/R4xH5tslESpOCRl/+jPRV4iMlGuJjj55bk0tCiyn04SpFIxyc0SO9WPuZ8xDbQj7epv9l/F58pqIC5VMOI9RHf6vQmF/TaQM5OjhQ36fex/Cty+pyxkOCic4ypzgRDvlPqdK2kA7BLdTp64ki/YeQj8ge8z7O+xFxzCwd3ASW7CHCy5P2dPPAJQFl821rIOCoLJng13qesccy4+fZI7lG8Kx6xx1M6l9oA7Ke0SAvhl7qA4DnjpzHQu9ct7hirFm2rKqx0PnuXflOuzYSyl7WF5ll3sGz5y3gGXmtzmWV2ktcBZrEv0lQGWcxBJYTseLdShsfiAe/kqoOcp4ni/F39Y1HrxmP6z+4IlzpjxWX+G11XPepLm/i8eGKn7VXvWUavj0p3zVey3vsxwpkJUjDPYZ4bCH0/qKrSyw7F5TQmHfApaZ6796bOj+07+8/sbGR9cvbp9tNbDVwFYDWw18lhrYAsufZbdtK73VwFYDvysNaID8FbD8L8FcXgPLOOm3E1CWtfwpxnLeWv6W5jaO+LfuBjZe56ubN2ybwPLmzZ63gqtvca3V8/j+5l+/VZf/6q+vFcQ9WRqMKdPGmbfBfiJv3+OJf6RQ/ApYRkN+VkORN3o+zxzLBVi+W2vBGJK1nMCy+ZVfrYDlpeCHYRMBySKkbdwmYuyhQmED4x8NXxmOL/sjGcf5vkawAPMwUOGin4wFyj2NcpVhiSFVmwIUTwSLDUEa1xagwfiCIasLyNXFcDsDIBvJBtGATcjbCYYTQzROYHxF+9CD+W6DsQywa97aLmG2BUjbGMHU3sVrmKOEp7wgVOUcgC3CVFLKEinhCTWKFmNiHWD5zjd/Wol9orFriUFWA6s5+s4xZt4AMhdDnQbJCJ1dhTju4H0f4bgByWWmCbZGSOmfnkXPaHyxhwxTK3glw6gP8F6A5R5GlvEZefsQywvCzZ4D9lwA/BiWuUF9lNA+Rrclum5jyI0cuALLMMEEeZTIsQywnEbVpxvAMnUQWA6QM5nWHwPL54CcisBy9D2/6NDbvSOw/Bi9wxDHSBQhtAFHDenq5wVHBZY1RKdgOEaPhl/UKOoYCWM9BogElv9bgsuEwxZQng2HnwSWNQKH2RP9BaDnsATYi+tqcI3rZx1jijg++C3Ng7IlQt8wWJYCqo8Elp+EdLowZAXTCIs4pjw/RdC1pbPJ8e6YzfzKGdKvAyB+ByPJXZwQjh59zQ8ILBPOk1Km8NlPjJM33yewHIMogeX+HQCVYwTdqbfu/l6UN4DoAsvqbwLIHCCT7a0M7mnYEaBbM5Y7ABx7sN4El3uwABbMF0FlQ7CeCypjQL+gXAJiCfQF4Ot4xoCj0bUBM1f2iCERd3U4OSI/J0bbJuVsjnHo7BJD6yW41wxAch/j7j424kHtnLl0/uZZlOZVrk9ZLwCVXDMCBGGuxBi1f2m7QTsdP/ZMllTBesQr67XKWWE24hlh4C33AP+DsfwYYJk5ZS5jWYsTAPS3b14hr2tvf3qFjoAMAZVl+QBtsCbS67HPecVoML9kPXIV9RUNpDEP0Ysf0RStTtIgDniDQdz8woabPICtbQjPOuCFc3LKOIm8hNQnwGW+t4NjSAgMpgmgmPnYDRk+PnsL8IZjzMUvgBunUf9lgI0YtgErg9mFQTUYy4Sz3YP9JBOxAajcwHi9JBLB+2fPAlSWySsL0jYKmiZjOdsawILjvwIeNMhr4BMcWQDWzysRWL5D2PO7GLcPYVwuZM6ag5XS0M9GRTAM9GzOeKX9DQBU2YIHGNEPkQSWMcADnAe4DAg4xhBunmUZy/5q/DJ6df21v13XCwPQHrKtgsqKYUQbrHe3gWXA5WeMW0F0ABfBlv4uID9A3iFA3kBgGd0EsEz4X5lz75/KoPsBgPiCkWPOXYFljfJUgN/XKWSCDgSXLdfA8pNar8c6DEtsQThb++4EQPkU5pbsrRZrRct8w64Z9O0BhnxDqTZZs8/fEbIYuQQYHblXhSQYbp2bTNoYh/Y3ayFUS8Y9qRwco4iggX1o6fwUVG66tvPdBocjx6mD07zwakEd0sFIrqO2K1bTarwbVjdzO3MNxoLYi2U+QhPlaXXt7BunQIAPXtt3KCMUNqCy/d8hBLyg8i5hm3vscQLLQ/JPWwaofK4DRQGWqSntdm/NPk+gylQcfZwAdpjHsn3d43sAzAJZ5z8TAha5QN9jgJgxuWotjx/drz14TLjXx1/VdjrMWNjoC8KuT8jLa9jaYDZTChIK4jVxtlJ36j50aGtsTrTJYZDjMfbtSofuRy5Njo9837r7jdSxgLLiftWFqRwpLwjPvBMpPWD9H8C26zRrpz/+a+zxp0ScyDDLCVwGCGI/cX1/Q2cqrxfA8nf/vXaEHP7hf/AmoDPMxekVrHbAtmuckxTzV3tWWTmkkK82wU70if4OHrI2IeYeZtDE8Figi/dP/505hDz9PqIlCPwx8kMvroqOnEbl6KSDmGlEWpyZFB3LhjjFnLAf2R6dniJ5AmtO9CbDxD6OPRHdeQabM16d21P6M4Dl/l6AV8ePv60dA+QtWLOX1+xNMDgvcZI7AfT6wNnO8McJirKOcU0jr7TYj5X9h+QzrsJa65RQHGhmrDXJpv63YIgLKie4PKsNHgFkf/tPtUOkgzPSDAaxoPIEB5jhu5c4MLwIZzXzKwewzPriWEEd/s88y7PgNNrDzlWBynX0HjmWAZUPvnjMvGrUrnGuEVi+gW26BpZxyuTaASy7RscqnOORS/NXrkWW2QuWWYeY5YyVmLKu5cxD2eBeRXHlCKeSWOOZo0zcAJXZE3Mvy9+J61bt4es5rvm9dDqhnXFtXnfs007HgxLzNXs49yMdnZina8ZyAZaf4rAgsPwUZ+SbAJU7rG+2NVtFQ3EwCFD5Y2CZe4Cl+wWpZCZGvSAS0QSnnrFrL5EI3N/DgYJyM6exobAPAZUPyEcewDJOBsHCpX3nr3DoAFQ+f/mXBJbRi3XRuTbSH3BGrrOOCaYWcb6Z12QJs/KSdezDa0JXcx90TUjsNs4+ppow331x4nGdiGgXOCW6f+ige5e94M6XOBoAkuYcZU/n7CNIffIT91WUAsuMruiDyLHsd74m+ot5xxlsS/ZZy1Mc5T5wnvnAuWbCXtzKnSp63j4qo6TePeJckqKz7iEM8KMvCRXfwzkKQHlxQQSZClg+rUJrL1zgGTM0ZgNYxjGU84ZRkZYTxiTle4Dt94Dr75BFnBkFdPO8EVFeqKhzxXUs10tHNI/Yh5w/qfd0KnRE5ZyyjFXZcydrhOdNQ6yrN+8fGqw5spZ1IDh5+YzUFs8AmJ8HsNwMhxjqwBqYTkuO8bhgrKk+9aF+ykN9b/zJe+vHbTvD+ju3vsIXNt9B/b+bx6auNhvt/uUo/NQjXkVHsYawZnmiGTGNza98CsJ8NUlg+X4VDnv3U8AyzhpM6F9ffkP3n/71/MrGx359je0rWw1sNbDVwFYDn50GtsDyZ9dl2wpvNbDVwO9PA964F8byFYDyvxAKW2D5XzASDGt7RAEdIL2/ASzfvpX7WIsbx/xbdwMbr/OVckNSPcPQkS9ufurWzQxf2HwvQkN//NOf3d9rBXHfv2pgedWySCqoesGP8kYYQNUKz/PmOjXm7XeyNWULwW7BqKtB3xzE7Xtf1lp3HwEs34PJKps1ZQbbS1BZcLmOYWVlzvaHMB74G6l/fokn/lKwjTECLRQ+I5DnjaUsvNYubJ7BcYj5+yInIWCCDK0RwMQNjLcJDAENuplLblnbAfTuE9rRUiBJdtLkEuFzI8K1jshPKaNHXHXu71GnYCzDbpG13ANYNqSzIKkWuivygZoP+RqZYpDUKDnD0LgEAAyLjkYXGyPIA7PB8J8HX2aOPkuB3AXhpwVNbj78UrsklKIyOn3H91MtgjmGkk7GcsX8BVRuBrB8XgHLMpafopnomSgXAHsRLhzQYhfQ4vDxE4A0gA4MLSWf7ITwtLKVL2D5WJLwdmVQbAIMy4JtwCLpEFL04NHjiuHzGMMQRlwFkDEZy8nWkbEcHYnuZFmYw1BwWcOyLG9zUyuGwj4nP7USwHJ+i381TqFrBYN0F6CqGKMDWDZPcADLPwT4FcAyBlbHTTJt6DdaH0wwShmyMraCtUzezdnwCtbyGlgeElbaPMuzMLatgWWqH0NSA1deN4EA+zIgFF6nZ3M88tzfFFA2LHsAywCGhh1X3wLLc/Q8QyLHKrq+gD2nvr1a9JnjnTFd8qh2YPUeYMQ+ePgN4ZIZqwHiy1iWLfyccJuGwhZYZk7FXElgeRdgWXAigGUM+CVsu04LAeRjzDcUdmHgBbBsX6k/ygg3ivHGsIwBLAPG78H0XgHLhngE4JKpXMRQ2AFaYZyzLWlkxGjOmO9i0OtV0mEsdJhHhrsVjJzAlp/AnBdY7ux0kHat3W3hhPIUeQYr+ylAwXkYlxtzmELMqQAJMK5aVwHlNUBGA3zw8/GwQTxsmet4Grc1oMMKAli2TMOp4AKhh1m7zJmoMdnQpyesWaewlU8Qw0PXZeMFsI0xmPGmcdq+c2w00JcG4iZIiIBAU8s9IFSEOXd+s5iU31+22qxbrlmEXmXt2sW4PsAIuouB3bypN7LTABJck1yz5ojsb8OkGoa1T5kMOVhZ9P2IUOEjwtka1n2MwVdwsYRXF8QuksDyncg9vAqFTZtlLH8AZBVUDsYya6cOP5EDUoBH+3oABdVaTLuX6CfCTqIBAZ+FIbFh6ys95uvxV1+SJ5jQpHePYTgBKhOeeU55AUP/jHEvuDzF8N6E6SxrWcayYbA1Yu8/uF+bAAiNCVesjAD5MscyALUsJzRZQmEmo5u6CMD7DnqyFGQUVD5EDOG7CSxHO6v2OqcElgUJZCwfHMNYFlgGYE62sgAzjGUADsHlD09/ZDwmsCyI5q/FIsE4cy3QWaGAy5Fjmbl/F+kCLAdjGXA5gWWYXgEuw1hmjW4qrBvJWBZYBoTr7dSuzi5qV+Rkvsb5YsycK+IcUA/OtQSWE1S27xukBhAqcpd0DyppDWQsN+i3AEljvpednauwL0VYc/rRtT4FdqqAIzqvE7ZUB6I5Y3nO+LAUR3CYK/xYPsrcKy/xt3s2/1dq4oPuhXzBUNgy3XW0asPU3SUP8ADZuf8NziYwimn3TTg+JVt5Qo51Gfn2labluIz1RncMJJwl0rHNaByyT1uAfu3dPVjeS+axwDKhaAGrZ+xvM+ovUCiwfK8ClruEmp+zJy0uTuIscIGj2WXISQUqoz90aNqOBEGy7aXpKqDsC7Y3dFK1tZw7430/aPurMvcpAFPAYMPxDu4ByBiaGXC8TUQSU17Q2ex5gLCx9/2fBJbRwYoNy+95hHKNKfvejL48/O6/AYAilF5kdgOjXeeE8w+AlgKgAMswwmMP8hq0oMGZqrFLTldyPfdgkhva1jWqaz0c74hM/w/PfwD4+z7KOixO3HWoj+AfZy3a7bprWHL38bL/t2L/T3D5irNOpP2AgW2O5XDc4doCzI67Iu6/CSyz9dkGAALBZUMPJ4gnsPyEMyWObjKWZYjitHXKOiq4bOjocPBDQa5jbQDkDm1pc2bdJSLHLg6QA5ymTCPBhAngznPcRcVYjkg0rN/hFEC5+5Aww98SXvzJP3KNvZjPhrcfM26u33MO/AB4yHocee/pEdfR2BPtb+pgHxmRRCDX3VIHoxCcbASWD2BfH375DWtCi7MobFscG0aMwxscUm7IlXvDb61A5Q1guexFMSH1+GA/0sHIvcD1Wn2GMxZrh5+NCeRnmMhGtDEEs2WT+d/spkTIbc6mLDysA+iWay2qfS1mMf9Y5rh2nscgihcd+rH38on8RVckVkycWCxjPxL8Y2ytGMtGAeL3A1R+nuCyjOU2AKysZfXoNf2ByOkLq37Z1rmUfMQ4MxXWssDy5B1nf0Rgecx5fMw4mMBEN8+I4Kz7d9QHHVju4Ox2ALB8CGt5DSwz8fi5AJVhLF9EKOyMmuI6lMByOjvUcVgwlYdyhBitpY5O68zDG9ayc84Tyg1nP9fTlBHd5bkyzw8ZVnunNm/txH3U4cNHnP8e4ZR3xNgmrHUIKUQMaU2o9whrPcG5k/98OEePH31RO2YvPbj/gN/uxtpoecFcMKy/dRjjOFuHrVvnTCX7XQfQFOZVn7mPNPpGT8ARDQby4A75x0nBkaGw33HvkIzlyNnMXu35JrulTuoJmNbs48ru8V1qhQ6Ys8sl5zqiP8icPqWcE7XKCDSEiYp7wVzXq7Fp/+YF4zzVYDw3rKPzk7WbRbzqw2rMMe4CWKYfdWrscwax3oLL3VUobBjLAsuAyobvtzQdk1EWmjo50586swguM3scvE7XeGThuMtH/L3+s9J+9V75En/m0/zgxsfz2tW1LGJ/2Pj77/lppdJfNTH0Qz/e0pO68ZPVi84318wMhY2zxA1MfBjLVzCW7+PwXPIs3wKWcdzhpopr/G1g2Z/6VP0+rpOf2z62GthqYKuBrQY+bw1sgeXPu/+2td9qYKuB34UGNLZWwPL0NrDcihzLCSybY7mtYIzXOdzDe7mdTDX9+oi/PuCvn92+E9h4vdJ13HT/+uVVT4SRpfzFT25+9O8NWF41rmqkGg5jUGi+3FRh6KhU78c0gcpajgdlfodSo1QlGuv6MIUElwWWZSy3MNg1yUc8fPsOA+ZbwDtComKUN0/qciJjWUORJh0Mbxjf/B1v6POX0pCH9QAjJmEIMQanURvmiGwcPqVhSUNs7/gB8hBw4gB2JgxNQFNZw1eE0r0ipO4IcCKN2xj1uHEdECJT2UMEksq1NfhfAxIrGjohqQSoI7Czg+ExQ2FnjuWOxmt+r0FoOhnOY8LDCZROYf5OMDBaChRr2FtgiNdo0yI/muGkNXYbVtg8kH1Chs9uZNBeBhh9A6h9/S6B6sklgHhqPQxPg3vUuxKB7SYhcZsAtBPApdMfCXEMYJihsCvDN51oLjtDR2o07AMsH38DsIxohDck9FwG05DcgDAqzgnXZ7lE17JUInQqTLou+Y279K/67VPvqDtlGLkAwhawv64FLcnvfIGMaH+EAKfuhnkdkJs3weWvAuQUDG/uEcKbzwWw/PQvgPMvaWs1xjAerIzRAKTmWG4BkNpe8xgKKvu9y9c/Bjgqs1JwNEYvl9CgqfEhWTiEthRYlmEUobD/BCtNYDnlGqbUJSwjcxYXYFnmgmPSkbiqk3XzwvxfHq4r9k8Aa7zhmFzl/MaYuIeBz1DYAstd+n5BGEZ/d0r+3otK1+rbMR6zirHZxritwbsDO7wLi9PxETo/vM+cAdzBsKhcAoSbx/GcvNb2fzyoWwt2ejggGDYd3RVWu6Vhk1Pf/4fxLbCMET+AEo3OlRmPMsJDMl41whkKW1B5D0C+BwtgDuPHHMuKdbik3y4ozU0eeqMtskli3URfAuXmDW7RHmXnIfm9H31X2yG3eINwqzNCNJrj27yYzUaKPXf25hnh859FucAA2cJRqYkB0JDUwVZRZyGuTXQL69JG19zuJ97QVJhadu2QExfZuTEgY3w0hD4SzBbyCNYJ678ETTWv5ZBwxZaGYJ+xbikCdRF+GN3Zb00+q9HTstWG2d+hzZQLDL6Rk9pQqbRPcERAQVZ7rFfo1vWry7jusiZ0kAnRFa4IVXmFAXgMgCCoEusz88j1qqxbjjzBnTkGUZ1grgH5r355AQDxCwMSoytiaZjqJXUTmA5DPobePUT2Yck7aH5IwdYIhf3sBWN/TooKzMHY4jqsbx3C8LYRQXND6a6EyrlGQsqKNjVIRyCQJLCsMXz/EaDNESwhQKwQDPyGwJalf4bMAJYjLy5hwbusp0cA0eZLPSCEp4ztKYDyTCCFtfQap58b1gsjQli/CIXM+J3ikCBAOKNMJ6cEl92LZCsZDnsFLPMaExEwLNtqe+0jR4Sy0wcYIAz2IeDy4Iiwv+xl5mU0FPYJIcIFlk+ePQ1guV2xMx3z64FnjuXMryzzzJCsrrd3nP+rUNgAHOwzASobChugU/ChATBquQcQrh4E5V13xwBlE+o4oZyqe0BB9U8HMw+cA/x+gCQ6OqTE2NTxgTpOWZsnIebkNYcta7v7kes7FU9Ag/FL39UVgN4241FnlBalzl9LQIglTjdzWH9TxvIEkGnK3uZ8y3W+WiV5wdfiX+dkPHf85hi2jFddR32XNjOwENY8gGVB5b2v/1zrP3zCmka9g11LGPAz2Pg4TYxO38T5gQmYbWUOtCKUtgzUPvOX/Z99TZHt3WTtcV6OAVNPOYPIEpcx73xyXnkWOHr0AGb9l8gXtS5jfkbeX2XCWB2enSCwUBl/AcpXe2Jw4mgDH0eHPqJh62dct7yiZnyeTVbffozXVIb/I+ZTDcCUdWmHCBGDB0+Y6zh/Aeo2cUhoMHbYyUmPQSje53+h/Atrobx4QMsYu/wK1/HSrnPBPOWMZHjeQyJNHLjvIY4vHXgW0zljkLYJLBNtQv0KuDYrh5gWzoCtgwfkvUbYO937ZfPKqmehR1hXAMZOyFV68jJFkExHJd11bHE68gAGsZ8NwtGJtYuyxbmlxZyyvMFx7oLILOaNnhB1oY1DhCuzUSEyGgppTFhrde7L/kJXtM8wwSYmaADqCigrEXqYxch9RBmyzpxx3jzj3Dli3zUiUgg3Gl1+23OijoHdPuMFB65un/WQNdY5JAgrsHz+6vuIHOM5I52Hsv8ElveJOOOe6HluzPgYM07GrFHXjFMdfG6I4OK5RFC5AMsxKrLbkymLpnTiWrYyncuC0ggah4T2PvzqCVOD/PTsBzoAjlkHrxmP1wDM1wKT1DN6mt8QbBU4V+/h1MT+02yzptDWOWDw1H0IYaHke+xZtM+B51YU32KOmJ5FBw/LDudnI52YeqHOmrFkvVLm6HHq3EdcgxzLObod09UAtPQR47y6fnxKcBn1xupNvQCXV8AyAGAAy/RH5FhmvH8ggobgstKogGXXXNsaOz0/HpE/BJZZswTmD77EKYl1U3B56VrFeUcRWDYcuozvMW3w3BBeo5SugmrQE18Cy9/BWiaULvsyE4L7A2d7jWhE5AJ/RWh0Sp2bYu3lW9Zmhv50wnMt2+eMvQ+ga9nE8aGFNDn3TK5HnJHf4zjKvQLjxbV0foNwntUpLRzTmH91nKwaPfSOGDLe/OpKh3PJnHV4RvSOGX1xwT1NRFTgmjP6SH3bn10+d8TvHyIH7H91zl7lejfMiSvmxBUA89jrjHF01MlXxi7OOW3md0TO2LvPHL3HGZ2oTjjnxPkfwNoz8WJoKGycc7jfEVS+4GxkKbAcPU8ddhg/B6TBOCCtQ0QLoS0N6lGnr65OOE9x9lU8t85GjG/Od0uB9mo/CzcE9BmRUdBtm7HcIvx+G+Eghc5u4lxlyp5wLGM8LzhceS+q84wAs+B2Ast381wX+3iGwnYvP4GtLLDcBFh2LW1yvhRYFlTO9Z1L0SDX5/WjGtT51mqM+/7mx24xlsuXPz6f8oX11bLvykf/bsqP2mi7HKNRZnHr33yLL20q009sKMow2JvAsjmWV8Ay0Z0eVDmWDYW9Q47lHuHtW5vAsvN0+9hqYKuBrQa2GthqAA1sgeXtMNhqYKuBrQb+C2sg7wk0XGB4QBafApa5P9zr1GEscy++ApY1F3ib7n1EubOg3LipKM3WiHbrjfLx+MDHX8g3P/5KuVZeaeMCPN28wt8nsBwmrlCBLS+tDyNT1f403qCL+Nu/+I/nfjbCpvlco5i0JcpVjmVu4LuAybKVBZYbPL+BpTbCoGupl/qSkLYLBKsXBpo06nszb0jNCGtLB8goWCCWM3KEaRgLwzrGsQyJyCgRtHzwOPKkWsrwapIDsIEB0S2pZgAAQABJREFUYoLh5OI1DFrkGmaMRuQCLkf4Q4yDsm+bgEggJgAjBIbD2HMFU3Lod355DWiSbMEZDIcdblT7sCx3AXYNha1xsgPg0BQwIKSb7ZkjYwwtsuxk3GnUn2P0mQEAmbcvQnSGUfMwDOmtfZjdhKSdGB4Zg+EEw6EsZQ29AkRT2d3VaMyQ0jAA0OnA/NUY0RNYJlexwDKg8tmPf6kN32AsoUuwo4b3vQZYjV6WfQw95pM9fkLus2BAwHQAsDC08TkGp3MM7xeAHeYqjPCH6L7b6+H9f8jnYYMRUq4lWxtpEbJzCSC+qOQKgPb8J1i0FbBc+lHWTQLLgMsAzAkQYzwb9AOAjpyRT/8arO8YkBgO/C/AUVnOFbDcBGQRkJ4A8Pkd2VvDAJY1CaZBOkdnXIVX0mhr25vBWIZhBPP24PE/BLAsuLwAvLgiPLTgqODyFFalxrMElh341AQJCyrXc+z7yJI55BzgbwFLxd9cYLxX5gLLgGuCysewlrt9DKAYY5UpgMklxr2LSt8CQxFCkgv2AKAjbDRGRcMVtwCU2xj6ZbYaSjd0jg4EBS5+Jlz0Lz+ugWXqIrt8H7abYdP3Ga8N9YZRsMHvF2D5DCBfxnKT3xUMMESuwLINijmOMW/B3HJ+de/AoANYHjz+E4zlR+GIoDOCcvmePMg4QQzfvwwngwSW0YLXQhfx4Frm2QzDNQDigHC3g68FkP5UaxHqewm4GKKx2zWB/QKrJyEenwMsI5RLwp/LDjUnoL+htsPAXNWXP+2E6Ct/NfqMMlY5XrA2rC6sV/ah34Y9E2bEdjjCGKJbkdnSlKlKWd/ZqU0BCwQ4J5QjjLo3iOUclmsAEGHcd+kASK6kAxDUIWSkpaDyxGgIyFQDP3UUTBVIG7D+7D6EmYi4NjRhiglsCBxcvKFvkREG6NwRaRMs5wO+s/+QMKmU5jqNSQ6LaET4/uEb8psjhpQVUBb8FlyONZq2y+Tts/aYX1mDawDLzAuZvAuA7gSWzTv8otYi3G0PQLlLaOAeeRV7g53aDvO1yW+Nh6xxOKJMKCdGewBVVpoCEhjQ2xiRe64XGJb75EruEYZ9zno4I2T3TCApwu4D2pxj1LbPGBPm2pWxbF7hQ8Nn45AxJ2xpOIBQ3rAuXpHSQNEQ3xKAQtw7JuhV0FVJJ6fYSWKt3QdU3r+LYZ6+NRRmHda8wLKA8gfaKUt7AWgRTD6utbMrsHwHMJowmgEsq58EO8IYDdhx8hxgGTZcsBHND+msjzUixx2ZQDOcKeBXAMvMfx15uvSX31sAWLk3CSgrMmiXMmlYM+jkYFjd+QK2N6B0//CAtYRxi6Aq9hjOUyEACQEi89uuHYgG93jNPo/n6VxwDTB1TW5qS1nugstspLm+C2gwHxx3TYyvGmCVLjroMkZ6hDGXqT/H2WnhfoSDgCDdDX0iQBMzK+Z6jtJKDVzRR54XfBYf2ShX6ynAbzClATVaezDpAZUNuz8A2AnQgH1/gcioHbFO35wQEYQ9cQE4vuDs4O/rkNEFYOxRttmj2ow9yzgjut6OcLzAkeeEfe0EXUeECH5XhzLl8CHOVl+RR/RrUncAAs5o6xQZM1avAPOumP+WMj2DqWzJ7zZprHtstNUFhtdKO/3LNwqAHauhn6UfI2y46xBIabxPx0bOWfpeJ7Ad9sj9h9+yd3zHGYN1CHDQXK+29wy25LlCvlejdKR7jOcnhk/UxdoY6t9A9oBl7EH7rNv7rN9Kk3nGUh/1lLE4/Pk5uYBZZzhvtFmD2vyWDjFdzjodHOkU8183BOhZP1w9lziyMAnjXH/66gUpTlijEXM+RwSMAJYZirbR8cX83tUpT+cy93/6p4UTiaJjWTlvzXCOkbHcxrlImH3q2sn5yTNUnt24JgpOxrI7AXUCtBNQjhzLlPyg3UD7iCKjAwugsuca8+q2dZBh/WpzXhPE7OE80qNsNonGApuzUcfBwY5i7ugMOAlgmYggnDEu3jwDlEY36oeyzxo8ePxHxus/APpzjmHNHgGUBavYsRrnt59jbSjAsqCZl7fPLZ3Xmc7FvbZLX/WijNQMAZSzZgDmC6IZ2nt6xZ7PmSGdnd4yHgGJA1S2/9kP7X8GfZOx0tnpsf/grME5eIwjWMi1EQdYIzk/CzAbBSjWFHTlPi8I2mQeKTusmT33CMo6a8aCs+yc9dv9cMS5KYTrOh5UWpTx+zHsq27I+eAnnO/5KfdeQWXG5gpYvhsOQLEfGfKdPWpZMZYLuFyAZdfc2PcZV7GGMC5BXGEsCyz3qzQ4zB/WTzbr2pRz//Q9czmA5VwHDYcdTnT0h7WyLgksk2riUMYykYQCWL7PfHXuOdtNd/M9IrD8PXqk7Xxfvds+nQNm1glgdsDZwdQfnq873Pu0Fc5xOjtM3fOMWBPsds4VRPCYsDbHuuBcYUy0iArUJpJJB9EBIyL8oJMG83JqHyATRGcXWfmXgtT2qQOAKnS4Bzqk7w5Yw93rG3uMce4zLHUgneDQNSFKzojfHpGe4gaZ4RTY43tdoup0KduAcW100T54GPt6Ax0odc4UiysiOiBzwOVzxsWF4DL7u9GkHAvqowe4vc/c2uMs5d7bpP06GDepg/c6caaCwR11GHJfyLnbSESegxV1631D7Ev8bpfx3MXpy9JzTUSX4vwxZQzOcJLRqWyGfjkQxZpj6T3LAD141gnG8i1gOUHlUwDmBuuZwLJhyT37syMFuKw6bcytNZ0RUx45rstf8dHVH58Elnl35ZztJ7nA+mr8ufnH6kqf8ZOP2ldaUvQWZXmxKlMFn3onP6CO8j6L9YP5Qtru2qeA5fsAzDKWA1g+wg5BHvZkK8ta3gLLH6l9++dWA1sNbDXwu9XAFlj+3Xb9tuFbDWw18F9dA+tbAm7yCrAMQ/n5/1qHwg7GMiGwDYddQmHLjMocy5WBMm5PaW1YBz/d6o9v0m5/qtylrWvk+79185YGkvUVNn/27w1YDo1UDSzaWZUbClKDBaApbEABP2+0U3iuMQXji6XAsjlKdwAqAliWsYw0ASENtTy5AGBB5hgQNMwsDIHGzXwCy94uYkzAAFXA5WT6Ci5rZIQlgUFLA6He+QEt+dsYpPcAh/cefROlN40JSC8i1OPlTzAqkWsMMWHQo+IyX/ZlK98nTCsi67iJIUSZwUS4ekPewTcJLE8mABcYLaawKnswiSK8MMByDyOJQIiMF4Hl0p4loNgUI7Rs5WDbyeygvkoAy7BABJdlVMtMqGOUNAxsGCQx0pjreYzxXoBzisEljC3q3L5AzwPA+kEAy+jW35bFa0hpjKBngLMCy1e0t4DKGkc0xJZQmzsYWQRvlD6GHzvSoSBD55LwtMNKDDVXgOUOgEifevf5LcMZNwaw+DB6WcpUXmLcsbyCGXLxsyxaGFAYrdLQifEdA9FeGJUFxKk34HBjgLF6F4MsrKnzZxjKCYUpkB/GwmrcyXDeM/Q3ZRtdN/ie4HICy+S6A1we4gSQoLIGobVhixYxmjQ+8C7SpN4HGNgPYBntf/1HDGPUmbG0ABy9hplegOUJuTUTVNb8idmVMeYc0PAXY5662RfxhyV/+XeOXs2MjGKMnQUoGMgcASCShSkrtYC3C8bUlbrGwHd1CoPO0IwY07T6a9jbpW93GSc9dFyPsKTku8PwuwRUE8i3NJfjBfmNzWtt/1c1i3Cee4zRfcJNqz+BZUHlBuByAsvqLkOPmgMyweBEGxwL1nGhMZV2aHDukGNzD90FsAzDVtZSAMvocEi4zyGhPy+RFWM5DIOpl9QQ4xfDueBlhAcnh2oBOjqA5QJqsppj3kYe3hP6h3DJRBs4I++2pWwWmXDJ68OQTkXDwKz2wzqezXd9orv813+id+yfFNcr5xLrRpgPMTAB5giG9mDlKDKWW8yRNgZ1nTaWGPQXjm/KG8bGDXq2FFgOMI+2RkhcxvgKWJZZA7u3o3MLDKkRhlQB4qkOHKyvjktDZg7I6zn44kmIRmejMsgkvMZIe0mbL34iagKMXRvistwAeN4jDPYeKQYs284HQjc3MbjK/LkiBL7RCgSWDU8/Z+2JMPWhKbWF4Zx5vF8ZW82DHOGhafcSg/j75+R/FGwNYBn8Fcqy0gdQ7h/sYSjH4C1QQb+PWYstp4zbmcAyDjgy5d0D2jD4goFNvuwu0gZgn2J8DqM45RXhvS8xcA8RgWUWULoBIJ59I4Bl5orAslETQtDLCEO8jGUZe+4fAgxNRDbtiDk8AjQZEVLdzo/+Zd7KmkoQXcYy8yfWLkIiMr9s40nIc3SkA5xrR2Es34m80Ls6GFTfkUWnETrAZUpDWluHNEYnsJyAoTlKDdPLaEX2nfuGwgf0SsZyAZZJXQDIeYqzlSHBw8mBsWhp6E6BZUVwos7hqA4DUW+hcEwRWKZv0wiPZbUyxicDT5A557Jric+vcWq4ElhGpoL1NzhAuYawJ7HbxvomcNiCudmGtdmm3MEpIOQBoVSZezNSPMyZ4xNyet9wHdl/NwBd/oZroWuXsyrWypx6sa84duPhBPQRZfUafRU5uvltHXGarHUDcpvufUWeZdi6MYfjX1jg7BMR7p2Q77MbzhCyWAHQvWCPtU0ArofoQNNkX7HUOcooIHPG2w3nj3MZrKfntSF/B5sZBxzL/YcwxL8gt/eXGKBZY8bsYxNSaIw5M0Rb+by6C1DZdtJeTdPub0KttqacLXgaD9cgH+4ZQk+WflDgaBNYjtQcvCmgbEQRyz773T6hePcf/YFzwpFXCf0a/eTiDQxa5IL0Bw3azzeos8Ci9cm68CyAMvd99Tr48rva3pd/CGnC7jY1gTJlD9EZzIgdRloRWI5oC4Cnssdb5LzWoanR6kUb4+qONRwNloTQXQBGnb15yX7/qnaG6KwQTkrUx1nomVDgVKeRPvtGn/OTLNA2oFubcW05ZR6ZqmSEyMZU/5HDnrk1RueGvx/rEMHvJmNZ3rbtyz3W3NzmMS/hh11H6NRYT26GALGwQ4c4MwpStwWV/y97790myY3kaUZqWUXZ1N3sEXv7/T/Fzd9399zOTM+0oGaTLJGVlVrc+/4M5uGRVeTM3bO328UNz0TAHTAYzAzC4WYQOtqSK3Idg+0y6WWDnQVYy0x9ZWKHmSBXJ2ZcnzGm+vrPyBv37Rf0hdWn6x8wfjxi29VDZOsq1XPGbR5fcM7q0Uu2CL5kos8VTvO+OyvYsu35rSde/iobJ4zobqAhdYDyP+aIFrfQf/tTtkLnHVQ0YQSmPzzDeO14wclHWbFMv1Xr98DPO3EyLDMmzS4TlOk58ju3DeDuaPMMRmNYztEMvFjcReMemW3T/raZaKR/xLjlkLZ/+OFHiw36ixvOeb6lTVzxbjoTV9o/K3/DidyYt+2/nDx2vS+OfYcJjRQw5LZxOROd6O8e8b6NYVkDKu+oMiz/mX6aPvfPf2LFsnXL/vaBYdnJITEqu9L6CMMy70b6zceffIJhmfcLhuWbGJaZwEB9sh27HXYooSz0rU86e7B9Jku+9fHvmbjFjj7vaFimZTHutjM7+frfmaT672mD99mtwRRwCc/BIfPI0TI7wO37HfQuK37ZTcmz3p2Ycc/OCffuOOE7K3Wbs9wZI7hrRK9Y3mGct8t7Z5ey2DqgvbJqncqXunPJWPUKnq5+/G5xRjrLQd9jOyAmwneV+zGTNo4x0h/xjt+BD9027u6SXZ94b+ucOHHOLhRlWD7PBFINy/u4LY7p2HKMj+8xDfZb0sgHCSvBHZ9hzOb7RIPyC+q+q5YdD1X9vs+xL34vHCoHaHEMuYMMpMOxVBxt8tIxFe1ed81OJL7LxGNb2XKyA+NQvx924X/vAMeEPcc1F/TlFxjVryjLMix7/jlpI4Qa66waluHFby7k6tj2CRPLnn7h+/wv2QLbsYR1K4ZlypqSSv+OB0/W5r4o43FZ7n2tgBC4NiynybR4VvzICtk9lFkD2SZfd7W8XzUss5MH5yxnK2zPV6ZfLsPyp7RhdgRi1fJkWGaM5Vt7fa0lsJbAWgJrCawloATWhuV1PVhLYC2BtQT+BiWw/BzwToWjK4FQgnJ+0nTGMgbm1xuWV7fC9rPD7/Sf//zwZfALX3Y/J5/XfNAUliX1nZTvyygNyKmD3mB/yV/fzT9+K2xIgofmWF+FYvs++aHdDo0DMiq3g9KytnQtA80uyjfPWd5BqXBzjjIlzvqAYlIFhStfXHVBXWnXxkh1JKWowNiCouEa5UltNYhCA8VMrTZiFj0rGw44k+4AQ4vultVN1xi+XBF6oSECJYxnFl9ioAnN1Ct5PcTYfaBD0bGHknOPFU57rA5TUX7hmWwo0S4wgpxhrDjHnb28yEeqq2ddsaxhWYO0Ckq3HLw5Y1s5VlLdnLPCGAWFykl58yw6VxM4m1/D8C6rIHd0KLVLlkiWenyOotCVKGc4jZtu/XvLqtTISpkLPQzLj36jcfnjrGTQ2LqZrbBfLJ7/6Q9xZ99+iVJEFUspR+YrMtwi1DM83aovijyUSLUV7e5koLmEXxWrrhpQ0bNNGe+q3HE7OgxQtbUeRnGUun3mr+WprE80iOEuMK6nDvGjgkh6H7Fq6RG+Brs2LF9igNawfPKXP7Bi+ZtK4y+N/xGrsl2ZnbMPUU5pVDadq5hOMIye/OVfs7JcZZDG5RiCI6mIltCa1a7xYhPj2VsYlB+zWvkRiod76odG5RiWWZ12iuFEd4WizdW7UTNSYWolIvU/StGq92AnF0vEKyXDr2WEA05Ddp/zqvH+mK1tj9mS0BXuWyrtMCpafy/JX1lrGLPetWF5m7g9DW2RN0p9txDk/EBXdnrGqUpNNOUxCrh99wtWnF2hBLeCS802iu6efKAMY5C3niC/lBFyO/nzH6jf36OsRW642taR1Pxbbiq9b6lv8qFS9Fi54Q7e/TBG5ZIdxkGMEroXOI2/ys5yyOqs2JycyEHrZkvWPuvb1YiPP8O4zLa3u66kgV7PWtUwdnuC4UjjEecEnwQvkxVoizSsUcZVzl2/844gnzCOUSCGLR5TbvJBhDIpV2XEIwAql8ptI9dtykRnm957l9WaOO+9emKR239eIXu3AXaySxny7LvUPXumcq048oy+dtm+FGPDOQYBdy7YZNWxE0y2MYIdfPhbtgXnXGfc9SlGWoy11xhDzl1dZd9DvVTpHNr9Ab/9Vfqud6hPbvtLn6VzW1q3Nr9EZhcY/2pFD30miudSthbvGpYfvedKJs5Opd/rc4fvkf9Pk2H5y9DvFtg7O5tMKOHcz3c5c/g9+slDJt840WasEtIooR0T+zIygC/P5gTXtnU3qx9rleMV/Gioy3nJKJYveBdc0I+b7h7jlxMYlInnSb790Sfpn2wjTjpAs4zSmdWL9OtXGkZRQG9QHzZxbgl/xiqwsxieOWIBejSW+ruPYru2wnyv+joU/fLriuUnX2hY/hLl8heZJGB91UDjVtiu9HrrfVac0XaFb/eUrTOf4TQwu5q6Vjlp4CYtL64Y9vAnwzJmv9oKHyPR736XiQZuz3pHWvv45z95zjT9HxNMyjyoiXA7hv/3MY6897GGZSaWZJYQPFHRPH+7Xd6d9M/20ZZuAPi1nsS45jbTyO4yW1ejxNfnPXj5DKMXziMFTBaZYdzVqLytYZmJLO5sccg514e8JzaYAHbNrgQ3uDYsX2j0i2FZBNUA0w4GFd7XxV3KZDxKpoyMy7FDJuHQ12yx0v2Qd6u7gnjshP1k95c3Grd5J16zDf2tfeB4t4p8h4lPvpf00x9QBrZ/V7N5lr3byV/YruhnzzCoXLKK2bbueGUH//hDDFtsvf6ILbE9v/3ir18vLpjkdGmdpc6ln8bP+xRh2Wso76plxYirj6v/HX2QLEoM8Ika/KZ/GnExRhOp/DUq1oQkDMtMCHrM5Ju32NnBVYtO8tK5Ut8dKl6wQ8XJ93+KYblqjP23b58ap0ld9vDwPUS5iu+ICXT6O9Rnd2jRYKWx9gqDju/ga4yHtRW2q7CtPxiyWO3shKAYeOyzcI7PYlhmDOd2wCee14o7Yet+V8K7A0btKAFfjgstC/oDt/Tex0itv8vEll2Mibvvvk8VZrzGWOEK54QHV2F71IGr5M/ZnaCdR6Ao4zqn3jozJowxMa+OMXD74Y9Ywcx7Tnd4BDmsdHd1LRNYnAjkOerpl9mNwbEUP/Fdxe2kGN8DflNklwfGb445nzOWefatE7i+WhwwQUa3r88YbP+Tzxf7H/8u/ddLzozVnf/IBBrGENeuAsV30qTvQ/POpDIbA5e/LZ+0gRjKY4bG+E7/zLEMj2h7TtT0vGPfkRo4r5hAc2W9dsxguwd/j52tbunlef9kO1/HgMS/xAB31hPYME5npTPjUeufE52WhmUmVblKFme717CsgRlLMoZldgrAaVi+4J0Sh2yr3wk3qe6hwWofHse7lwdr54DCVyJlyPUs9LyPqBN5H9FnawC84/2RrYox/OlrWM4KfVdo22BGRk5Ic/vunqCpUfkRRmV9d3bRqKxx2RXLGsQ1LLvjgmURivCVf+ihTlk/H3/0edwBY/zUE97tXiesXHdL9BN2BXEcZirrk3+WQkqCMtq1X6F97eI8I/1A9y47zlDHKEQLnjrGZCzGEU54qC3Fq8+yf8j703Ei3wgatv3+0Tmx5JI24U4K9t9XpK1tyTlmw5dwaCEHxhjujpMJN+zikGOC+Abz6I3UEArc/G+Q6RWTtHRO1KkdC2jnvDOcCnHHeci+j7bsWzFWu9KflsfYmbbKt84t9Vujcjl2ObI+2j9YwtCw44p5+1nGnY4b9xlH7tPmpaHdtTQwnteoLA3icEBhnY4xO2MqdAOIzV1U9F25f/akxlROOrmDl3LWafoc5QulbVg+fp/xXE+i49tDw/LTGJY1LlO3aOuZtODOPakJ1tDq38ONFXe6wqBFOF0r0R06ymIGlpiHOot5/Bxno3kjfZvnnHAFNAuIvHh+rdySzra5es1lUyM13wG9Yvl1huV/yC4ZB6y8j2GZsQUzgKBjblieU/Awx9X8109rCawlsJbAWgK/TgmsDcu/znJdc7WWwFoCb7AElkN0P7O9+MjEqOyq5fv/tGFZxZip+bDgw6wu/DHmn4JGzC99pA2QVz9efvb7ofPrlHP/ZxPNgf7G75f89V38Zk2fgI6TmZa3pWJ0++p14kyCJiEKMj7yVATnLD4UCa7828VwsodxeRcl3B1L03T3Oo0yfMSXH3UMmPxcrNyLJDNRUYCiAXfFir8LlEQXP3yfFZPbKpNZObKNAmbn/Q8Xu+9/hLLyoxhSPMPMLbc9784tRzXueIaxV/O3g6Fxh214PT/wAEPC4W9+k61btzGmXKOEumHVsNtSv3h2sjh5ygq7Zy8wTnyY7ZkfsaJon+3dVNJqWHaLuEsMYa5Q8azlHbaO3T5EEYOvpiVbXqIUzaoElLNbGFy8z2pIlEP6pyhKTjFA6TzL1ZUBTM2PjKRZ6WgwiBIVXvW3zVuDIc4tvE/+zIoK3Mtvv0atolKxZKrSrKSMgZiVXIcoWVS6qGzZwW1zfvEWvHiOdM4rQ7HjSrcYlsWhUVyFJAbyrGJ2VRDOrXlTPqM8c17id6xexWlYbmmrnNOg3K4My6zUhhaV2id/YQUW7gzDcho7MvPvmG2Xj0inYdnzpIWXV7fG1BD9Anf6DSsOoLFUg3JZKLxpZaEKCLd3fMxsdo3Kjz79fckeJW1WomLwagPpNSs/lZsKpiiCoSU0iZcr9Wf5U4H+CodTHZXtLZU5+Xo23QG0u2rDM2R3Xa2lzFH4Ket2CJy0II68oRxZb7ICwza4gXJfRX+MbE5awKn8dqX1S84CP8VZ/lJnu9xEEXiMEvEIZaL+JspaV7ZvolTzrPGWt9sphlfal/yGjfym96bOyMPGYhdj5qPPNcr/QxSEbZB3xfcpq/tOMWjqoyEsxf2QXZR91ilockvWO1bz3MLH8Yds8+qKPNweitxNFLGupJP3a86lvH7yDQpszhh+yupWlKin+LYHa3GVswpd+IxTZhBdtq0UVUosZRGJTFHVZxkrGEaFOAwMKqehTT/nxGNQdEJAlJEohzfijlC0aiSizHARdORdSrA2GAU7ylK3jERbSj/E2cf0WS9xGofcVt7tHHcpi11XHbOjg85tVM89KoC+S+NfbZFJv0Vdr3xlcoM+p/os+61DVnkdsdX00W9YXU1FuabvuWFr2auc88mkGvpAnZdUisGdBx69yxaV77ENrIZl+hBX8bhCTEOrxmV9FbvbKNS30eQesqrvEfm4pfQ+xux7V9bSpqcttqPIpcVS3z3PVmV4zvF0AgTuHh7ONUjoKE+3BK8zkTGWQZStzbbiWbmeyfhYhxJ6gzbrGaq6yB3DVQxMGLTcKv0eQ6PbSr9AZlmZ+OOPqQcpA/AeUOeP6dsnXmlzGonveWc8/QKj8pcalr/MKr4yztxnK+zHyOYxMsqK5fSxZVzWqBzHSmfPx9yiDZYhjPZKZdQpA8/LRVWdFcvHGsp/y5mfn/Ee5H2l8ewew3KMVk/Yqhd3gnMF5jVbw+q7ylrD8vusdj6ivKoTgCHaaZ1v7k4LGEdU5MdpVIBr3kMxhNg3MxklZ1qyG8Yt/bPujn7jnMkKLzGSnbH1/xXndLpiVkdC3oUYlnD6GpaPMSzHsMQxDxqWr9kh4eoJ2/zGsKSBhpV2tIl6T4x2QB1T/ikD/ZlG2D49l9mNG/vo6meoM2xlW8ZHJ+GwawD95Q7vJn3AqCeMB9qlDTo2oMclTvbtD2J0531qnbvA6HDGyjbP59bA6AQv6519ruMUjS97GCEPePcfYlzWkO5EKSdmnX/D5CiNUhp/MER7rnX6GyggO+i3PGSifCcFxVAsbxBTNFWbC4idT1/QOSU1OS5HJ1BvPA/98MPPmQTFxBuOCvDsX1en3zkJA0Pnix/+Uu7Hv0yG5ZoYJKKSq4aVrATHUOauE/usmnRCigamXcZlbhXuO9+V8BpcdZ5jLLWWp4a7KyZ+eCasvhNm3FZ5D4Oq2yzbFzuRTMPyC7aabqdhOYZUjUNe9sH2BU6ScncXnDuP7HP27B5unzGMgsrW7uzm4JnKGxj2NwZuxwPuYqJ/y/jDyXk5xzXyqv4n5zczFvMcV48y2M5RHdRj/EyOIp1lnh1YGHNujPfnNe/+OOqKhsBdth/eta+BHmFd1esklufkrzthxe4Rk07a7TnmZELj7kdMZsSYdfodE6y+/RZaGZ86+cFJgbjaYj8jkaozyrikM8bNPNlnEJrtoaldrnR1p4JDxgqOG9IOkNsW9dVzZDUips2mDYxxmngzYLceOF5j8iXyvKeMTikjt9A+ZUtwtuSp8dJ4h5VhmXLivbzFVvQet+GW9LZ/277unklr1/QZ1+wekglC1MNLnX2QlW44+bIdhkH8tIfEOi5J7Qqk/b2tSPOdY6PqozUsM4lmTIC7j2GZbda/xNHves6z51Vv0Y9VnmZDJvR5W/Qb7vqzxUTHY4zKcZ9+ikGc1ay2YdwlY/mlYZmJSVJiw8P5/aLRXl/D8iO+W3ROHnULeuuoXL5gdxyP1TnBd3KF79xNjJ1evsduwGVJ5ygeJgI4GcA6efgO72lw+c2hAXyD+ubEn0ySIGF2mJAbZRefe98nBHgcgKv6b5D3NUZxt453kuwFvpM/68gD+3bqBFTalVufNAabv99HR5mIyniQsfQm32hYezPZQ9Bb2pvObzE4xZEv/gUT3S5PXVF8Fn4OHrkbFWesM1y6O2cCFzTdYlz2e+XF+G6hcoaHqgMAUjb2Px5PdIRh/Yh+6Ih3m5M+Ng4Yy+Pgnvxt1/JQ/Tk3UEC9Rh6KJL6TkOkXrNOOj15Spx1TOWkoTFuOpEvfZ13juJED6pNG5WPGLU6o3fD977ib8nzGhDInlfk+9x3uxNTabcESpGYinK5nVpPlRWjKqUJWopZAJH59zPx9SDbhr5PN8XbYG+c/4KnFEGkMufV9/MFg814g85hXJUDNmMYMtRW2hmUm0FxvLD7g++5DvvOyYpnvxuUZyw8Ny52Hfhdo+6/muQ5ZS2AtgbUE1hL4dUpgbVj+dZbrmqu1BNYSeEMl0EN0yfdD0d98GGpYXgzDcm+FvbJieZyxjJXAc5Z7K2w/yvqjbuUDDbTzof/8I60/YMjwlWtO3wqCX4acxc5znQW/UbdLKXg3PTVr7U8RSyCjVOK074e25Rxf5QeKDEtsy1ntKAsyWx/F5R6rZGJYxhCKlgGYUl1U7mZUCoSuL0FIaJ7zNa9hTSUlhmW2/7tgVYzOFV/Onnd7tB2MNDm7C+XNJkqcc1dmfP89Cr7vMPYyqx4Fs07lZa7wifLEVQ5x+xiWUSaxYukYt4cx2G1O71Dk3KLIefYT22f+iAHgp+cxLLvF8CNWLe9zZtguhguNy+qlzjGsuQWt5yLvvYMhcThXD5T05B3OIl9kh1LozlU6KEbu2Cr3FP5OWbWsu8EY00Y0DR4eyerHtAquYwwuukesgN125S/G1g22/nSV9umXnJeIouQcJWhWMKE8VFFs2ZjeSQDbrIJQob6rYzWM29Pt4rZVokFrVgli/E66FDDKGmR3D37PO71HyS3DUcaBL8pMV+PQAM8xaL0k79MfkD1K/VK0kztKu2OU2scaOnE571cj8dEBiqsT6EZh96Vnw34/ZKW3gRKKVTPvoNzE30bObp0trzesvDPN6Vd/XJx99xWyQhkEr/qKyUvlvmc8RsFOjKuYjj/hPFvdR7+NAeIepbkK+wtWf5xhMHE17/X5i8Kl7JCcCFNkjTjyTBYjZMRaCchPZ8p2mfig4hrj5K6GZdqCSmm3AXU1Ya3KdBY9eFT24rvdbRtv71l1pbqvnSqVaje3MdK5tbXOLW6lRJlb51yNf/gOjnKNIV/jsoZlJk2cfoXskN8VdS0rNMi3DcugCBs3aHpofShLMSzTro4/wxj827+jXr9fRnlWTd2jnH+poQq5ubpWo0xWSkGJ9ScKcBSnmbDAytMbHQrV4w/Ytr7PEIVOV6rq5OsS49Ulq7Av8FWenuNKiarho8rYujYZliXYK3XV0uKyGPhTWRWjrNHDeeM9NSIw/mZrToAtM1cyHqGEPKT/OsDfZBJAuw3ahQpoy00hWdzmZAur/LlDlm4N71blOrdHfUl7sD/COrI4pP4eUPc9d3gLResmdVs/K97Sb1EHaROuTrxzJREyLWMK/QDZeJ6nLltpo/x/9DGTTOi3PD+0jZY3rIY9/YFJKhgSTjW2eg2+D1x9/A4KV7Z5dsVzGZbZ8htl89OvvkGR/3WcxsJNhKxR6SCGZfLyzGTq7YYrqew7XYGVeo9MMGJVJmaEDDSGMannDuPlLYrgrMKm7ln/NBBFTirDAS+jCnlh3D7GQOTZxvqbrmbHQOT5jJE5TETaGE1cMaW7IQ8NJy/k9a9MQAChdc/xwD67G2gcPmK1dXiljqlY1oj+/GvOg//ma7a65X2C0UK81qv9gwMM76yiI53nG7cyWoPHyVdfxT3H9x20RR/u6r+HK5Y1Dmtc1nnO9GO2WXbl8i5b8OboAMrW1ekvOGv6xVMM40xeytbZpnOV8zAsZyts8r2j3ug8W7K2oa+trDPhh/ejZ/9my9ZM+KEPp2w2x/b5mxgmXfGsszzP3Lb+K7ZzxV0weeqWySsaWn0372BQ2j12whSGEN4vR062wrGslTaJUYl26VaslxiaNCxpeCtZK29bj62hHB5haSDeJtzfhFA21hXLyFT2MzonK+0e8E46YNIXEyd2MUbo9nAbGDXdDjxbgmvh5bLMxBADiwZDyuPWSWS8T/XPWan5EqOyKzavMCB2e9V46LnMbp2d85mZRLCn8QEjhKsCzzAqn337Fav//0rdYPIDRkb99MJkXbmTN/Us3U586PBBusioJhkUpLwGzsjAemPouOx76Btdue0K4yMMy48//68c3fBfY/C8ZYXeHatur23XP31Jn8tkIvxNDSKUv7tOWA5BGLKQDO2xzuZm94sYdTmzlW21d2lXrhTewffojwglgiGh7XK4C8ZR54xJnKCnbW0fo6rOfsZ6qJHHMZXbMp+6PbMTWJQRxqGtGIbgTbzImtkp6d+3kLcTvPYxVu6zuljD8iaGr0g0nTUydDW6fR4rGF9+azngWDV86xgkBij7DpNotMKARp3x6BWNsQdMkNl2LEN/usOK6OyCIQ06+yRoDt3u7sA5s44V5TNHIbhTBe/nLQ2M4Y8Vy0xGPGFMcoIB6/SnHxbH9N1HuGPGLcpwm/f4NuMZ5kpy3IqGZbcV58gVeXBCDfmkH7VtpH1IuOSUX+Oooo/XJMZJ3rfgclebfSakpX7y/kk74F3uhDTHaBols+V3ypwEEYg4dbYH+gqM2vfn9BNnL+gXoT/urxjunfJSpl3B0/bIN4Zltj53+/PtR5xJP9r/Ibut3DHZ7oojTnSXjpFo97Z95WOe1Q5BNkSd6mQMdNWf3XJD6Tt+9H2BIZeJO+4McWQbZBLNBuNSx3l38Pns6684T5xt1r/+OhO1ajU8b4vwW9w6ttzifRjHOOuIiTxHvA8PP/44W2HfsuvADc6JqW6N7vb9F/QFk8zE5TvM9zo07fHeP2LC1zGTvZwcm/prHYbq02+/YCLjl/GtR2VzVuaMcZQl755MqaANa1R1otqR+Hh/HYErx7nQFj1Cxt1+MglIOZj36FW4QVhlMLYc3RnDia6O1ZwwdklZeOyJvlTFuI2vnDNJiHpmn5r2D18bTBh4RD09djIqzgmkTtRy0pYTSxBmUouh27/+yx9Z4f0TDn+bYz0OOdLi0KMwbP/WLd5ht4yVbffZnt32T952zRl7g9W6fAPaDSc6vvN+3um+17fyTmcya9dn5WsZeFkecSSGk3bm50QNV6G7+lyjsmOmS8YX1ge/QPOPZ/ejYdlJcNaro/eY5MwEhqpbnFlOXtarOOqYkxWWOz84xgSfdIuQS3L66t1rfJ4Fd/TS7za+DMnd/J0oAsQ1XXaBb/q1wvbP8Be5wWvLr5+Ld/uTX75qzFCTEWNYZhvsZ+fU2SsMy5yt/Iphme2wsxX2yorlee6dY/u/nP86di2BtQTWElhL4NcjAcYQ89f8r4exNSdrCawlsJbAmyiBHqJLux+49cmgMmUYltlK8S//J2csD+PyFufQPtplRSKL8A52MCqj8Nz+/9GwXHT5y/WL3w5zTgr8P0jQQG+IX/xNXEYW/OjrOoJX7PSWzU0phDXC9CVouTLIaPz0LC63rtSYpgJxi9n/GgW2Hr8LbD7XSTUUCEmt4mCJqTLlOUF+YKr2KuXCLcqUa1Yd3KBcucew6FmAbs24xSqwbFXKagCNBpcojy4905SVSirhYxRFUZlVKE28fEDrPQ5iUbiilMSQcIDBRSXKAvzmoRHg9AT3AiUnvucDHrdhGWObZ4LuYKxTOfMCpZvO1WC7xxgRj1E+ooB0m2y36/MMSy9Xcbrdm1tA3qPkcvWavmeF1SoQnlFsLnmnLCA3yiIUMHsqQHEahbdYCeD5a5so3T137Aojlsrwa3gvhabKe/JD05fPdXxXs2rA0cDslpibKrqi7MLIhDIv5y9qQLPcSQvBKEihFfwxFrGCQkWtRaS/gVFZ/lWWuqriEgWeKypuNK6NeuQqPlcr7aFQ88zITVY/SbPGAo3+F5wXp8LSlQiFuLw9tmSMe8SWtIPXDSYTaGwT/pJ01xiFaxWrNQxeQ5c/Q2Yo7pz44EoNz7vbZ+XWHkpaV4LcuUrK1ZMo6a49441zrW9Z4ZOV3vC+VGBSAPw3beL2sa7kGFkkdMhaeVtmLW9lvoVxe0vlNcpGt+bWqKyxMsblyMq6gZvkTb1l22GwkJU52g7FWsZlDYiePXqN8VWDiEY6ZS6+GGZQtHtO3yaKauWnf007ciWesnPiRBnlXTtkOxsXPEThbG5Uvi1o3Uc5uYcS3YkUnl3KntBpW+4G4KpznUpr1I5RdqpgqvKvVTTXw9CmAe3Ic7MxLLty2RVC2yjRdWjEF+ffcrY5272ef/dnFNi0+eFUthbvSrbqW0nFZ65RDIOD8oiQK6M6un0VfOUEtW8CK/XEbShzTjAKblcvb+AW0BZFrO0iSn0VsiqiSYqsRO5qmzZ8uEo3DgPDNRNHVGpbtzcwfHlG4C71fsf6PNqe/oVb9mIAS7+FErUMLLQ5ZGpbrD/yo7/SeVa1ilPPDnZlzpZ7RNpGqb+eCX3BmbLt5LAEwNmHrjzE4LqPcXsHV6uxDzEs72CExkg0nG0/xjHQOilCI/sB+e3Sx2pQ1mjThmXbdxTDow5Xn+FklOrfNMLeYOCw7t3gYii3nusgLRNAKAONJjH0IW/z2bTu4jZ0rsZNfwMr9I93KLV1Nxo54dWVS7qNGJYtGrZI5j20j2FWfsMrzxvInT2TmQxRxjAV41n1ZbtJGg1VR3FOvhFeIz7732Y1uSvKz37EWE8Za1DWqJcJLRGyP7Qd6obOjTVdhXf4LiuAUW67U4UGpztXwPJ+OTv1iIVyWFOhC7fN1swYxWpL8I9TXk6+0bkt+u1sK2xXK099lcp56mYceDY5JznGZfw9zuHejdvLdumeE3qKO3/2w9jWHMMp7cH32wETeXIuIeVt/dIgf4uMz2iPZ9/9ha3Mv4P2mqx1i28TcBJTFPtynwaGLH1pza4K7zDjiUy9plVTrlHnQ39WH7oCkfNSXam5zXtum/Zhv3+vIYR6mlklqTkgEQdtJO2EPuKO96j1Tf8G3/eqRrBb+ywuKXA1YG19f1i+E8SYPLGD7zjB7dqv2HL2xklftFnPP7eOJC0/xUUYndqV7TMk5aeACs7gvpPcQIYWMSk5+5BsB5+tpzHifPi7HNnwmFXL26w8l47uR86fYbx8invG5DEMy9vUgWw9Dd5kHU+ZUiI4J1Y5acd3T3z678gUf8P2YL3Rcd3BZ855h1e3m/V8an2PHfB8cM/szYpl+ySN7bgrYDLmwt8gfXYPoV3Lce1mw52Gs9H2zHNHIxsrcjWUZotnaLQPyc4utO20b/oxt12+fIpR8AnG2tEPumNKSV7Z0YdTZzKREUOd/Xb6VA131hnauXjDI23Vo1ey0prxg3xdx1h/Sh2AJtLu2N4tC1c4k1/OckX2F+56gwErW2DTd+tnoht107ETQ7oY4TVSXwHvTjNUuPARg7JjCamljECf+/ymWhBj/ae9+K4S0qMstulv7L+2HTM41uNdHoNg3j/DuAysDUk0PVHHHWQiK+THbIqMYz2L9iJj4qcx/Dv5yzOfvZw4pvOdssfuJnv0ATp3s3CV5x79140Tg779M6v4/5KysN3fOj42D+uduPQlB17k0XvruqUVkEApBaGt844UmMzCmCR9Pv30DhMdrB/2tff09xo2Xz75MX21785MolBCIBRP5Und8V0E/fp7vA91+zj7aCc2ZXKT/QB9p8dYXI9JpikPMNlO0oPhe77xHmP7Pb5bdviGkRnFIy+9DfUl/aZjHY2otWK5jLoalzOKEh91Xrx7jJ32wLOP7+RGd5LgoSZmWZZ8F+jCEenDF+3aMtQ5wSKTXHlvumOB56J7hIFGfT6b0zY1S5tOHBkDcm9/qnNClmPufcacGs09k7zeacjasSdM6Lwy2dU+AFlf8U71OA0niHqkxR6TSvb9njFT6xWy9RvJozau/OZCvjV5IiILPTU5EcTw6RFJu8oCtzHGU6nP0/eR4ym/MBVCufvsasVYV59JGo5tzNvdPmpMxSQixjrCpyxTL6CPAnPlcvqFvP/t/3inUNesX5aNW2k7BrCOaVh2xXLv/FDHrEBOaAFdhDP8VO5xb/jPXXnBrUZWUMk6MSCePaWeraZ4855W2P4Z/iJPi2mw18/1WP3ZL3Fuve5dTibDcq9YXhuWf0l067i1BNYSWEtgLYEHEmD84Khjfa0lsJbAWgJrCfwtSGDeIdcnvyF8YmNY3nDFMoblLzAs/2UYlrcxLB9jWH6EXW//f5BhWTmtfsD8LUjufx4NyqIVQH7d+oEb+fCTN6wf6QaM1y3qh8DrewUWv5VhUaigxNCQlpWvGC7vo0Q5ZutRDBdD0RGlEumWWArTqkKhiBjqZvJFPaUiI7PWUWar1EEZknNNXTaQFXSuosNQqaEQZcMNqxJcibapQhiXaewT1TyO1UG3KHXcqm0HxYlKrmxTDX4VpyqZLy5xFyibL29QvLPyDMPycbbC5pxADcsqo1EcPv3y3xfPWEH7nG3ytllZpdvBuSWd5425skambzEU1gooFN0ouTZQzsQgpPEbet2Skh9AlShy4Etdo72f2zmvECNHVgyiIImc2zAJjzFUo+C5R4FWCs1SuIAIPCDRaaBB0aPCyS3x0BhRPkdaj2JYjnFZWuFJA1GMROLW2KlMvM8fIJJH2aiI0bAco4mrw+FJXoyv/gCFkfhdaanRAGXSJkaCrJiAXycNaLzIaj7SmNC0W9ClIky/VupIOwq7GBBYCUkaV08MtWDoIMOiTx9+s12vinN42kJpuMWWl/p3lEOU6CqRUVphfSiHQlgllfwrQzgUZfz+VXkaAhNescL5X/CmGc9OKEDWkTn1M20BOXjOq4o95a1bGttQDKPcS/2DRlePiDOoc1cqQ1fyR9mG4tFzZi2b2jJZvjWku7K1ZJ4yVYGHc1vVWwzpGpVVDE6yG1x2Riq4kxO8Wt8iN419lKMG1NBFXXBlbTnapQo6CI3KuAmGZmXBRpbZHljT8wEr/o9ZlXf0we9R4LpFJEplnPVeg9fp1//GyqA/hq87tuG9t2yoi9axKo3ySzFMBlxmR/TgomqdgZZOFMMCeJMLnowYRkjUs2qIwY+zrFBSVz9GeVlm9mX2MZRTOdqHxhJlQxpzs02nbdN3bHDvuX32Uz1Bxb7LMrN/UVFrmbAkLe1P3/7KM2Hd5t0Ve6bVIWyzabKzotG+y35L43TOa0dp6vmo1hnztu15bqPb997iRwrWaa6c78xknGzXiW+fucGxAtbRi5d15vclvjyZrXkrC/Oyn8y5j0OJr5xaBiqF7WPrjETrsJMPbFfDyG7/jaHd50ysCSztiwysrzFuIdMyWPsOga4owWn7ni9Ou68zF4FHLr2i2z7jDpwaa63btVMDtMPuFu3LIxO2MIrJLxYb8MsrRxdwRqmrWPWlJ20enreI2wbe83o7zb39JWlvmKjkSmN93yttoLEG2Pb8NNX11t5l1HObXZxGfMoo7dS6gvOdcsmOBFdX4DrA4IcBQv8Iw/IxKzo9Y1W+a0W2Z27/CK/w6bsCf9pm134KQw2Fm3LUOB3D8oHb52LYZveMo7jHGExZvUj7ehnDMmcIM7nmStkhr+zGwS4jj3nHbWNk28478RDjAkdCfMOuErgLDMuu1rOOZltdeLfqUYKpZiXHujeIaOqRNcmr6mC8UR/TklMHrAfSX2f7UmgYAujDaBtumapB2ckP95SpK1XFdZ8GT52zndGP0wCrflEPUs9c5Sqd+pRXU5H2RD5Z9el7gclZWxgLtzBoUTCsxKNP0zjNezTjhrwHfRfUBaUylSu85b7ai4GylrpQIKnjgsh9u0IAH9Z9HfTEUe8P3Yr3M45t+O0/Qhvyd7UiK4M1bF08Z1LQCUeC4NdqeVfNW38LoxlISfpv8Gq0rx0G4I227jvBrXjjO1azHxt9mWenu124/VivHHY7f+u3W+LvMNaK6JFRrW7kHcp4y7bnuMuV8xqWt6ayHbSQ6M5yow25EtXydDtcjT0pA8pd45r9830MshqtXZ2PUXCMDVLXocN3i1dWwHoLjxqnM3EL/46xwj1jDMc06atDM/0K6e6st+DXl25XQetv0r6zdbB9BFcZljGwOR6jbykj6uVilzHLDm4XXpzQ55jJsadtx77bPlxjtO/BjWy7jZyQRUoj/rKOWAclv0P0ewLgcsKZ/VWN0ZKXE3rsw6A3Lu8sypcGmHN4KRfHNLaH2lLc9wHvAWhzC319J5BpxmQeb/KfDMvwcfT+p2yBzfb7tn/6q3LHTHjCCMe41p1OPGPd9p+jHiijqOPgzT95KueNrI9+MTml1cCxftV5/YyNqZeWn+8Ztq6qtg5vV/SzniWtr9EvdSs1G8n5ryPDOpqBvoE6tE1fu804XqNi+oOMr/0WoI7S5zoZwgkUNZYoelOXLCXqn1urx5iPEXgTeYez5AUvjDXdFaS3OIfFGnMCVf0/9TIpqt35XtuijmzjPCZoYxt8cZSp7zfK0bqnHzmaVlnan8XxDkXWDArowxxT856zzsKLY+30uxDhmMsLMnPZU6X9s0W7E0zcItx+xL409cn3tm2feuwxPjrHtGn7eTdRjzJ28L3qVvi+/sb3jB0NMPb9NQHENqKrcYak6KRFGhy9OknASWjK1r7IsRQDirQd27/fRsrBYzRSqKRx/B0ZYGR3tw4namxkO+xqkxrcM7Yi7xqvp5BISHuwElK3MrbmneGEZ8c4OuvYPQxdp14x3vJdbt2izerXeNhyLT7kJPVMmnJ1PV4+111Lf4Qrp9m1fJS2cQEye7L7e+OvJZ+w8jP8RTLw2hKq535alckrAkFIvtP+vxqWM8agF1yWovm24Nsv2l/Jexb9Stw6YC2BtQTWElhL4I2UAGMIX/Pray2BtQTWElhL4G9BAvMOOR/i/Vn5wLCcFcu9FfZYsfw/0rCsrH4NH2//Xcp8fCTlG5wf/bxZVWxQoFFw5B6FEc9ZiZCP9spdhY6XSjXMCPGj8EW5oyLBD7g6a9LVW26+h5ID5wdhf5+17ydm7itjdAohoFKQeamiOjUYYvBTkTXSoTxRwSgToXsYODQyqIhEVQUuayaXeXB5opiq5huUL2pLNVK7siWr9IAU3nxvsOqqfLvGP3pXwzJGsTYss9LZFZyeX/njn/4F98+cT/qH0F1b1JE3io2sPFGZYr4oQlwxcYvSchMFjU5j0A57r6nsc+GhhtqittRUGpSVtx/U0n09fDmh5IIXlQyrl+4WO1HsotJBhpNxGXjBooDkphQ+VRY3rCC1fDRUZcW5il8VfOBSyT4ZipS5yp7hSpEGJmiNrPBLqTxm/suBxQhdOjbszAo+1wZIRxuJrBWl1KE0UJCL3y39Uo5sD5qVXBsog+QBhP7J19a924CqDMKZN3lEbsCk+oiDNFUnrY848N3Br3WzzynUoOtqhZ0NXGonqjDwuzIqDEi/eXMpa+9KccVN6pLc1TVqIw8K27CStcq91F78tAloKXmr0FbxVYblnCHp8ifzbkce1sPCpqzBJH34bt8XhSu+yrU2LKvMc0vV8Itvu5CWtGGNECjrNHxqkOh6ru/VvCZX6I0MB70aNLOFJfL2ClbwtBE07Y3A1H385BcNHdOLOD/2arj99z7FqPw5SuzfZcWyRuVdVpaoSDz54l8Xz7/4F7ZGpx3dOTFEg4VGNPOEKvNuuevjBnfxU0MMlh8iiv5BLAHCJsJKomOZUbV72771hHZBe+/zLjUOunWifoyeKilVyjoxg3DTKnfb9Q0K3xvadVbtkb/llHMhqaO1XS3lKl1eqZvWSftL+kfKopxGiaqTSe8288iwZRlDwOiT6LSo89Kgooz6T51RTpFV6gh5KSPzjJwilVAQKqBBw+XY0zNbedr23NLTK0mFJo8Yf5EBCVBIy7+KcfoJcUiD/Nh+6Qs14qnUj4Fl+NbVbWjSz0plaPXcZNPZ/ypH83DrTPta+VT5rgI6Rmb7J2jNGajk484COg2H1jekGEOvvGcby/ALDvHzbz/QeVknqq3YZkY7l1ldknQ6eIIOW1tqWeTLE755utPKjv01sX1Wuv2JdUVebPcxiEs3kwm8egKJ/Y8r3Ko8mWPAtt8H7Oyxz2rOA7Z+PmCbc7ehtSyecMTBE444eP7t1zFMR+HuewPazTvvQ/JCUKlPzADAmNxQy/UAAEAASURBVMCKZQ3LuLc+cgX0B4u3OEP4BqOkRuWX3/wbqywxUHIcwIWroBHDO5/8vtzHf4cRoCYfbUD3GSv0nrF1thOnzjEs11mn9j1jIgnyTDNHfoowP/EVJ7Ic1/TpHqABl/KRdmVs+ZezZ8pEAOqa/p1tBD/GSTIr9Pwig5ZH6hx1r+odbc4+knh9SiR0SY2tYLSwtG3rt/Uv7QzaNGJO51f7DLz1yjwrdcit+iSHXV3GvWWWeoCfOgdA2kdlLrY425J1Xz91HCPiJnX+AOP+sYZlzovUaHrOLiS6iyfsRvLiR1YI4vCzFbZ9OK5oNIOSjXU27wH8O/qHO+qgvn0NmeCP8uU5Rl1kcI1B+ZqJDtdMIosBkr5nK86Ssa757kEKVpbhqv7RhcCR7U5fw7KU2I3Y4+kyZjEPhaWRWTqkgXdyGUm5J4dMXEsf4nvFCTYaMd122PbNal7FJU5l7Kuae1cghid8t5J3TON71j7aySWb8kh7jUFZgxjvFFOmnwwGyiflQP7wVe9hkJOB/PTxDo4Nt6BBvyQy+gaISN0efUnkRH76toUqG0ukLkXgfWg3rcEJrDooZJWfvuM0ek348f0bWckPsqu+pequfa/vHs+i1jBuqlqBCR9TmyDMvpLMJ8MyeV3Tx2nwe/zR7xePP2Yb9o8+p/3XhCONcWfUO7fOP2Hy5OXTH4I359HSTqbxtnzCQ7oheYEr+apxYjgsHuXVchZQn/wnZ5gdCWWR97Ztm/JwFXbKAUjrIyxUvvqkzxbi9Bu+s9OG05Z5nxtrW46zFvosLZQN2Uimfuop7xz9jBNHvcw9NGQ8Ch2OE3XdFkK5xIgRvHHcp87nvcHDGMNaPzOZNRgcO9R42/auUbXkJK/goX62c6yWPG2H8LEsS8e9NKHBQ/UzUiJVDmtKLhrLb23/1h/bffocpEmYdcj2oXHf+n/DO+WG+uMEk5rIAa/k6ftFWcq37xzbfvWRhivDGn9DPLlzyQPC7bGX4ydr5M3wqy6nh4lReYt3vKv0Y1g2vZc4aPdOMLmzD+Bdo0MwoSkykS7pwU3fjOTheMRxAmROYxrrm++yWqUNN6ZRUuKw/8Q5UUc+08ZhxPoBGbhAFlnFYe6V9epVdSFho154P7v1KdH5AXz2hLyWUW/q3QqvP8NfpASvLa1Id8b77HZVDENA6RspT+vVyoplt8L+3S9vhd2GZXOvfKSicxx+E7aaez016Ovi1mFrCawlsJbAWgJvnAQYF/qqX19rCawlsJbAWgJ/CxKYd8jLTzC1PnwQzlYsl2H5nxbbN7ViubfC9mzlHTRGbrPVaobl1xjYezA/u60PmIpY+Zj5DwTya/h4+w9Y/H8VHR0QYizJI2D/41GS+PVTRRDFURJUFsoyShkeoxjhQ0/Nkkr8GGRUJgxVjGqJVrYntbi5Sg3CzXg2v5RqfO9VYqgIWio3VGQUXCOpWjPTBASh6UrRifKDDAJtUv5QI+DKUGu6SSEVWYTa4FDRLawGgKN3P2ErbA3LnLHMdnkalXcwLt9pWP7jPy9++tN/W/z0538lT5VQ0otSW8UNhigNiHJbKxtdNYESQ0UGqz9d/aaCSFeKU/mWWilFIUq4TzEsQ2spaiQUx+WvCh7PNtxWVihLFJE8lyJtAOH5UR7DSqgTlxMAiuIoYIci1oIto/JQ3IDT1Mo9NA0/eZCZ9JZBTQVY5SvNXvqtktOPvCPzorGUV5aGfQbYSVDKHJVxlCA0FpeF0TpRiqUuxSqvkobUBU34NF0UXJbIwBUDqfwlryonFZYavUp5JgGR1MhXr7AH+TKU8KLJ8EgBv0CFVypQS4DYQi3tQwWbyr5sg4jCXwW4iq6SeeXtfZR4CiNXsAejNLayr+uaucuPyrSUlEpE8ojh0vSDvpZ1KwxDIen0pdd/n0I7dHsf+q0jtm0kFP4KNAo5KjMGALlTKUeZdpxouMThVtiqSD3h8fCD33EO4u+zHbbbNG6jxHZlqdt5n3z1h8VzjMpu17ulYVnFKi6yaFkHadMMpcqoxZQc6yd9PQ2j+vziUDjBO41+GUZLGSnWVsrqd59l3ekVy2UQsa8r+Sj3rIaiHaddk0nKCH+abGENoIyrXhexZRApJW9NqDDemtLlyz08b5JPybxpK8WxfW2UqMb7FznAwfDDKDRYDOLRN2dbSOgQKX11FZilR/0Z8hFFoOMDN8q+4DUIlYFKwqRB38qnYTkWHxS1KoFr9R6tHr5SV63n5NO0VfqBHxx9LqMG5qzgVMnv6tLQWfyK19VSWRWN4VqTrQYT/ZVyTU7i1hlpeda96KNaDqPSM9ImesCTSKkJYql0ezQP67h99dLQpQFiGCGUlXlRC5RXGS2Vr2wre+B4SI9HHbPllGH5PXwMy5wTe4BReX8Ylp99+QXnX3+xeP7dtxiOalJSJiZZV3DWNTIiT/tKjNhshb3Lecl7x5xbin/8/rtMiOLcavyrZ9/TttgR4Kt/Y9t1DJVOdMIgpYDe/uTvcL9fvP3p34UXjVSuYjtnxeILzlg+/Z7zz09+zCQJ+1+NtopTzuA0MlRYyktmiRpX3xnBFa/qYKDSYYiFmj/et7a9MoCO9kE/aV+mgdSJVkFDmStPjS01oQFJDkOIcpE+oONH+iHM/GmvlFEkZ92VUlHCTKhQpsCII/XJKJ7rr8ivamTdr7ShaGJPugabZqcTjkxSn+KT/ygv32+e8+vW6/oHnIV68OFni4OPPiPJJnL/hiM2vlmcc67ozRnHNcQ9y/ih+5fknxzMo+pr3gPk5VnLd8gs/bfvBPPFd2JKJqXYlsnHsr5hNad+lSnys/9RUvGLett55EIlVnoFiw/TGpdjfCY8fIcWigj+b4ar9xKpoMMyzgrdQUNNTtGAZt/h5BQnQPEegMHQgh9eQU7xlDyhPVTKA7K8HZPl5K8msEGldYW+wskH6aMqJQhABF3dh6V9ph8DOX71K6NvGXmnzJUr6SKRMDpqhzIYspKqlAZhBYkwuEI/fssnN+CSDiOR7sxVPUnvibyywlzDsvJCKBmT45dBvN4/9r/pF6zHYhrPToiRpn5Hm1/agXhZ0fr4k88Xj2j/jz7+vNo/ZeAEmIsnP1D/ONsbd8222NX27dMpJ/lQhjIzGJMNpZG46XcZ6WQdJWKClsz0LC9DFt1XiqvGOfqVwiy9NJwqL43K+vWNYnlzH1hCfQ9NOZlqyo3wIj2rlmXDtqFDvsmJjKRD43LqggZeyjeVD4jyxelVXFffb44DX1MP3ioR6j33Wa0co67jP/Op9wcvNhireqoxNe3PlJZnly1+ei4Y0A8jyo1Luqe2P1J3f9ft3vaetu/4036AtLe2fccwuHxDgKnzlpv0iWKG1p54abs0/9Aix/wLW7xzB958txDKKDEG5tRCZaEMMLxvxcDNOx6avCJecaStKgfarWVofcMVTU2bciM32yyeY6VMtrNPMDhRwCibMYaIXxQmv7wzlKeyJVyelKSO5HECel+huXlwb1hBVCz3A4He8po9DRDjknIWtYR/s+4su/k1f/aV7tW8Nmh2Hqmo/L5WDJ0IiLR3+3pqwgVV4plnLLsVdp+x/Lt/yFnLfq8fsMvY/tucsbz/mJS0s3xLUt+nsmoqOlf8DprRNN022BSwvllLYC2BtQTWEniTJcD3jMOF9bWWwFoCawmsJfC3IIF5h1z3/vpB7/ZYboHpVtj/lDOWv2TF8lYMy2y9yKplVyyXYZnVAGg8HLc76NfVhwi4ejA/u+0PlvILwHtznuC9f3D1x82D4P+1HiOkwTKii/RmMja63rLjo53nKGyA9Pt8kq9KAwCFL59SIyyf/PhRASBw/XzMqzjw454ESRV/yiwKBfFbC0KORER7KEY/+IcTQSEpH2jL1dCkw/eplJwoJLlP3Ri0Ctcfp/rSrGHZxKaXA51CkPYYAsFyODMs773NFr6eG4ZhWWVMjMp//G+Lp3/5l2FEKWOKK6Gz0g6DbTCjrHNlIhq7KEpcZRgnvWQe40jnLzHc30JHKYrwkWEpipFj4oWpWw3LpdwtfosPImXFvyGglJGKF/hWyQOl8ct4U4qmAA/Zq/CqxCWTKvH6bYOV5aOyOcon4KN4rqwhbtQF8lJBKt2lANQ3XSmNVIb2JWsaGUqlCK8ksvqYrvJSCUTpJE3lnTIzITBehOLE0/dDaRgpGyaQUEqhJBHcpoywGhV5gzJBEQE/PCeXzquQFQwx/vlfNBQdoVglP4yo6BOphsuspoAU62i5ZDJlWKlDLCibXmTNfTszrlUv1m0ulIWluLf2DxkAU/CWQuEJn4TLS1jIXdONL43mij+1FZ7DtixS51Ju1j0go2hMpORb53QoFFHUukr7BkXisUblT1mR98k/5tw9S1eF4A1b0J5g9Dr5htVRbIW97cQLlIqujEweEjmuUNVEk4fEm1dAwNX0SbeB6R8QTMtIOGWdmjWArVsCa9SyzrRh2YkylpEyrRW+Q+kMdOEzc42q1U5Sn0JLKcLTunwGJvAgJ0Xw2R+K05WzJStxlCwjccnXSRk3Ocdx0KciNjWNcP9AEJ70dcnFsOBQ4UpwhVZeoaHKNsl95jK5l/IpQgeM0gJZKd+ViW1ZWScDYOVBIRcPKbO07eoPohgnXvClsTw5VfnAl/y1YzlTZKSSP4lM6CVP4lURHEUz9Y50qRPSTPbFhHRV0tQDg3mOk7H8m2CkzZ33Ix/zC4yYuRTMcEa1gSZghE/1XUpC6/C7rQdF5SeJ6XFUsCPXpWEZ4zIrlvdjXP7Q18Ti+TdfccTCV4uT7zlTnq1Jr5mA4VmhyjcyhbriyTZf268evf0B21+XO3j7Medw4955zIrjb7MbgBM4Lp7/iJ4eI72GBN5PjzEsP8aw9BaG5euzcX4m52xePP8J4/L3WeF88/IZ6lmMthpY8NNfkb++/Edew285Rpr9oz9kxV1dygoHlsjCXgrM4aX97NphO4wLMguqZE5960lQ1QdVu/Nd5CSnvBPBKFn54SZGVmQVvIMM48Vs3yie1P/4YY67sIcvoNzxl3IuvMHfceGpsktZiwL4YCZfjSr13nXyFOfOc57tEWegHnsW6rvvLXbZDn2XenBD+bz45kv6wy8WL//6LUc/vGC+Jg4/u1VQByyPIZHQFDqVDU9OSquJQbQtZSzP+PKf/gM6qh+BJuR4R4XTT98DQ/HB0cbSsCWj9GHmmXe+/rivnVLCbGTUtJRhu2gIdmkwlX1q3Gjj9h84+1INPjGsDYNP1ZCRV/JMrsHTBsaszMR44OpMy0hXbRF6HXfFaIdvOSmhFHrBZfzjMy7vEvzUJ/zOm0TjGnjFLx8jjb6yMjRDypHW7KS2fgYKs+I29ckI0fAzuSEj+9mqr/a3GgTth31zAR+k3khzyc7+N4ZB8yYsGHM/MJMmqW1LTmpDVltsT378KUblTz9fHNMHXLHlv+fm5vzsZz+xUtkV898zqeHFmFhS7V8aZiRICHTIFZcRuPQDAcoD8ZS9vAesgKSsy8rymuQCkPhSDsi1egbwFkBkFQ6Rh36/w/VLkoQmo0mqUsalbMpPDPcTDY4Pweezbdf8QwMk9uQGR+S1mnoQAhxZ1o83w8lrjN74g4vEWaZzw25WRafei896KjfWf+n3vvjI5E3lgSv+QEcKL+tCUVP5lxwd31db05evGud3HRqw8k+9KedXT+Gf2v14bpklI36sR2AoF5q4V14Eljx9z2lQlit9qFa2ka+0YFymvW5RB1NPgBM3GPhRDq6KL19MJZchydHOUj6jQpVRuYzLhYf8REV5SId0VdlURikm5JtvsMgZqk2QC18ArqRLcD0nEHyrV6czNNyvRudplmYObtws6jUJ34igqh9LUoulYrTZjU/Eir9M8ooYNiL8JUDqE/XHWqph+fkwLJ9iWP6QM5Y/+O0/xD98D8Py2xiWOTO+DcvuFFBf2SvUDOSjAJqwZZbLu19BGS2ZWd+tJbCWwFoCawnwzp/e+mtprCWwlsBaAmsJ/E+WQA/RJWN570exhmXPuXs5DMv/tNCwXCuWFzlneWlYnq9Y9hsLTPn4KD8szm77A2bpL0f8D75DkrR/fimuYX7V/iigfo36MT++ncP2iK5yVEEwhBFFDSKeFKmK2/IRBiAh821fJacKgOfxMS8oSqxSpKBUED64K20yMZC0NeMcH63cPRaGVnaYHTbaKOtUdhRhQVTJzS8YikZ5irEBkDJ2mmclM+9StqKMUvvnFQ2DN0OxgJLBSwPgLUog3eG7bOHLiuWj99nCd1qx/CiG5Sd//L8XT1ix/PTP/1KKNxSYqo4jt2gY4d+soEFCVF5Yx6P0zj0kJFylH3HAGi94tm0mTgOz54MpCBXsTXPhJY3KXpXCJDKrKH24cZu4yQBmBDxpSG9lSxlwzTCR5UdW5u7lg/f9zO1oeCNF8pv4gobVi3owFEnK3XxMNxKBSnj7i+a76uQdWvFSQvpcdUK65SvqqqQjrbR5b3ri44CXWklxa9KAJGUZX0J3aJEVIVV7KTvVFiGxfH4F80c5dn0npMItW64iofIhReL0xRxnWwA0CnbSpP4RAco4N250Cz5diZaIIDW1l37LB997QlJXjOa5jaZhB4VdjJb42TaUQP0oCkmYtpRkxVPyGvTCWXIrrJ1z+YMxvOLRdJGfPgkmg6F8kd/k2NL2zi0fcRqVH//2vyze+t3/xk7HnK3MiknP8L45fc52v39anHz7x8WL7/4cg7LGZQ0o5jGtbCDvrtuh1XKJUhQarB+hDWoCBFE8A5F60PRUP2Nq+fDXCzjLSdpxZFmGLOLDt21uOOO6XVonTN94qkyGPMjXZ0ojCMtwU2WlQbn6RSH4k0cRc58SoCLoF21SVzFFW8lfSYSH4PeHa+BpfPal4Rc/+XRe+pENaaZMhiwgo+ohEZKkDAaQLSQuafiJfMwX50/zMHzDaoWT7Qt5QMcWctyyEiaFfCtz5VLJxR/agCsltFgKTi406sawK27SVB0UmYjKC72SZzA/1h9ixcKvV/nGNwvLmmC8MUuolmcnh42RrjEWPumudFJKen7ii4//3NMfalxsd+BW2Kwu1sC8j0F4zxXL732IPDZoD9/QHnB/detqzsFm6+pLfPu8MqeIUbYtl012ED9YvP2bT3AfL956/2MmPx0yCYpzno8PFi9/+oat5mtXgEsMy2U48MjNXdrl39WKRfyLp08XZz/8sDj78YfFJYbl65dPcc84S/M0WwP3+dLFnOUCDZE7fjOMHFqeYX0IObCCRRIQHnmVMFPb866odlgTKYAUZjR6y1J8fXW56KcPBS7bmfKc+hbaiq7KG3xpx6OOgahwiNa2anup7CZeBrXpY4G3rQtdvkWhUUY5kI56nX4I3/rs+yfbY8OAdbnK3P0xmGhz7wrb3cXb77NdOZMJ3tGg/DZbmD9+HHfJGbHPvvzT4tkXnHH73deLjevzxSYTNfU17DvFRb9aUgjjRx+adNze4lfdSBFFlhRVgHzv9ASVAMuA/+N9qh/RgwPSp3zS5gAkOO0viUQqwzov05gYd0faas8a2gRRJsAgaMeFvpACa/5e+Knbo45XORBHuHlqQLIfMRPx5D1vtIaDvPuUCqVpXsUYdJYUarxhPuWaxi7LwlrR1h/rhGnE5U/qEDytGHgJD9v43aZ60l31o0V3hAIar0Lnb923X/1HcoUfBIdLWPtKgP+qs+QrfSROiopKvZegor9ytY6s5Mb7J+fPspvO9tGjxRFG5aPPfh939uOPU/u/ek7bP33G+/kpkxrOpjqXyWnmpyzMXRlQEL5jJchwm5nlXwF1n3ZimRUxBMpjwdTuPHIirfxG3pZ3ShPISiR03QJL2rwj8P0T18gRmEpXGI0amYpXAvArb24HDSVNcjKabJSv93mPQqrvUttF3v+2eyIz5ggb5A3T9Vx1k7khkYljC8uSyMpzuicv5QYecUnrVHekgLys4Jal44h2IU7YIQppVWaGpG4mH75fiMjkVAGgrcccPIUuy8t8+YlL/oIiK6id0cK9ibgq13quvoD70F6xARKOBGbr6BoxxE958azv+CV9EL/BLTB49DYo88rJ55Jzcad8ij4AYKLor3IY2JTtKE998Vnc+Ybi3qiObiN9T8aYZGGqBgxxJMzLBz9XB/azudRVOfbT3J+lWYJ3ojngG3nfzauJn8uh2W0RTn4DD38mIerU/KkAbNEalf02z1bY57ViuQ3LH2JY/gAD8xFH7rhaeZ9Vy9t7jyhLJxv9kmFZ/OQXQl/NN7n/THBRtv5dS2AtgbUE1hJ40yTA2MXRz/paS2AtgbUE1hL4W5DAvENe3msMwLCMu2eFsiuWv/w/WLWMv42h+Xg6Y3mTbbBdtYxCVE0xo3p/+4MkxoQxmJ9/tOSezHqcP/8Aec23yCSmX4qbgH7NN11A+r5K+XBuGcr2Q/mMT/z6vhaygfErrtDkCXRRBeAHvfhI4H0pNMiLj8GKUxkQAHxuAqSyQGVUKWZKAYVCAY2ACo7Wx0SfOBsGmN7k5i15UXRxE6UIEeonVHoIE8ePSg2NfKXkGAnxAgGsVIs3RmUUlWVYZitstsHWuLz3llthP1psPyrD8lONyrhnboWNUVm1cQxiYozM+GmauDGoFTErvvSSd+L9gYYoYaUFFyHQVmJcNt4Lv9oD6ZDVhG+UrXxEaaVmRVjDm3eIa/VNIgdCILnqt269H8/mO/BUIfKYaPP2fsAlobDFkVxpYM4lDi5jRq3BF8Kwciri2oEidSNG48QX1Ulrfjj5THwBA0UsPKOTG2SmRiSXVobqFw7Vh62EDMkTHdIvVGVT+Yg74SFWOkce+AZ5JZXh3McR0Su3rBMWRyv8NGZsIZsoJAWWSpHmqrqbMJ7nSsdkT1jwAx86AgOvypq2ZPux/HXCW326LZnANPVjbOcycI6QpqSZi9wAT7mbO/+hpWUlnsh+4Ge7aw4bzznFRxiujj/7L4vj3/4ju0rvL25ZHXV7dra4YpvN07+yMu8Htt388Su2wLYNLQ3Lnbc5pdjIQ1+9azFeVKZsi5gQVe1PeXddQA7SPvAIGsDhWy7KJHIB0D6iEix9cyrDspXLaGnSICW2ZdnZ21nrxquNuliKd3FXXa0yMk33Y0Eo0riRNU+5CLYUk56A4oFfwb2MD8zAx0Mbls2vQDqvSqR8vEssP+HFAFzhrXRCjOD0GYo9qTq6kky/BS0Ml4UkYQh3Czo0vukHJ+HVRxUd5uGVvhl5xgcmfRjh4q1JGNUniDd0gtss0uE2kmThD3F4/OaPgITJdED4Lb9iJnkmlDDTgjMODMLm4ib3ywTLCO66aqZOGZP6AR7aZs6+1bjM+2Xv6B22Qn47viuWsx3y+x9mm+CXT55wzqmrhp8MozKGZYzLk6EMerxqVSPjKM9LffeDxSPcY3BtsF/3JodBb+xwXvJP37IC+o+sgP1TjEW7xO1QFnv7+5zr7Nnnn3L2+Wfk92Rx+sNfaY9sl41R6ZZVsneskl3cXMSw7Mo9jct5R5u9spcO74scSUI2LSBZr/uGm4FFiJFq5GOroZQRdvVbIhrQChtXsOYwsgNWiIwfiI9PQN6FxOnzD3DhSZ9g3aIOVpDxwUp7pS8G1KyKl0q7rD9GwFkA8lNyiAzI2/ELeDeQq+Wu4bPe3azKsw+0L+Rs1dtN3MYek232Fo/feS/uLfytA+I543pjd3txcXbKavUvFs9wp6xY3uK80U3PHMbXsFeG5UhrlR7IUiLSbB2MS5jhtqC6LB/HzvVnWPGjUJRH2i1BKTr9AVFQpi2ZBZv8i1imuSKfJAQNfuSH32XqG3dCjMxEHryVnHv7zkFtaCmahKly9g58MNdy7hXQCL94Jl0MnQOPxrIa8ZA0xEoD/6FTKdQ1+cBY9aRFeZRMzDaJJMSHlTjfz/b5AUkeQsyv5VNwjqjBtilLXgn3XtlUWDCN5JV20KSsCDcqrmWoH/orPI8jvefNegzF1t7eYufwEVuvf7LY/5BVfh9+Stv/IW2/2v9zPuNOWSX/kklg1jtWK9Ofp2ygK3/glJ7JSCkdxoX0zrB8y6peB1Jj2HDAW09DI35d8McN3K84QwrbiCFt8OAtY8Rg+RVGQSqNMjNqyC5pTV6xQsUIjG8dHaAOpYonwMJr+B0Ukzb8modtH8ato8ojk0q0qnqZx4Dt+7SLQYvwA6SqlrlLrOH4bVQuM6xxhVYQKc2jCFIZIBh/am8CwUSVC6XHc48N04AkDwykjr+sT5WJ4cYEID73RuESB76kN6yATZB2L/tlEOQmyQSwpPjr/od0Jg2/xlbDMyB/S9+4oKm4SpTE4lM2kU8Lkuf0f0AvxxBm0HhoOxPtEjGc2EPmlNkIICKXkfMrhIiWq+7nsXU/S/MQZBb1aro3JASelmxUXWrKm93IlMDJbwD8ZVoBfF4JCeSqYfk+22BnK+zrhyuWh2GZVcvb+/9Zw7JZkGeIfTXv15ATmtY/awmsJbCWwFoCb6YEGFv51l9fawmsJbCWwFoCfwsSmHfIy/v/hGEZ/dk+RmXPV9aorKuh/OyDxI/L11wJJqqH/vEF5WPy9SkKSX3MPIQYWB4Gm6QzqOS/it+W3ZyZvFUHr36Pr1z9PCKG+iKKiTlci0+/39IJywc+gfEL2QpMPuQLk0oPlQL6KcjEFWbUJCmOhyUcXMmTekO6yqbqkoZWtQrheaAUi/VAZWdW0Jo2f9JQ2FoZNTcsH737MauVP8O4/FkMy1vHx4utYVh+9qd/xqis+0OMym1YDmZQilWKpK34k6YRgU/w0hHss/yashRD+NKItme52ioA4wccZiKukV4cfYU/47mkoX5K2ZNgBZIEy1QDHGDu8l8hk3wBjXLKYHnhqi1pB6qEFL7ImgwKKugSa56GRok08ikgZWIGpi8c+eUnIWG20qY+tiwTaZJAB1VIazzxzboQVS0Rw1KlWfgrHyFzNeE8DFaXAMmq8jNwWa6rSau+kV5lH+DiSa7ctDIsdcNkRibPkXHQKxMufiIz77kShl9JBnxCBQRyoOqhcxSGnSgYBkBVjA5J/qk3CRFV4yZgnn4ElywHsJ5ocbbJrf2DcqymPPj488U+2+4efPz3RG6xIvLZ4vKZ7gkrJb/j7Nfv2Hrz+0zMqO1eXe+yejUlXaPMu2BSG5K3AVXc3HifRMTrV9CEtFMbYHQmNCQWQK94JqqEJdNqm4ke8RHhyEdEtmHlXW1ZvORvn5Sr8SUx4ITn3/jhBBmw5YujUxfXHZ4kphzxjS+8QlhoC2YASJT4fjZIRAMotwrP8IHPRN7qurUM4oxKOFHDr0SdZyWs+lvZzOgJ0kGNkSIb+GKQGjgjOxAJUjIdOEb6EGXy0caVTi694CMPmGm+K7LKRtgBXQwU+VN64xLEzzKKu040+XWT3wHbiv2kKyFDB30ABmWNwa5g3WJFjcrPrT3O2GXF8vEHH+E+Tpu5woh8fX6+iM8W2DcXl4sb/FhnYDorMCMQTI3g3MR4eXD0eLF//NZiH4PRHedR32KMvMModMaWtqc/fLU4/fFrDMWni/293cUBRsz9g/3FHqul9x6/v9jFf0l7PP3pp8UL3A3b37JPPUYlVspy3q0GzdoSFklWBzbV6UixZbEUVMmpw4fgO7r9Fvbo5ZZyFqAFajnM8MzTBgy5drT1NsYv/NTcGbC3o3pXtuPXtLZV0y6zrIQFTyj/M1TTQ9qd6SiLjF8sY4DHEGSxicHfyWg7rA7d4izl+53DyR0QdnBE2eNEeIfh2HK7YBeHk79+t3jxw3cY+39YbHqmuMcD6FsOw1n8EyHjrmt63jXEW1TdvsNcC0Cah1BTPStSaK7mtP2wD0TJOdkWIKDACNb9m2UhQOQANdwb3ZhyXwCFtPEMf9m3z2rESDyVD3QkW8IDFUsmJYgBzfC0vUFPDL4kLJqTexETGotOb1OOPnIzRXE/sh7UFby8Jdz4kbDSdD4z1gAMuzMKRDaSTXirKObcF28d3iJL2uQO4iJiYJZ28+Uv4WYyQAgLHpBssVJ5hwkluwcHGJY53/utd1ktz4TJt9+l7T+h7XO2Ou3/FoPyxjVb7zOpZIN610calDEObut/8KEcBisjfDAduNBsvPQETml56Rdt07sl4Z1MeVZC+e9USQNcpG10CTgpC4aYhFd5dJgAXV4F3Bj1G2rkGDrzE9CCN88Kq3KZRTUN+oBMk2/EnDjCk83wCZcWq6k4zVWwRiOO1EX8jCfEw30u0wyBh0PxepHYd4z5tDwDZjzhRUfTJrKlfAIiGM7w8jpDnmq2QAFU0oBl3Gv0wJV0IMm7jof5avTE+YPwqp7663Pl433k6w3MVujwJ+ZNUFelLZLaUG1McaWPAyh9YCUpYO7zjhCSvAtPM0UkAQlNhAnhjuh6nAKN4BJH3Y1UDdiBhaufJtgR8BBdw71pfuTzkLkZE/BprOWxCjXqAHFLOc7SeUsC61OtWN6oFcucr+w5yy8xLPc22PquWN5zxfLcsMzXud8cdc1zn9//UkH8UtxAu/bWElhLYC2BtQTeGAnw7h8jjzeG5DWhawmsJbCWwK9XAvMh+fL+gWGZ1cpfes6yK5bHGcuuWnYr7B0Myq6aqRXLfostsfzcF0Y+PADrYX77Snl8Hr5W4NN2qg9jH2oH5vFz5PPwN/Re2YUl/Eg6fu5K4dD84k+fetwXBD6v4Hzid0DglvEPxRKwpOdnXHNx543uD/8qPPKnUsRnf/j3SmrgGsukHCGuaUr6KE4MJE20KjMc4sWJ0g/U/rgtjvg1TcUCwUojFf9Zsby50LB8zMfq8fufRgm3iZJ469Ex5yDeLJ6zBfazP/3r4oRtRt0CexuNu8ZlEUZhJGKuXmkjGZXNjDaCDI4jeG6MilFZUAJjXB60i6Qwk46bTm+g9/OrZN7QFRNpEmRoyjqJOuUSd4ZdJZwqoyjPSSd/MFjGMicFFI9dbwqTCvbKw3yKgiVuZdGulHBFUNcDja1eEw3cFzzUExWcQ76Fm7BKUrS2VAIoohEp0lzS0pGF2yTiNrjyHaB40jWvNwkBuOoeADCbCQ2m7WTg8r6U/PP0BSBOZddlOM83dAgWsovnwmaq1WuIoQJH5k1D/JGg03WciApb8SHP+QtA5ylMSWo114EN2AFOtHj45ccVfLsqrofb+fCzxe6Hv1vsfPj54ubmPtvtuuXuxZMfF9cvMGSdPonzjM1aHfXAsDzlU7TEpsaPbSt0Ux9tc17xmlnic9vkhkcpHVdHriQaOBpm7gM/spkhAYDArqvmKH2pG6adEgw4w7jmwT7VX8VJ1pR+Bbj4CdlyMZBMdaAign0FfxDOECUBEDP5xNBk0JRwQpZsDF5GLetEtwuxz/E1cLCQMCkaQXx/lnUmhQKwoeVIwY3pmvz2BWiei94RgzdKvJo8kfkbTAnlVdDV/gpX5eV9YJY/U4KmyQDvEd1ARI4GjEfpWjEsJ8L2T584jMrZxWH7gGXtOPxDVhm/9eHHi8esINx79FZodwKUder26ortqMvVGZRmRofjSjTPpN5m74PtnewEsMWq2C22oL96waSNk+eLS/xztr8+f/bXxdmzHzASXS6ODvcXxxiVDzEuadTe3jvCP1qcnpwsXjx9tjh59pTVymy/jEE5zh0EYFBlvPU6/bX9P2Qog+oDS+pSlnYgz14tI26NqwBLhIufuhOo4sWSJBXUQIlvmCognpTPCBRP6CGgs5z7hgpT76RRn0jfbSwGEvvwwjiIJYUMwvRUx0MzmSZjMzdNE4vPfzYrD22McTUcv/MujjOUOUuZvc8XG/uPmV3JpIKd3Rj6tikvDXnXL9h+GHfBNsQvn/60OOWc2wvKMDs4sJPDNuXg+6INy5XrkhDrXP1BHpHl5DFkhtfc5d3NnfxGBoMH4XDCK8vgEif3Rk0ToAJUYSWHAAd1pS8pmt4+Wb/DmxhCpnrifV/mU+gr1OeE8SgdUyefUGISiVQkmrYVuslUWZhz9cNpKpU+1BRu05g89DV+ngw1vF1ueDZkpBz+7InbgjfMO64RnSfpG1en6ueGTzhg4YHI+AY2e8FBwISKe/8BtP8pugdPFUVcAacek36bSSV7h4dMPmGbfNzWPm3/oPwTJpbY9k/oA+4xKlvfMqEhx1IwXQK51pbiRXnl5D3hgyayLZr0vRLOTyIqqO5HAgCMqnYJRoNxFWtMuRFM/IghOHULv/Me2OOlP+an01WcwCtQ47kD8QHhP67urf86AonOBJJRqSo8tSdIBTGN2ILR+yYuAR1RD6YMDvyE8LMCJnjwIRd8237VCR74r2skIh+D4gaSgDTCAPswElpneJI8yzFkEhUs+M1zfGFoW9n9RMDE41kfxBHhmFY4f3Bc9b7T9yH/+QkIgeUHNPxVGn5hFvBKJ+Pe57dxkG8RXlmJCwBd5CO898kAjgZsoTBCEqUdN+5FJLhX0unnSb9jzGN5b3TznvsphRGFr3BEqoIskdZTAfX9G+0PTltog5dIix+DdX4LLa96yC+RK1ENlHDf2xiWqYO9FfZ0xvL1grOV3QbbM5b/IUdXeb6yhuWtXrG8YlieIc6tVP3S1VS1/0uw67i1BNYSWEtgLYE3QQJrw/KbUEprGtcSWEvgfxkJPByO1/PcsHy6+OIVw/IG22GjU2OLxl80LPcH2mwsn9t8ZCDikfksmqD507IYAjo+TpehfUeagatDJv/16KboN+kmrER2gym+uvPh7Q9BKx/pPidwKZrAIqhWpAQLH+tRIjwQxMgheDudIFUOU2zyT2hFBJf5FsTwC0GlltSRob6qh8bvc0WNdGqconVq3oyvj3v1AioaWqFj9uKaffqXYVkDAIr7g7c/KOPyux8tdh6/vdhEUbx5dMRWdzcYlP99cfLlvy9efPUnPl3ZKhCnj8YFwyskSAOXeqjemraMqMk0cdIt1fKtc/Wv15y/GCbnyu0RL9w8bZ5Heu8npNwqK7FOvwMuOQ8aOql5B64ScYt8IFTFknzIV7vQbByujcGV8ZyHkTP4gtn8gq8gY6Q2DrxthG9cJS9TNQ2mXcVXsZVf8CoV8SuAZWR4Wv4ULc2rOAUP7lF3rCMGGJUIvKDrcONw0hwBm04XOJERrPN5dp8Io4nAix+gJCTQBIkoz2CBDKpredch+pKVn05vigFqXPNaYRUX7sLjrE0EEUlX8kwOox41XnzxJl/iIws86sgWZznu0U72MCzrb7+Houf9TxZb732yuLq+yZabL9ly9xwDyt35yeRsQxqw3Haz2mTJP/TzEx7IL+3JfKyPhFd9tO3xb3kUOSkfHy0nyzMKbJEFgPC647fvht8wxve9eHwOQm+SXfnACBZlK/GQVXkTWxjrV6DADRKmbIOr4oIVHPkbyeavsFV8yb4IGbDS13KKL4hx4hSReUuEN4RHwsb7OCpsozJMSC+j+urJWsYlnrjygy15CTueyA5KRrsK5EAKSSWn4Vf2TTV+4AZw8ImVi6AlC0k85ZV4EQNUNOsXDkPDM4/SlmdxTW1eeoJh8vtGqsTSvuHWqyW+3A6DR9XJrovCSksZll2xrOMM8uEOWTH4+DcfLR6zann/Ld4zGIA2OQN5gxWGzMRYOpcLT4yDcBiW3Q5Y068U2FOcs432xdMfcfgamTkrWYdqdnGsYfkQYzaG5Y3NHdoS+eBenp4uXrx4gYH5RVY7ZwcO4J00lRVeZKdffbJdXfXJ6bOt8JGN5CnQkJKwEjJBAfEHHBFkyTNAPnNVf1q+QEkS4EIpTECH3MMv8TGqjr43BlASJi2/+uINTPIuug2LMz7lD+ZBx3RjPvBW9ZLQgDSc6c1HmRdhUpzxheXL/R67mxxyhvLR+++j7H5vsXHweLF5+LiMyyQOh/jXHAlw9fSHuIvnTxbnpy9wJ4urs5c1rqDc7RO7lFMe5jkINv+0MZ4jf3FDm5PSpC90+iMgvKYMqUodrhwAizz0LRl5jcy4EUfkapZewANWl4BcefaHuIke4lJPkGFknXpSuENDUtaPaZY46j7oCO06VXQvy6/oAEr6AzfkMOoCxZD3s35wACVv00WykM9PQvHlrOuFcLkfcJ22MCzxVPeyfB6VPdlEUpLIkxAzqOQVoA7vfKQHQPMr1qRpYnPgIrZeaEFqPrZF/6bqLI6RUH+bPmX/SMMyK5bZUcQJKRtb5dL2qXf69zfXix1maOp8J/OC5d0ALQ5svQYTopYwPX9Csz+vuQZUxVRnEDRCK3X9CZ8Ig6diTWRc4+h8XpdVaDEBV6WZ0TOPlODp2ZvxAHinsL5V3wL/fA9susMWE6IF7bbRsjaV9BBLvkXphHWglqZlNssynoIHXHkDBzi9y6ubDJr3xI58ZJSYGt8kk5GPiAYzej6Wq8DUFwLEZfrAjjyKPxJ4pf3SA5iPYANGXAakbuQBTJVB9T/C+5zsCn+lKX4G6IgHjgDpSN/VkYYlaaUXVbdJfZlO+8MPXSEJqORNvH2OcCIJdh7xTRM/+PgZfkEJWZd1s68Vw/JIP8VNKSq7Du+63c8zMAn4FVwtKViJTGYsKXoe7TWEGs2eu2I8vw/TEJsr4aYy3VixTOu64ABxt8HOiuUrViz/bm5YZmt/jMoal7f2mMDVZyxPK5aDTozjpv0Of+gXnU3vw9j181oCawmsJbCWwJsngbVh+c0rszXFawmsJfArl8CrQ3JXa17ywXbBln7jjOVesZwzlhc5ZzlbYbti2e2w88FagvLbz/F+PizzEchwnsC4gCQyMD3cbxHPP/6WYdz1l0sHrvgDy6uMLKEeZrSMeXPu4K/YUH2A+OSXH72EDx4j/+Zq9hBIgFsxF5CRpsH1Z0mmYPOwwFI+I03CxFdRSVeUNZ36AI86UIBBNPIQUdEvTVEuEJL8RTpclA3J0zo0ggeRBRIKBibx13Mp/WuG9P6jdxb7bBN6gNs5ZBtslPGbuDtWEL38/uvFKe7lD5yDyKdzu8h2KDnEapZTHSaL5FJZlfyFKY7zrJLG6HLcg6BWvTaFYq1L9tolhEQ+B703syth/dwPwLTsl1EVWeKv+/AQBQ24pY9glW5e8laG4IeYhB20QFFBj1xII85cjQ9fPJVNRabOicTUnWakCz7TGtu4uI8sg5xAkwUgOc1+mh4BRnD7PFa+HV58icar/dS7QdO0Sl4NysDTNKXsTJdwVVl1dXahz6COgKeWTftGV8pOZcjsmtIa5sOAG16i+SkD2zyuy8ywIcsh7wE1oRKzV4X7C0UiFm9otkwpP5X5KF9VXO+yMlJ/6/G7i6233se9h2H5ju15n7Aqj9V5rJK8v3y5uL86wz+j/JdbvbakWj6pdxIATNqT+l3ySzj5S0voAaLkJj2DXuHyZ/JR9hOD4uwHfZlaeqGDoMJJeECbuoau/MUd2gQbcBNm6Rt4m84p22RX+fprGvFMF4Gzp3E/aKhkqwAknPgVCYkndNKYNJXTFC4clTT5NE7DuOaPVY8rpMMNA2vlkxTBMu6gU4YFnhgvpObd+acsIWzCOe46ZImx0k6A5DuoJmIGlVtSD5/Iungu/me8Sl7oA8R4kSedz3XTdARsFudtnBFe+FGkgjBBA7b6cTFrVKZPZxqSJ+bebewsdt0WmYlLBxiVd5m8tIUBaHPPVcgYfkGiscJtaL267HwSp3I3PydX5GxPjD9XGCUvX2CYxL9mNewNbewGX3NntsLGcL2r4RrF6wZK141NzvY9vxjunG2Z3XaZd9qGRmVNpPJYpmu5khRdwqEhq9mAMbCojBgKwPAhg4AIsQJkKCDiCxz4BvzEa8MDJ8+5BmzyDMr8DFpFWOVb0FJftMXQaRwRxsWJH9orP7GPDAHKjiH6/lUWAgyWCns/JT6wVcauCj14++3F4VvvYGTWoHxEuR4tNvYOKa+7UV73i+uXL1it/Cxnzl9zxrJboOvc/rzPVNaoXGXQdPq8vIq+orvqfMmq+QzDg08rTPfZIomkIggZW/KqrLwSBdLkF/gOrfgA9U+ACr9ilK70ZeCVFq/IqWnx2cAR1zBTkOECVKNK2u4bi25/BcKBuHAHY+WX98TIQ2qMGnlxxyWF8eIXpsJocOc1wQW28Hu7vDpMOip0ieVVqCbC/Lq8CmrwYDjElux4AHCSTRINXsKQ0WMcBjKzjxyCkGcT4jY5Y3mHtu/KZfuYDSakEOgLe3FxYfs/j88H3Gj/vo9TWWgb1jvvzTzklF+PuW8JDIkC23CraRqHiUIrtOsv+RO+YoTxvuJKouFtyWCB9C9JZySN+yJEjHXNIKZMiVktiMi/rfQpB79XxzjY4e90HjP0SY6XmHU1Jp7RMstSOGVUSZZUGT4nR0Nm8AHiXb9Hp7xmwI1FFnI/y6/jun9T2p1Uvhq08BYvJV5TEi9wOyICN5BaL0L39JMkEWWJU+wDeEoDTu47X6MDxY9j1IAZ4LN4uVpa9SQ5g27Tpm8IhtDWaZK+6Z4wFbbKvyADYvDIz9DGgaSMyfXf1bC8RNvo31C/JQX53L6Ora6TDZn61NyapiMmqReeLmNHIDfDXbDj0fNzDct8g7sV9mcalv8+q5aP3sWw/M7HbIc9P2OZyXmvGJbNfMr0wX0Tpt/ctD+PW9+vJbCWwFoCawm8iRJYG5bfxFJb07yWwFoC/0tIYDk8f51h+X/PVthbMSzXiuUDz1ge22Dr90edHxF+OOui/EN6WSVJuDD5DhgfsSvfBIlaHfiHpikInNP9KJJVgBFYQP2hPAKX3xZTwBtysyyYEDw+w5ffU8pyyGVFPCsPxWuLvRID8BqYATnyAnIG06T0R3o/C9xg7Vu2030hnbJt+Hn6Bum4qW4MoNQdMHaa9oWf7seXrTT7EVuKf+op5yLucmalbhsDmSs+VMi5VOSM82HP2a7yHL8NYirhg1eBBfnguIioHI3CpTzIT177w3rOt8njCNSvs6GXSpdO12niC7hywXcDrIT7IHBF+vtKUkP8h7iQP3gIBRU1Ug9exDYhGRjHcwfHJ6pyHdkTmHCEokw0oizxGFepJxGOxIZWTPs+dS0fPkEBb0Ag+krQPKMZ3kEQoCOweW88HSwy4tJnGPcgPkHAWqcSNdJNeE3PVWQAMdL32cYTuDCBfM0PaVbixLESMKFN4mSxEl+yWpbrIGIJDToS1P9APhAIikt9Nh6lawzL/NhOtjnLVX+LLWA3aUNbuOsb2g6ros5YIXl1hkGZs2AX11fxmW+EIhuHQCITcEdyg6SuC9KiS902/xBB2LikV5D6mQILjseBbvJXAQe8yTt/75fBeXgVx5CDsAO401T5jqdOOMPXQe13+gmkI8Q9Bf7MDYmVRyV5NeFSrpV+Fd/q00xAD/qRVext7Jv3NaMEJmF3vh0wz6n5DVYiQn18aZzx0Nx3EH7hmWObySXBJYvOI7GdUdCPtI3T/AiaMFbhhQpB5jw2lLDl+KUx2B4KHfcDURmBDa/3y/29Jpt6c3hGct4vnH+6vcd21mk7tB8My9us/m9XMq3a7Tjp9vYW4yQGytu7HM9ww+rmOLayvsFdYyyyfWkodhXiJhr4bVY577B9tjg1f9BooQjF7fUt7hp3A/0YlOFbCmvnAqn2GlyVxzOh9Z/YGUQJxADiJ/CGSsDAyX3h1q+7fh5gnaqQ9dMAahj9BK3ga2BoIFKYCU54wixe09mHJ32SCDXgTZc2lSDSV1ylMqxSVahtr5x9/s7+Hudesx02bpcthzd29zgPe5+V6Hv0g1VW8THoXZ9j/GeFssbkO8rqlvh7jtyoPhGjPtkkp9DZNHSYdAyarXxhrEOQapEo0GAKGMET3ojrubAMsAEvWDuDXr1GquAbsSOoyQmGjjcON0CW6EZbM+BVmgcYiQpN/67WmhjflhhnhC9Lzuhql0sKckdgk2jCui8Y7+tumaay6XqzTFmAs2cwPUxVaWe/AZ/l0AkazYo/4AZM1WHozXMBeputsHlMncR31e0G7X7T7fPx713KPdwNda77Dw3Itv9aGU9NHm2jv42SgxmIc8bCIGcWUrddrBNsd4pEV5qZfBoo/hxjy3mgB8c81tBK2hgH3MA3h13ed2YD9oEXuVqB+Q+kP6NtOdK/A6BG/MVH6jrhU1sVfJlZkMwfiZ54eJWbkSc5h4458ISk6+gSj1Ez8U74Te5VHM9kScCEZeANDlOO52qMAZzCjGreGucsg9AgHY0icSNNDOYjotJWrEGZ/NjpRmSBrmKqqCEboqRlgvC+EVNeCc/zBDFoH3IgrsGb5oacSYo0DSWhpmmoB/crYHOoJY0zkGL+jf1dyqBksmSkY1Z8GG+DcSCJtN3UzzJt2hBlp++79BrZY1OuM5YxLGtcLsNyGZU/+Ozv2R2kVyy3YVmjMi5fFUvZm8vy/ZLMR/aU9jJCKEG52q+n9e9aAmsJrCWwlsCbKwHGsnntvLkcrClfS2AtgbUEfsUScGjO6bSM3MeK5Wu2wv6/lmcsl2GZFcucr7xyxjJfDdmOC/2Gfm+xa5fvUD5bnrr9WJ5KYTt9gFSmyXn+8WfAyvdff/0GcvYzB0rw8uOhFSgT9DJqCvqbv5nJp2hdMjEXyepn73+Oq1dEN0u2gm9kWZ9uKzGzFKufbXPaVoD+sw9ktuR0NdHDejLFkiBqR3w/Yl1lqr+FAnhrbx9FPwr/KPm3F9us+pCTS5TAly9PF5fntdLSMBVxuV4ZsiwLo6OKxkmlk6/eChsoxkNNxoemidglg8pKsE43l92c19w3UOCX9ExoX3sz4Ejb8nkF7EFlmNMwvw+mGQ2v4CFg4mcij5t5mnHf0ZM/h4Gefuz825/n+ZCfB2xMoHM5ToEPbpLfjNTQRaB+uWXdbyPcAxQALnMKPoh+yMeraV4rnteBrYT9LK9dOQd0D72jCIKYUrog3xmDgeFZfUwbluPTTlqBbTvapA1pQLvBCHaOwev8/HJxdYVRmdX/GxjI9GNEAVGUSuJUJg9okjSVj9UuQsjEW8mryr9lN0WOdD6bqp3Pdb2awpD/h7034ZokOY4Ds4+5BwBBLHFQwsVbFFfa//8LltrrvRXJFcVdEgcJkDgEEMdcPd29ZuZu7h5RWT0QpbeLb5DZnRkR7ubmHh6RVZkZX1XRP//YYd/kGYA1gkAtTADM9vJwciO9Ny6nTmw7yVMWsWmGG1Ulx057SqZ5z7iC36l0r2kz45519zXmS/g14fTrLIYt4i7lmrwZnznF1wam73IBWoyYI0khgH25ZLLVyD4Oe0pWV2HFox6WJ73PGzVhb1cs+b4iHhBx4eclPhKrhUv+RQYXebnwiz/I4B9l8D2Hnyzm/hoXJXMRmAvCL3AePedCMBcoUX6EP8549uxD7Pg9ZixIctH5BT55yEUieuTOebycywqEUaIHSAhzwm+i4GKyFpUg7j9yITi2OQ6WVTnzFekpq8KAyiqWNHF71mKMyorI2TitD/eLXtHjtcW9cK39d6+s41jH64xn6Bj/ICwftmbJnVnn+L2BxeU3+M0NGMPH+uphXD9gUe+jj2LMWH6M18GP8TvaLF/ytRAdFwt88LqYU+MJX2A5RvQ4EjMzMl8r77/PrFn0fHZ3VNJF7nTXOWJr34CcQQz1OhYDZCcDW9XVqMQMaDDofKNSMnRi6mwkN+CzO/eVeknLqCphOoCeC1TMegKj0HFwDHvPiwG8U906OFCDDq8V7g3i6WrkQxQRh/0Soj3nftQ9vsDiv7EhjX5GX0OjuQgel3wR7N6SMTbVWlHxSQRlqWaHYNr+US8QOadRtku8ACnVprhPVI6yyxNQcUSF3xah9/80UgEzlrpHYD3btKCcrN4pm2PE9to/SrylEzezFBeMWGobMHJbYzFL1WFgWVpWEWNbzVEpLye2rRsGS//mOVV52cwUM/tzElzkBixp4zL8rQamfSUfDQEsSxtRvL+G2id09GubOTc40P6KAABAAElEQVR9PUNaAmYel/rwQ3tzpZnMeRiwkj28yuidchI9sHQv6/oje69rJVxz9HCEhX8+Sj+/BEp80ZEWl9/3J5axsPzes8f4xPLvHb+DneU7X/hX+hpsfh320zf5VdhcWMY3MnDH5lhY59tpbPRtTZRxn0OtQS7T5CquDFwZuDJwZeDBZgDv//Wq/2A7cQV+ZeDKwJWBT2sGdDmOT7kc+BrsRy8+wKctfnF8lwvLf/HnKusTy7jOfxNfge3fWGbJa3feHMdzs7jI5ys+L+Up441FbfOtwPcCUObtQMOmydkdLJHLXWsbBHyQE9tqth7GtnVh74TTst72fnLXRPuKfNzwAevxmSG5Pqkc0ydH8S9A2OHZYMIx1X6gwE8Hs83fn3v8NB4IP8FCGT/t9YSf9oD2IyyOPcPXVfJTYWxrMUxWe6bLcQUtbseBxsxBgbLSD7bpZQXTjjmb9mzjPzU6soz2EEFibYJOirJKKng/M9qFMDNMpWnQcPXEmUTVF3NQkJtqSWypyzDGMUHlPwGDxnSAQmk+G0xfRXob9wYPmqTLEGTNeuxhYd159iEVAGEJ3ijLM7ylmLo9LgOT1s2bcbRdnAWAwaBtUENAxOiBS443Jbo0JzDB/QEoLIZg8YS/RxglfscRiyqPcT59jIdIH2IR5cMPsZCCT0fy0/9a/NKnpGAHurmwrCdOEQI0sek8Rcf5cHduzoVinYqsK0yAHHKGndqVLDhiTFZNwIOrur542/GOK0DI3Op4sXXD/M6t5afl5tBz+8wNfatvQ8l2z7ZTD0M4DNNuvgTMevSz+zv73SE3X9gi+lbKQ5xg/To2eRTYajBi5ZwN/vZCNeeunUTZnEBKlBatiHljswDJFyFxhqAps7SVVsoQw5Ya5jr8RxmfiEWdJxA/7Y/3GH5t7ZPX4g+ZnuLc4fsPziZY0xOwOI9ecPEYuz65rE+54pOu+HQyv2b5Jf5Qgz/ZAGR6VK9xiEiz1xmvIKjHuUEbvgbJViX02sgVjCm4LWa+wkliaNubYYRE/qxLI8A3CwPulzBYXA6kuNApcwauz2/1ufCB4hRhzSXJbR+V6S24Nba0Afhx/pEAF5U5flxQ5vjyK4g/xuK/PyH6An8cwE8pc3+JseM4kLl2xK3LYDg/exxSUUAfUWQ/S5Edkz7rFiVG/UJdJXQuCRPkxDYo7iq217kRzCQPkj7aWUsUzLCGBnM4OQyPWT2NWO/XErus055ak0QP23iCNJJWxbi4lVnOXDlClHaWo2H8/RIGNj8BLeG4T5uJFr0kayJH6/nLsFjnNSW31tOG2tjcL5Zdj7mlPG++aVvW7V6UbjrVaq8dSttArqrdUXqR2MyO2mX2KtUVF9Suu9+22Esz8+cH9Npkw8H5qywsu8/kp6lp7E9tO5NwR4TdsqBJHGA2mzpbm9dt+3PpMXW7y2C9Z9de24I19jN8hmXUQ8bxdKzGMuaZG7P5fPQccBn64BaHDVB6fGYe6M/ohaMCgdYAcpAvdRTTxuo5V8oHlAE3iu2um4u0m2aiVliAH+ix+668oElJS7vuhWXmhdi+h0gjZQBZ53UKL4dQ8o+0+Gllfh32+7hl+Gcc4quwsbCMr8H+0lfxddj4Smx9YvlzX8ZXYX/5fGHZAcGx4tSBsdF3KlMWRTYC/UDH5gr7ysCVgSsDVwZmBq6F5ZmNq35l4MrAlYFfxwxwYfnF+3gwhq/ywyeWv/uXWFj+y/+A/c+Pp/gq7HewqPzu6/jEMr4K+3X+Bqf2urLHpft4OJH9kxaHQPmuYOs87wkWEZiSlmLfrBpibN0k+qYBijYzKq1aYZpf/3Lrgm+QZ1fi5t6aO10SKKw2ylOD5QZ7IOzlHseMa5htYzs1v1p94YXzpQ0KxQMhSz9QYMmbWf7+JJ4O60HwY5RPMGefcMEMaH1tKD9lhE+IxeN+cMPO/F7QcJTUdd8TZUGWtqXNVDkuk1tHfOyQLJOeDGbbRkTiYDCCaG/1l/xDKXQ+CYq60Sin3yFOeEURqvDruTDgqt7aBD6UmZOMqzRV6YBdMx/tZ51tvdqYayupZ/78rMHxmje0AuXBiCmLOsOjNko0QBIhTzZiVyktjNhjJ3rZYFrY5Jn6ZgrpHLLgNoFZ+rWYUYV0O0a4EbbqwcGHQTwR+DvL8dWbEOh3XONc4u/APsOCMr8ClgtiZI2v3Aw/XEAhhbrBB7vAc5N3HsDN13SdE2jbNWvCKAw/uGxb4WEefY/+hZbs6yYeiOROfKueLdkmcOex/WJVPKH9xDFN45174UQjZpb7FVrHdmZLv46vY7Ak+7U5eZWWWZ/zadbN7/dat0nvuKerGpt2ONX36zC8azKcRj4C6YXdJqXcZwqRmb3N/uyToAHxnCMj5pfzbHuV8IH/jsMx6I+HlBHmEjx17mCBGQuR/OMMlvFnF+wrSLT+iIMWkWMhmYvJ2vFHGi+xxwvY6AtDGxt7zGBYKqY+6L2Mar5v7Ztgu9Bt9xftORfSg1Hyad80abN2GH72dsRbRFlp+10TbXHxtcN4lvSLAz20JusQalxQhu3WAwuTz1FRrHOCc5Jjxz8S0Pjx9Q9kTChKLv57jzGMb23AAI7ckA14HVnGvKo3pjE4gRJUgS7tFJ8VHiN3R2XTqEau+/mFxR1nq80A2dlNQJMrIrnHYblZVYaJwsmqYnO9yjRy3xmGdRFSAMJHaELi1wd32VYxe0orcTqpPrJtfAlPEnuLmXHa82BQVbHCNCMvNdniD1dYRgSSFeJOJRPs84Mo98i5P7VMH8v55LjoGJvfD6KVWRH5tKI23ueNYymY+JJsKve6A4bc6BojyqgX12oYZkBCp08tr2px9cIyYw52HmmrffAGX5PMGEJqcPA0MmsIdOeYcTPOySkWGNxhA9cnaIazeh+7Ceq+oObZ4CGaTcbK8b+ZQxA4Ko0LsC5pO3sjWvKEIjgTYllZQGDeMjjBWkes4w9YM2reDr+DGeblpQMjl4lJhm2gNk3oH/oxshXvU8qlJpDnL7T8L1Ag9V4m4JodaoljyT/05p0CF5Y/wNskF5V/+t7H+irsL33tD7Sw/KWvYWH58797vK6F5S/hm8Y+C/v8xPJx5xPLDmEZlY7DUUcUlF/blYErA1cGrgw89AxcC8sPfQSv+K8MXBn49GeAC8vPubD8/vHio58f3/0rLCr/1Z8ff4/F5Scf/1Jfg/0Ovgr7Ley9sIwlBNx4xF+t4hYsL/Tjq4ji5mTeilm/J5P3LnObD3/nwvKExcONurPQDUxzTCSkCWv9A6htXaicQO7uqETy3L7p1bj7fwVqMVtusIdm2m+h3fcP+x07KNfq6IRthqgeZIwulb0fJNyU+WSDCwB8SPxED/l5u4kHw/ykGD9pxMUxTMxcT4u+wPGcq7OuPDAwBKk4M9gZ6+x0hrA97IjQacN8l63BlIg3NOHCKLRUXaVkrEXloE9cNJbzyFRUlU8bRWkXDQ1/MumIF6NX2iSR3TUb424vJKyWu5pe5tjrMdbO6XYz4LWpZzTVxX1TnxGlQxSUeoRUB0EjJ9sqneM6427mtRYYe1p1u9Tpkvd5/nOiZkjMT0WkSsda+aYce32KjhAGQhouhGEBhTsFjIE714n5m7D8bdgX8K2vegWEZSBlHkkimPGhoNKfduBDXXyDcE09+xcu3IdNekZR54/7rv7RITfy52ZRlcln/SzNRdmgUD8mruriMjP6M42GH4kbtnAXV1Z6do58pG3FN/zk8BRNjSUkA1Z6V6Yfy1hqXGeso+7+RYnxHQ7O+CJejMzgmL7u1Wcfdoz/wCdc2yvKcrI7i5la2RhBk6PeR6cjKDR73T/MWW/yCA55yQNPs5QAFueEFjFhFouZsPK5yJLWtsXEpy9J0w1ft8GC9yB++p9C+48yJPN8DrkoUVXpgF3av9ujDOshmNWZr4V4tbKKcO9BY83MUWgmQ6PCfoZwVpct+mQOhxk8MebFmUpiOU32b0YQfxAOV2aCDYzCD2T0ueWyph5RgOgPazBu8Qc2YVnEaGqusJQK45gQzYJwK/ioLudacZ1UHIsoQZDUN0jn60aRfbiV7+MyorOzTzC6uR4ZM9XxmNXlDGe6cb9YWu6+MwzrI6Riy/NJwySUNVHGWRyzhxypncQitBUbw5M7IcymKxksprl9DD2rogJ1Q6NGb7TXzjrB2FxG684x4zNnla8wnrHWWZB4d3d/vZ42lUPFCEM7HSEGz0QO5Va9zw2guTc3M25d12/9ZTMWlnluO5fx+kpKxkc7bmpHNXI+AuqqA9gcpd02ASRV6DajRKaSVvUOG2I61yijQSEfhUJliKW7d3CfaOvc2JYlc8Px91wQTzbkDyCVaS+9DpZmLOSBXNxZJ0z8wgeP45FI4KHM6tTRi+OmvGaZfGxxV6SMg5axLT63zDUqY7fRp6TkWx03XpPzfUrX5hBKnMrlfYt59RuakjMzFHW+fz7HX6y+wB4Lyx8fP+HC8kePDi4sf/nr2FG+9fmvHK9/9ktYXI6F5ePANyXNr8I2NYJRKI41Qs4jQQ0MSAIX3NW4MnBl4MrAlYGHmAG85/hd5yGGf8V8ZeDKwJWB34AMzIVlfWL5z4/vcHEZn1jur8LuTyzH4jIu2HENP2/KdAmf1/Hx0u+L/LwZOEnl/g4xH/56QaxZSOAbxHC03OSKf0Vv94YnEfwaikYX4kY3k8rely5um7s9+pHCgmYSuj2w5BzNOZ4hDu1iOxvTePAY4nKounpia/xUsc4u7X0VFkqWfqDgBwO6MaYcAi0e425UX81OvD4phptnlOImP3YeVLLqSspZeG56zro01OW4t40qFPHoimVsxrpUB1LX9dJaA1UwTE2IzLw5SI/OC7WqCz5ZykXlubUrdz2waZPIG2C7jd0s5bCjxRzXsk+Xs+26c0Aa9mXl7hncC1ARl+1p1/Wz3hDRY0X+3YcAN4c8JyGffbqBbQJGfB/f/aGZx9FjXv1QBQeVMdsyhW0E++XBMACewxUAibmozBMgTwL2ijsXk/U1vlg05r9YWCY23ZKfQc6VNspMhYrGC22PoWLMQOlaOzmwiUueogvuu3oXSigmNm02WSD6mGo7MIUApm1012buIv+hm3WjHSvb5c9KlO7bENXYUnlmY+ES43Q0ybK+zp4GiF9+mm1SzT65LmQG1lYZK7kSMGOfuPaeNQAxe27EJbBjCIIzsDrLZrBlIE2ha05LAlv8n7HRLFyEItgpBYqxpf/KYZ4PgQgp+bhryquecxzOKOfGkv2MvuIIAX1596IkF5e5OY44y8JeCp5/qqStG7aRYfstorT55CL5MwDRO5jynPGxD95PHG0jcep6Ulf9BOk4zCkIfTMmGIatUGXN6aG9JF3JYU0BgdZF7tiUiK9XrieE7ZoG8s2ovLCcIGKwi8PzFI1oJ4aAsS1NAd2vAdqqgqVhmmyIT2qG1eJ7mFDevAOFPrV8xDkSWwsO4hu2bKexpXspk4apaX81pmlkuW1GNGJwSI64fYVljF5IQ4L6II1zluxDyKaJWd91ksVBVnaaM7XUUFq10AmQc4/hJIhc3osDFXO0TF7VtM5lY9aaLBZQnm1QUNzxxesXrXebeX6GTsfFkVzgdWxxtSC64X4zgsnU8hnXimK8ipt0NE6HrPrncszjV9VpowVU2u5bcrHQVolJyfBzkyDb7KYzONgX94Znc81EAISX3zNtYCrMaK7H4dO+mRvWRZul8gNhXwclOkFsOad00PXEDR7qZUY+NrA5/6zbojkIoAablaxP32xjC5uRC/noeZuoKHAcyBEz1XYY0BO3ofjUHXFGoLPc9V5Xb3jdUc8nZSgTY9h89sNzjYvKL/DHqh/gq7C5qMxPLP9CC8u/r0XlWFj+3eMNLCp7YfnmE8tOPhxGTLdjsk4Mj946ht2Dq3Zl4MrAlYErAw8tA9fC8kMbsSveKwNXBn5zMuCL9fyNZX4d9nMsLH8HC8ra8TvL/sQyvwr7rfwq7Ndxk/AUv7GsvwhHtuKGwmSRvnlzQYku70+u8XnzMrdavKMQdy+rOgjipma/UTTLarHdGxr0YMqtNxE3hMxEpXOCfMc3enj+GKesgVwRpZm8Nyg6CADxywOA1Fi20dCwY1eLhx5r4h0DS9UhdEm0tgTRj310HY8LLIQl56gWy2Coh56lRN8Llz6SvoJgWz7ASZ/A0yTmOLhDjeOw1115xkVAbnY1RFYVWDonj1rW8T9scRzGHXto6yHJwNjnpAynCbpRbFwdoWrrbBlMS2jBYWqWFYdMwrfD7H5k9wxGZ6tPlMmglEqNWsUf6EAkOxrlJ8LN9ujJwBBScW/1NM/CrOGNQvaD0oqZQqsNp2zbbDfFYZZMu23OX+UNOql5wG53LFXHgaVnauRaFlLUmQeF8FDFa7pz2b3R4jJ94//8xLLj5rml0Ejkr8LWyRecmgeMke5FE1y098Nc94my2MDpcFWSnFuUFiUkVJGRhECTSlsmiE6r+kmVhiKTw4x1+x7iivkub9p5kV24kzgnp7nsL9qjNcA9araKUpAzkxPffogsVca7sq2cw/0CG+4kn/lbgGhwrAMfbJMzzlhqsU+FJBQQkYoggWyRqj0POi8Gl32rxGQumgzaHnitEh4jlJu2/NqT54zPQvaA/7goyTpKnThRp9XkjpaP6j1sAuRzle0+r6j8VTd4Eln1VL4p69cGckWSPHaa93DodnhDT5Im0LaiNhTtxRYos+8h2Y6KY5NtTeagYoVOudsdpY3iRt1zO8Q9ltHvaJNo7Ue2yI1dLkBIdFqEjEdApXdC0v9ZYR/CE2BBgkt+YizoJwIczCQ4N3I/jOxQrIFdCwOmHLTFnBN9Bg1/CudUYxKVdlOlKbYQrLexYWzHeAdiyqmztCMJ2YK7IR+C2VESektI8CxsRlQZ8VWzUstpQxpPH3t12Ra7l9mbQFUEMs5xHMIUN2XWZmz3umqj6bX51miHyzpfbL+X0W/POeaC1uArkhhb2jWqWSLeAaY1mo5tiSxp3V9b3faZmnylEShZBtC8zofLjmx0weCplIeBWXQnBu7TwBHlPlhc7U05GSs/MJow2ur6DELnyLyyHzF4vlovg2qEPZuKh3ypO+VNoHwkrorhkzJjlO+pk4/9fcpo+u/6GrsjC4+N6pgrlk9NBXN76SivUbDxAHnpUHF2WAqFit6HoSOOZwn/dJuLylpY5ldh/zI+sfyLjw58DTY/rRyLy2/9diwsv4Gvw3765mfBuH0VtmNKH3ZuMQxya0lGbsVVXhm4MnBl4MrAA8/AtbD8wAfwCv/KwJWBT3EGfA3uheWXH+Argn95fOcv/ufj29z/Yy4sY1H5XX4VthaW8XXYuFF4jQvLuIvgt6XyCx59W5e33Lix4M1FOIgHn3HTsWczISW+v7BMH7HpBnS9A7QKpTtl8FA9wOrWm+qBn2N0Vqhq9Jqeeeu8WpiQC0JTY37r484yW3YjAzfgPQkkQZ0lZY0I+4Q1dSLu4fzA4TamoJh+XaemerQRc84yBs5f3ylzrp7yZ7DRD+QxTTjPPXd5A0tYQlEOhxJ2u2tGM9KxASA+A7NDasLEJS3WeNlbG0GX9JS0FPXFLQkXQQbizE3LVInv1kYSwFuD/GRDLKizDMaI1NgqQylH0TdryDuUo04f0mS5ZUE6sjhXZjSf2iCwXM6Tf+cOHY8r2jaTy/7a5k6qzXYTw8jVqbscI05C6DVnUC65oB0EhFDuWRplRiYD6qPSZQSWamiD3HpS+/Vfc62AQLCOD1/WH14AHJ+AhoyG2LiYKhMcWItFZUSGdsSnSoATXw0lV9aMqsZW+hBTms10iJbfW+hx2c4GawFEY8K8KCX2NdSF3f29odts1k6MCOHA0ars7jSluIZCbVs1jLV7HLt8Wps5+h9jNFndR9q4br1soTAH5TOPxrlc7WcU5gaTxJMxrPUHQ+R3xgAhSnG11K5UBstyRoRcMeOAyWwOMUGkr3PHpBdvlnzBZeySpU821NYJkT4gIJ/OGdR6UZnXUUSHnpayRTukUlV+mUPxhDjOL0nSEvpplzAVtOttokLjfggDkSKxUeaDul5osDJYyahxlK1lgZnIfR7UuIXJcpxRUrHOEwgWX8PUDgcB/SrvlpmMHMLn2NKPxo5lcqJ032IAQmELu4syzhXPLsuCKV//mjZra2E+Svd8rchXtSJGHSchOjKbCwOcUReWLj1CLtvCkiptKI7wEozThsMWwI7DhrZpvDWUeMj2eqEBNqfKMW8Lo0pE0O8N0Vfn2hyrTUZiEJT+4yC/LwivGM4ZqLe5ESzdR5bso3ZKWa8e0XrbMiHBBaSJAAuZud0KbrMs57iFtg33kk7eAVN1xif35WoEY05aiHfViSgPHpNAeKZAOYKI6vQ8GZyNIYPoxqPiCAz54lok8zZ0xSIOsxiQ7cHPqCid0Xneji4U7VklejA19jtl0SdzT81i71ATIKYBMPMsrWZZudl4SGeusrUhlVtn3RRkcImf+G3buaVO/vKXNme5ZnB8pbPfgNqSuq6vOZydWOfNqtkCfqBNv9cp/LhAqSqv3/ltRXwfZMmNOagdepoQ5z8+ffkSP5mTn1b2wjI/sfyTXz47fo6F5S9zYfmrv6+vxH6HC8u/9eXjTez8jeWDv7HM31fm12HTJx3yIB9RWuT3Zvqf29acqqt+ZeDKwJWBKwMPMAPXwvIDHLQr5CsDVwZ+QzIQ9we4YMefkr78EJ3+4HiBheVv/cdcWOYnlp/98njn9WMsLD8+3sDK3GvYn+BKXgvLuqIPMj2gwJV+3AhE6Qt+l85uYNxiiZuXvBuQDneCwRo6I3UDaqCFVbaFRA/87mLrTfWSlfVGvJGqjX7Pm+0gGMpklGQ+fANJo7omeLuKIJLDQ0I160t7+kG9GYNsUrJOvTHuJ8t9kyiBrjcsHpyyrZvPvAPVghieLHthuXRtuLipfmACq1/ABWcY6KEFLCreMWu3pxkrb1m02H2sB5RyEcwdB/CQ2x8biSgin2sRYcRLZdPBohtlF5Vbvgmwdsoq7hTqzM0A6aZilz4e5Tj+Kh0sMMFnDfs6lKNevIDKz0A6TrLs8Zlvl2dSFKXGmrUMY0YgABShCk1x3QIDjqPjLQEqZTeFxKodc25TQZm9Y6kg4sEOcfZBe+04sIxoPVuJ5OYeEMRRIzLtsk5MSKVKC54/0GDnIg03nUeqsA4LfbMvQcRFGbHBC5okFW+SKzIoqNLmxKDhB/eyECD6T0jhkyeNxe05QJTzEvoBHn5Cd3KcfqAOk8xoUmWXZGx2lRXg4N34ul8DgyrtHbe5VA5YpGPkTdw7KgzMNcyrOnXTeoavfgNYfU0l8dO+SFHZx2jyTZx8LsqOYtHJ0QIUzc3CMn0DpthyljRjeC4W9ikbltUfW+XEjgKfwgGQPPr9XvHjQFkahj/4lTPM9XRavBGtIqKMC8qPgWl9GKRZxg/g4GdVO0HwbVtKdRbbGOq5GRfl9GNN5Is21Z85gDCJ3qNkzrRPD5lv0JX9iI7I9kSOtjVvS7o2YBI2N5r0lVCXZWlnqWCTPme+K1Dz5PiSVWY4uDSv/AtPDfbsiN3JDwKL1PX4MF/igkJlEs66fbg0J9vpxqpfsVzZnbu6xjhhUZTqXyjNwNfTfk1tQ49dlTYA5J4NrVe2MGJ/u0aU26M+kuL+hLaPM1d1LrdaNcUmLkfeANsPV6lEdBK6kxjLBIVNW9zLsblJaDRLMhYrBH7fM/9Z7mkQHDnP8ILDdshQwWZOSrtO/qGfQYU4OIof1tM4MS5mbIJVAKtRiWmYsZpjlr/awvL0Oq3Z5/a0xtO42R/WmUHLqmx416yUhIbRRx47p5Frx2F5mTTb3Vr3gJDwsYMlBfBcyz7lBkDVyTYa09Z1loawZBf9em95ModvCMt2ApZcBQ/tBCFnkojfhKMU5+CWarTLpxVpazu773PRFgGcZ8TMSUfW/Urqitnth176WsUZcQfxVogN5wTzrYVlvNbpdz84q0NOCK/vsYas0gvLLPVV2PrE8hP8xvJLLCpzYZlfhc1PLOPTylxYxs6F5TfxO8tcXH7qhWUuKnNxGcOlEeMBziKmqDNu6dCUjuXYFP5oX9UrA1cGrgxcGXi4GbgWlh/u2F2RXxm4MvBpz4CvyGth+cOxsPznx7fyq7DfwR+PvovF5TfxieU3cJPwBj6t/DpWFbigoIVllHEB74dlQexWpfHsKt8xmCExEqMeHKth3OCSdZWPW4xyeQNpza99rVKDSGfdvVYJxXJjzF4ZkD0M2024gUKLm8XpSNx3CdNPGMwbctYptUz1jOWWLeyHWtUZrR84LLGlwfThLpGRN73c9JfWuPvUDSgP2Lig/CQXlrkA1otgUG7hsCkfpINd9Q0KQXGQimrs3OZ4rAkN/Tz6oZNkgyvIk1GOwjdxbNqX7CCJtoAS+ebbEpeBJ8dgcBKlhKZUu5WtEcumsonjkDqFrDtvMzvTZo7trEdPl2jJ5kDWOQZCIlsbdc8fGtFn+AWygSMbLayYHShsqR3NCsUylU0B9O021YvdBnWvl+ExBgMQvlCqEg95qBY/ZCw5Ti4J0wKvLGVECXZufKWV5ShDc3ZUTmHKDDeDaAK+BJ2xAahYYByeVjx5+uGfGsFFmAfLZfpVHCtUThiVI1sfUBNM2oqATilYtyFy/ybAJnyd6XogZIqDU+By2tP95I16OI0j0BCybvtZX7gyhuIDcPIZax6393LqKwaAipd1KTKwVBhLe9d3G7adp90v27ZbnLVUJoUpUHs5W1QuP4orsM0RTpsh0BpPCCXPc4z1OI9gjf/6xDJkWlimjicg/t/MM+qwx4ulGJfImQ/P0qgLXJhokZe15Mq6CtlTk0JWuUEuv9GqI1G2u0UEx+KLVGk0ztjyppgB2MeVvmmnPdGOJ7x0xG3rs7XCvamYgwrFxTJ3urHeJXHc7NN1+lwXlq0ZvNPIDElsfr4mRV5wzI7IDAfOI/uo1zQYUl/2dMsNQstCcHsUb4o7ZxtuJymjXWG7AlgwyhiPmWcq43WVtWkbWEn8vkRIbmEz8dHfeN8K22CGwRJq20yx6q26zR8AU23uPW+KK4ERoyNue9rsXC1wVAMkUVvU2De1anssbdEp0PxyfAPgjIlouGbb8Qru8ASMg21rXM1v44GViIfhY497g2t+WBY+ToIAoLsD/eC3Lcv19TSu5aQfQdz7gwHZr15k6kP7z1gqhn49G25s1uVQVmSQsbexwwP+z3nlnIuk/DXlXpsxBuuOiLZ56XffiuPEn+1os9vOtjnYZc5nlZsj4dVfKFwSM/JkE4vES85UnPFStXCbhPI0pF4Y6cwWQMotsd/Q9DH0wWDOtprcu023H3pNvXcSnbDsVNwzoIHXdl0H8RPL+J+XPcqvMLCjjDReXH4OwYvHT3CthN9YxucX+jeWsbD8r2NRuReW4xPLvbDMTy0/iSjCZYzliI++uHnchioUOJ7JSnlVrgxcGbgycGXgwWTgWlh+MEN1BXpl4MrAb1wG6qocV/wHPrGMTy3rE8tYUP7WX/wHLSw//vgX+LTycXBxmV+FzUVlLi6/zoU5WHFh+clyWxekPtoFr+6rnonWBb+EfenvGwSLdxua6gZ0KNr61sdDvasY3auHlpk2Fb5Jnn2f+ll3Ln2LZe750Ct4QmNucUDEh6T3Nj1KGeo5fkv9HkHOiqJARfUM0nWWS1zJVz4EnE4QNWSMnVT8a+sX+RVemL5YWMaDX+z6K+z8S+zgj97GQgLs0qkecnGyg5R9tp4eCVF86b4eNFmZ8vsFrLO/NiEfNz8I3OtSDqPANwn7HjZrGS2zo9UmofLxLNnWOeluZzljEG260R+4K2+rAdV244jcXpGR35Z10K/0M+KUrySQLwxg+Wxi1AY3AJP/DGYOAqsO4Kzbrpkt6XLHd3SIYVfSrOI3Mua7VKLVman4NVcZH8ZA/zQ5kjQnSqBJG1G6zY4E0kFA744oBjeMo3NijUdZ1Tx3oDV/nG0SYC4A2HSwcwNoclSblKHrxRvouWWyqGVmYkdjo55cSx2GDpd09zaHEmGFRdmBQ9FBoDhKMdiGH6tZys6l7LPvkPk8Giyq0o7xmIckVUdDnC3Yzas955njoHKaRr+nJPsI3LSfdo7NOaNubp7BZDJHeJhRTIvVf3Qw9J4XE826FylKntQq8hDnBvqr8yT6LU+Y54ToPGKpf+vCsuOW1RZe+UTFqshF9Fx1OHDsxtAueKGZwiQsEWyjCzyWNFFdUBNjIXQrVGvv9GVEv/9Z0h7EBXD0pemIFAfyqHqrypOjnLaWbfCl6Sicj+B37ICO2LsXI2ZCYOTXDZI7hhkr54teGnUgChv7ykJ7zII6JknAA6frY+eHRrTLUvXRYfdHoP1g7gFyzAUF76ArcQhDOX0H4NQibTvQ4RZ9vzMX5QLaNqsYZDOiEwSue9TiPLCBojLoJpoc1Rl6OYVw+jcRZKwWDHV5THjEZ+9BITxtUhzlJN/qBkrsBn12vT2ssUx51DGr0mzSWRYYAGYIELJ/NNO+6WgTojwnze+SgJmgQtMw5vMNhIKTza7XeG+B4TrRKDKUAs7X7DlD/JpE4H/dwnJ48Lyb3S3fo697fiuwcKym+2B79pk98h73C2G55GPrr+0DuR/JdrtJmobniMzp5stMM55Te3KnglXNr+zgHq+5qqSTmWC2c7NYHCM28Rs0SoUA8IzR9fJHMgOHbVWh22O2bsrNZ539uO1y2lj2kMt7/WSfTheWKZ+7GjjgP7m0sIwaf2P5ORaWn2Nh+UP+xjK+Cvun7z0/fvEsFpa/+NXf0wIzP7H81ue5sPwVfGL5M+DBAyd9HXYuLIOzNgebvubADlXBWWF413Zl4MrAlYErAw87A9fC8sMevyv6KwNXBj7NGfBV+JFfhf3yo1xYxqLyX8b++NkvsKj88nibC8u4xn+TC8v1ieWXxxNw9G8D4vY/r+D5wM2bar4JsNAl7uR80W8cVazvN3k2iRvcaNnWuvaakh1g4K9xOfsQOZmSDvzejXgjsrbk3o9VcLMV5AVvDUTQdeowRichaIwbtIwX4R4/m7osh6qE1DSeP9Of6y6nPX2IwQSp1KwCmUo8UdXXcmlhGV87igViLizzq9x1A8yFZeyiGPNRCzlgF38uKvMvKdjWJ51R0sZxOYQlj0GaUd0pRgd2ruWBmszthQ0ZJulAAmKUYk1EFNZs5gsGDQeyy0esu2rpN5Qefy+IzWhpy0joxhHdc2ksy9hWJvuh1F9TK1wqij+tw0/ny/qdm+bytAIEW2IdfaDyBC6bNWqJ6jBtOrL7/qlxP0jixTDWw08cOeW9IKazgeeETzJGKsccuY7OdZZUa6eNIJCyzPpoLLzhQ+QMiQHKhJxhLgJwx78UBjZUsMkKStWy7XmmuKCgWJ4CJA5GzqZzaZVKIsy91aeYqnubcRFD9DOOsEgnnj+enzvX5KCO9hFzICtmAC3nw/akD1DakUuxUJp1A+aDeMv2UpzVgeqCYEMMBcerN8fC0v21nmX1cYvJDB4ftiMGM7I/XTc+SnuwUWtfZVPjMGhjsQ35hUznEKh9LnFh0J7iHAoczeNTy0GkMTGQodT51fYkilwQmOdVOFfHuUDibVIp5uQTwko0qipFxEaOdYTMGvjH8GO71kRE1tgPy6iDOwdy2mrOcT4I1GyyQ8z+ZDc1htCeY2SeaWtZM53XIqbgJJP8GQoS+3Jt8rJOn69aWDa/XsNg4HxGCX/I4fIPhBEDokG/5Q8H+niM/LAkQEMsWwYBHgEj8FkPiY8wNI65tpjlUC31iZFBAxVD6Re2kkYFNrnN2JTvEzPmVOPaZjZHaNJ0u+yZL4rTSBwFwzgV0IhStmoYiaZtPDE9x1zKYziOP9ZRfEVdFTJ5Z4yDGZqMWegZw0BJPNrFHJUZj1XRheaOtrXwarpNYS6qWVfZZqrRJMYiFOQqPmi6Tr0cRJ+hsFv7CYbzY1hO7nMcpZwZ3nbuuwvLtMmAftWF5fCRRjgJqj92nuWccxJ1eCtyBBtcAdQRApZR7x5aR6JhXrGsDtySlRtLOcfrHop+3NfFGI0ZD3ULh42GvbjYno6T1KIuF7ZEReG+y8XOvyCjIabMKSWTmf7sU+ilEfY82mdLuuauUjLNp59GR23a7LqH2n5lf/l+xTcPgrJ0DlTyAAxfVl8ARAhLflKZi8rPH/GrsI/jn7Ww/PHxy2eP9BXY/LTyF/OrsN/6nD+xzIVlfg02F5dfsbDMUOQXldxmHxRXymfd2Ku8MnBl4MrAlYGHlYFrYflhjdcV7ZWBKwO/SRnwVTi/CvvAj97oE8vvHd/+q//l+PZf/q/Ht1ByYfmtJy+Ot5++wKKyF5YP/c5y/DYgFupwAxEX7lmi4dtp36jpfuQmt3m5DyVrxhImPIQOMZFiqBtctW4Ptgnwrf7XXTLjV115mNLIl3IC8cyN+zZl5qAuWERoKEqib/kFSHE/WlpxJpF0ODXKY+q28V22xuYuGZLrZw8GZAmAy+ZkLSwZt+6DcfCNMT+x7N9Z9u9FEUOL2MM2/uo6+NWPXFyOx8idMc3H4TysrR+dcFQKmAY+b2CxwsQWsGArE2koWyXzyYn9E7qhZO3c3FEyYwW54RDh9BCUZ1EymYRr54OJrIdF5hpC2sqegJMtuKdiBc45xoyqXZCwNof9RLtA4R8uQoIjAKrbcLpnPSAhnXVI7pmkWdjcPW6RvYoMQUw1H+pkBzTn5U+diBnLc0GLJfINsIwzXzAUNONyixDBZh95snBzaUs+WKJcgaQlCsNoRd4og1cWtEvKVlpAQtTJg3+iFijtqco9JMQTG/ONMjOpFA8ADK80bENLHop/hc3mgR/x0zYdah4CkM1T1ur30M75zIA8FnzQzj/S2DfGoBywpDIdsl6+paCSW0mjScmiL/EGDZChk8V18sw+ESs8ALYb7IgkpLI3cLExs60G3qJRnmtDStjORkHIeMQ4AupzhFa27Dnc81d2ALC8zR9ndjBDrY0SbRBbJwnI7cdlGiR3S83YEiBTyPe38hGelqMWyoevqYwIIir7cJ+8qDwHVvON/QBoiQWkXlCef+RjTnog3jtj3+1nXK5PDLnMRza1EyB5gQNVTfqFiO0q6SBgwdNNAT0XCJs97XMyanyIrg3k4kdDi9fIjxaWqSQEO/OqKoG5OdduryXQxG6gMk+1bUouAeJbBeFchLZYS8YW20osOU6Q1q+we4t8MeJ0m4GgCI7gv2EMcU63PXjaJsBhbmX4CQ906dcjl5SFNl5PWa/YBtecqxZHNLa2lGX6cx/ddDuhFt/2anI1n/EbTYIjc+JKIOvsJ8/1fSMkYGFX8wIGksM49HGkvbk99yuHO/nWXvk2ZTXXrJ9x3y4ud4S6FsgXZsVZvK5Uh1KQvRg21dOFIBulNN9eBmA3zWwil9Dg/z2aaTfr7SUsz+xLRsNq2LLZonYDELCyn3DH3dbmW88hZXGj9FyKEkxnJEnncRYEPBNqXXtGDQC7c0m9fbiUzdKQRIdT3lTbv7jdgG76aqaoDdiuetDt6jMqrKuf7iwErlIZ9RXI9NPO5XOguLD8MV6RuLDMTyvzU8tcWP7KN/7w+N2v/9Hxla//4fE2Pq38xme+eLzx2S8eT15/F+RcWOaiMvZyiqa2dJLF1NO3t2k269Zf5ZWBKwNXBq4MPKwMXAvLD2u8rmivDFwZ+E3KgK7CeWOAx9X4tDIXl198jIXl/+t/O76T+/Hhz7Gw/ByLytgfc3H5kfb4KmwsKsPWX4Wdjyvi4SzzqDv/vNFAc170s/6qi33qfXOCqjbiZQMlbxTLPuu0aWH6K5AoHsRB/UCkVVYfLIluUGxVlKG3TKjFJEaIVos46JqUtQ2w35jThx9EVBDBgOPkn3UCQAxj0s+Yqam4A0KRtvZdiArPzxFc2mYB4EES/cWDd/gBDdeIubjsxWYCyF6fOCI+bbSYA6UecgkUOqi1RXx43EIDbPUgPprbsR7nRH/TL0GkTooqKZWMytyMcTvK5lX7BO/4ym74Lpkrw56i8rkHA11D1xg8JjQ5X2SAbcYgjnTSfPR8tiUwVdNP5WvoPD4U2U/7WLnSTK89qgO4I8zRfGu/9xkfnOlRZEB0AHapsnxN+IIYbCMQP/gtEj48jf9hgHq8HAcy/IMA/+mTZwjL2tK/50yMUxCGKtF5bmkBRgocWMpZI3meZUjph/aIBTjZoik0QWNjLiVxINRlXW5oh85MNZnMwpFxnabB1WXWqNIWEbs1LS3LONGMeClHDdDVNpiZ5349SMQJNtipH+NA21BovrDuPcUqaKVFrIxgzQUhZhE8DgrFuR1yV2Ui0NKvZgqd4Sxbx1xEy7HcosNS43OivLdINf2VT9vDpavCZVuRLIpmkQ4HlnF+dGU38dSUDSx8DrPtupndb7XDYIktuPt1g+3FHxppVmNv7igDvfihwkYrWNzygU6otB54mliqelCHDA5EWY46Zi+clgp2tud7JheYuc+N2PgkuFhvztuJdV0UgJtKPqiEgNFEGw3HakNpq5HI4GEc5jMiXp88cy2N0nMjXz1jvOXf+QOuEhFV5ucxvGhhmUHm5nj12mBZBQMt/ru5z6tS0E6cOoR42N2zL3RUQGJkBqIilVJ5/K3f8jN95twy0mXPmAx5uIz+VTAVjVPp0lxVFkfbsi+zVVhUCp5C4/hVrazPPLNNvHeaTOazuUPMufP2LJ9uOgAZnhyIA2b6JWrhUIRpK2zG7LrAqU9bz7nJ477vY1GWycf2Oh7uTCGrsvCXdFRINHipWbkb+6r5c0OSZuJChxTh5ke+Eqc4XR/dmfJQQ7kLEx/FqqzW4CQPzyaL7vU3w1kK8aWhxumOgzNO+yuTZPa4L47USCQMJ5/r5pt25jany4lx3Txsuz45Z52Y4mYjt8k/68uJbDBK+7Fo+jC/dEOxyKWEhHo4HDBTfgpKv9pglqrznQH3mP3We2GmwoNDJOe2SgA0Jig/Rqa4qMz9/Y/zq7BR4cLyv/7mn8T+e39yvPW5Lx2vvfuF4/V3/4fj8WvvgM2Lyiyx3SQ8BIpw6NQOi8VkQFJ7FVcGrgxcGbgy8NAycC0sP7QRu+K9MnBl4DcnA/EkDf2dC8vvH9/5T/879v/j+C5KLiy/8fjZ8cajj3NhOT61zIXlJ7DjVys+RulbEpa88dCNCEvsfMhYrlgfGb53wS8bKIk1hqV2CrFL7jI5500mYWWc+odQKG4EytJ9sCwlkQfoOzeNcJ6qr6nyI40uC6HKzN3U3N6Ut6+Jm/Xw4eimBj0YhJ43QoB2WgwY1K2Z3hmz2q0OZxDq5pgTCVvYxFEPtoG3if2wzcVmLXTRBgT1qWUqoXOOXEKqhxbz6+GmLjwSRX/dok+dK5LjoHbESZQ5lEcHGjAcz7YkOFMNmftK0awPiKo8b7kxFm4uo9IBdW3tn4ygVF9oz9wNHtZpyxjq0zWoTz6o72y07s25osRzW/VJJu4U3PhpPtWG3eRujxG32/si2BxnY9SzjXxydwTMVVvdrQEj2I4l0dzRZHzePLfZph/7CpN4MESdcZojsGcpVyo7y2Wh80aGNNd463wBXg+cwMEw8F8HlvThnWIC5pyceZyvGSJAMI5pXViOhMgPIo4y/coJ6gGpcmpTlUgFNepRNUalHKBmRwMdftBvG8zZDXyJYdMZZXxNZnrSsu6dbW/kYQ5+tfNocDuBJhrlfD2bfYt4ZuTDaFTnnKP4zCIiwRidKBUa58PgdDVicIv56vpI3TKXdpu2iJy6LY+Dz/K9jNhDqvltGyhcjbxBkOAZGy39Gks862WXFZppL0VR0VxjrgrrrrBMfxZZx3L5KuyBY79jT3MEFOqcvxm8peSiiF/17H55HLyg/Byg4ULh6L03x1VxAaAS2vPRDj19EGc+llHn/HFUkDkY6Fu61ZPEfgHVJk50ItVx/VBeAIGBbFjmgMkGKvZddjiYQQvLUGhhWeayFm5e39K5c8f6PHfEGWZULbj0GDHJryBq20T2tAsVjtZQOOqlj8rMYw0wTaY92k63mO6cr2ScdtPt4ofADEnjzT5l4GukVBC8bgF19lcd4TYhLmnj3mTOnzQzlmxdD6W4ZggmS9tZ2NqQ2feJm3X7o2zOhYlhfX6at/KUcSl/mwFjoP+Khfp0JrlJNrspnvWAzWjbUD6Gyj6FGCSjWmPdLF1zHilZudEafmxB3nldoLaVozQXy6o7JwNXyinL+q17MYV2Ubb8Xjw7fVvk2E2+MZnWPE4QGIdy4WPiCjo1FHd7mDd8C1RocNlqhLYhl3BmaHe5SWDeqmfc9ltO7jiefSC2uo365J6KRS6jlizXR9R9Gja+p2GrPwLF6zk354pq3R9DYpn/MDue8fBKCPYBVPkc9WcvH2t//+OXx0/ff3785L1nx3vPHh9f+4M/Pb72+396fP0P/u3x5md/53j69m8fT97+/PH46VtgyYVlXtXamcqlodczxuitR6jNqLOVcVd5ZeDKwJWBKwMPLwO4Js53pocX+xXxlYErA1cGPt0Z8Muzvgr7Ge4Inh0vnr9//MPf/J+1P3/vp8djyJ7gk8yvP3qOr8R+dLz12mN9LTY/qazFZZR6ACM+1PMq3osTutlAJl3uST276J8P3qxnqR1EvlGsMvkJ8M2FShvvTn+N246fIbK+9qO1zoe74ocB7rLKhguWI2WTyhUF+z05TYureOYjnqK5qTTKDIYEEX2FJolRTKTHNaympseXOvKIYYWEkIqkD544Gnqbr1ic0WIXoPpdZtjXwgF95eSetOSbDxpmHldct9g/nTO0ZVhqR7hEmUN5zIDbmgYn25q0E0CIJmzWbSB3m8/y7cASnDC1nE/zsGPqCwR++F88kNE28kBA5gHVT94mS/iIJIZlzz206aTgEe3a51LKWK2ARXvUJciDOaTG696E3eRBNkBs5G7OCLb0Tpdr3Q6zdDwCkTB3qdOBX5eFyXAEUz0eCtmJHh1BLl72D0Byzd0WSS8lzx21x3nCtwU9rMqwajyAIR/fMFSmD4o8aJKzuXQw28QjYbZVAMTW1iOhmFLuHLu0L6rLX3FMyxAa43KcrGXFSvAjSwWkNBujr+0B8Y5+St7wSlvjyReMzMOvy8JydKGjXLofIevo/q1nTwA037bzyqYzn7POBNnXSKPNtnEocVWCq+cMFd2Lgp1UxhiPGAhUPJMk645TmGy0LEgI9U6iNKWJGjnz1WxbNRewdeyZ8gqIZSQNH9LKmHkIX6jAQHWUYZMaFGx7YTkwyQUFF5fPF5YjhrO5mszZgS7ox3FTGrgRNwARXWgYP22MvK0HnyDjYP8q00kW4EutyMIBX+IorWtVQXAIqBaUvbjMgGjKMaOaMcou/cfci8ZcTBQVDXObuBDluABoWPixdi0bBflGlmGHARPubdbLC5QTQuyd81WqYWe3Mgf3oFF4GmsI1Y9Uum/kkuNVYClKj5REOpxAyyfpfW1C8IylzwjRVA8cl3i3+KZ983VM7nsw3j9WzCBs64kPBPnm8FCq/BF6EhvxjlFl0CAHIb0X3+LDBAonCVRfDztXemCHeoNwNqefBjHmRu28SwLSSNcF5E7++7zgTupZRqwzAtQN2MRsdnRWJkMpoj2bVU+Tve0YqgRAdQK3WNy/KDcmK9OP+Rj1ShOasB6orp70M0gJMZfgWwjpWh1YVADP9qzbZriXaPLPeihvGbbuL/5os/MbsMg3knm/J7+fkkP1GZWo95nHzOremBUqiQmQm8qCXk/xlWAsn2FSfISLAe5cWP7nD14c/4zF5feePzm+8Yd/dnz9j/7s+Ab2N/BJ5Sdvfk77oydvgodfgc3FZV4pwMkyrN2gD28ZipuLSaNKfVWuDFwZuDJwZeCBZeBaWH5gA3aFe2XgysBvUAZ0V4AHO/g6a9wCoONcWP7g+Me//avY/+6vjg9/9qPj+fs/O1588LPjKb4u+93XnxzvvvFYi8tP8WjMi8vxMIyX9uuNCG82KQlN55Zy36udXfTXwzqYWM9SO+8z/BCL9aSVZzToi5tKK0P0II6Ov/rgqEff3K3IYSeBcmW7RbZWqRxB16PUefKDAQJnDJOTOvtmndu0CwExiZpEE+vBF8HKOVWLJh1Nf6xvLhSC46BSkeBQ96A08B0xqhmpSv32cjJoYVnQXDgYvjoG9FQ+zLLmY8YWZ0GQh02MgiwzToVGn0m3z+kM7bQIm+lxhXWE6HPCXBpZmPIfmmJ1YMpWz6KAo02gbVGyqR3JN4fLyEHEkiZyRnm5Cffb0QyreNqsiGDf+7paR0t2I5jJOfHmEtSvRQmQbHBI7IAGYYiQlyQbqsrVTjNjcJ6nTFTpKx5+2UujyElf1PCxfpRuYzyg8/lLrF7bAWKdj3n8hxe9WJxKIgjKTQ+YoJKPLBsQwAGX6WyLBoKQgeBk8zh4wkz7np3RN5uLKYGR8+ae9oFvne2NcUnftyhbQ1NAM6Ccg53iKRJf2pnb5WCpqhb43LrjMtTNonl3FhuAy4PTNol+1gupHXZZ45EZmfSPoDRVlKGddTORp97jLczSeXJptX1XSQXJ4YbFjme743MsM8Y0JE9tES0NaZGt0rIiptSzpTYVAAuPQ8ja2jYmlCbzxXojox72zR1DQimQBmdpXyyVV5T7xnMl9tDQVOYwkr2TmvziAkYLOElmt1xUZm5VbrrHsOdiq8+Yom1JWnQhX7Jpmd6+6YN2BGCz/2i1D7Y597wlHE3KuhVdc5sl5oL9plgFD9kmA3f+xjJLHqJkP+PTyoTyK7HrdRUCXt/+91lYzn7CaYakMuqMyTUGx82ZR9WJkzwPJolehHDkTl7UwTaySdwDtHyvyQzgpax4VtKYI/CWYvsIzoEdCknP+kSjHQeRoDByjggL8+YfZkXBmChfYrNfCNs6+0retDZMvniYDtgcxlKlL0J/1c3xEb/RKza7UJkOl7h2o3Q8YyNRwO6AZZO5GJDwmYSjMLfLoUqmJEHh+I1x7EKkknXNIcc55NOetmxLxnqSLAtWUEpMhwayvmxESFlSnWnJR2FxsD6gA1K2rjg+trs+mahIbgCmhvUIdzgjEbaQTHRLFxIgb2NNu1SYXfENSsslUiOUA6JYeJg+SnhaWefUoA00gxjbzrtq02TgqwpgxI/jidFyfVRGD7cSfb2NX13Pe2Vf9vH6n8mRGAeVqdQ1P+ov8bvKL7G4/BHe5D7Ebyvz95XxQeXj5x++OH72wcvjgxdPj2/+yb87voH9m3/877Cw/NvHo9c+czzG7ys/evIGAvGiMu44IgjIGOUcDL/3h8x9mCijXd728JJcGbgycGXgysBDyQDuM/Id6aFEfMV5ZeDKwJWB34gM8M6A/3kZjqt/fFqZv4bz4vmHxw+/89fY//Pxw2//9fHLn/zT8cHPfowF5h8fT158eHzmzSfHZ998eryDxeWnsOXi8lPevcVdBm4Q+bhs3ehBNxwp9r2fLvahPLvo10M3KGhrPUvttIE/10nL+o0fK1g+oI39ONskZ0dzW26asxHqeBgwoDbBMLXUD7uo1EMBVqC2f5ZE8wFJWUFYdegGHVq5CTOILGcp8SAZVanR7m14Go4ESRXrQ9WmrA3u+IrrUMdU5Q1xOBMVDiz1m4i6cebXYOcDY+Dso8qg0pGPc+YjHWOoDA8B1oOmqOpBivMq/xkr8dolZN03z2l4p5CftFm9rgYTwvqcQ6WjSTbEi6bLSkQC3KfginniWJgH1rXzYQN5x0bfYdfCGc/MYyNY25lae9fmrqJtizn7rvaoGylRxi5ZvhaV/sQmQoZihO6zKkIbc4xEyTHzYX6Xs0uOSaaMbShnOBqFDIOh8PU/yhwnyIj34jGVtKmxwjjq04YcT54XEeBC9wAAQABJREFU+kevuaUzc1KqurBs+UwJIMRC2GcgeMSWXIl0M3Q+wt55vM1VEgArN7Zhu1Wot3aIE906mxvjkmS3qEBPbturnAFAMJviSnLW73Gbj9C5wEeDis2gKpvtv/fC8kgjvHlUwrEX9uy9yxlp1zXftvPKXWCuZr4st/9ZkpG+dhvbh0fMSXISV/OU9dA61kBkbqEKrb1HKVnpgreQJlKJg9s0HWR+X6La88dQlwGPcyl8pi8AdEYbiNKzkzjllf62jaMVe4fVORJJWIwxCa6IYbirXL9qYZkLzNpsiEbMmJGIQCg1S9zD1NeVjnXQZY+ShOwL9YoMlAFZTkjGWxyEYCeE1wnMua58WeeLGv4zZi0os4QhnrPrdZW+iNU1LhvYHD/rc4EWpvLDgtvEhSTVc1yg8JjLvloMK/t2Qja5bS8f7Ig3gAaDpSpn3ItiNOyDJVk95wLiaJmDXBhM29XniIf6ofQ5m2ZLYd8UzrobYp19XazbDSF0aWi0Iwi9H854kiMiRlanbtSnq+KlMH1N/SfVF3uA7SZiiLyTQ68TqZTOQOpGnVhv5lZbsd0BanTD6lfhNq9L+3O5LPRamOWM1fb+wwSW2hRrVVMY/STEHHy9dZ2Zs/nNODQI1jMHZUHWfM3ps66QAyYZ2qXL6AihG0OjvaNgJwDOSwP3iKYiuVl0VBaeE8zz2r7ConPldFRpSpSrzW0/Db0TptVVvmrejsFb8kHj28wF5eh1+WBFfbkT1Ly+XoweaINvWZwRLHztHwvIkZ1xJkQiIdbbXJac6MKjfIFdC8tYXMY68vH+sxf6tDIXln/xEfYPsdh8vH5889/8++P3/vR/Or75p//+eANfgf3o6dtYVH4bL/yvIwp+Ypl3GtwZg3dUa6MfjmqMLBHcWHqs91KA63Bl4MrAlYErAw8yA7geiberBxn9FfSVgSsDVwY+tRmIC/V4iebnPj7GFfnHx8sXHx0/+d7fHj/5/t+h/LvjZz/83vHzH38f+z8ej569d3zmrVhYfhc/svz0ERaVcRnPkjcecYmfNwB5lZ8tXOnHrYnEvtpHbnnfNpqVbT90482d9Sy18yFa2vm+j3L5Sj8k2n1R9lA2xZ7Buv9Tdr8fHgfmarNAMqdkPlioBwJwZgxL5Vtl5PzMr22nTuNyqiAKzCedksjOC5CsG5ebgo+YHcPkYp33n75h5pyPm+JyFv0ERg+Cicf+qk8s049iwIFYWkSZcsniQC8z88JBSJltLJv9ir4FoiMdxFvVtu11A6Bpfx4Cnz9Elm407DdKICIoIhJfGpyTiU4ixkOJ9nFeypj2UBDqGFxav/bHUpfpy80s79oInoFtNrO5w874lphp7H6b6J4bJ0S4BoWPfkgnSqiFyG4avffabettMx98WWdCtmkXezxMcluh4eBzxWPCseUMX84jMPg3yG0XPoKbMsfnW4E4S4LHaaNOMeIQ+mTLwKPoc6V8kf9sgOw02ao5DKeZF++oTpdkHui1aozLGcONlRO4UqAF6wGe8RDq9oDcMFhgF4xH+btrtCrCB2TuiAnJ4wAsS9MQ3xpIUvTbWDnA5CoY2huSniOcnBObqfJC+z089R0K4h2LozSeNqwToDKqlIQNSsujxCu0BULxMOdqCUdl9Agni3qTgYjLfC6H5VoNQMWckbVZ5glGoq9DIgqIeLKeYVTb/kId71BeqKWOcklhWLaUDj7/QQNFKY4xgoFkWZKPm3/j+V+ysEx7xiE/PCR3LGBTs27r+ysMFohY0mAqWM/2hAiZAsNR8tWTUu04CJHl/MQkR0sLy8Tme6FsxEtZVlDU+6iwLXdtYimL8Y15Z5oYTcYTEsUFrNviGkTS25ic0RPBaOWUhK8BTIRjyObdwi5ZRv9XT2HoT7VzvjTV6vVWMV+H28qMKJNAlpMMwbAZjDgOnb0MkfLNdp1X7lS4wlgWU0rMjb4uRJYXTBXzssH6NFmRd1oZtO1cEu3+qD4dUTeAs07sss2YABxmC2x6M5/8w2DGQSNyKJzJPdjuLSybz1B3iSWXpFhWfAIH0nYsKzYB+zos4GFtXlkXTzHTUxDPnqWRZ7gRCaz5w/bCzzZ2xcYyDXnuug5xbwByFMyx+un+tEHX+vWgOhXKSeLrM2oQwKJKp46L5cZ0YzPtK5I0OtUVaHDbL3XTyIFQPAKZkEGn6oAtKp3Hdwxvro8Wy4fX0D1xhl3X/rp+yexsF0KU+npGZdwY6L7hORaE+UToBReW8fXX7z17GYvL+G2MD168dnz48rXj+ZO3jq//8f94fA2fWGb5+lufwwn7JhaW8fvKj14DO87e04XlOVo8HzhAsVvD0sO2l1Bd25WBKwNXBq4MPNAMXAvLD3TgrrCvDFwZ+LRmwJff7B/r2HVnwK/CjoXlX/zwH45f/Aj7D//++Mk/fff48fe/o/3Fhz8/PotPKn8Wn1p+BwvLr3FhGXdv/NQyH5o9Rl33F6Tkv7wZ8Q1x38TSd2xxS+BWl7WwjFsEf9rJWC1ywIfa7AI21lntG9u8nafioW/Zx7pbQn8sqsroZ1S3bJeBk+HHHWjDQGqXg59cvEE3p6zNFcIQjToFdVNvrFBURGWDW6tyf0Ao7HhgYLBFMearo7AJd6rrJhltNPihei2IYX7qvjQJ+chEfyOdwlg040zu/NBg9eRoEgR++bPNULsqBpDQn7HWsTS/+zd1USeiLY2nbtaFbVg3E0RVjFMIJnT6bk4g1EDcLcxIzIEyYTEuYeKH6QzCfjSvAr7wESM28RhNKW3Dz0lPy28gt2Oa7Rk3m9H2W+3VPcSYMwBRLNVOQEMotrOP0g55Jjf5NcuyHuAwuBGZRz6MbJRqjC9jNJylpnXObb0+Q6bwcR64Gyw1L0FUXDTGxrb2weHzKMDdRRn4ICIdkkMepJ0PtBbrgJsh6B3kKq3YSwx0md/YBCqGIJUFZgS3Bla7LD8F7Vlpx1QVfmmUdQayAue8KfrNZG/aj8phZLnxQ6XglrZBVZ5pg3Hn3U0W/XyhyNw2s/M2LKB0SyXBFqDKpl5XSplqCL2QNxejGJvwKP0VzZLxgM3UsZjnVujmYkZIjM8eKNasG5AlpXGagJO0EBjJ97fyZGHa5amVLZIEgH242TbbG315LBpBJlVQxDiwrnYCWGfVO7W29bD6AXvwiL7Gp/hCrCM9acFnxOZqsHtOhNH057rpxA+hx3fKiZ2vgcWaJGfnOXsaI1MgUcZlrHuI0mqX6bizE4Ly3yY2jS7D3qylgKlkPCR/0r+yUP/sB3Y2Nb9jczvIIoCzuVX5EjCszKlyJcrYjJihrkC1wm2OW3iaKLIwd14YJFszT+T0M+uNVjLTH0lq3BOiApQsz5hDluARR81/u7VxQsvPwhvKm3wXvUlslK8TQ0x3BVd9etq0aTfxREgs4Uo845p12yw8MA2K8VpG4M0WPszHFuuej4ZzFvh8cW6tYzlfi2fUqo/AbFtcsJ1/qOHs2c5c3UZN8bX36Gf3tzWsrWeKdexja8KLw3QpLIDVDtemqPn4ibmTXWZ04yCZ7Yv4FZWIFAAFVS0OWMaJeKc4g6cPiV3Sb/rxWNjtTm25y6R0s0rzSSA/KZkGo7MzzgkpwqwECxGLB+QN7TuGft/buR5qe16Ha2EZ/eYfWXdOMje+V0CT74t1r85F4PhKjuM5xuA5bD9G6YXl9/Cp5Y9e4kkRPpX84rV3sIb82eN3f//fHP8q96doP3qEr8DG4jI+ugy/4NPCMmPIp0F0qPHIWNC4XViOs04wWO4lRNd2ZeDKwJWBKwMPNAPXwvIDHbgr7CsDVwY+rRnwRfksUcenlfkbyy/xldgf/fSHx4f//APsPzx++A9/d/zjd/7v4/vf+X+OZ7/8CRaWn+DrsB8f7772KD6xjJsvLjA/wRX8Y9wLPOHNBW8+akeTV/d4YloPB+bNH27mfPE/Mx63EuMmAX5EQypw+56PJTfqWCV19wwNKh7wFv1zj6IzbrFzXXcnkZvRZyFuQIMnsYKgfgMFrXINxbCSM9uU5+Ri2+NincsBWYbGfms2WJCG927kY7wrOLtR6dzx0Q1zYt/66kqY+A8fbKQHmQCy5MYQ+NhOocBY8zdJJCtGkslEh4AMQau6BvV4pBTyhbuha23ypgEAUzrxkjdsGReNa4Er893f0pE/SJRTJN2ULiuCHHj7ZcldX4+G0niW8g/lGgcU2ML+zvxuhGqe77KxrTTjQD/V7BpFtqv6UI+XKtgHMrt4N27Ok8kpxxaM3FU4jMGkEjrbM+ZEJw8LU0oDnw5bVFC6LRwbEuCQCs3tJJnnApmY02LkA53cppz2XlguH8bZACVtxJac4lcQYIChfSuejG2Yq7qkJyQ62u+IMLrXglP7Jd/DJ2M4I6D/iFt0ijtqHAd1bBsPaDOGin34sW2XHXCPfmhb0+hJVXW+LzbkpJbzMkFnvGVUQZck+1OzYiiyCsI582PcbabMbjZAK4gOaMY/6zSM13qXHT1xDJcLyvqtaZTT1gvKLLlzK2vmbOBDnSB3QOXIbQQNkluZeVWKBgf89wNYyRO0Z1IpDzjOGRoDyIJblmkKQZw70uVB51HaT/msm655YsTcdqmYYai8ssyM2V4lwfMFcjRDZXSxiodS86FaG7NZGW0TSCOOAqqC/kMx5wRZvXlMlVMIp78IOeyNZ6nxgLLGBTF4qJVvgiAIexowyPRZc6UkCk5a8jB/hJMwsTah2DSsqs3K2ab4rJjIypyUCzfIjXQZDC03o8tV09zuT2c6LIJ3l5pt9er8+fexY9yNjVToGh8iMnosG7HytZy1EYNgaIOAVftVhhNm/pUjWuFl8A2Q59UQnVbl2RQdwEmYJ32CKObkLXVQ9ris1j16dn3LQMlqNcNb6oSaKE3UZHwDaAjh69bnDM19LTgxtOWY+9p7z2/dOwI3o1Z9OLad+ehjqNnE1vlx+M3ZsQZSBpqDam8Ow675iDFnRYqgZgyqD54Z89K5cF2vccG9+qLMfbUP86X5iMeSV5cRWvRsIoMXM3Ko3FeWFFd7GBp/L74BraqxFgyXEtmPvE5wK5Y4J8ScLtfRaU+/KQvL6jHf16KC9Vx+uwbGWW8ikQ/OOup1jaEysufrGj38Af4lHgJ9jIc3seMTyvmJ5ffwY8vPHr1+PH3nt47X3vn88fpnvnB88et/eHwJ+xe/9ofH09ffwUTmwjK/BtsLyxw17iBUcHwqhM0TiuexYtSde546cX54vPcyCK7jlYErA1cGrgw8xAxcC8sPcdSumK8MXBn4lGYgbhJ0M1Y9pIx7fBU2f2v541/+9Hj+3k9R/uT4wXf/9viHb/3n43t/99f6reV3nr483n4N+xMsKONJ7uvYWT7BtX3svPHkTUju9MMbDt4g6CofB4dBlfYhIB5bfLl2Q4XDDQXvKVQHf9gCPMzrBpckuulg5eFucQ8VfY1j9CW6HDdRp71jrqxQzmhREmnEkSLWxz25LZVb5VkcFssy0j7spbWLBW+7KMW3inIIt/6Ag578cM3UNlUUEGKm7V0TJOaKUNnzYKCE96nSsJKb4sKc8cMt4QIVueF8kj8aBFeYmixaWy9CeHMMIrIogkl3g50Cx7saWDqRrJfc8BSwGXNr9sTzDHaJD7iNaYM6hC0ZdRFqNBRGn4vISJiVHe01PuTa+GjMSByDyCSzL8/tiI6k5GMrJTbpcvFBdGw7Xu1Uz7rxHFvHq+5agZL4GXdxK7gmbe8dt0gHl+eQsaIowu5niHSGODlBBYVsyImKcBSM10TJ+DpNjA5RIZsYiQ8Rjplz2EuMQy0qk8NYWQaZRfGAKlzTWl83zzhoB6jeK+Rh8shzH4Azn2sOefpuAxEOm27Lbg5eEgefHZk9GJWRVEmT6ih6fgvtQBM/Xa0BBXcfORY2bum92oKUrwzqjoG0+/jfwUYYJ3xI9uJ32mMwS1eVACwL+WkjdASVII9sk5JmQvQHZxCaz7kl7jFWjbm4jEuTZfOCsksqDZE941bs6BuI3MN4aCmB+HTuyzitOXlzoz03HmPHEWTOSGihU4XR2o/rYRj+pYxcSk0uWuSGOnk4W+QM4uAVuUBjmG1V5UBJxjbPoZYXVG4jNxGCw1DpEw+Gsk1l8MQ50UwlDc7NW+fJHhhUW3OcqJEonKuuuIeJE2U8QVZzNGwfpY5ywlqc40RjtyrLtNRrVauhzET3a5y9iXbh8escNfKCA0u5GGZ2nQxdnJ57jWb/aiu+lg4tYC0vm6XiEQmh0ZXXBcuGETeKFIR3HTM2Lyyz3Df6WZYL0F5RwbfaTQTqCVHBJkm9Zd39mZaEBPIVfQJgtzG1S/sNto7HehMELjyWjpU8v2bY1ts3I5yWUQ/tlBtP+1l3T30qUy+7BBWHjUoAHp18K59h5PEWfBEnZ1WaWa2SdjEWY97BkHJJkni4l11wq+quVP8ib4MvYWQ9i6G4R8LdH4kynqAJTdjEPGl7O7JBaaSQZSbc/Ez6XpdVCll37szukpClr4Nrchj/SWXY6LhCxQtvKjPdji/ES17NwNgUo9my7ea9MqnprjbVrbDU45U5tdhxur2bUX42O7JnefqdBQumM7EdPbBSOcUFhErErmsQHPieFjObHYKW/4kjMJpEa9cf0+ITxizx4eTj2fPj+Ag7F5bfx1dh8/eVXzx583jnt790vPN57F/48vH5r3zj+O2vfP34/O9+43jyGr4CG7+7fGDxGVdwwctAtNGZrvzQQl1iBsHzON4lVA8FEL6CS6iQIroOVwauDFwZuDLwgDOA+9G43X3AfbhCvzJwZeDKwKckA7wY5+YyWvqLUHx5kReXX3zwi+M5vvaaX339o7//1vF9LCx//1t/c7z3kx8cT198cLz24sPjNXy6+U38YekbTx+p5CeWtbCMcrkZkTfeANCXDuU+W5K2DdXRYpSOtLFxK8i2H3iKGUDd3AwbEtuemIe0VX/vdMA5mtmu/uFGu+yZgTscxs+HLPu9eT0UuMfxiTluQ8dEv7POtiOeaNVxMHZ+OoI2fJoijABtKV2oVe25ZSanhO28USZ+7DQkY7ACw5vcBIQsWdEwP9XeLHN7LRMZRHluGDFZLGOZ4Cmq+rnNtJh1x+axJc1kEBYC27gkqmwgnDYKhUpsxnsusa2Hx2lgO3FBqd/btJEYEGGCPC/MW7HbC3ABzbkg+/1QZLtiaVcIgLuuMs0JZtU58GJSk0R0Pp9m7IGJ/BnftPCihr0abSTV0KU6iswEG0lUixuJ4xOgqpJKweOQ+OXqXECj+8FMR5BmaU6kdvlIu3wQFPQhS1eiYZ3MXljW7UHGGHw4ApRsw3XGc6sAFnmYTspqzTXFAZskmZ9hL23O46JKW487mWbuaOP3nt2G7UnHUTuPd1r+6vUKPbuVs6IIZm+9CEblnJsLZmRf3OVARsV7VhHUiUGDbXNHn9mahATs7Wa2xhBaa6cCO0fPY6J5hWePXFjmPjd+Qs6Lyiy9LfaImxxJDX5nMsowG1nLfjYqWCPGmFdCpz9+sifCcgBRhke4y5hbC0E1NiVcSZKH1KYQStu5o1tZePEAjP+WReRhQJraq7/WLUYAun+hFx+Nly28ELmrWmOD5jdWr7ctVnD+Q4PogZFQgZCtPa9k9wKj55VkhcWI7AoCclN+0k3kCo34D0QqiGV1JEFVnxupDnT03KbZIkONiRoAnPVFIBENS7SDuzlCa+mUtyz89NisIxqcHQMZ0xbVyT/TZ84o8wgz4rnHp1f3GMAM5ZwnRNi3vSXbVkyudKQCo1WqiJaGFGkfYxOEo/eyL+NQ065pStaV6S+l6lMjWKuYRM8ZNfwk/zIf03zmxowOJ8oRf9lE5UaTLsMOR7Sba8RjRywDBmiDb5Fm6X5ScvZeSUqe3/6jTnHZvF0QRag2q11SGNqQsH42Rs75tBMhDiWDsT0pX1DEnCTSGuIjmy6HKtmSMU0CjUY5Ilu0mzV80ZNjZT1e6yaKUtrDO+NTK2eQ+YNamrMDbQwtfdlQE6zUOZdzPjo+IlkXl0saQUAG7xQFaOWWfByIn5t4UxA+p2QiZ8SQJ2znC4uQnjJJdWJ8Cl79P9SWu1a5QmXJUL5GRkGlZh66i+ursfPrr7mo/BHKD/B5hfexs3z0xrtaSNZi8pe/erz721/WAjPLx0/xFdh4qhS/r7wvLGPmyynKCg7Ryv/twrJBhrp8qONyxX1l4MrAlYErA5EBXCfmO9GVkSsDVwauDFwZ+P85A751cOn7Lt6MemH5Ob4V+/3cPzh+/L1vHz/49t8c/4SF5V/86PvH8w+w4PzBz/Anqe/rd5bfxm8tv43fXX6Cu84nuItbfmsZF/68EeC7QHtECrLBC37ve2IIiZ2ItmaLC1FlN7hsI59CBGtbR/vX+ch+eVMdwbuUHA33h1noOrRpnEVrxUGkNc1hX34oYD7LaeGHFm1NbSBtZ/xSwkA2G+nK0xYB2/oENR9k2MYlrTICOdlcRN8hLDwmofk1LeMAEsihkI54GNiGFmGTeioACGzrJE6rjp4RftJmT4Gzr0+yimhW27ZJucnQZJXR7hafNK7ktFXRocLREFcKWVc2ykHmBm3P0Yihc0tuPRIQ3ypP2rIllhvnWriIqM5ybduwuD32TAodx37f6IfbiUpSqpk7PwQllhvx2gFwvx2xADgkdT2ks9wC6+2920leBkDAGf3VgrLBFHrj/EY9xgcAzV8DC2R3EoR2xwSW54c3coqbgUCueVH6DMIJzqYWlYHMX0wQg24TYCcI4ysO0a6xDSXx2gtfFYXIMeK2SilJBavcEhC9gVbtFaO+QVRcqfY402a1CKzxN5SpWG3YsoUiWw73NDoPVqLFTg0YN6SZWjb1jmJqydJ200FIG7ujYu6t/GEPpMxWi7XVdoQWl0EQssr9MZ47xsKyleFlLiov4wSYXgMxR70YHZ/SCbvwN7kw2oqX/qJibZSIDpWwc9xGso16TC7UaBFWcXSLvu0HTFK6jLh8jAjcsr9d2nrXApFxpfOyYtvnLKpszp2dSxM7TASK3NhPbtlV1tTmwdlwWYo7GjGlefkNIrBqNlTOzWUblvPaIfTRAVJ6gZlytrVgIjUsJaBmvmNQmL2xE7ezzwLUQSBRkceb+i4/wSd5q9W0xiWFmqvJ0+5FJBsdPEGjkb4z5kah1iOw+BDGIzijTtnmLhx08MXVouE1tH2OIIa8nio7RYZD+jENy47YlAClYY+SLYwJCGExH9NA6uhT5HX2tWiBGl5BTetbDyK7e+AsVXzT9UQjAKmSuE+/7tUCZwMGhDO6olV8EW/JhqH7SVH1QTaN9jlrictBk76DgcfiMujMSH4ifx5/w1mKB3bBtxO0h12zt284Ozupup+ftk1WuLVn5e7GmblQJvAGIv957piMjgQMgcUq23WHI3j6Amj3QTsuyqtcrEZD5KO9k6RqniOqD1y9lg4ZndIzRXsOKHNM4X4ajli2qrBnUPm67f80Dz9T0mNI6eSeLvSHw2U2NRTu7TMvZfzgKtWbrPRj+9nvnMM51sokbwb0+v0Yv6vMr7/GUySUXFjm/gE+qfzhc3wdNnaWT9/+reMr3/ij43e/+UfHF7/6B8fr7/7W8Tq+Gpv7oyf4Gmz9tjIXl3Ox2BOKf1KBn1tbxkGxct6xErsjjLalD244roCvDFwZuDJwZeBOBq6F5TuJucRXBq4MXBn4/z4DvlGI0q24YH+Oy3NevGOB+eVH+PNofHcRvhb7p//43eNH+H3lH+ErsX/2g3843v/nHx3v/+xHx8fv/ex4F7+1/A5+c5m7Fpb5W8u41OdvLT/m7/Rg572HHpTAmf3xJpibbwlclzAPRPiGteUntxFJSi7Z0GHWVXmgh+gFchSJUK7U1VR0buKmXn1OnTNgDg5A1U/ykSnUgwHXDZMdhCzN4ZLYuvezwSwVPEEhtN2EzPqMsvuXvtNRcwSpjvYzyVDXwyA4FwaHWMDinOTCFkrMT8o4HftmOvzJBhx+bFcPHhBATt+y4eM/TrsZW9e3oLI5+3qL2K0dzS2yJcNmDAot5wP0wAdf5GfG3X03hT279MOl8gYF69JLGEi3o5UPnjJY27L0GFmWEPD5oUFzkytwU0uL8GLb83L3MFDDXFVALXI50IqBC1GO0BiWiqzso9+OmhyOwlM22iKTNTHcjItWesiCOvnJtvA5AWUnec3cmN/sETC002QN4j5S3a1X1ujKrumF9XAf54GM+yQJrE4yLsYTw08tB4fOPyLEydhIJob1gAlZ4nTOIvrT8Uwjz9WSOemyl2XElsRJe3K+ZFgAdAxRcww8X2xvf0R4l0z2gdIxKAz/lcq7JoN7Eq1+VuvIQMftGWOUy8n3SXXP+ImLGHSEeGP1C8002Oq2ZBlcKHMsPaRk9Vdhe5HYNLGwHJ9arnFKwziPY0Ga+Bkd82PfUXHGPK6hlU0aKsZZzyBkCeeTwTPaPlWO8yZMwehO7gEWd1Y+oXBfuoTHEWv5oUtxRbQJCVnpAFjGzqieT+aOsOyVrc5C6IxoDkdQevkdHICypR35scYMPvf31AknW9SSgz4kpwh9ahu+VlUEwrNpjqzV9YB4pAwb9VL2Jmk+XQNjrGuGJWSYV58sqz45JCgUT9EbaYAjdNtAy8t7AsI+UOsY2TJyYx2k6dISElUUNoLMnqjztKENz81pS3tuHgNSBM2OKsepl1Wh2fImn2j4NSPkYS9+VPWtKTbIcnpUPQLZUGfNjG1XQXxGEfkIpfygaob9NcKU4tH8SWwS044ctjeeJSHM66Iddk56cNhyQctZmoAnam7bQuXwo1gAUknvVW8LcaSN+VyGXWOdRctdBqJbtDeHra11aflZKVskTDw0wB58zepc85P33FbesC2pIInwSQCbmzyWH1HqQCv5AsfqI2KKhWX7c5yJ7XCbkLXhR5yJi7q9DIfCR5vQ1WYdV1vTDbGcRSxj27WWjzIht37MMDlCZn6Xg03Vkg9TRVWK3YLtAT5Tf0pk+uPUzEPcE+M91dci6KNeBfxmqBJglPwqauaQX3/9MR4dPcML+odocFFZC8svHuO77Z4ez14+Od787BeOr/3hvz2+/kd/hsXlP8aHk9/G/pbK4zEXlPFJZS0ue2HZycUYaGGZz6ewOY6aVQw89hgtn1Ehlc11uDJwZeDKwJWBB5+Ba2H5wQ/h1YErA1cGPl0ZiEvv9XaJrVhU1uIyFpS5qIyPLR+//C8/OH72w+9j/97x8x997/gZPrX8c+xcYH7t0XP8xjL3F8dTPKF9ipvwp7gn4P4E3439FDsXmXlvlvcsSqXq+VCEtwBT51wzooiR2vXBYeDHjWoAw5Q3OyZ54GXkqXM3++Xeu2RX/ayi8wltGVXlNCu23VHmMo/b098poYU0EKmZJ4NBaxnIHkfNEAhXS/PBVorRHnSOWzMoIXETDVbdoPIGGiHmTfT0MRmdH/ry/TZL4XFgqfrw3VUz3UcYO8fTsrAyh6VdLjaCrX4i9mkfdaKcn2kxKWxlixs8FLSt/PjsS0LHRnvu0w/r2kWuAyTcPPYuJ39og2fahOW/6DhpMkCLXE7eGTfrE8M8sB2yIHMOohVMzmO0gIayexvS/Sj7dJZFQoK5nrdQKoBfN12mhwWYFEk4Y0zNeQGgYyC7zlHI2j56HecKkMUfr/fGUezoythKe+7JZUnyoT/AOo5WsgY/ZwoIW15BydTwcOdWsDLqtgtZOO4YVovIRXUFyqrTsBtJ9t9WiG4PgJRQnIkdwNRF3bPViP+WuCZ7xLKwnY3rAoiGWarccue+63EkQLcLyzHvtYi12EZfOa4ULyq0yh91bkBqXJWqBIBH1SBrJOopbFlYx9lA32Hvot5kyjH0dhhp+a8+pod0EWQZ1uAyKkREGRmhbEEUfJPDbueuPoq6DMPR0rkVWSlwcoYrsmiHbIhrvGw7dZ52XmisSKAQDgKPSwanYr5syobkZTyqJUM/RNjedc2RFxDqZV1ETE9RN02U/fpTbFCw7v5Up2+pJOm5x+aa4zZp1I6wX+e0bRBDBZF5MDhB0cQr/ZDTE/tWf7Rnwuz4gKqfySyU+dQQ3miXJmsrj/fUEM3+3FoFKkMhSoIZfyDOj3vuCtWEJSrncJFTI6fV2SwMM4+B/XRcmdNmr5p6oL5mECedNs8eptqyNV0Yn1Bs07CNgtNjbp4oewx6/q2IaJ1pg3ei7Sm5h8pYl0N1U3XflnIz1BwGYMZliMemZyBckMwAeQx2+6Cu6iMi83N8FvOkpK+YE0am8QnetPJjsjMcAdbLaIAoF0GwyetQUzohAW0yxrtFGkRpOKgll2UKg6W5bGgbl5aflmUeaM/7HZvaXfypa8e9MLuFcUFu6g8+Ian3PSQjxhlPiYDhzk8oP0fy+JvK8dvK/HQyP7X8CF+FDdvX3z5ef/uz2D93vPv5Lx6/89Xfw6eVf//4An5b+dFTfEoZX4Fdn1bWwnJ+DfacXHo2BUf65LJHl6VmvUpPRs+piQLg2q4MXBm4MnBl4FOQgWth+VMwiFcXrgxcGfh0ZaAe5Ge3eMmuBWVdwOPXcrCgzEVl7h/hk8kf/Pwnx4e/+Mnx8x//4/Ffvvft48ff/7YWm4+PP8Cfqcb+2pOXx+u4J+D+mvbHx2v4/eUn/OQyrvJ1G8CyHqrBKRxLfpJe3yAwttvN2ltNMLb8VchG/XrVmJO5+SESZcoHAahEbgJd8jRsm0TtpIlzQVQgLenSpi5bE7Vzu5bes9t52J7jFQxh3f2ZVunjxEGIUr8WeaOMh3YA+UHeZO16GKa5xB1fSzPCNGtE85zXXonUkw74OOnbORukCmk1WEUdMzmMdLnzTrTrPQ671ehNqmxD3qivNn7wtkoLXHNBtgO02k0vew/29iDZVaM9GWfdELL4kYZlxkXpCK098QtgS5fGkNPezObKMsXMuniabAVigk+Gfoi/GUzQyrC0ptXtg3r0yQDxDdL/t71z3XLkNg4wd2ZvknYdSbYcW06c/PD7P1F+5uQkTnyXtKu9TaoAFFBAA81mk8Nlkx8lEkDdUPjQ5HYD02SqqjqYpDefswiKqu16jmEteFSYbSxrXbAQxVRqXiXXIom13iJjiDOJV+Y5ek57U/hRmiycSZS4Qe6pOteO5SHRSt52cPgxz/fT6TqI3Pt/YlIfg1Hte/H1iXOK7uUSL7mUz6PIWdu97Zh4Z2SJ4f011CiD+O+Dav38Tcdq/mrVzkTyDJ0XT/NIfWenXAn2Gi1YFvMkr4vWq9bWrZ5tkFkfMmirqueoHqNGbfl31FurhUSuRHXsGKO8xtySQ04qSas4xrl3bJUup8dCjJUyC4ZZIpXQRRD4zrQueXtRSTnUcoyJfOoUJdFjqrVxlUA5tlSifes1f4xkfw0ZGimDNkzq0n06BElt5ubPx0q+TjuVuECWk5ZTHxtnCqGFGKasrRKUOaToY8wscc5+2NHKlDbWvpdapV6z29jSJWnhq3LsWR/D7TjiZ1zr3Z9zS7ONEUfSk1qKvRxMF719y+qj3IKHS9nyUrmvW5xg7xrONUgnPkEgs5cNJxZp5lxQV51aO2Wq2rGhzdxNZRalGqt3DE9H2vZaovY5Vp1FbsWlUmquA1Vlt6xRHwvRJ0XPQ5j2Vuai04v4BZ6tW4jXCjv+WSS5DcwH4uA50i3/dysncHWVwEYOQGMU71iWo1fhiDD8uyelXjsEKyk/yq7ye33KzrJuKoffVNbN5bDBfL97p3cqf7zbffGLb3ff/Oq3u6+/k+evvt+9lvprKV99+2u5++C5fGuY3Kl891w60T8LlKd9DXaeNT1ANI9UZrlW7KhXX32EIyzVQpHHFFu8QgACEIDAlgmwsbzl2SN3CEDg6gjo6bl/xHY8ac+byw/ytdjy3Mnz4ePPsr/8Vsq3u3/I3cv/E35v+T/Cby+/e/OPsPGspXwb9u7F0/R89mT3XG5bfiEby3rXsvyffntZT/3lkRYuY11loebTCvVyqRMuLZy+HYVTTWL1Y3uPS673ss+jl4pnlIeeDdKlVi9IZ9DOrdIudK986kYv8v6o1dh6IaST7mJF3fnJWoMUMvZpRz2P/ePW62gb++LxOZ9JHlWXJadKPHGqBdkrVKaeUSLKqSoEsvHUUdP8tUJtS6jKx8Utywc9x9PK8rhdWEvFSlV5O1+Pbt4yBXJGi+c4uR5TxG7n81keX6J1Qqn/QNyVFxSl1s+hH7U6TrzjINw87/7CZeg5xFufw3y/PvEz1WU8hZ003NBcdWUyA/jdaPt7WxJNo4wiqf8oxshHHYyPn7upfR25bumAi4fFU6mXj/7CyfcbfY57nea2P17IoTIr46nEjpeX12PYl0GK7WLV/j5yrI8iDrIUp9rDb1RUGzwH5DDNynLrZzFlOorgsg1pT+NFiSinqmlQN6ag7PrUR6kP0jVXgxC3vF9qn3FuopHHMGoJEw2T9SCeiMeZ+25KsAU9xxz2xU6Z7jtWk9lsUbITs9CYZrmvnz6HvrSXTJVDz0Blg9xUNZffKPZ0lBqp85AA1UiyYx05i/shOtJaNOdfWzb5ZGWdTxa3lWC2sLeB2SGfJ233B7Vb9t55kFs8TqLh5LiYi+dj+3r8kPaSUB91PzFsBP7bFrxqkqtXXlE9cpN3VAIYN5blPFiPS93rVbluKkup7zv92nf92uuf5UW/9vrnD59kY1nuVJZ7EXSD+cPD0/z85rvvd//yb3/Y/e7f/7D75W/+dfdMfk9Zn0/lDub81dd6p7L+GxA6sk3iKJJXeWgi9kxJhn8zdIZCcqKPcrXSh7eKEl4hAAEIQGDrBNhY3voMkj8EIHBVBOzEWwfl6/o1Q+FCSqVhY1m+GjtsLstXYn96t3uQ5xu5c/nP//2fu7/I7y7/Tb4e+63cxfz2H3+Vu5n/Gjef9e5l2Yi+l99pfiabzM/167DlOuFennrXsm4wa3i7HIh1t61cJRSzCfDFr1IFob60f1ntYpljtr2uSvcvre1qqoIVG+GabQZB5dKxs9Ad1UKR72F/tGI9nPzUr1iKyf6IC9McmJV8BgYiHudg3mMLizqd1/3jC9HDy0z8rLJcrMe5vDvvu2E/MW7vOEua0mGuzWh6/YQxRB8NkYeU452uUnrpxxz13ffrWFeGsdFj1+99nbR0uS+fpfFTxE44izCjMpOmLFnWimmkYjnVDf7BSCHFU1xarxKv1EoO0Xrs02rEcxKmLN6VuJ+nFlILL5a3NKyaUmqaKxKdAOjE2N/LkigWeC7aXJzWL9iGF9NE7/F7tBfdfP2hUGSW8/Q4MU2KKS4dLzNaXPYyXOpczsb6mUz/3fKRpefJGHrZlNh1vGjbsu9F8L1qvURsNdF7GiOeQwZ5VmqU2GhzaKP6dvLwIlef16ph7t68gqA3ohSrpzJfjZcDOkNXLaYpXhHsr4lLXOTvmYpS+mm7yulMNE2MYiiK2OjNQxxf24uLlVVVwGCQVc7cV7vsvEGuS2wJti9eNm8qk8yCoBctWrYciv+MT9Nn2ywxWk3TPjA39V4Su5e59dydh+wwjZ5VKcDUwiKPyzaGtyzxelZF630m9WzWi9FYd01igK6qcT+mGXoJLzM99VR5fNp7ylXsunO5N8EUrNdP8p1RTaKPPzNKP4fEm3SwEYH9+65jDSMXMKEUgf3hVfzWl3j7gewly1ddP8hG8ie5M1m85c5jfX6S5/2zr+Qm5Pj8+pe/2X33/e93v/7t73e/+OU/7+5fvNrdv3y1u3vxlfQkG8phUznvXhdaFXTNJM1HsDClZq11exarYlFCUoMABCAAgW0TYGN52/NH9hCAwJUR8Kfnvq6n5PHiQqQP+nXY+pvLWteNZf1a7Pe7d29/2P309z/vfvzbn6X80+7t3/60eyPlGyl/kk3nN7LJrKXe5Xyff3P5IWwol6/Eln4kbOwrLuI9sSsXZZ2TSpcGUpjIymjmWnYVERS+oQL/8DrnHy5MzM7LVfZYPhrb99XvJ0qLrmylF5lG2v+wvryfycx7pBvJ1W+Jru3H+7U6H8/yOqT08XwsL/f9a93rvM+czvvMxVPd6OH78vG8XH1HupF81J/JR36Hyi1erxzF6tmabI2P+o78vFztPFevG8nnfYpXeVeqR91PlBz26nNr43ldyaBmMPLx9odltMx6lJt6R13MwOfRspvryfzm+pnzH+l8PLGxbrx5NjFlFgwcvLOvj/yWyDWO9a/1U/qcOp7PTWPPPWxMrY/J1dfrRnKl09dF775uGVPL37bPRrHqTM0rlt6n1ixvLeOwbEw+lmbg82t1owy9z8hG5aeM18byOXjdSN7JU02zq/fr2AZRNpZWa2+6Vj6KpXLz0br3G8nVbvTwPmrj44185uQlXozk45kuntHPRSm64lNka2sWS/19Xvvijfy8/NCYvT59PJ+fl7f9eJ336cU32bE+S3M4Vz+az7F9eXY+1pqxLvVRu9FjLoeRzxr5XD9edyyfNbmpj+Xg+z82lvn7mNaP6pbILcaoXBJvaV8+1mP6aGzfV+QQX4vct8M5VMKlZ+dxJSiW+rvK2tbfVn4vO836u8qf5LbmZy+/ys8vXv9yp88vX3+7e/X1d7vX3+jz17uXr77e3T17ubt7+oX8vvJLmRK9Ozk9U39hniZ3pFueWmbDUG83lkVYPbx1paABAQhAAAKbI8DG8uamjIQhAIFrJmCn6DpGrVvbloVCKX+tamW4a3kXf2/508d3u4/v3+4+yJ3JH97+uPvpL38Mzzd/+d/dn/74X/n5/uef5HLhY3jey0WC3qmsdy3r0zaVwwm/dK4XMbEeLwHsmsKWb1VpOdpvelrb5sm3YxTTaDmVeO3m6zr40RDndJ9l4Ecm5Cfa8h+N3fRbLdegmuWjoHoGKwG1oR5rHvSPTuxDYWWqF+22Zp4fc0DtvM719VhzXvV5JKDeeA7O+9gcLvgYNj4HM6kmaUXjSKYrelztcq5Uwx/Y2YRItmefk9WEiqNLPwv3jmMG8Iwqxz9JZaajGdWyrhWABjnRow21l2/T79HjaeL5ZnsMq+7Q/Hw8X1+ad5vDqfrXXFr2Pj+tn7Ivi93r8zH6sf4OLdv8zpHb0mPh0LF8TvuKo0KsBI9zbK0Zb5NWCJHnvJO39TGas14882nL3E+rOLL9mJ8ZR6b2WO4ZZbp13C6znsjXy+k3ITyRl0+i+yg3GWgZN5StlN9Z1hUe5Xb/bPfVL77ZffVanr/4Wn5P+fvdN9/9Tsrf7b549c3u6RevZNP5tfyk8pcS9Fn8XWUp4wGti0KWiRwIVm2P/UlbDcuqlXPMuHKoLKECAQhAAAJbJsDG8pZnj9whAIGrJGDXcVbaIO00PXxHlV5syDN+8ZH8cI5cRsRNZvndZfmK7E8ffg53LIe7lv/2f7s/y1dj/yk9f37zg5jrnc7vd08+yeXHE/2b1gcpJV7oNG4bhxN/uTCxUvPwdy+Ha72UnNbbe9ty/jFAtMzC5JiLYJRbxXgkV4uRridXe+28pxvJ9/mo/pB4NvjH9tmXd6//fT7nGOu+HC417zXzutWxbjVv5khnbvwZOKdbw+5cPvvyvtTPjK3mvWZetzrWrebNHOnM8VkXKYw5rDlO1vjMzYXGu9TP6FsaK3MU3y2XfDwyR7cyR/4T0TaUdewqt01lbX+SNY2wqayby6INdy+L0YN8hfXDnfzemTzvnj6PG8v/pBvL3+z066+//tX38vzt7vkXr8PdyU/kTmX5fmyJqL+nLH7ha7BDb1JP2eRE7HNRVGFNRUt9tO+d6OdWk6JZek1RKxkNCEAAAhDYLgE2lrc7d2QOAQhcMQF/6l4NM20oh3N4rYdLCfv95fA3q3J+LxcZsmn8/qd/7N6/0effdz/8/a+7H+RrsPX57s2P8rPMb3Yf372V317W32eWzWj9Om0p/aWA9pG2lfVKJaZhpSUVxGlLWS48Yt5N9knevS6xOKG0S43Gf1Z3Lh9NYtTXSH5JPppLy3ULebc5zzGd021hrMyREpgepyobzd9I/lg+Grc9Js+dQ9v/qcd66njn5sMcKYHpcaqy0VyM5I/lo3Hb4/jcObT9n3qsp453bj7MkRKYHqcqG83FSP5YPhq3PY7PnUPb/6nHeup45+bDHCmB6XGqstFcjOSP5aNx2+P43Dm0/Z96rKeOd24+tzZHcby6BhNJWy0eJ/qqKy72X/jqarmbWcsnT/W3lF/IXvGL3dPnL3cvvny9e/nlq92Lr17vvpSvvP7y1bfyVdhyt/LzL2QP+bn8lPKLsAkdN5ZlU1puNSjvTY2p//eOT5NZqTn7h2Y+9VRpiR8avEAAAhCAwMYJsLG88QkkfQhA4LoJ2Ol6OBFPjQfZUH4IP6YjAtmt1dP2+G1FahD+ZjXftax3Luvz/fs3u/eymRyeb3+SzeYf5fnD7sPPssH8/v3uo2wwf/wgdzFrLEOq4bUV+nWl6VURxMEg5KIqvdBJTqXUoMks3HEtzfqhBu1DHUZytR3pRvJDfdT+c+dg0EZjGsnnxjqnWxPvc/owR0qgvLlGczGSq+9IN5If6qP2vI+YIz0O9HHOY0H7Gx3HI/ml+mhe52R3Lj6XynvNv73MkRLgsy5SOO/7VfscvWdH8kv10bz4rON9pMeBPs55LGh/o/fLSH6pPprXOdmdi8+l8j7tOUOkGTeUn8hmr7bD+o+uAemNBSqQp/4M2d39vewp34fyqWwoP//iy90zfb78Mmwu38sGsz6fyWby02fx+UQ3lfVrr/XuZrnLWSpytOjXX+vGsj7ipnDMI3QVxXpMVUO1hpXJLCRodV9OI3otdQhAAAIQ2B4BNpa3N2dkDAEI3CIBd76um8rhKRcW4bpCXvLP4ISzfTXWp35FdrqLOdTjV2brZvK7H3/YvftJnrLJ/OGdbDzL88P7d9PLALtD2crKIvUTrhHidnLs1+Ra2iPVvchUVprOrjlMruVIN5Kf2ufU8chbiZ52Xk8djzkKU3TS9x5zNM/0EvhcQg5r3ntbzfuWxsocKYHxv3tzujXHyRqfS8hhTd5rfLY61q3mzRzpzF32+585Yo4igXkOa46TNT6axchvJN+qj887rbXobynH/+JdxA+f5Auw3cZy2AOWNZO7+7vd/b189bU8n714IXcnv5K7lL8Km8tP5HeWdyIPpX3Vdfi6a91MlmfeVNbFpHK3suHVtHRZplqayUqpBEUWiKXVKw8Nkx4mt9LklBCAAAQgsFUCbCxvdebIGwIQuH4Cdm7ejDTcrSw6vbgIp+XykjeW9a9Yw0NL2VQO3z8tpfzusm40x99ffid3Kr+VDeW3creybCjLncqfPnzYffwoX4edLgji6b68hnCuzJcWqoh95TuUg5PJoy7YxGBmLn4zD3Uze282kqvNnM7H8PVL8BnlMJJfylhH+Y3kl5K3n39fX5P3Gh/fZ1ufi9faWnvOZ6QbyTXmnM76bMtL8BnlMJJfylhH+Y3kl5J3ewxYe03ea3ysv145F69nr7I5n5FuJN8Xb00O5/IZjWkkv5SxjvIbyS8l7zXzOhrTSH4pYx3lN5JfSt7M0brPxxG3S5nX0XE3kpP33IxG3Ry7kfecz0g3kjNHI8pFPseuWNW1OZ+RbiTXyHO6uufSOrXPKN5Ifu68y8il5jeWBZ/kGDaWBWRY90nrJXfyNdhP7u52d3LX8v2zZ7K5LHcnv3wpdyvLbyfLHcl6N3O4Mzn8jrJuHsc7lHUj+SHUJZAETLcrVBlow5ZlrAzzmK0kqb4iW9QVM7ay1tKCAAQgAIHtEWBjeXtzRsYQgMCtEAgXEHGw7el3+BqkxKHVhSsP1YVNZb1S0kfcVNYNZv1N5U/ym8qfZCM51qPsQX6buXoEV4luZblySGaqsKeKrB4cUv8m13LuYf2ITR6QxkmNFDI2XcNVY/RT+mjEU8Zzybrq6fNugldN13DVR83hUfthjs77nnCT6arzxw9zxBzJMfDYn+t2mGkZ+nIHqKuqepuf61vNu4FfNV3DVcMUbfLfXubo8t97zBFzJMcA/x7Fj9nV/1byPuJ9xPsonKboW+HU7yONGR4S2L4xLpV2qqR9hi+rDn3LxrK25UU3mO+fyd3L8lvLd09lU1nvQranbSin31G2r75OtylIjyFY6rsUXhrqOQmzmQhSqI489+GjWhxKCEAAAhDYIgE2lrc4a+QMAQhcPwE5Fw+n4/qSzsvDX6fuG7mz9+fueqey7CKHjeTwu8x6nRGuQjRg6iCXrpNwIWMn/1paXXzC3dG+w1QPG9qDuHODsDTU1brxYVr5nM7Hav28btTPY/oszdvnttSHvJXA+PiZ063hvcZnaQ7+OF3qo3bez+c3ki/1WZqD7+cxfZbm7Rks9SFvJcD7KFIYc7i0Y2vNe0/H6P38mEbypT5qtySe72epz9IcfP9LfZbmsCbvNT5L8760sW41b+ZIZ278uTCnW8PuXD5L8+Z9pKTGn91zOs9uzbxqbO83iuflS33IWwkcP68agzmqGcxx9ceq5zbnYydOYh82fdVPn7pxHPwsqAVMv7us6zKqUju5i1nLJHClfd213q0cf0c52tRDsh5Cd/riHnmZx8km1ermBq+1yFZ6HXUIQAACENgiATaWtzhr5AwBCNwGAbk+sG+2Puj0264zzElP7nVTOT3tL1zDT+mEKxBz6GHNQZIytS2xfHVpMXxpdXVN9Wpj2eldNWehXY3kLmS218pan148G/q5cljTz6nyvqWxHnOcMEdK77D35S0dW7c0Vj0OdLxr3hNrfLS/1m8N7zU+2vcWx7rVvJkjnTlb650e96Zr3w8m1/IQ3Rrea3wsv0NyO8anx+GW8r6lsR5znKw5Hk91bDFHSpLPukhh/XmG+rfH8S0dW1c3VhuQlDKvtrkcbgjQuVZ1nu9UkXWZUBNd3E/Witrpi5lrPdxZIKXWTRdLa4siP0xjgkWbympcGeZkVZFCWZmaFBCAAAQgsFkCbCxvdupIHAIQuHoCdh5uZe8c3HQjGHZir5vK+pvLUoaHxMp/yGqCXowQ33fs66Kc9J8E1m9rENTeydd7CSCDAAQgAAEIQAACEIAABCAAAQhAAALXSsDWWXxpdR2z1WX9RJdQ7C5lw2Hq/If8acNZbbNMjKpFIPt9ZQ1iAXxNxOJfNLFdC9TXPcQ49ZyEmoDGsChWJjUFBCAAAQhslgAby5udOhKHAASunkA8B98/zNYun6snhW7yhr9k1dJtLGvkYGsOVva6bHRtnxMXb+DqoWrttpwEQQABCEAAAhCAAAQgAAEIQAACEIAABK6YgK632JpLqucNYTdsXULRTWUtG3NnJSbBMJYWJ5X5DugQwPq1YC6KhKikGtIelcKEUoq8mMUcota2lkeOLgZVCEAAAhDYBAE2ljcxTSQJAQjcLIFyVh4Q6F9/2il5n0njoKf1enKfLizKaX6yE12M1zvB78msVw1q9bmyMQp5mL3qGr0mO5Gp/Ug+p1vjo/FGjzXxzuUzylnlczmM/OZ8RrqRfC6HNT6jnOf6mdOtyWGNz9q8R35rcjiXzyjnuXmY01163qPxnivvNf2Mcp6bhzndmhzW+KzNe+S3Jodz+YxynpuHOd2l5z0a77nyXtPPKOe5eZjTrclhjc/avEd+a3I4l88o57l5mNNdet6j8Z4r7zX9jHKem4c53Zoc1viszXvktyaHc/mMcp6bhzndpec9Gu+58l7TzyjnuXmY063JYY3P2rxHfmtyOJfPKGebB9NrPvLUIr4ERVg1SUsnspAfZOHF7EJpYlk1so3lvLYSY0Zzb6x1/7QYInXdBKlv+xDFxb6BO0nMQcvoML+W5QJRhQAEIACBiyfAxvLFTxEJQgACN09AzsPD1wmlMpyMy3l5OSm3E/ZCqnz9kNdZvS01mJ7ox5P9EsXXOroQpiNPblGT+rIus7kJrPT81c0AABtXSURBVLS+1KCVqW4kn9Ot9dGYnzuHXv/7xnpo3jYZvb7WsuvF2pf3Gp9Dx/oYOZwjb+ZIZ+6y3//MEXMUCcxzWPuZqlF7nzVr4/ViaR+jeCP5Ph/V9/oaxVO5Pg7xUfu5eL1Yj+GjMXt9jXJ7jBx6/e/r59C8mSMlNj7m5nRrjwWN2ZvbUTzmSIkxR5HCmMPo+Jljd0vH1i2Ndd+c9z5/HsNHY/b6Gh2r1zpHykEfNr5SVzpho1gqQSsv3iq0KkHwEKqx1EjVw+5cDkJ1NOemVHf/aNuqM5dkl37aOc1odNAv3C6GZRUruVBAAAIQgMBGCbCxvNGJI20IQOC2COiFhF1M6Mm7fn1R+QojO8OXMv4vcEwWL0LStUPYP45/4KqXGWZzl2I1VwX7ENtVQ7Zr/fXu6iqVcj0RfKR/+zPYHEs9Ul7hK7wtZiMPcQe6KlYwjDFDiEN8xG0uh5DmknhuPIvzXuNjY92Xt895oc9Z8pYxM0edY445SgeGgoh8tKze5+79MpIv9gmG+tKZi1E/ajzSOXkw8+8/pztZ3hKT91Fn7pijdGAoiMhHy9FxN5Iv9gmG+tKZi9Fxr8YjnZMHM95Hw7lbzGch7+pYWOizOIc182o5iC+fdZ33l/GRcu4cljk6EZ+FvHkfnYj3MZ8Ze94TzBFzpG/ng9Ym7P1/qn+PNF7z0EWcsA6kRVy90X/6wlpQYxqadnoUGvp+sacZ23vIG1rdl6mezM3bTtNy2yrmKm19KxU3q/lv3YvGzsWiUEIAAhCAwMYIsLG8sQkjXQhA4PYIhNPxtLGsFxR5U1k3l/NpezxpD5cbdv4uqKxtm9Dh2kQRhgsTMVRbjaOKsEKnyoWPfAGu9uNLA7s+m5gERUggdpjjiSyESzotzDkHiy5lYXXGRwfZjTeSa+wZnc9bzHJue33UNj0OGqt2IgNY4jPMYWY8Qx/tVvtO/WvqS3JgjiKz7jEXID7e8cgcCQF9ryiIMAHpGA5gki7J5477oY73kZIMgEfH95r3f/ZJnzVLPmeYozgV/jPaH/dDPuKWeccQh32uM0f538SDeBs3Zb7gM4g5Ek7CbPQ5M9St8dEp0flhjoa81xyPzNHKY7g5HqV52Ge0Osjjc/87qm8nPuvix4px4H2kB+bn+VzXw3HJe+IS5khz9Q/JSZZt0jO8scIRldeD1FYN8kP+4bTTjMBbdekZzJJtWPvJTlIxJy3tmVy9WXL3olBP7kEt9WhmxlbancrROLlMQiGAAAQgAIHtEGBjeTtzRaYQgMANEbDTbxtyuFtZGraxrPL6esA8pLSqOafSNpe1meNJPZzihzP73un9IFiKWS7SVNDzj4YTTRA0sfMFn4ZyupFcQ490Xh4uqmIe4dXrqn5Ua5lK/1ZV8SIfdT9h3j7WbA5VojeUN3Okh0V1zC09Ts52bDFHzJH7fPLH3egzdekxvOpzvXm/HJuDH8+j5s37iPcR76PqPGzV+5/3Ee8j3ke8j8K74Mqv6/is2/RnXTpEYyGbynquKf/rw+8fh43lKA7rOqoLn3DyUtZ2kqOdr+YAJnefiXnhw2Sp9OfKIYnUqS/MRWRmHm5uCDapr2RvW8va9PWkpoAABCAAgY0RYGN5YxNGuhCAwPUT8Kffvl5fTRQO8VzeLONfteoViD9Z792RbB4ayV0PlMC55i2jsJaYt5XZsVTEod4IL6pc80FDKBVIZSLPHmOd91Fzn5rXjeSP6aOxJzmo4MLHutW8PWsdw2jOvXyrY91q3sxRPDA9h73Ho062PLyPtr2f143kj+mjsSc5qECSmcjVOD1GOi9X09GYRvKlPmrn+wrxVHDhefucr32szNHlH4/MEXM0+iweyfWYGelG8qU+auc/I0O8DXyubzVvz5o5UgL1sa1tz+jY49vHavvyumP76eatHUjgUT9dHxXKw/toe5TfSL7UR+18XyHeheadx6RrOpqjPT2EtMojIjV5+GTrP4JQZPFuZg2kD/VPD9tg1mbeZNaGxk7xqwUb7cD0WsrDhTOXqBBVCqFG0cwba71anUru2cnCUEIAAhCAwIYIsLG8ockiVQhA4PoJtKffvu1Pu+10PcrSbxkHPHYRkk7dxSCewpu3lUtYWu9W1j5FajGtrO18a9aiBMzXNsF3JFflSDeSL/VRO5/ssfF8rKU5rPHZat63NFbmSAnU7y9tj95jI/lj+mhsf0x+jhx8/4xVCdTHiLY9I+ZIidSMPjcfzedz5+D7f0w+Wx3rVvNeM69bHetW82aOdObqz0Btj/6tGskvzUfz8XNL3krksuZV82GOagabnCNd7dF1nU/hAAvrOTKvZWs2TrJuPquJbi7rI2wq38UyCPyHTrWxrFp7A2ssd9DkzWWRBROnMxd192JfD07esNR9/tHFOWpMHhCAAAQgsCkCbCxvarpIFgIQuHYC5bS7nOoXWakZB/uN5XhKXvThK7P1bD/8n7Thz0hjPbzGqoXqlBbPyqlJ0fhgvl77jDViZ8F6Rvt0W/NRLDqmreW9bx50XKMxjeSX6qN5MUf735efc16ZIyXAHEUK532/ap+jY38kv1QfzYvPOt5Hehzo45zHgvY3er+M5Jfqo3mdk925+Fwqb2V9aG5qzxzxWRcOnDMfC9rn6D07kl+qj+bF++gM76O4sRzvLE4feOlYKTcNyEpQuGVZ0nEby3qs5b1hna/wsA9NK01upR2I1omU2dR0YmsyL3J1NYgmZmhl7IeNZeNNCQEIQOA6CLCxfB3zyCggAIErIeBPvet6amkRTt79Xcoq8tYORharkz2jvroGcC65mv+qNQcRla9Hy5KJj+jrOWJMvTSpQQACEIAABCAAAQhAAAIQgAAEIAABCAQCuuaSNpdt/cWWYWTXOG8uiyyI0wazLrbkzdtqOSbG663lpMUl6c8crNREfF3b9aN8/bXJ/cayJWw6l1vOcj5+8aQGAQhAAAKXSICN5UucFXKCAARuloA//a7r0gr/p21cOQe30/DhprJSzEH0L1rVI3rpX7Ga/xi2OAejHMQHrNzK5rKK1akfvS+tQtGAAAQgAAEIQAACEIAABCAAAQhAAAI3SEDXX2wNxu5eVomuuoTvuo6lkjGzUPcNEeRbl0UefldZv1pb5fklNMvaja3WWJnUnWK6qaxGthke661b3vSWBGIP+/tpY9CGAAQgAIHLIcDG8uXMBZlAAAIQCASay4F0rSAn6UEhFxPu/DtWWw8HsjrjF2trS9WFcQ5NdXLX8rivsrlska2MMetW0w9NCEAAAhCAAAQgAAEIQAACEIAABCBw8wR03SWuveh2bfxf14JkYzlszKbVlXZ5Ji4aiYlffUmxsk7hen3bbnWqrx+2rNRIpek3l4s2RrS4bCwXMtQgAAEIbJcAG8vbnTsyhwAErphAe33gLyrsdNxkiqHIPBST6t3KJo8y05h0WAZDc04XJENjVVhkK71s1hElBCAAAQhAAAIQgAAEIAABCEAAAhC4cQJxDca/RiC2zpI2Z22pZi8tv5ZjMXpOc7piP7exHNep2sRi3Ji19WFliUsNAhCAAAS2Q4CN5e3MFZlCAAI3TcBOzNtyDoqeqNtTquY659Lq8rm+OlsAK1tja2cnEbj+TU0JAQhAAAIQgAAEIAABCEAAAhCAAAQg0CVQr7pYy6+1yGqLibsRHk+4ZmM5Zu7Xh+qxPF62RIYABCAAgccgwMbyY1AlJgQgAIGTE7ArBiu1A1/vdWgn7emEfZ/5KESQm7OWVu85qMxfIFjdypEPcghAAAIQgAAEIAABCEAAAhCAAAQgAIF9qy5G6HNsLrOxbPQpIQABCNwuATaWb3fuGTkEILA5AnZp0Za9gdhGrpapbm4985HMwuTNZA2yL1B2SlF929dHnSKHAAQgAAEIQAACEIAABCAAAQhAAAK3S2DfyouROdvmclrOqfOyli+trqtRfg1I69a20kZBCQEIQAACWyLAxvKWZotcIQCB2yNQzsfd2EUYrhy6SrGzE/SmbMztr0xnL0IsRN5M1iAWyEpNLRs2ddXZw2ysNDklBCAAAQhAAAIQgAAEIAABCEAAAhCAwISAW3qxdZzWZnZdpzUetRcu1bh0JJK1Yvkkt9tOLHhbtna0IQABCEBgCwTYWN7CLJEjBCBwmwTs/HwyelEMN5btJF2drJ5KF6+9GBlehFiIcHFgAdrS99XWtW0PC2alySkhAAEIQAACEIAABCAAAQhAAAIQgAAEJgRsCUYU7VqOtx2u63ijufrCpZqSjtViGd1N5jvyga1upbejDgEIQAACWyHAxvJWZoo8IQCB2yPQOx8PFEQRzsFbA237k3OrWylqMRldiEwuQrKb9aOlr4dk0ks2lravq9q3fT25UkAAAhCAAAQgAAEIQAACEIAABCAAAQjUBGwJxqSypFKLrJW+dNqajZW5D8vJUs1EEFxz+BwoSor11CKaFot+OwekAgEIQAACGyDAxvIGJokUIQCBGyUwOh9XHNUu8MPgksFO3K2sOVr4vtZszUrLUp/6eMmSusWnhAAEIAABCEAAAhCAAAQgAAEIQAACEMgEbPklC1LFL7fkNZqoe8h/1F87Vy5tvNl28awj1k7V11/3DEsYcawadSBaEIAABCCwGQJsLG9mqkgUAhC4OQK9E3KD4M7F47Zyz9iMrDTnskVskqmFaiymL63eXg74CL26l1mvlBCAAAQgAAEIQAACEIAABCAAAQhAAAIVgbL0UonLvqwZWGnbu7r2YrJYrluNUa/iaRHrZLyF67Y10nYJ1dMigwAEIACBjRFgY3ljE0a6EIDADREYnbkrguqkXLeWe8beyNcjQ/OYaoyxWYxKS6ONYO22tLiUEIAABCAAAQhAAAIQgAAEIAABCEAAAl0CD7YO47S2xJJFxSbWvEHRqbnXZPfZSvGYi1SsJFhtOI1eGU/VSCAAAQhAYDsE2FjezlyRKQQgcGsE5k7KqxNyNYzGU5fKUOza9hxUi9aWcz6q0z6sHyuLZJ83eghAAAIQgAAEIAABCEAAAhCAAAQgcJsEbA1mbvTRprzGtZfas3w5tkUqKzQm6ZUWa2Rd5KUmcerOY2CVeSNf73WNDAIQgAAENkGAjeVNTBNJQgACN0mgd1JuIKqTcTWMxmMXc7DSAs2VFq0t53wsvpZWL/ZTSdFRgwAEIAABCEAAAhCAAAQgAAEIQAACt01A12BsHWZMIloUu1Krffw6jK/XVnVruiVteosQS2sFbZuAb3tDX7ewlBCAAAQgsCkCbCxvarpIFgIQuDkC/kQ8D16E1Yl4bVS3zMkcrDT5vtKiWan2vm7+Pq7WfdtsYjnW1Ha0IAABCEAAAhCAAAQgAAEIQAACEIDAbRHQNZfpustUolZFWmrTFRm/DuPrI65Hbyz7ZLQT36mvjxJADgEIQAACF02AjeWLnh6SgwAEIOAJtGfm+9r+bN3qUrZuvgtfDy7R2L96k7r+xIW2/qJF3aqvKeoYtCAAAQhAAAIQgAAEIAABCEAAAhCAwK0S0BUYv2Vcc/BLOr26X38ZrdJ4m7hI1ErqdsnA5LG0VtBbMlYWp3oRqHLyRtQhAAEIQGArBNhY3spMkScEIHDjBOzM3ErD0bZNbqWdsUsZTK1t+j1lNreLmn5/5a9Zs8MkcKtp2xMHBBCAAAQgAAEIQAACEIAABCAAAQhA4KYI6PpLvfZSt+LyTivziPx6y/zmso9SvMoaT4xarJ6km4+jbfEQOzUqhj4dNpZrGrQgAAEIbJ4AG8ubn0IGAAEIXD8BOzO3Ukfs63ME7DRfyuBi7Tkfp6vM7dKm7dsuUypjF6RUvYWvFwtqEIAABCAAAQhAAAIQgAAEIAABCEDgNgnElZey7lJq9UqQyr3OaNlaS11GS5Opbaz7CEXLxrLRpIQABCAAgR4BNpZ7VJBBAAIQuBgCdpJvpSbm6/sStQsDKYObtff5JX1lHvvt926by+O4PpSvjz3QQAACEIAABCAAAQhAAAIQgAAEIACB2yEwv7FcVlN0baa3PmMWsSxbxH7VxmwiVY3SSsZtu2dZfSurUUKtYeWkSh4QgAAEILA1Amwsb23GyBcCELghAnaJYKUO3deXoLAzdimDq7WX+IrNwHwui5HOQlm5MAPMIAABCEAAAhCAAAQgAAEIQAACEIDATRBYtrEct4l76y+25qKlWZlMF4ZKfYyztrIt6ejp/X09rDn1EtJuvKGvj1NAAwEIQAACF0yAjeULnhxSgwAEbp2AnpH7s3JfX8rGztilDO7WXug/Yz6XTU9noaxcmAFmEIAABCAAAQhAAAIQgAAEIAABCEDgRgjo1nJZVSm1uJpim74mt9LgqJWtu5Qt4WhlEcx2VFofUa9RLGKJrboilYZ20SajRvrwhr4etbxCAAIQgMDGCLCxvLEJI10IQOCWCPgzcl/vMejp27N1aWezVteJmU2ykzOKyp7GGU2qOeREgwACEIAABCAAAQhAAAIQgAAEIAABCNw6gXpjudAo28Qqs/UYK1Vmay5WRplZyPawVc3bG6pxeESh30zWyObauuS2GVhZh/OhTUMJAQhAAAIbJcDG8kYnjrQhAIHbIOD/SnU84nLWnk/oh8bewtdHDiX21KLvP/LoW0+jIoEABCAAAQhAAAIQgAAEIAABCEAAArdJQFdVyspKqdmqSiyLfErJLE0jGwCpaqVpUtk65C1qzaRWWoRaKlvPpmhC52brkBVUIAABCEBgawTYWN7ajJEvBCBwUwT2nZeXi41iuexcXa2WWGrcErvAN18ri4YaBCAAAQhAAAIQgAAEIAABCEAAAhCAwBoCy9Zheis11lu1UlMZSiNvMou1N/T1oCgCH8LXi8WejWVvaElSQgACEIDAZgmwsbzZqSNxCEDg2gn4k/X5sZplLJedry+ziv1afJ+F+VvpddQhAAEIQAACEIAABCAAAQhAAAIQgAAEDiegazDL1mHmrEK/rUHeVE6KdknniReUug/j68Ui7VF7pSVQxTycBh4QgAAEIHB5BNhYvrw5ISMIQAACgcDkfFykKvMn7gWVt/b1YjGtxUj9eGY9ipW8Hua9LUooDzCt/GhAAAIQgAAEIAABCEAAAhCAAAQgAIFrJpCXX7SSG27EtqhipVMtqeaQudLcZpzihqLuw3kMe5r3qLXDICggAAEIQGATBNhY3sQ0kSQEIHCLBNoTd9/un5KbhZXLqfXjzfmLR+jmQM8DzecyQAcBCEAAAhCAAAQgAAEIQAACEIAABDZPoFrG0UYlSMOzBRUrDxh1L5z2kX8Y2WKm0pqpi657033tYh5amsbKxpEmBCAAAQhsjgAby5ubMhKGAARuiYCdiuuYrT5/Km5WVu6nNR+v5588QhcHeh9o3usdGQQgAAEIQAACEIAABCAAAQhAAAIQuCoCeRnHKlbaKG1BxUqTLyjbUOqSN5VVaTFTac0UuueeVLmoXcyjEzt7UIEABCAAga0SYGN5qzNH3hCAwM0QsNPx5QNe7lGf+C/vIVqK99Kujuvo0MSwhwAEIAABCEAAAhCAAAQgAAEIQAAC2yIQ1ljmFlqOWFzxYXOYjjDranTestaUbela7j0GQWsHWhCAAAQgsBECbCxvZKJIEwIQuG0C/nTcSHBabiQoIQABCEAAAhCAAAQgAAEIQAACEIDAFRDoLQDZsNYsBM3Fs7haront/alDAAIQgMDNEGBj+WammoFCAAJbJ+CvBTjf3/pskj8EIAABCEAAAhCAAAQgAAEIQAACEOgQ8AtAXr1mMWgUy8fV+prYbQzaEIAABCBwEwTYWL6JaWaQEIDAtRDQ6wHO9a9lNhkHBCAAAQhAAAIQgAAEIAABCEAAAhDoEGg3hI9ZDGpjtd0dE7uNRRsCEIAABK6eABvLVz/FDBACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIDAcQTYWD6OH94QgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAErp4AG8tXP8UMEAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgMBxBNhYPo4f3hCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAASungAby1c/xQwQAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAwHEE2Fg+jh/eEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABK6eABvLVz/FDBACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIDAcQTYWD6OH94QgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAErp4AG8tXP8UMEAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgMBxBNhYPo4f3hCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAASungAby1c/xQwQAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAwHEE2Fg+jh/eEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABK6eABvLVz/FDBACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIDAcQTYWD6OH94QgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAErp4AG8tXP8UMEAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgMBxBNhYPo4f3hCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAASungAby1c/xQwQAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAwHEE2Fg+jh/eEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABK6eABvLVz/FDBACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIDAcQTYWD6OH94QgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAErp4AG8tXP8UMEAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgMBxBNhYPo4f3hCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAASungAby1c/xQwQAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAwHEE2Fg+jh/eEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABK6ewP8DqLYFreMn2F4AAAAASUVORK5CYII=" alt="Screen%20Shot%202019-11-13%20at%203.20.56%20PM.png"></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Local---Model-Based">Local - Model Based<a class="anchor-link" href="#Local---Model-Based">&#182;</a></h1><ul>
<li>Explain an individual data point</li>
<li>Look at two approaches widely accepted as interpretable:<ul>
<li>Linear Regression</li>
<li>Decision Tree</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Linear-Regression">Linear Regression<a class="anchor-link" href="#Linear-Regression">&#182;</a></h2><ul>
<li>Statsmodel Output</li>
<li>How does a change in 1 unit of X affect Y</li>
<li>Coefficients are a measure of importance<ul>
<li>Large = More important</li>
<li>Coefficient +- Std Error around 0 are insignificant</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[40]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">local</span> <span class="o">=</span> <span class="n">ols</span><span class="p">(</span><span class="s1">&#39;TARGET ~ PTRATIO + NOX + RM + LSTAT + DIS &#39;</span><span class="p">,</span> <span class="n">bostonDF</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">local</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                 TARGET   R-squared:                       0.708
Model:                            OLS   Adj. R-squared:                  0.705
Method:                 Least Squares   F-statistic:                     242.6
Date:                Mon, 11 Nov 2019   Prob (F-statistic):          3.67e-131
Time:                        17:47:47   Log-Likelihood:                -1528.7
No. Observations:                 506   AIC:                             3069.
Df Residuals:                     500   BIC:                             3095.
Df Model:                           5                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
Intercept     37.4992      4.613      8.129      0.000      28.436      46.562
PTRATIO       -1.0458      0.114     -9.212      0.000      -1.269      -0.823
NOX          -17.9966      3.261     -5.519      0.000     -24.403     -11.590
RM             4.1633      0.412     10.104      0.000       3.354       4.973
LSTAT         -0.5811      0.048    -12.122      0.000      -0.675      -0.487
DIS           -1.1847      0.168     -7.034      0.000      -1.516      -0.854
==============================================================================
Omnibus:                      187.456   Durbin-Watson:                   0.971
Prob(Omnibus):                  0.000   Jarque-Bera (JB):              885.498
Skew:                           1.584   Prob(JB):                    5.21e-193
Kurtosis:                       8.654   Cond. No.                         545.
==============================================================================

Warnings:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Decision-Tree">Decision Tree<a class="anchor-link" href="#Decision-Tree">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[181]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dtree</span> <span class="o">=</span> <span class="n">DecisionTreeRegressor</span><span class="p">(</span><span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;mse&#39;</span><span class="p">,</span>     <span class="c1"># Initialize and fit regressor</span>
                             <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>         
<span class="n">dtree</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[181]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>DecisionTreeRegressor(criterion=&#39;mse&#39;, max_depth=3, max_features=None,
                      max_leaf_nodes=None, min_impurity_decrease=0.0,
                      min_impurity_split=None, min_samples_leaf=1,
                      min_samples_split=2, min_weight_fraction_leaf=0.0,
                      presort=False, random_state=None, splitter=&#39;best&#39;)</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[191]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">dot_data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">export_graphviz</span><span class="p">(</span><span class="n">dtree</span><span class="p">,</span> <span class="n">out_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="n">X_train</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">class_names</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">dot_data</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span>
<span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">pipe</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt output_prompt">Out[191]:</div>




<div class="output_png output_subarea output_execute_result">
<img src="data:image/png;base64,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4BMEmGjdJ26jw0WcOHFCkNA/bty4sn79ekmXLp3DdiwkARIgARIgARIggSAQmBUxCI3ZlARIgARIgARIgASCTACJ1rHj4IgRI2x2ggvyQOzgkQRy5col+/bt0137ChcuLEePHvXIeXJSJEACJEACJEAC3kWAIYHedb84WxIgARIgARLwKgJMtO5VtytEk338+LHUqVNH9u7dK0uWLJEKFSqEaDx2JgESIAESIAESCNcE6GEVrm8/F08CJEACJEAC75mAkWh94sSJ7/lKHD6sCSAkcN26dVK7dm2pWrWqzJgxI6ynxOuTAAmQAAmQAAl4MQHuEujFN49TJwESIAESIAFPJoBE63369JHOnTtLjhw5PHmqnJubCESJEkWwYyDyWLVp00YuX74s3333nZtG5zAkQAIkQAIkQALhiQAFq/B0t7lWEiABEiABEghFAl9//bVEixZNBg4cGIpX5aU8gcCgQYNUtGrXrp2KVshhBjGLRgIkQAIkQAIkQAKBJUDBKrCk2I4ESIAESIAESCDQBJBoHSFh8+fPZ6L1QFPzrYYtW7aUVKlSSd26deXGjRuybNkyiRcvnm8tkqshARIgARIgARJ4bwSYdP29oeXAJEACJEACJOD7BFatWqWeNLlz57YulonWrSh4YCFw7NgxqVy5siRKlEjWr18vqVOnJhcSIAESIAESIAESCIgAk64HRIj1JEACJEACJEACzgnMnj1b8ubNKx07dpSHDx9qQyZad84rPNZAzNy3b59AyCxUqJAcP37cKYZHjx45rWMFCZAACZAACZBA+CIQMXwtl6slARIgARIgARJwJwEIEX5+fjJ16lTJmDGjTJgwQZC7ionW3UnZ+8dKkyaN7N69W7JkySLFixeXjRs3+lsUxKpixYrJ1q1b/dWxgARIgARIgARIIPwRoGAV/u45V0wCJEACJEACbiFw+/ZtwQf25s0befDggQpVUaNGlVq1arnlGhzEdwggf9Wvv/4qVatW1RBB7CZo2OvXr6V69epy8uRJ6dSpk3pjGXX8JgESIAESIAESCJ8EKFiFz/vOVZMACZAACZBAiAkgsbq9wdvq3r176kVjDhO0b8fz8EkAYua8efOkZ8+e0qJFC8FugjAc79q1S49Pnz4tZjFLC/mDBEiABEiABEgg3BFg0vVwd8u5YBIgARIgARJwD4EBAwbIsGHD5NWr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AREQgQSB0bKwShDRRxEQAREQgdohEIIKJ5U+gQDWBEFZxTYURA1VVoW6wysTR+LcFCutW7fOeEi+a8p4UAM2NkYA5latWjWgRTq0ORPI9/uOK6vgUAplVZLnqquumtyU9zMKWKwIM0m+a8p0TH23wWPNNdcs6HDGpuD+WNABKiQCIiACIiACJSagoOslBqrqREAEREAERCAfASwXkGRg43zHab8IiEB5CNBnsYQKsbLK0wqdVQREQAREQARqi4AUVrX1fetqRUAEREAEykyAWFnEu0KIAUUcLNyMJCIgApVJ4M477/Qx5nAJPu200+z111+vzIaqVSIgAiIgAiLQzAjIJbCZfaG6HBEQAREQgcomgLsbwaD5CxIPeBy26VUERKAyCJAFkADtQRrDzTDUrVcREAEREAEREIH/EZDC6n8s9E4EREAEREAEGp0AMbBKHQer0RutE4hADRMgwLpEBERABERABESg6QlIYdX0zHVGERABERCBZkCAbIHPPfecjR071rbbbjvbeeedq+aq/v73v9sOO+xgiy66aJ02z5kzx9hPJrH111/ftt9+e1t88cXrlItveOWVV2z69OnxTan3Xbt2TQsq/+KLL3r3KqzK4NalS5dU2fBm0qRJ9uyzz9oCCyxgvXv39hkUwz69ikAhBKqxfz711FM2btw4n0G0T58+dbL4FdPPkozy9WuyGD744IPJw/xnEk/stttuqX2Mey+88ILPNLj11lv7cSK1U29EQAREQAREoIQEpLAqIUxVJQIiIAIiUDsE3nrrLRszZoyNGDEia/avSqPxyCOP+PhZr776qn311Vd1FFbE5jnggANs5MiRxoT52muvtXPOOcceffRRP4nOdD3E9enbt6/NmDEj027jXCEL4nHHHWe33nqrYbGCQmzw4MF28cUX26mnnpo69sQTT7TPP//cb//Pf/7j93EOWJOlUSIChRCotv45dOhQu+OOO2yzzTYzYmbRJx566KGUK2Ix/SzJp5B+fd9999mBBx6YPNR/3nXXXVMKq6OPPtpQbuHSTB/u1auXDRgwwNguEQEREAEREIFSE1DQ9VITVX0iIAIiIAI1QaBTp0521FFHVc21Mrlcb731rF27dhnb/Ntvv9nBBx/sLcWwiiKlPZNmrLAOOuigjMew8YknnvCT6g8++MB+/vnn1N/48eO9ZRSckPvvv9/m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YPv1kVron7jCMmZgZcm4lksK6Wfx/llMv8YK68MPPzRiaCWFxBO0kVhyDR2viM2FOzYB4SUiIAIiIAIikIXAaCmsspDRZhEQAREQgcohgIsL8aRwVWnXrp0NGjTIu9ldcsklPuNe5bRULalEAlJYlfdbaajCqryt19kbgwDKfNyHDz/8cDvzzDO9oq4xzqM6RUAEREAEqprA6N9TFVX1NajxIiACIiACzZXAP//5T3PudN7qZ+rUqd6y6u2337YDDjjAQra95nrtui4REAERaK4EGL932203Hztw9dVXt7POOsu+/fbb5nq5ui4REAEREIF6EpDCqp7gdJgIiIAIiEDjEXBxUmyXXXaxjTbayGeHc3GgfNBzsoZJUdV43FWzCIiACDQFAdweXRxCc7Gy7IwzzjAXz8pQXLk4e94VuCnaoHOIgAiIgAhUPgEprCr/O1ILRUAERKBmCEyYMMFninNBy73L3yOPPGKTJ082FxQ9b1yXmoGkCxUBERCBZkKAWFhkGySWHxlbUV7h9k2WVZeEoplcpS5DBERABESgvgSksKovOR0nAiIgAiJQMgJPPPGEde/e3bbccku/uv74448bqdt33nnnkp1DFYmACIiACFQmgRYtWtjFF1/sLa523HFHc9kSvSs4AeMlIiACIiACtUtACqva/e515SIgAiJQdgLjxo2zTTfd1LbbbjtbaKGFzKVy9389evQoe9vUABEQAREQgaYl0KpVK7vxxhuNmIUdOnTwMQyxuH3mmWeatiE6mwiIgAiIQEUQkMKqIr4GNUIEREAEaodAFEXGqjmp0Xv27GktW7a0iRMnGlZVWFhJREAEREAEapvAmmuuaffee693CV9qqaVs6623NiyvXnvttdoGo6sXAREQgRojsGCNXa8uVwREQAREoEwEfvvtN58R6vzzz7cpU6b4uFQjRoywTp061btFs2fPVmyretPTgSLQdAQIrk2gbYkIFEOA+8Njjz1mTz31lA0cONAn4th7772N+8gaa6xRTFUqKwIiIAIiUIUE5nMr3VEVtltNFgEREAERqBICBM6966677MILL7Rp06bZn//8ZzvzzDO9u0dDLoEJsFbb0wl+8MEHdtppp/mMWyuuuGL6zhr/tPHGG1ubNm1qnEJ5Lv/dd9+1t956qzwnr6Czqn+mfxkdO3YsWulExlgCszP+H3bYYTZkyBBbaaWV0ivWJxEQAREQgeZCYLQUVs3lq9R1iIAIiECFEZg3b57ddtttdtFFF9mHH35o++67rw0aNMjWWmutCmtp82kOCjwsEt5///2iJ4LNh4KuRAQqk4D6Z2m+FxZBbr31Vjv77LN9Ntljjz3WK+qXXnrp0pxAtYiACIiACFQKgdGKYVUpX4XaIQIiIALNhMDPP/9sw4cPN2KQ9O/f38ceee+99/wEQ8qqZvIl6zJEQAREoEwEFlhgAevXr5+32D333HNt5MiR1rZtWxs6dKj9+OOPZWqVTisCIiACItAYBKSwagyqqlMEREAEapAAE4WrrrrKTxxOOOEEH1Adt40wmahBJLpkERABERCBRiKw6KKL2kknnWQzZ860o446ys477zxvWUpsxF9++aWRzqpqRUAEREAEmpKAFFZNSVvnEgEREIFmSOC7776zSy65xMcHwuWPgLhMIK677jpbbbXVmuEV65JEQAREQAQqhcCSSy7plVUzZsywXr162dFHH23t27e3MWPGmEL1Vsq3pHaIgAiIQP0ISGFVP246SgREQARqnsDcuXN9piYCWbOyfchhgXq0AABAAElEQVQhhxhBha+44gpr1apVzfMRABEQAREQgaYjsMIKK9g111xjuKB36dLF+vbta507d7bx48c3XSN0JhEQAREQgZISkMKqpDhVmQiIgAg0fwJfffWVz8zUunVrGzZsmA0YMMAHVb/44ott+eWXb/4AdIUiIAIiIAIVS+BPf/qT3XHHHT6LLBkEd9hhB9t2223t5Zdfrtg2q2EiIAIiIAKZCUhhlZmLtoqACIiACCQIfP7553b66acbiqrrr7/eTj75ZK+oIujtMssskyitjyIgAiIgAiJQPgLrr7++jR071iZMmGAkA9lkk02sd+/e9u6775avUTqzCIiACIhAUQSksCoKlwqLgAiIQO0R+PTTT40g6qxa33zzzTZ48GCbNWuWnXnmmbbUUkvVHhBdsQiIgAiIQNUQ6Natmz3//PP28MMP2/vvv28dOnSwQw891D766KOquQY1VAREQARqlYAUVrX6zeu6RUAERCAPgX/9618+8xLpwglee+GFF3pF1amnnmqLL754nqO1WwREQAREQAQqh8Auu+xir7/+ul94eeqpp6xdu3beUnjOnDmV00i1RAREQAREII2AFFZpOPRBBERABESADH+HH364Tw+OOwVB1Nl23HHH2WKLLSZAIiACIiACIlCVBOaff3474IADfGB2stvefvvtxqLM+eefb99//31VXpMaLQIiIALNmYAUVs3529W1iYAIiEARBMisdNBBB9laa61lTz/9tA0fPtymT59u/fv3t0UWWaSImlRUBERABERABCqXwMILL2zHHHOMzZgxw0466SS79NJLbfXVV7drr73W5s2bV7kNV8tEQAREoMYISGFVY1+4LlcEREAEkgSmTJni03+3b9/eZ1EaPXq0X30mxsdCCy2ULK7PIiACIiACItAsCODePmTIEK+42nfffb2LIIs2d955p/3222/N4hp1ESIgAiJQzQSksKrmb09tFwEREIEGEHjttdesV69eRialt99+2+6++27/irvEAgss0ICadagIiIAIiIAIVA+BZZdd1i6//HKbNm2ade/e3Vsbd+zY0R555JHquQi1VAREQASaIQEprJrhl6pLEgEREIFcBCZNmmQEn+3UqZMRWP3++++3N954w/bee28jvodEBERABERABGqRwGqrrWZYGb/11lveRZB75RZbbGEvvPBCLeLQNYuACIhA2QloZlL2r0ANEAEREIGmITBhwgTbfvvtrWvXrkZWJFaOJ0+ebHvssYfNN998TdMInUUEREAEREAEKpzAOuus4xdzJk6caAsuuKB169bNdt11V6/IqvCmq3kiIAIi0KwISGHVrL5OXYwIiIAI1CXwxBNPeBeHLbfc0n7++Wd7/PHH7aWXXrKdd965bmFtEQEREAEREAER8AQ22WQTn4Tk0UcftU8++cQ23HBDO/DAA23WrFkiJAIiIAIi0AQEpLBqAsg6hQiIgAiUg8C4ceNs0003te22287IiPTcc8/Zs88+az169ChHc3ROERABERABEahKAjvssIO9+uqrdtddd/kFHwKzH3vssfb5559X5fWo0SIgAiJQLQSksKqWb0rtFAEREIECCERRZA8++KB17tzZevbsaS1btjRcGsaPH+/jcBRQhYqIgAiIgAiIgAgkCOA6v88++9g777xjV111ld13330+ztVZZ51l3377baK0PoqACIiACJSCgBRWpaCoOkRABESgzARIvz1mzBjbYIMNfOY/AseyGjx27FjDpUEiAiIgAiIgAiLQcALEtDryyCNt+vTpdsYZZ9jVV1/tFVdXXHGFd7tv+BlUgwiIgAiIQCAghVUgoVcREAERqEICv/76q91+++227rrrWt++fa19+/b25ptv+mCxZAGUiIAIiIAIiIAIlJ7AH/7wBzv99NNt5syZduihh3rlVbt27ezmm2827s0SERABERCBhhOQwqrhDFWDCIiACDQ5gXnz5tmoUaOMOBr9+vWzLl262NSpU+2ee+6xDh06NHl7dEIREAEREAERqEUCLVq0sIsvvthbXO244452xBFH2HrrrWcPPPBALeLQNYuACIhASQlIYVVSnKpMBERABBqXAFn+hg8fbmuuuab179/ftt56a3vvvffs1ltv9cqrxj27ahcBERABERABEchEoFWrVnbjjTf6xSMUVr1797auXbvaM888k6m4tomACIiACBRAQAqrAiCpiAiIgAiUm8CPP/7og7y2bdvWTjjhBB9QnfgZI0eONLZJREAEREAEREAEyk+ABaV7773XJk+ebEsttZRfWMLy6rXXXit/49QCERABEagyAlJYVdkXpuaKgAjUFoHvvvvOLrnkEmvTpo0NGjTI9t57bx8v47rrrjMCq0tEQAREQAREQAQqjwBxJB977DF78skn7euvv7aNNtrI+vTp410HK6+1apEIiIAIVCYBKawq83tRq0RABGqcwNy5c+3888/3iqrzzjvPDjnkEPvggw+MLES4HUhEQAREQAREQAQqn8A222xjkyZNsvvuu8/eeOMNW2eddbxL/+zZsyu/8WqhCIiACJSZgBRWZf4CdHoREAERiBP46quvbMiQIda6dWsbNmyYDRgwwD788EMf0HX55ZePF9V7ERABERABERCBKiHQq1cvmzJlio9z9cgjj9gaa6xhAwcOtG+++aZKrkDNFAEREIGmJyCFVdMz1xlFQAREoA6Bzz//3KfHRlF1/fXX28knn+wVVeeee64ts8wydcprgwiIgAiIgAiIQHURWGCBBXxm32nTphn39xCHcujQoUasSokIiIAIiEA6ASms0nnokwiIgAg0KQFcAk488UT705/+ZDfffLMNHjzYZs2aZWeeeaYP1tqkjdHJREAEREAEREAEGp3AoosuaieddJKPSXnUUUcZrv9YXI0YMcJ++eWXRj+/TiACIiAC1UJACqtq+abUThEQgWZF4F//+pfxkIqiimxCF154oVdUnXrqqbb44os3q2vVxYiACIiACIiACNQlsOSSS3pl1YwZMwyXwaOPPtrat29vY8aMsSiK6h6gLSIgAiJQYwSksKqxL1yXKwIiUF4CM2fOtMMPP9yvpI4dO9YHUWfbcccdZ4sttlh5G6ezi4AIiIAIiIAINDmBFVZYwa655hp77733rEuXLta3b1/r3LmzjR8/vsnbohOKgAiIQCURkMKqkr4NtUUERKDZEuAh9KCDDrJ27drZ008/bcOHD/eprfv372+LLLJIs71uXZgIiIAIiIAIiEBhBLC6vuOOO+y1116zlVZayXbYYQfbdttt7eWXXy6sApUSAREQgWZGQAqrZvaF6nJEQAQqiwAZgfr06eNN/HngJE4VyqtDDz3UFlpoocpqrFojAiIgAiIgAiJQdgLrr7++YYU9YcIE+/nnn22TTTax3r1727vvvlv2tqkBIiACItCUBBZsypPpXCIgAiJQKwRYHSWI6oMPPmgdOnSwu+++2/baay+bf36tE9TKb6Cxr/P//u//7IILLkiLc0K2yT/+8Y/etWTppZdONYHMVATy1+8vhURvRKBRCah/Niremqm8W7du9vzzz3vl1aBBg/zzBNbaZ599tq266qo1w0EXKgIiULsE5nMB/RTRr3a/f125CIhAiQlMmjTJK6oeeeQR22ijjbySYPfdd7f55puvxGdSdSJgPtbJ5MmTc1rrzZs3z7bZZht74oknhEwERKAJCRCLSP2zCYE381P99ttvduedd9qQIUPss88+84lbBg4caC1btmzmV67LEwERqGECo7XUX8Pfvi5dBESgdAQw299+++2ta9euNmfOHENhxURljz32kLKqdJhVU4LAAQcc4K2msObI9oeydP/9908cqY8iIAKNTUD9s7EJ11b9WMjymyKswCWXXGK33367tW3b1s4//3z7/vvvawuGrlYERKBmCMjCqma+al2oCIhAYxDAaoWHxWeffda23HJLGzx4sPXo0aMxTqU6RaAOgX//+98+MG8uY+kFF1zQvvzyS1tqqaXqHK8NIiACjUdA/bPx2Kpms++++85nGh42bJjPMozb91/+8pecFrfiJgIiIAJVRkAWVlX2ham5IiACFUJg3Lhxttlmm9l2221nCy+8sD333HNeaSVlVYV8QTXSDFKhd+/ePWtsKmJX9ezZU8qqGvk96DIri4D6Z2V9H82tNYsvvrhfJJsxY4btu+++dvLJJ9taa63l3QZxH5SI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27vvvmvvvfeeTZ061d5++23DWv23337zl8vzFO+DBRavxLOSiIAIiEBjE5DCqrEJq34REIGSECCbH26AX3zxRZqyKlTOg9Ruu+1mf/3rX71Ze9iuVxEQAREQAREQAREQgcwEyBTIYiB/cWExkBAMKLH4Q6H11ltvGQlv5s6dayRUQFBwde7cOX6o3ouACIhAyQhIYVUylKpIBESgsQh89NFHXllFDJps2WtY7XviiSfshx9+sCWWWKKxmqJ6RUAEREAEREAERKDZE1hwwQVtrbXW8n/JiyWG6OjRo41kCgRr79Spk80/vyLNJDnpswiIQMMJaGRpOEPVIAIi0IgEPv74Y7/q99lnn2VVVoXTo6y67rrrwke9ioAIiIAIiIAIiIAIlJgAQdfXWWcdX2v//v2lrCoxX1UnAiLwPwKysPofC72rUgJff/21ka48KUsttZTPlLXmmmvakksumdxtpFT+5JNP0rYvvfTSttNOO6W2vf766/b3v//dvvvuO9too41s2223tccee8z233//VJlKeIMyB1Pt7t27F9Scb775xkaNGuXjE/Ts2dNf1wILLJA69scff7QHH3ww9Tn+hqwwuN4FyVdXKFef19mzZ9see+xhvGazrIrXi5XV0KFD7dhjj1XGmjgYvU8jgMUewWIJMsuKMGMEGQfnm28+Q0G6+uqr2zPPPJN2DB9WXHFFv9LcqlWrOvuyjSe4SWD5F6R9+/a2wQYbhI91XulP//jHP1Lb27Zta5tssknqc7neEMvkhRdeSJ2e/oglI/0zkxQzhoTjOYbx9tNPP7V27drZLrvsEnYZSRbYRzvWX39923777W3xxRdP7deb5kNg/Pjx/vvmisge3LFjx7SLS/YRdu64446GW1MQyjz99NPefenbb7+1Dh062GabbeZ/V6EMr5MnT7b3338/vsm/33vvvb1rOffV1157LbWf8WKfffZJfS7XG5KP8NxD5tudd97Zll9++aKakquvUdEjjzxicAvCmHn00Uen3VcZ8xgTyA639dZb+34ZyutVBAohUOp7cbb5AOEk6OdY6SPc68kwHH/uTbaXbNU8DwQhw2m5MyH+5z//sbvuusvo/yQXIvB9vja98sorNn369HAZaa9du3a1P/3pT2nbwocxY8b4mLBdunQJm/zriy++aIzRxDTbbrvtLLk/rbA+iECpCLhMDxIR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JmOtE1UTgfiNl4w9KNRKKSiLmlLiyirOu/TSSxd0euJR5FJWFVNXQSdUIRFoIgJM4ogB1ZylVOMMCoFsSoE4v+Q4w75CxhDK0VZn6cLbOuKs2eps0wYRgECu3yWLSyGAfyXQKlV/DNfirEfC24yv2dLd5+prxMlac801M9YXNqL8KybTcjhOryKQiUBzvxeXut9nYpjcluleTDw9iQhUKwEFXa/Wb07tFgEREAEREAEREAEREAEREAEREAEREIFmSkAKq2b6xeqyREAEREAEREAEREAEREAEREAEREAERKBaCUhhVa3fnNotAiIgAiIgAiIgAiIgAiIgAiIgAiIgAs2UgBRWzfSL1WWJgAiIgAiIgAiIgAiIgAiIgAiIgAiIQLUSUND1av3m1O5mTcClzba77rrLyOpBIGKXcjdjNh6y+bzwwgspFi5ttS2xxBKWL0jxc889548juLxLX+0zcKUqib0hA8y3336b2kLmEZfaPtUWshCNGTPGZs2aZV27djWXgtxnXUsdoDciIAJlJ/D3v//ddthhB8uU4a++fbjQMYqLJ9snmVa7d++ekcVTTz1l48aNs5VWWslc6uys2ckyHqyNIlClBAr53ZO179lnn7XXX3/dunXr5u+z88+fe635lVdesenTp2ekwn06BF8utu5c40jGk2mjCIiAz1I6atQon32zZ8+etu2229oCCyxQh0yhz+XhwB9//NHIvJpJSHay22671dmV714cDiAr8IgRI2zgwIFhk15FoLwEXNpfiQiUncCGG24YuYGx7O2ohAa4iV204oorRi5TT+Syi0RuhIhcpqNo9uzZdZrnJnd+P2X4c1mRIpdyuk65+Iajjjoq6tevX+TSzfuyLttPdM0118SL+PfUQ32hbl45XxDa6ZRpkVNqRW7yGjkFW7TaaqtF7uE6FKn3q7tx+/O6m2u969CBzZuAy94Z3XLLLc37Iht4dWPHjo022mgj35e++uqrOrXVtw8XOkZ9/vnn0UknnRTxXR177LF1zs+Giy++OOrQoUN0xBFH+HHPTcYj2t0Ywjjnsso1RtWqMwcBl9bd/wbd5CpHqdraVcjv/t///nfklEvRyJEjoy+++CI65ZRTIjfhjX799dessH777Tf/vBC/b8ffv/rqq/7YYurON45kbUyeHbfffnvkshLmKaXdlUyA3wa/L54nJXUJOMWP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MpeNGjXKZwPu2bOnbbvttkYA9rgUUiZeXu9FoFYIkPn0ueees7Fjx9p2221nO++8c8Ve+osvvmjjx4+3hRZayLe1S5cuGdvKfOXbb79N7fvoo4/s6KOPzjofSBXUGxFoAgJ6CmwCyDpF7REg9ewLL7xg559/vj366KMVC+C9997zCqXLLrvMrrjiCjv88MNt/fXXNyaecfniiy/s5JNPtrZt29oDDzwQ31Xn/YMPPugnmSitjj/+eCmr6hDSBhHIT6BaxhCupJDxYejQoXbccccZCvJhw4b5jKw8IMfl888/9xlHmfT369fPGEt22203++233+LF9F4EKpJAtfTZr776yjp37mxvvPGGTZkyxXbaaSfbbLPN0pgWUibtAH0QgRoi8NZbb9mYMWPsyiuv9AuzlXrp3HNRpt1888125pln+mfzSy65pE5zWYjedddd/YI1i9b8vfbaa1JW1SGlDeUiIIVVucjrvM2aAKln+/bta5tssklFX+cJJ5xgjz32mE2bNs0+/vhjO+yww2zGjBl2xhlnpLV71qxZduCBBxpKqFxyyimn+BvdHXfcYYcccogsI3LB0j4RyEGgWsYQLiHf+DBz5kxr06aN8ZB/44032vvvv29LLLGEf9gPCFBK9e7d29Zbbz0/Di277LJ20UUX+Qn1oEGDQjG9ikDFEqiWPstE++WXX7bbbrvNnnzySTv77LP9ZxbZghRSJpTVqwjUGoFOnTrZUUcdVdGXff/99/tn8Dlz5vh79BNPPGEtWrTwz/fck+Ny+eWXGxbQH374of9j0Qgll0QEKoWAFFaV8k2oHc2SwIILLmjzzTdfRV4bror77beft6iigcstt5yde+65/gaHCXFcNt54Y1t77bXjm+q8xxoCy4mrrrrKTzrrFNAGERCBoglU8hgSLibf+ID7xD777BOKGxP7Pffc05ZccsnUNtwrnn/+eW/lGTbionTQQQfZtddea99//33YrFcRqGgCldxn/+///s922GEHW2aZZVIMWYxCQn8spEzqYL0RgRolQD9HKvUZ/6WXXvLP5NxHaSNuv9yHf/nlF3vllVdS3xoeFW+++aYPCbLaaqt56+dVV13VFl100VQZvRGBchNQDKtyfwM6f4MIRFGUinfCoIxSBX/yIFgOTZw40Q/Gm2++uZ8khX28vvPOO979bauttrJ//OMfhovcn//8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z8dGwHXXXefG2eIp9YkioAgoAm0RmGiiiUz//v3dGDJo0CDTs2dP8/3337dNqDG5RkAFVrnu/uob//vvv5s999zT7LzzzubAAw80d999t7qIrx5WLUERUARqgMAll1zi7Omde+65zn5VDYrMZREs2D/44APnPCOXAGijc4nAo48+aj7//HOj9qtKd//6669vzjzzTKclMWrUqNKJ9akioAgoAjEIbL311u6III4cVlttNfP+++/HpNKovCKgAqu89nwN2j1+/Hiz9tprm2uvvdbtvp966qlm4omVpGoArRahCCgCVSKAmvnee+/t3K/vt99+VZaW7+wrrLCCOxKlxwLzTQd5az1ahYsvvrjTHM9b29O294ADDnAbl9ttt5159dVX02bX9IqAIqAIOM/yzzzzjJlsssmcrVG8CWpQBEBApQtKBxUh8PDDD7tjf999953z9NCrV6+KytFMioAioAjUGgG8AOIREK3PY489ttbF57I8xng9FpjLrs9lo/GKCb3rccDk3Y+THbx/caQHBzwaFAFFQBFIi0DHjh0NgqrVV1/d2RwdMmRI2iI0fQsioAKrFuzUejcJd8Z4dcBm1dNPP20WWWSRer9Sy1cEFAFFIBECjzzyiOndu7fZfvvtzRlnnJEojyYqjwDHojCuPHbs2PKJNYUikHEE2OX/+OOP9Thgin5EK8JrYTJe/PHHHylya1JFQBFQBP5BYJpppnEbBgcffLDp16+fOfLIIw02BTXkFwEVWOW371O3/OeffzbbbLONOeyww8zJJ5/sGJPpppsudTmaQRFQBBSBeiCA7YMePXqY7t27OxfJGPPUUBsEsCnRoUMH1bKqDZxaSpMjgHbV/PPPb5Zeeukmr2lzVW/WWWc1I0eONC+++KI7kt1ctdPaKAKKQFYQgH/D1AwaVihKoO36008/ZaX6Ws8aI6ACqxoD2qrFvfPOO2aVVVYx9913nzOsfsQRR7RqU7VdioAikEEE0P7ZYIMN3Dg1bNgwM8kkk2SwFc1bZewTbrbZZoEGRfPWVGumCFSPAJpCehywMhyXWGIJwxh8xRVXGBxeaFAEFAFFoFIEMO/w4IMPmieeeMKd7KP7LTwAAEAASURBVPnoo48qLUrzZRgBFVhluPMaVfU77rjDrLjiimbyySc3zz//vDsO2Kh363sUAUVAESiHwLhx40y3bt3MQgst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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Global---Model-Based">Global - Model Based<a class="anchor-link" href="#Global---Model-Based">&#182;</a></h1><ul>
<li>XGBoost Model</li>
<li>Tree Importance</li>
<li>What are the most important features in predicting an output?</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Train-&amp;-Test">Train &amp; Test<a class="anchor-link" href="#Train-&amp;-Test">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">bostonDF</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;TARGET&#39;</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;TARGET&#39;</span><span class="p">])</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">888</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Learn">Learn<a class="anchor-link" href="#Learn">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[19]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">boost</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">XGBRegressor</span><span class="p">(</span><span class="n">objective</span> <span class="o">=</span><span class="s1">&#39;reg:linear&#39;</span><span class="p">,</span> 
                          <span class="n">colsample_bytree</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> 
                          <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                          <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
                          <span class="n">alpha</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> 
                          <span class="n">n_estimators</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[20]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">boost</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">preds</span> <span class="o">=</span> <span class="n">boost</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stderr output_text">
<pre>/Users/wilsons/anaconda3/envs/pyjup/lib/python3.6/site-packages/xgboost/core.py:587: FutureWarning: Series.base is deprecated and will be removed in a future version
  if getattr(data, &#39;base&#39;, None) is not None and \
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Predict">Predict<a class="anchor-link" href="#Predict">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[21]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">preds</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RMSE: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>RMSE: 10.263212
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Interpret">Interpret<a class="anchor-link" href="#Interpret">&#182;</a></h2><ul>
<li>Global Importance</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[32]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">xgb</span><span class="o">.</span><span class="n">plot_importance</span><span class="p">(</span><span class="n">xg_reg</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_text output_subarea ">
<pre>&lt;Figure size 720x576 with 0 Axes&gt;</pre>
</div>

</div>

<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Model-Agnostic-Frameworks">Model Agnostic Frameworks<a class="anchor-link" href="#Model-Agnostic-Frameworks">&#182;</a></h1><h2 id="Shap">Shap<a class="anchor-link" href="#Shap">&#182;</a></h2><ul>
<li>Shap values consider all possible predictions for an instance using all possible combinations of inputs. </li>
<li>Exhaustive which can guarantee consistency and local accuracy.</li>
<li>Exhaustive comes at a computational cost.</li>
<li><a href="http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions.pdf">http://papers.nips.cc/paper/7062-a-unified-approach-to-interpreting-model-predictions.pdf</a></li>
<li><a href="https://towardsdatascience.com/how-to-avoid-the-machine-learning-blackbox-with-shap-da567fc64a8b">https://towardsdatascience.com/how-to-avoid-the-machine-learning-blackbox-with-shap-da567fc64a8b</a></li>
<li><a href="https://github.com/slundberg/shap">https://github.com/slundberg/shap</a></li>
</ul>
<p><img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMX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AQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLT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AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6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AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[199]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sh_explainer</span> <span class="o">=</span> <span class="n">shap</span><span class="o">.</span><span class="n">TreeExplainer</span><span class="p">(</span><span class="n">boost</span><span class="p">)</span>
<span class="n">sh_values</span>      <span class="o">=</span> <span class="n">explainer</span><span class="o">.</span><span class="n">shap_values</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">sh_expected_value</span>   <span class="o">=</span> <span class="n">explainer</span><span class="o">.</span><span class="n">expected_value</span>
<span class="n">sh_interactions</span>     <span class="o">=</span> <span class="n">explainer</span><span class="o">.</span><span class="n">shap_interaction_values</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">sh_feature_names</span>    <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Lime">Lime<a class="anchor-link" href="#Lime">&#182;</a></h2><ul>
<li>Explains prediction of any classifier in an interpretable and faithful manner by learning an interpretable model locally around the prediction</li>
<li><a href="https://towardsdatascience.com/decrypting-your-machine-learning-model-using-lime-5adc035109b5">https://towardsdatascience.com/decrypting-your-machine-learning-model-using-lime-5adc035109b5</a>
<img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMXm8m3+R5/oHOtGi2gmdo52t1KESBAgAABAgQIECBAgAABAgQIECAwq0Dbdx6vj4iXRsRptTtzdGMmKvNbj21Ju1rR3uy2tSPP2QgQIECAAAECBAgQIECAAAECBAgQWASBZjIxp2Dn4jOzbW9sSUDWE5Wz3dula5KPXeoNsRAgQIAAAQIECBAgQIAAAQIECIydQDP5OOoCMjk6sp68k3wcu1dDgwgQIECAAAECBAgQIECAAAECBMZJYLACjfly45k/aBzPdJjJx/q2vX5gnwABAgQIECBAgAABAgQIECBAgACBbgmsRPLxcw2CxzWOZzp8Su3CjyPimtqxXQIECBAgQIAAAQIECBAgQIAAAQIECEwJ1Kde3zHCNx8vaEy5zuM+bvVp4/X9PrZFzAQIECBAgAABAgQIECBAgAABAgQ6KZArWWfSsUrAzbboTH4TsiqXv1m2r1u9HfX9vrZH3AQIECBAgAABAgQIECBAgAABAgRmFChmvLLwC2dFxG+OcPsJEfGoWrnvRkTzu455+YxamZxu/cKI+HZEfK92vi+7mXBs25aiH9qe4xwBAgQIECBAgAABAgQIECBAgACBXgvUp1TXR/ct9v4je6g0k0EPmyJkAgQIECBAgAABAgQIECBAgAABArMLrMSCM7NHNPrVY0YvqiQBAgQIECBAgAABAgQIECBAgAABAsst0Ofk43JbeR4BAgQIECBAgAABAgQIECBAgAABAvMQWIrk4/vm8fyFFs3vQ35roTe7jwABAgQIECBAgAABAgQIECBAgACBpRew0MnSG9efYMGZuoZ9AgQIECBAgAABAgQIECBAgACBsRZYipGPYw2mcQQIECBAgAABAgQIECBAgAABAgQIjCYg+Tiak1IECBAgQIAAAQIECBAgQIAAAQIECMxTQPJxnmCKEyBAgAABAgQIECBAgAABAgQIECAwmsDkaMWWrNQpEXFGRBwfEY+cx1PujIhfj4jb53GPogQIECBAgAABAgQIECBAgAABAgQIrBKBd0dELsCy0L/Teug0U1t72BQhEyBAgAABAgQIECBAgAABAgQIEOimwBv3I+lYJfAkH7vZt6IiQIAAAQIECBAgQIAAAQIECBAgsGICOb26SiDuz29O2e7bNlN7+9YO8RIgQIAAAQIECBAgQIAAAQIECBCYU2AlFpw5fc6oZi/wnoh4RkRcM3sxVwkQIECAAAECBAgQIECAAAECBAgQWEmBlUg+NkcsfiIijoyI/K1vmWAspq99t3bh5bV9uwQIECBAgAABAgQIECBAgAABAgQIdFRgJZKPzVWt3zfHqtW5ovV5Db/XN44dEiBAgAABAgQIECBAgAABAgQIECDQMYGVSD42CX7QPNFyfFVE1Ec/nhERR7SUc4oAAQIECBAgQIAAAQIECBAgQIAAgY4IdCH5OBPFsY0L1zeOH9M4dkiAAAECBAgQIECAAAECBAgQIECAQIcEupR8/EzD5ZmN4xMaxw4JECBAgAABAgQIECBAgAABAgQIEOiwwOQKxJZJxpw2XW1Pj4icVn1jdWL6NxeWyRWtvxERvxoRj2pcd0iAAAEC8xDYdM6F64/atXHLYKI8tYzyiGJQbC6H5ZFRxPHF/Qt/RRlxW5RxQzEobosy/8oflRFf27bmrk/deumFO+bxOEUJECBAgAABAgQIECBAgMDUatLLzXBuRFxSe+gHIyLP5UI09e861oo8ZPfHEXH4Q852/0Q5Q4i5qreNAAECiy7w2LMufsLEAeWZUcYZRTl4ajFRrlvIQ4YRe2NYXhWD+PTk3rjiq5e/+ksLqcc9BAgQIECAAAECBAgQILC6BFYi6dVMMtYTie+OiBzxONf2noh4xVyFOnhd8rGDnSIkAmMnsOW8dSdvPOVlxaD87YjiQd/PffS62+OJ67fFxoldcfiae+Nha+6JTZM747DJXVMMP967Lm7de3DcsueguGPPgXHnvnVx3c6j4pv3Hvkgpn1l3DYo40/vvjPeccOV59/5oIsOCBAgQIAAAQIECBAgQIDAtMBKJB/z0VdHxKm1XnjG9NTrTEzmaJrDateau5ms/McRcXvzQg+OJR970ElCJNBbgemkY5TFa4qJcnO2Y9OanfHTB98cT15/Uzzp4Jtjw+R9C2rejn1r44s7jomv7jw6vrzz6Ni2e/1UPWWUd8aw+LeSkAtidRMBAgQIECBAgAABAgTGXmClko9HRMSLp3XzW48fqEmfEhEXNb4LWV3+xPSIx+9VJ3r2K/nYsw4TLoF+CGyZPHnrc19ZTzo+9sDb4gWbvh4/c0jzc7qL06Jr7tkc7/vRyZG/uQ3L8q6iLN5x7WUf/aOIK/cuzlPUQoAAAQIECBAgQIAAAQJ9F1ip5OMobpmEfExEHDe9GM0XI6KvSceqvZKPlYRfAgQWReCE51x07MHr1l4SRZyWFZ5y0LY476hrp34X5QFzVJLJxw/ddmJ8bnv+n+qIsiy/tm/yvnO+celrr5/jVpcJECBAgAABAgQIECBAYBUIdDn5OI78ko/j2KvaRGCFBE7aevHWKMr3DYpiwzFrt8drHv65OOmgW1Ykmu/sOiIu+uHT4x92HRbFsNxZTgxeds2HX/X+FQnGQwkQIECAAAECBAgQIECgMwIrkXw8KyL+RURsjIgvR8TbR/h+Y07TfsP0iti5sMG7pr8R2RnIEQORfBwRSjECBGYT2DJ50tazLx4MildmqWdvuCF++5gvxIGDPbPdtOTX7h2uiXdvOzU+/uP8LG/EcDh837Y123/j1ksv3LHkD/cAAgQIECBAgAABAgQIEOikwEokH69ofM+xWmxmLqA7agvRfDciTpjrhg5el3zsYKcIiUC/BLZMnvzLz72kiHj+2mJfvGLz1XH24d/pVBM+c9fx8dYfPq3cVa4phsPyyusuu/x034HsVBcJhgABAgQIECBAgAABAssmMFi2J+3/g/Kbj9X2qOlRkNWxXwIECKwKgZO2/tK/z8Tj4ZO74l0/9TedSzxmJ+RIzPc+6uNFxjgYFFsyWRqxZXJVdJBGEiBAgAABAgQIECBAgMCDBPqUfGyOdDzmQS1xQIAAgTEXOOmX33bxYDA4L6dX/8E/ujJOODAHhHdzO+6Au+Ptx18xNRU8k6UnP2/rO7sZqagIECBAgAABAgQIECBAYCkFlmMkyiMjop4ozO831rfH1Q9a9o+NiK0RkaMdbQQIEFiVAic/922/U8TgVRNFGa8/9rMrtrDMfPAzAfnmR3w6fveG02N3TLzs5OddvOPaj5z/u/OpQ1kCBAgQIECAAAECBAgQ6LfAcnzz8QMR8StLwJTJyO8tQb1LWaVvPi6lrroJjKnAE89++6l7J4svDCImX/Pwz8cZG6/vVUv/x92PiDf84JkxLIsY7ovTr/vo+Z/qVQMES4AAAQIECBAgQIAAAQILFliOade5qvVib7ngTN8Sj4ttoD4CBFaFwJbJfZODd2bicevh3+5d4jG76GcP/X786pHXTfVWEcU7ff9xVby4GkmAAAECBAgQIECAAIEpgeVIPi4F9W8uRaXqJECAQNcEHn/22S8ponzqpjU741897GtdC2/keF646do4Zu32KCbKE0963tm/M/KNChIgQKBd4N0RkTNKqr8L2ouNfHax6xv5wQoSIECAAAECBMZdYDmSj3cuImKOePyFiPjrRaxTVQQIEOikwJO2vPXIwWS8KYN7xeYvxfqJ3Z2Mc5Sg1hbDePUxfz9VtBgO/uDEMy8+fpT7lCFAoFcCb4yIXAkrE4L5+9IljP7ljbqf3Tie7+Fi1zff5ytPgAABAgQIEBhbgeVIPv5+RLym9pcJxPr2ntq1erlq/wUR8YyIeEJE5IrXEo91PfsECIytwJ7DJt9QRLHxaYf8YGrqct8b+tMH3xynb/hejn5cN3lgMZVU7XibMnFSJVIymZIf28xF1GbazmqUz3vz3EK3U6afWY3sqn5zhFZz8bbmMzLOjLe6Z67Ym/c77o5AJvSqfqx+sz9HebdyNGB1T/7u7+jA2VTyncv/n++w6UL5+97ZbnCNAAECBAgQIEBgdQgsx2rX+W3Gt9Q483+Zrq9c/V8i4qradbsECBAgsOW8dRHDF0YU8Rubvzg2Hi/d/KX4zN0/FeW+Yuumcy5cf+ulF+7ocOOeV0ukZJj5n13HzPDN4Uy8vL9RPpMvh+5H+/554z8vq6pyhNaPI+J11YmW34yz/p+1s8XecrtTHRHIJHMm9Jpb9me+b6fO8D5W5ZujAfO4/v+TVeUW4zffORsBAgQIECBAgACBhwgsx8jH5kPrC8Xkf3na3izgmAABAqtd4KSNp5xZFMX6kw66JTav7XJ+bn49dfjkrjjloG1Tox8ftnv9ufO7u9OlczRiNeKrCvQTEfGB6mABv0+a5Z5MSM02CnOWW11aIoFMFNZHm+ZIw/19xx8zS6z5vnXp+6n+/7lZOsslAgQIECBAgMBqFliJ5OMrIofy3P93eERcs5o7QNsJECDQJlAWxa/k+Wce+v22y70+96wNN0zFPygmptrY68bcH3xOZT2j0Y78H9d+rXFusQ+fv9gVqm+/BDJRWB9tmpUdt181zn1zJjfnmoI/dy2LUyL//7k/nh6VmzXmv4H8dI6NAAECBAgQIEBglQusRPKxjTy/a5Xf1sr/ApffNsoRJEv5kfK2GJwjQIBAJwRyOvJgGFszmGceemMnYlrMIE475MaYKMqIQWzJRXUWs+4VqCv/8+uiluc+KyJubzm/mKd+r0OJp8Vsl7pGF8jRjy8evfiSl8xPAeT/sJz/I3P+7s/I3yUP1gMIECBAgAABAgSWR2Clk4/5v9jnFKWvTX+UPP8LXE4ly+9Z5UfK87/U5ZZJyStqf6aaTcP4IUBg/AQetnv9mbkoS0653rRm59g1cMPkfVNTrwcRk7s23J9k7Wkjc8TZh1tif9kSjer/YONZXUs8NcJzuEQCzfdAEnqJoFVLgAABAgQIECCwOAIrmXzM0Y2XtExRqrfskOmDDdNT2nJaW/516X/lr8drnwABAvstMJgYnJiVPPrApR44t9+hLriCTKzmNhhMNqepLrjOFbjx1S3/GfaeiPizJYplY/z/7N0LuFxVff//755zIVcSAoFDoBiV+iiQgFysF6TRiqAViApVrLY8f/kpWltBEaXqr/jziqLhZ7229pH+a8U2XpCiYL2lGi9FQCCAFpHGFMKBhJB7Qs45s3/PZzIrLBZrz31m75nz3s+TZ/bes/baa73WnmTynXUx0zyS/tYRbhegAAAgAElEQVTJwNPJ1ZEHvwhWSNaPf/oRsN7wXv0wqB8V9e+7rvFXWda+fmxUT7h68yAqjbtW17j7qgxuTkW9ZuXTbj3kq7poJEZooWPVT/dwm45V3h+7E96rflR1ddFrJ3oC3uLlr91OBqFlrZEnar9wpXeV3a93UIzKobNwdZZh1iZj9+OyS1/rVeVxz0JWnjqvNMrXbzvtqyyNXB/mrWvCZ0HPn+ra6I/hyiPmqvrGnqmwDDpu9XPh39v3VR2UZ9bnKFYGziGAAAIIIIAAAi0J5BV81JdC9W5sdPtJkLDWJPxBUg4RQACB/hJI0tJhKvHYyOAsNBO2wEEjO/eeSqfGwvf65PilkVWIbzKz93a5/J8M8u9E4EnBCQWbFDzTv81aQdnf9KOfgmi/qRGo0EgF1V8/KiqPcA5M5adAs+b5VBoFXHTf2ObPBaprNJeiAj0qgwtW6/W84OJO1ENZKtD022r7hhY6Vv1k5UZnNBqAUt5+3YLiN3z406q1f0EngtAKQqmNNfJE7adny22u7VRvPStZbRd+t8v6vqZ76XlRm8aeFXdf/1XlqbUAj9Lqc6k6KF+/7bSvkTV6z7Wbn3fWvjPRtX5+8lBdVYd6wTsFHbNcdV//mapl6z87un8jnwtXftemfj1dm+rzyFRHvgz7CCCAAAIIINBxgTyCj/rCqi/JzWzfDhI3+kU1uIxDBBBAoA8EElusUo6NDt6Qa6f/2HDypFJXd75PXvXv2JeCsmpxjfN7MM+j/j1UYMzf2gk8uYBdI/+uKvijQEUs2BIGq/zyxfYVcFGgpZFtRTXQUyttp+qhH0cVaGpkc6MzGknb6TQfDzJsNwitNlXb+gHH4Bb7DtXWtYJk+xJm7ChA2Oi9MrKInn6WmX2rTh1Uv9hUCbEMlV+9crrPRFZAU0FzBf4acVUZmrGt97lQL9V65Xf11ggjNgQQQAABBBBAoGsCeQQftTpn+CVM82NpcvJwOJlf8fA/W830NPDzYR8BBBAotEBiU4ergIcMD27Px4XDuyptkKSlfuz5+M+Rf8de26V5HmPP6l8FJ/VvaqvTkXw66NEVZB09VEBFwb52NwUgFYiqt/k9zrLSdqoezf44qvLcm1WoyPlwvsZIkoZOabiset35W6tBaAXOFKRqZlObtPrMhb13G72vAvy/qpE4/G6ZlVQ9/mIB9DB9o/npOvW0DDc922FP0DBN7Fi274+9EZyr97l4S5CeQwQQQAABBBBAIDeBPIKP4a/DH2pwfizNTeNvi/wD9hFAAIFBEUgtqQQfx0YHOPjoFtIplSt17aO203/ow16C+ncs7KHfzSrpXuGPda0EntQzyh/KqTIroPXH1R8E9aOgAjWax9LfFJTRD4n+pqHA2hRc0w+Kz/fycPnIKdyOCU80cby5mrZT9VA+YcDpnUE9VC/VQ4GwbdX7v7maRu+FW3h9I0GvMI+s44uCN1T2VgKCscCZyq22V9vpj54J1dnfWgnUylj5+pvupVXv3XOiY3/TffW+Vs9uZCJcfTaOq+an1zBIq7yX+zeos+/nF/s86HL9nRB+vw17Ryudn5fqq/LFAtIKWrb6I7v7XISfbd3HObt767OqH/e31DHgbQQQQAABBBBAoC2BPIKP4Zep69uqARcjgAACCCDQO4HwP/S687re3X7fnT6wb2/vTiuBp9cEeSjIo/r5gVT16lNwLQx2vjy4dnU12KPgmhbc0bG/KZ93+yeq+8dHzmWd8gNiCoZ9uJqwk/UI731HcEL1Uj0UCLsteK/XhypL2C7NBqH1nSwWTP9o0KNTz8SZQQX1zCmY2MwW/tigwKDu5YKKek507AcMdZ96cz26MihQfrrXNmqj2Gc2DIC668PXML+sz4Oue7Z3sT4HKre/qa38suk9lU9pYwHIU/2La+xnfS7CSxRkdM7u3vqsHtlgJ4AwP44RQAABBBBAAIGGBfIIPjZcOBIigAAC01EgsfQ+1Xt8z5yBrf6GidmVuqVpMt5nlQx7Aar4CoKFP6x1u1qdCDy9OCjkjUHAyX/7B/5BJGDlv61gioZma15Af3Vd7YebVvBuZDu3GpRS8EebgmEu+Nepeqyv5u2/qPea5oHsxDBzP99O7bcbhNa8huGW9aNwGFDWdc8NL65zHM4t6AfD6lxa920F1xQoDzc9M34wU+/XG7KsNLomlp/euyq8iZm9wDt3irfvdmsNN3eBdJdWr2GA33/P7df6XITTFWkuU30ue/13lSsrrwgggAACCCAwjQXyCD664SCOPfwV3J0PX8Nf5t1wpzAdxwgggEBfC6Q2VAk+Pjg5wMHHyZnVNtobaO2jBvtypLeZejjpP/W1Nq0mGwbiwuN6eYT5xwJP4XDo8Br/OOz9pX9nwzK549jQXD8v7WuOO02RovkDNWw0/Hc7TN/osXqMaY7DrK1T9VCQKuxJqLZV3TdWy9DIHJVZ5ezG+awgdKP3OiKSUCtau3YPXyPJmzp1Z5Baz4gf3FVgTJ+DMDjYyHe+cHoe/1atBDlrXRObe9IPpMcCfH6PYr9s2neB9PB8reN6n4u/i1ysz6WCklptXj8SFDWoHik6pxBAAAEEEECgnwXyCD7eEoCdFxzHDvUFKdxa+aIW5sExAgggUEAB1/Nxb+/AAhaw7SK5no9m6dq2M+t9BuoNFc5/54IoWaUJe3zF0sUCFrF07pwCT+FwzXe4N3vw6pdXQTmtNBwGAntQjLZv4dfjTyO95NwNNHxXdVSQK5zfz6XJ4zWcI1EB09j3pm6UrdnV6vXMhp8dF9xVoFOBsXCRFp0r2ne+opUn1rYavh7rqa20Cu7qR4Lf9PBZiZWRcwgggAACCCAwTQTyCD6GvQr0HzYNzdK8QeEvsEdXvxSFvUHCPKZJc1FNBBCYFgJlu1/1HJ8Y3J6PGydm7W3KZKjfhl2r3Oohd2nkWVQQpddBKQ2l9DcF/3oVePIXqag1pNQvXxH3/Xqot5vm5YstjuPKLuNbc2hrd//wVYGwMMgU9ooNr+nUcRhIbCRfrQzfzBau7t7MtdM9rX4o0aIyWe2kQLWCkOqZzYYAAggggAACCHRNII/go74kh8FDBSA1zCccZvO56pcifTnyt9hcO/777COAAAJ9KzCVTlUWubh7V/h7TN9W6QkFX7Pz4L3n0r2B1ickKP4JLdQQziOnUn8ho+h+gCsjid2c9UaN8wqE5hF40r/jblhqbAVjBTs0H50CdVpZ1/2pUZVc3vLr4QqgemlRGa0MrMBNrJ2V9mvuggK8XhGUoRdBaLXxT4L7NnL4skYSVdPoGao1XLmJrDqatNmFdjp68yYz099VWiBJlmFPaZeVvm/7PYDdeV4RQAABBBBAAIGOCOQRfFTBNUQo61fYehXTfwJqzf1U73reRwABBAot8NDo9hvSqWS3AnSPDU8udJGbKtyWyf3stp1jlWt2PfroNU1dXKzE50eKox/RNIdduCkA4AJwWa+x1aDDfGLHscBTo/Mp+/kpEJdVtvC8ege6TaMUwk292/RvtYKjvd5arUdYTgUh1W4nmdnzI99bFODrdU/XsIzuOBaE1rQ2rfirrmF7x44V0Go2MKjh+f6warWVguf+d0J9z1PPU/nm+X2v1q8/sWfe//EgnN9c7VTrWYkFM1tpO/c8xF5lqV7Rco0F1BtdXTuWN+cQQAABBBBAAIGaAnkFH9X7UasC+l82axa0+qa+LPn/4WnkGtIggAACfSWwYeVl29NkStNR2I+2xtaD6KvqPKGwq7cdYVNpYuWyfe+e699ZWVznCYn644T+LQvn21PJez38OhZ4Wt4AoQI//qaVj2sFXPy0/n5sPsutfoLqfq3gSyR5w6c6VY9aN9RchbGVj+d6F8UWITnee7/bu2EQWqNKFCCstf008mazK1hHssg89WfBOxquL1eV0wU4FexVIL7Twbfg1nUP9UNCOO2PLtJnJDa36hovxx96+25Xfy9kbe+JvPGjyLlOnJKr5i8Nt9jnOEzDMQIIIIAAAggg0JJAXsFHFVb/afv9yHCxrIrol3EFHt0wr6x0nEcAAQT6XqCclCvD43609Ul9X5ewAj/csneNinI6lTUEMLykyMda1EELYoRb1vDrMF2njt8b/KAXCy6E9/pGcEJTnPxntXdUOARTPbPUa0q9pzYFvbgq0wQEea3whnEqL/UG1TyJ3dg6VQ8FR1U3BZzUQ8830HunRArvr8Ic+37y4uqc1rpU+cV6uEWybemUgkphMLzec5C1AIwMwrK68n+wulpyK70S/RWhVUkNwW4l4N0SUAsXqZemfghygXMZ/HPGwkrf9fL3991pBYNl5vLSee0rf73nb/pxvhVfPw89y8pDn1v/nqpDrJdjI1ND+PmzjwACCCCAAAIINCww3HDK7iTUF3X94q3/NP2BmR0TuY3+U6P/DMW+1EeScwoBBBDof4E7H7nzmqUHLN2+ZufBczT0euHIjv6vlJm5Iddls8kZW6yfh1z77aHhrZq32N/c8GsFJ3ux6d/Ij1R7XTZ6v6+a2YfNzJ9XWUMytQBFvc3v8ad/o8NN9Y8FZcN0nTjuVD1UJ1ko4OQPDc4qY2wVZp2ToduUn/9sKKhUrzeiu7aV138ws3cFbVovn9hz04hBK9/LNGe3H2iL3UdGN1YLraHM/5rzatcqr1/mmKeGifserjdy+BwpGFwvIKz8Y71sY/etdU7PXqP3Uz6xgGmt/HkPAQQQQAABBBBoWCCvno/6Nd3/oy9smjdI/0kL/+i8/4Wu4cqREAEEEOhbgVVX7bYkqfR8+fyDJ/RtNcKCf3HDMytDrq1cvu7mVRdvDN/v02P1Houtjtzr4dcKPDUznYn+bW1lCpSwmZRPrP5hum4dd6oezZYvtgrz39XJxA/01kna0tuyUDCxmU3fu8JFi5q5vpm0+jut3rMiIxfw02ru6jGr3pa93mLzIsbKoIDzJyJv6If1RvPwL1dbtNvr0c+vkX21Sd7D3BspJ2kQQAABBBBAoE8F8gg+vrHaC0A9Adyf2Jw6fUpKsRFAAIHOCOzcted9aZpu/8GWxXbj9kWdyTTHXO7adZBdu+lppsV0yiN7YnOm5Vi6tm+t4EOsp1+ted7avmmQgQJPlwbn/EN/iLA77+ZgjpXdpYm9hnmp/uHci+F1Coxq9ehubJ2qRyNlUz2yVmFWALhWwKlZ50bKE6ZRGbLuE1sIRderp129oGB4n6y8wnT+sYb/NtLzz79G+wpCxhZyCtN18viiBkzU1q/M+JFcn0dNF1Tvc+HK7D4fnej16PJs5FXt3upiV43kTxoEEEAAAQQQQMDyCD6+POLerUm1I7fiFAIIINAfApXFWNJEvWfsygeebXvSPP7K7oyVFpj5+PrnVDJLk/IVd6689J7O5NzVXDSXoN+TUAGd9Rl3VKBBPeHCoE8rARp3i3Auwx+4N2q8anVmBRP8ciu5zilAF9t0/shqQE29rmLBMwVQ9J6ChxpWHOblAi0KyoVzeSo/zUWoeZ5/HpTNXyHYlS28PpbGpfVf262HerD+cbWeYcBInjqn+qseWT3TnIPq6zvqetVLQ/Sb2bSIjf9M1XoGXb4qgwJi/v31nq7VMPusTQEota3KrrqGz5Cu13m9LyfNJRhu9dpOc6H6w9LD62sdvyF4s969/OThZydsX6X181NdZS8Trf6t93wP9ywouBh+Fvz7uudBeegzGN43fK70+c3a/PIpTb3PxXHePf2y61qVQ+VRWxB4zBLnPAIIIIAAAgh0TEArC/Z6i02srS9l+tI/6FuaUcE82iGjKJxGAIFiCSwbPvYVZ/zSrHTMaw66w84/5JZiFa/B0nx54zH2hQePt3Karl3zyO3PMA0rZ0MAgekkoEV8vhVUWIFM9dRUkM7fNDWP5ocMA5V8X/KV2EcAAQQQQAABBPpEII9uNGFPDlG9pE+8KCYCCCDQY4FVkxN7hiqLFvzLw0fbf/Th6tcaMv7Fh55ZcUumJt9E4LHHjxC3Q6AYArFFBdeZ2bygeFqN+fDIwjxh773gMg4RQAABBBBAAAEEiiqQR/BRq1KGQ4H0H2vNA8SGAAIIIBAI3HXdhavT1K7Q0OUP33eyrdl5cJCiuIea5/GydX+YquxlK195+7WXqPc7GwIITD+BLZEqa2V1DXHWyBD3R8c6Hy7OkzXUPZItpxBAAAEEEEAAAQSKJJDX8JUDzUz/AT3Rw9Av2q81s63euVq7/ThMm2HXtVqU9xBAoKbA0pdf+dkkSS+YWZqwzz7lW3bEfo3+dVkz2669ue7R/e1ta0+3TZMzFFX46u1f/+a5Zqsmu3ZDMkYAgSIL6LvfbyJBxUbKrB+tNb9iODy7kWtJgwACCCCAAAIIIJCzQB7BR83j8x4z05dQP/jYLIXmAbq32YtyTk/wMecG4PYI9LfAsuGlrzjr6sTs7AXDu+2TT77eFo2Giw4Xo4YbJmbbhfe+OH1gcm6SWnLD7V+/5gwCj8VoG0qBQI4CGuXytchcjrWKpIWOtPAWgcdaSryHAAIIIIAAAggUWCCP4GNswZlWiPpxkRqCj620NNcggIAnsGx4yfIzv1sqJctmJBPpxYf9LHnhvLXe+/nvao7HD/7P89Nt5f0SS231+uEtL9mw8rLt+ZeMEiCAQEEEtPjMy8xM8zueFpRJw67vMTOtUK2pevrth+agOhwigAACCCCAAAIIEHzs7TNA8LG33twNgYEUWHjOZXMOmZz/90NJ+mpV8MwFd9ubx2600aSca301r+PnHjzRvvbwMyrlKJfL14yPbHsdgcdcm4WbI4AAAggggAACCCCAAAK5CuQRfNSE4a/qQK2PM7PbOpBPL7Mg+NhLbe6FwIALLFm+4rwkSf82SZI5R87cZJcc+lPTax7b+j1z7f/8zyl29+4DLZ1KdqeJvWPNNRd+Ko+ycE8EEEAAAQQQQAABBBBAAIHiCOQRfNQQm7PbJFhnZv246iHBxzYbnssRQODxAk8744qnzxguXZ0kiX6QsefNXWd/vvD2ngUh79m1wFY+fJR9f+uTrZwmCjz+enIiPfeub1906+NLyhECCCCAAAIIIIAAAggggMB0FMgj+DgdnV2dCT46CV4RQKBzAsvOm7Fk/tJ3JyV7S2LJfGX8rDnr7dyFd9ixs8Y7dx8vJwUd/3HDUvvJtiMqZ9Xb0Urppx4Y3vI+hll7UOwigAACCCCAAAIIIIAAAtNcgOBjbx8Ago+99eZuCEwrgcXLVszff75daKX0rS4IecR+W+2kOfdX/iyZtcFmliZaMtmTluyOnYfYLdsPtZ9tP8z+e/cBlXwqQ6yHpj63bWjq8rUrL+lOpLOlEnMRAggggAACCCCAAAIIIIBAEQSKFHzUcOxFAcr6AVvlkOBj0MAcIoBA5wViQUjdZTSZsmfM3GBLZj9kh4zssPnDj9r+Q7tt4fBOWzCys1KQTROzbMPkLNs6NcO2T43a/Xvm2N27DrJbd4yZApBuS9N0e5qkXyDo6ER4RQABBBBAAAEEEEAAAQQQiAnkHXxUwPFiM9OKrXu70TyxlI9U53f8spmtfuLbfXWG4GNfNReFRaDfBZYNH7P8rJOTJDnN0vRFpZKd2F6NyneU06HrrJx+f82W21bbqqt2t5cfVyOAAAIIIIAAAggggAACCAy6QJ7Bx0vM7PImgT9rZu81s4ebvK4oyQk+FqUlKAcC01Bg8TkfHZtXHn1RuWxHWzo1lpSGxsxsfpqWx5JySfuWlsrjSVLS8OnNaXlq3JKhcUvT/9o2MnEDw6qn4UNDlRFAAAEEEEAAAQQQQACBPhVQ4FGBuFb+/KJP66xiZ9W3j6tE0RFAAAEEEEAAAQQQQAABBBBAAAEEECiOgIZaZwXhGj2v4GU/bln168e6UGYEEEAAAQQQQAABBBBAAAEEEEAAAQRqCgzXfLc7b56dka3mdrzRzH5Qff94s8r8ZE+NpH+DmX00cp5TCCCAAAIIIIAAAggggAACCCCAAAIIIDCNBW6I9Hx8Yw2Pk83snsg16kHZbxs9H/utxSgvAggggAACCCCAAAIIIIAAAggggEBfCYTBxw82UPpjI8FHBSX7bSP42G8tRnkRQAABBBBAAAEEEEAAAQQQQAABBFoWKLV8ZesXbg4uvT44jh3eZmbfib3BOQQQQAABBBBAAAEEEEAAAQQQQAABBBAopkAewccfBhT7B8dZhwcGb/wqOOYQAQQQQAABBBBAAAEEEEAAAQQQQAABBKa5gIKIm7xh1BqGXW8Lh11/pt4FBX2fYdcFbRiKhQACCCCAAAIIIIAAAggggAACCCAwOAKXeMFHBeReXaNqClb+wkuvwGU/LjajKhJ8rNHQvIUAAggggAACCCCAAAIIIIAAAgggMFgCSY7VUe/FN3n3v8DM7vSO3e4KMzvRHZhZVjqXZLXbKeCrgo+xLc92iJWHcwgggAACCCCAAAIIIIAAAggggAACCLQtkEfQS6tUP7da8neZ2QFt1+LxGTzVzO59/KnCHBF8LExTUBAEEEAAAQQQQAABBBBAAAEEEEAAgUEU0ByPWcOPO3Fewc2ibln1K2p5KRcCCCCAAAIIIIAAAggggAACCCCAAAItC+Sx2nXLheVCBBBAAAEEEEAAAQQQQAABBBBAAAEEEOgfgTyCj5u7zLO+y/mTPQIIIIAAAggggAACCCCAAAIIIIAAAgg0IDDcQJpOJ/lrM7ul05lW81tX4Pkeu1RlskUAAQQQQAABBBBAAAEEEEAAAQQQQKCYAnksOFNMid6UigVneuPMXRBAAAEEEEAAAQQQQAABBBBAAAEECiCQx7DrAlSbIiCAAAIIIIAAAggggAACCCCAAAIIIIBAtwXyCD6+NLLa9SXdrij5I4AAAggggAACCCCAAAIIIIAAAggggEBvBfIIPv5ZpIpbIuc4hQACCCCAAAIIIIAAAggggAACCCCAAAJ9LJBH8HF+xOvOyDlOIYAAAggggAACCCCAAAIIIIAAAggggEAfC+QRfLw54nV05BynEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBpgSeYmabgnkf7zGzA5vKpT8Ta7Xr2J/+rA2lRgABBBBAAAEEEEAAAQQQQAABBBBAoIACx0YCkL+YBgHIWOBR59gQQAABBBBAAAEEEEAAAQQQQAABBBAYOIE8hl2r5+NpZvbvgeaJZrYxo2dgLGg3HXpKBkQcIoAAAggggAACCCCAAAIIIIAAAggggEAtga80EWCMBR3duZNr3aSg77myh68FLS7FQgABBBBAAAEEEEAAAQQQQAABBBBAoHWBPHo+xla7br0GXIkAAggggAACCCCAAAIIIIAAAggggAAChRTII/hYSAgKhQACCCCAAAIIIIAAAggggAACCCCAAAKdFRjubHYN5faBhlLVTnSvma2unYR3EUAAAQQQQAABBBBAAAEEEEAAAQQQQCBPgSTPm0/De2uux9hGO8RUOIcAAggMuMDCcy6bc8ju+ctKQ+mJqaUHJqVkLC2nB1liixOzg1T9VIuxpbY2KSUbLdWf9MHU7NbxkS3f27Dysu0DTkT1EEAAAQQQQAABBBBAoM8FCHr1tgEJPvbWm7shgAAChRM46qUrjhvaLz3dUjstSUvPTobSGa0Usmw2aeV0tZXs+8OTdsMvr33bTa3kwzUIIIAAAggggAACCCCAQDcFCD52U/eJeRN8fKIJZxBAAIHBF1h23oyl84+9ICmlbzdLDvcr/LQZD9sz54zb/KHdtmBklx08stMWDu+wA4Z3V5I9MjnDNkzOtocmZtmmiZm2eWqGrdlxiN21q9Ixcl9WU6ltLKX26a2b7cq1qy7avO8NdhBAAAEEEEAAAQQQQACBHAWKEHx8ipmdamYvMDOthH2gmR1gZurB8eocbbpxa4KP3VAlTwQQQKCoAtWgo6XJO5OhdEzFXDiyw46f/YCdNGe9nTD7AZs3/GhLpd8+NWo3bl9kv9xxqN2841Ab3zOnkk9q6WYrJ/+XIGRLrFyEAAIIIIAAAggggAACHRbIM/ioIOP7zexNNer0/OrCMl8xs1d56dx571Rf7BJ87ItmopAIIIBAuwLLhpcuP+stftDxqJkb7dyFd9jz5q5rN/Po9bftHLOrHlxqetVWTtMtSZpcefs13/yA2arJ6EWcRAABBBBAAAEEEEAAAQS6LJBX8FGBxxvM7MQ69XNBxkvM7HIv7WfN7M3ecb/sEnzsl5ainAgggECLAke+5PLDZ88YvdoSO1lZHDtr3M475PbKa4tZNnWZgo9f3fh0+8m2IyrXpWl669Two+fcufLSe5rKiMQIIIAAAggggAACCCCAQAcE8go+fqZOj0dXNRd8PNbMbnUnq0OyT/KO+2WX4GO/tBTlRAABBFoQWLJ8xXJL0qtKSTJv0eg2e+dhP7Elsx5qIaf2L7l794F2+f3Ptf/efYAl5XRHOlS64LavXfil9nMmBwQQQAABBBBAAAEEEECgcYE8go+a4/G3kSJ+x8yeVZ3v0b3tgo86DgN3eZTdlavV17AOLp9+rIsrO68IIIAAArZseMnyM1eUSslbhPHCeWvt7Yt+ZjNLE7na7CqP2GfGT7RvPfL7lXKUy+Wrxke2/eWGlZdtz7Vg3BwBBBBAAAEEEEAAAQSmjUAph5qeHdzzETM7zsxON7Mbg/f8Qy1A42/qDcmGAAIIIIBAzgLLhpe+4qyrFXgcTabswkN/bu85/Ee5Bx6FouCngqAqz4xkIi2VSueNTez/b2bLhnNG4/YIIIAAAggggAACCCAwTQTyCD4eH9heama3Bedihw8HJ+cGxxwigAACCCDQc4Ely8/4+8Ts7AXDu+1TT77ezlxwd8/LUO+G6on5uad+K1EZS6VkmYKlBCDrqfE+AggggAACCCCAAAIIdEIgj+Dj/KDgdwbHHCKAAAIIINAXAkte8fEV6k2oHoZ/83ur7MiZmwpb7iP222qfWHxDpTekgqVLX778bwarFQMAACAASURBVAtbWAqGAAIIIIAAAggggAACAyOQR/CxVTytkM2GAAIIIIBAIQSWnvXxi0tWunAoSe09h/84t4VlmsFQAPIjT/q+aXh4kqQXLH35io81cz1pEUAAAQQQQAABBBBAAIFmBfIIPt4bFPLo4Dh2qMDjicEb64NjDhFAAAEEEOiJwDPP/MSJ6VDpw7rZxYt+Zs+Ze19P7tuJm2j17UsPX22lJLUksYuXnLXiRZ3IlzwQQAABBBBAAAEEEEAAgZhAHsHHcH7Hd5hZvV6Nrw8Kr0VqwiBmkIRDBBBAAAEEuiGwbHhquPS3JbPh5Qt+bafNv6cbN+lqnn+4/+/sNQetqdwjseRvmf+xq9xkjgACCCCAAAIIIIDAtBbII/j43UD8qWb2GzO7xMyODN57jZl9xswuD87/e3DMIQIIIIAAAj0ROObMM89PLH32wpEd9v8dfGtP7tmNm7x24e22aHSbJUPp05e8/MyLu3EP8kQAAQQQQAABBBBAAAEEkpwIFFB8Uxv3fr6ZrW7j+rwuTTNunFc7ZBSH0wgggAACMYETll1x0MSC0m8SS+b/ze/9h6kHYT9vt+w41C5ee6qlU8nuPY+mz/j1DRet7ef6TOOyP8XM9MOsftDVphEirzWzb1ePeUEAAQQQQAABBBBAIDeBPHo+qrLvNbObWqz1Z/s08NhidbkMAQQQQKAoAhMHDL9fgUfN8djvgUeZHj/7ATt13r3q/ThjeGZSmcOyKNaUoymBRV7gURceYGbHNJUDiRFAAAEEEEAAAQQQ6JJAXsHHh83sdDP7TpP1UuDxzU1eQ3IEEEAAAQTaF1h23gyzsnqT2V+O3dh+fgXJ4Y1jN5lW7C6VbfnCcy6bU5BiZRVDPfw0yaZGEtT7c4OZfdDMjs3KjPMDLfBSM9vUwHPiP0dfGWgRKocAAggggAACCOQkkFfwUdV1AchzG+gFqV6SSkfgMacHhdsigAAC011gyfxjT0+SZI5Wix4b3T4wHAuGd9uxs8YrvR8P3jPn1QWv2LOCHn61inuamf21mWliTgUi6y1uVysv3us/gZdVe4A2U/L5zSQmLQIIIIAAAggggEBjAnkGH10J9SvzSWZ2kJlpLsfwj87rfX6NdmK8IoAAAgj0XCBNklfppqf0+TyPMbgXzNs71WMpGarUMZamIOeOaLEcCkQSgGwRr08vUy9Zts4InBz0IlWPUnoUd8aWXBBAAAEEEJgWAkUIPjpo9YTUIjLhH51nQwABBBBAIDcBDUfWsGQV4JT91+VWjm7d+OS56ypDr61ky7SoTrfuk3O+J5rZ63MuA7cvtsDmYhcvt9I9N+hFqjlF5+ZWGm6MAAIIIIAAAn0nkEfwUXPwqBejm4upkWFQSqMVsnWNrtUvsGwIIIAAAgj0RODgPXNO16IsGnK9cGRHT+7Zy5vMG360MvS6ZDa8e97eIGsv79/mvd5pZon3Rys+a6oWrfgcbu8KT3A8rQQ0usZ/VsL9ok87MK0ai8oigAACCCCAwOAIDOdQlb8yMw1/0qbX6xtYvVq9H/WFUL+0alPvhSOr+7wggAACCCDQVYHSUOnpusHTZg5uZ3wFVm/ZcaiVSsMK3vXzdq+Z6c99ZvbjoCL6HqHhuHqfDQEEEEAAAQQQQAABBHogkEfPx1ar5S8tqv8YMZdPq5JchwACCCDQlECSlg7TBWMjg7PQTAhw0MjOvafSqbHwvT491jQusW1R5KTmr3tjdXTFLyIrJOucRmDUGnmhURr+Stz+XNW6Tsf+6ssazaF7NrLpO4/u7+evMl3SxkI6ylOrgasc/orP2nejU+p911Kd3LUqmxvN0kx5ZaO6hTZF64XYrlfW8+FG97j6q12z5lOUicz950DXqb0a9XLefh5Zbe7SXB55SBXYd22v19izrLrpfPiMKV/Vo9EyR27PKQQQQAABBBDoJ4E8ej626hP2dNR/Hui50Kom1yGAAAIINC6Q2GIlHhsdvCHXDuGx4eRJpa7u/AC+rg/qpADI1cG58FAjLvTnTWb2WTN7c5jAzJ4RrMStxXv+wsw+bWaxhXw0+kN/zjez080sq1utyqfgnBv94W7tyvQGM/uYO9nAqwJCb6uuBJ6V3JVNq4V/yMzenZHQr5d+GJaB5geMBav88r7YzLY0YHNKhnVGcbpyulNeWc+HAnOycZv25X+bO1ENRn4teL7c23ouXHt9wMxeGVzr0qke/1xN6875ry4PPeMLqm800wv65Wb2eS/DrOdWSZSv/uj5mRdc52XBLgIIIIAAAggMikAvgo/6pdjvZaAvP/52tH8Q2T/crDL/VDNfgCLZcAoBBBBAAIHWBBKbOtysZIcMD27Px4XDuyo4SVoalJ6PmmM63H4b+eHyvDBRnWMFZzSfZFZAzr88DCz577l9BZsUoIz1AlMd6gVG9f3ocy6zOq/6DtZImfxsFIBUgCsWcPXTaX9FEEgL39exyqtgqsriB91iaWWtpdg/GnuzB+e67dVIW6gX5A8jwedY9WWrtC+IBCBrBR79vMIgt/9eo/vqXVnvuXV5KfjIhgACCCCAAAIDLtCL4KN+Mfd/GQ9JG/3CHF4X9lwI3+cYAQQQQACBjgiklhyulSnGRgc4+OgW0imV9aNfP2/60fNsM4stLvN3HaqYAnKfqNFb0d2mXnDNpdP3JOUZjuj4pEvQoVf1eGy0TP4tFQT8UXWorH8+3G80b/Wya3RTO+YVfMzbS8FP9XhsJiCotOp5qt60blMAsxlzd52C9Y3++P8Nd5GZvcXbZxcBBBBAAAEEELBezPk4vwvOsZ4LXbgNWSKAAAIIIIBAwQUUaPHnntN3BJ0LAzY3ZQSxflDtyajh1Fol+7hgRWQdfydioGG0jW76IVZBHMWw/zhjJe5Tg8zUEzIW+LnAK1/Wqt5BVpVDBaAU4Aw3v2yufLIKNw3pbXSTl6uvVpiOrTzu8pK7S6u6hZvaMWsOxDBtveNwnkL/udG+f59eeoXl1pB0ba+PPAP/Ejyjej7D9lKg0a9LLPDor/x9UPW5VFv4baUpj/RMaEX5cPOvVxp/yHXY6UBl1j2UTn9UZrW1PquurmH+HCOAAAIIIIDAAAn0IvjYDS6tmM2GAAIIIIBATwQSS7Vyso3vmdOT++Vxkw0Tsyu3TdNkPI/7d/meCrD5PcH826lXnea407BiLYLhz7WndDqOBd7qTRvj7qEAoYZou16N384YwnyEu6D6ujw41qECNn6QR+VVb8Mw+BS5NLogiIJKftl0nconKwWG/E0BQj+g5b/n7yuApetdfbXwz6V+Am9f7SJ3l1Z10/XhVlnwKTzZhWM/oBxbQKUbXgr26RlRcE5/tP/Vat00n6e/qZ0VlPafUe3L2w8a6ppYwNHP61fegeYbdc+lm+/Re7vtXT1L/pymKrPaWsFN/3lu+0ZkgAACCCCAAALFFOhF8HFzB6uuLy/qMaAvSGwIIIAAAgj0RCC1oUrw8cHJAQ4+Ts6sWu4NtPYEtvs3UUBGvawUYPODH7E7a4irAk4K6IUrXqvHXLg1MledAmnKL9y+G54wsxOCc1qUJdxcUMo/r8DdRf6JjP1Yfv+QkVZWsUVs6gW09D0tNjfkzyP3USAtNm/mdZG0x0TOdftUL7z0fGp+Rj0jMtcft6/pA8KeryszKq3rbgzee6F3vM7bd7v/mTHPqHu/ndcwcK0et5rnU3ViQwABBBBAAIFpKNCLOR/1heMWz1a/4vpfpvTFXJOJZ236wqT/9G0LfunNSs95BBBAAAEEOizgej7u7R3Y4cwLkZ3r+WiW1vo3uRBlbaIQGrL7hWrPMAVosrZLqnNEhkO1s9I3ej7LslZZXN5hWTSUuZHr3PXhq//dS+/Vy+/OMIMGju/JSOP31HNJsuqy1SXI4dXvDdgLr4/U+G7rL9boKDSdgP40uynYrUCn/0ypfloURkFBBTzVAzHWTs3eS+k1t2pYTs0bqj8KOn/czFSmrGeglXtyDQIIIIAAAggUWKAXwUf9Iu9PFK5fYv0vdF82Mw3JYUMAAQQQQKCYAmW7X7Mkj08Mbs/HjROz9tonQ/027FpDYd33DK0OrUVa/O8ZGpaslX6zhl1/MGMuxGI+i5SqHQHNUzhdvnNqSLPbFORTD8vYqtkKSLrAoALSf9qBoKA+j4ur+boyuFd9HhX0VDDUTXXg3uMVAQQQQAABBAZUoBfDrkM6N6+PzuuLh3o0siGAAAIIIFBYgal06g4V7u5dGpk7mNuanQfvrVhq9/dxDTUti4bL6vuFv2m4sObKCzcNA40twhKm4xiBfhMIPwPq1ajAnwKMWZs+JxqO3Ym/6BRY1BylYTncvRX0VBAyNremS8MrAggggAACCAyIQB7BR30ZcavdaVLrTg3xGJAmoRoIIIAAAkUTeGh0+w3pVLJbAbrHhicXrZStl2fL5H52286xSga7Hn30mtZzKsSV+pFTw1nD7e3hCTM7O3JOw0I1v7S/Oq96zLEh0E8Csfkh9dlQD2D1DNZiP+HcjKqf3nt/hyqqodz6rq9FdLTidWz7HHNBxlg4hwACCCCAwGAJ5BF8zBI82cwa/dPIaotZ9+E8AggggAACTQlsWHnZ9jSZukEX/WhruChxU1kVMvHqbUfYVJpYuWzfu+f6d1YW1ylkQRsvlBZSCXtcqdeXvmf42/H+QXVfwRn1oCzafHTPipTVndrf7dR4DT1q5adsnhvJK7ZwSSTZQJwqopemGHA/4Nd7dVMRxBpDQUgt9qOh2eqdGG6xXsJhmmaONaek8lRgU8H9cDs1PMExAggggAACCAyWQJ7BRw3p0DxLmpw8NTOtJNnon1v5lXSwHkRqgwACCBRdoJyUKz13frT1SUUvatPl++EWTc9mVk6nsnonNZ1nzhcocKiAR7i9JjgxPzjWYSzoeHQkXbdPhcNjNUw1FhTSD7JfaqAw/x6kUX5aaCe26TvauyJvhCsqR5IMzKm8vWJzU/orWHcKWr0Ttfijv+nZ8LfKtBP+CTNr5TOhoOergnx02MjK8ZHLOIUAAggggAAC/SKQV/BRX5R/U51nyZ8Uvhm32CqAzVxPWgQQQAABBBoWuPORO69J03T7oA29dkOuy2aTM7ZYvw+59ttTQZVw08Ia/nx2N4cJqqv/ujT6vqIgpoaG9nr7RuSGWpnYBSBVRu3HFhGJXBptW61IrACk5r50mxbt0bx/YQBKgWkFj6bLFvss9Nor/DFAczKqB7bayD2jag/tq1ev5k/U+5uCRtJ5/divH/2Vzr9WxycF6cNen7EVyM/3nht9TvTHbbq/6+3on9dzFuvluMVdyCsCCCCAAAIIDKZAHsFHfeH5WuRL7WAKUysEEEAAgcEQWHXVbkuSSm+6zz94wmDUycy+uOGZlSHXVi5fd/OqizcOTMX2zikdG+L5eq+OP/H23a4ClHLQqAyNtIj11HJpu/n63UjmCghqkQ6VTWXUfhgkjFxWOaVnNzbHnwJqOq889edbwWrhLr/ptjBPEbw+5fC9VwUg1UbuGXXPgkYPKUiu98NnQj0L9WO/2lDp/Gt1rCkJ/K3y95x3Yr2373Z1jXtu9Dm51L1Rvb8+N3o+9Z57tpQ+FsiPPeteduwigAACCCCAQL8L5BF81C+erfZ29L1ZJdvXYB8BBBBAoOsCO3fteZ96P/5gy2K7cXv/d8C/a9dBdu2mp5kW0ymP7HlH1wF7f4OPR275Bu+c5naMBSi9JLntqpeh5vhrZFNPtbCXXOy6V0bmwoylC89pwZDp1OvR1T9vLw29ln0vNz1LVwQ3VNuH0wAESSw2hUGYJnashW+m47MVs+AcAggggAACAyuQR/DxlIimvuhovhl9yW7kjybHZpXsCCSnEEAAAQS6J1BZjCVN3qs7XPnAs21Pmsc/o52pnxaY+fj651QyS5PyFXeuvFTDMgdtUw+ucAipfgDVsFW3afhorEege1+vClAqSNLrTYuG1LuvyvYCM7ulgcLpu5PS1quvy0rptNJ32BPOvT/or0Xwkr0CkOFzXMu+mbR+PmpvPR+xYKC+n9fKN3aNn3dsX8+2Fr5hQwABBBBAAIEBFxjOoX7+vEK6vb40a2XJ2ATvORSPWyKAAAIIIJAtcPs13/zUsa844/Xje+Yc8/8/dJydf0gjMZ/s/PJ6518ePtr+e/cBVk7TtWs236654Pph+2k1cOZGUCgYElsMw6+LhoP6Qz3DAIoCTH9gZmebmQKR/hBU9fa6ypu/zs83vO+vImWrtTq08tYQWbf9wO0ErwrOXG9mbzGzF3tDav2y6ZLDguuy7q36apVjzRepH4Q1359fZwWg9N1Mcx7WCzqqt6U/LD02h6YrlvL07xOb01JpNcRXZWimjd09/FflrxW93RBk5RkbPuxfE9vvlFezz4dfFrWDhibrGVVwUI7OR+n0TGsxIPmvqab1r9fq73oellev89uh0faWg667uPocuvvrei3O4/eWPM7M/sTMND+F3wYqk55blVNlaiVg6deLfQQQQAABBBDoE4Ekh3JqImz/y7Z+za335TaHYnbllprzJrbl0Q6xcnAOAQQQQKABgaNeduXJI6Ppj4eS1N5z+I/sD/f/XQNXFSeJhoy/e90fVeZ6TCcnXnL7tZfo32Y2BBBAAAEEEEAAAQQQQKDjAnmMFwt/Fb+v47UiQwQQQAABBLoocNd1F65OU7tCQ5c/fN/JphWw+2XTPI+XrfvDVGUvW/lKAo/90nKUEwEEEEAAAQQQQACB/hTII/iooUP+9hL/gH0EEEAAAQT6QeD2b1z0jjRNPrcnHbJ3/e6PbN2j+xe+2Crj/173QtudjiSp2VfXfP3fBnGRmcK3AwVEAAEEEEAAAQQQQGA6CeQ13Dcceq25YTSXzKBvDLse9BamfgggMM0Elg0vfcVZVydmZy8Y3m2ffPL1tmh0WyENNkzMtgvvfXH6wOTcJLXkhtu/fs0ZZqsmC1lYCoUAAggggAACCCCAAAIDI5BHz0fhvTlYMe+HZnbywKhSEQQQQACBaSKwavL2r3/z3HI5XbVpcoadf8/L0h9sWVy4umuOR5VNgUdLbfUDQ5vPIfBYuGaiQAgggAACCCCAAAIIDKRAHsFHrXat1fq0Mp7btBLhj81MPQMb/XOgu5hXBBBAAAEE8hNYNTk+svWMqTT5ioYzf+C+U+zKB55te9I8/ol9vILmdfz0+En2rt+9yLaV90vK5fI164e3vGTDysu2Pz4lRwgggAACCCCAAAIIIIBAdwTyGHatla1f1YHqPN/MVncgn15mwbDrXmpzLwQQQKDHAkuWrzgvSdK/TZJkzpEzN9klh/7U9JrHtn7PXPs//3OK3b37QEunkt1pYu9Yc82Fn8qjLNwTAQQQQAABBBBAAAEEpq9AHsHHcL7HVvUJPrYqx3UIIIAAAl0TeNoZVzx9xnDp6iRJNJ+xPW/uOvvzhbf3LAh5z64FtvLho+z7W59s5TRR4PHXkxPpuXd9+6Jbu1ZpMkYAAQQQQAABBBBAAAEEMgQIPmbAdOk0PR+7BEu2CCCAQKEElp03Y8n8pe9OSvaWxJL5Ktuz5qy3cxfeYcfOGu9KURV0/McNS+0n246o5K/ejlZKP/XA8Jb3Mcy6K+RkigACCCCAAAIIIIAAAg0I5BF81MIy72mgbLWS3FtdtKZWmiK+R/CxiK1CmRBAAIEuCSxetmL+/vPtQiulb3VByCP222onzbm/8mfJrA02szTR0t01p+QdOw+xW7Yfaj/bfpj9925Nn2x7h1gPTX1u29DU5WtXXtKdSGdLJeYiBBBAAAEEEEAAAQQQmI4CeQQfp6OzqzPBRyfBKwIIIDCNBGJBSFV/NJmyZ8zcYEtmP2SHjOyw+cOP2v5Du23h8E5bMLKzIrRpYpZtmJxlW6dm2PapUbt/zxy7e9dBduuOscctapOm6fY0Sb9A0HEaPVhUFQEEEEAAAQQQQACBPhAg+NjbRiL42Ftv7oYAAggUTGDZ8DHLzzo5SZLTLE1fVCrZie0VsHxHOR26zsrp99dsuW21rbpqd3v5cTUCCCCAAAIIIIAAAggg0FkBgo+d9ayXG8HHekK8jwACCEwjgcXnfHRsXnn0ReWyHW3p1FhSGhozs/lpWh5LyiXtW1oqjydJScOnN6flqXFLhsYtTf9r28jEDQyrnkYPC1VFAAEEEEAAAQQQQKBPBQg+9rbhCD721pu7IYAAAggggAACCCCAAAIIIIAAAgjkKDDcxXsfa2andSn/LWb2+S7lTbYIIIAAAggggAACCCCAAAIIIIAAAgggUHCBr2i0WBf/KLjZb1uWR7/Vg/IigAACCCCAAAIIIIAAAggggAACCCBQV6BUN0XrCea3fmlDV85tKBWJEEAAAQQQQAABBBBAAAEEEEAAAQQQQCAXgW4GH3OpEDdFAAEEEEAAAQQQQAABBBBAAAEEEEAAgWIIdDP4eG+Xq7i+y/mTPQIIIIAAAggggAACCCCAAAIIIIAAAgi0IdDNBWeuMLO1bZSt1qXrzKzbwc1a9+c9BBBAAAEEEEAAAQQQQAABBBBAAAEEEKgjkNR5n7c7K6AFZ2Ib7RBT4RwCCCCAAAIIIIAAAggggAACCCCAQF8LdHPYdV/DUHgEEEAAAQQQQAABBBBAAAEEEEAAAQQQaE+A4GN7flyNAAIIIIAAAggggAACCCCAAAIIIIAAAhkCBB8zYDiNAAIIIIAAAggggAACCCCAAAIIIIAAAu0JEHxsz4+rEUAAAQQQQAABBBBAAAEEEEAAAQQQQCBDgOBjBgynEUAAAQQQQAABBBBAAAEEEEAAAQQQQKA9AYKP7flxNQIIIIAAAggggAACCCCAAAIIIIAAAghkCBB8zIDhNAIIIIAAAggggAACCCCAAAIIIIAAAgi0J0DwsT0/rkYAAQQQQAABBBBAAAEEEEAAAQQQQACBDAGCjxkwnEYAAQQQQAABBBBAAAEEEEAAAQQQQACB9gQIPrbnx9UIIIAAAggggAACCCCAAAIIIIAAAgggkCFA8DEDhtMIIIAAAggggAACCCCAAAIIIIAAAggg0J4Awcf2/LgaAQQQQAABBBBAAAEEEEAAAQQQQAABBDIECD5mwHAaAQQQQAABBBBAAAEEEEAAAQQQQAABBNoTIPjYnh9XI4AAAggggAACCCCAAAIIIIAAAggggECGAMHHDBhOI4AAAggggAACCCCAAAIIIIAAAggggEB7AgQf2/PjagQQQAABBBBAAAEEEEAAAQQQQAABBBDIECD4mAHDaQQQQAABBBBAAAEEEEAAAQQQQAABBBBoT4DgY3t+XI0AAggggAACCCCAAAIIIIAAAggggAACGQIEHzNgOI0AAggggAACCCCAAAIIIIAAAggggAAC7QkQfGzPj6sRQAABBBBAAAEEEEAAAQQQQAABBBBAIEOA4GMGDKcRQAABBBBAAAEEEEAAAQQQQAABBBBAoD0Bgo/t+XE1AggggAACCCCAAAIIIIAAAggggAACCGQIEHzMgOE0AggggAACCCCAAAIIIIAAAggggAACCLQnQPCxPT+uRgABBBBAAAEEEEAAAQQQQAABBBBAAIEMAYKPGTCcRgABBBBAAAEEEEAAAQQQQAABBBBAAIH2BAg+tufH1QgggAACCCCAAAIIIIAAAggggAACCCCQIUDwMQOG0wgggAACCCCAAAIIIIAAAggggAACCCDQngDBx/b8uBoBBBBAAAEEEEAAAQQQQAABBBBAAAEEMgQIPmbAcBoBBBBAAAEEEEAAAQQQQAABBBBAAAEE2hMg+NieH1cjgAACCCCAAAIIIIAAAggggAACCCCAQIYAwccMGE4jgAACCCCAAAIIIIAAAggggAACCCCAQHsCBB/b8+NqBBBAAAEEEEAAAQQQQAABBBBAAAEEEMgQIPiYAcNpBBBAAAEEEEAAAQQQQAABBBBAAAEEEGhPgOBje35cjQACCCCAAAIIIIAAAggggAACCCCAAAIZAgQfM2A4jQACCCCAAAIIIIAAAggggAACCCCAAALtCRB8bM+PqxFAAAEEEEAAAQQQQAABBBBAAAEEEEAgQ4DgYwYMpxFAAAEEEEAAAQQQQAABBBBAAAEEEECgPQGCj+35cTUCCCCAAAIIIIAAAggggAACCCCAAAIIZAgQfMyA4TQCCCCAAAIIIIAAAggggAACCCCAAAIItCdA8LE9P65GAAEEEEAAAQQQQAABBBBAAAEEEEAAgQwBgo8ZMJxGAAEEEEAAAQQQQAABBBBAAAEEEEAAgfYECD6258fVCCCAAAIIIIAAAggggAACCCCAAAIIIJAhQPAxA4bTCCCAAAIIIIAAAggggAACCCCAAAIIINCeAMHH9vy4GgEEEEAAAQQQQAABBBBAAAEEEEAAAQQyBAg+ZsBwGgEEEEAAAQQQQAABBBBAAAEEEEAAAQTaEyD42J4fVyOAAAIIIIAAAggggAACCCCAAAIIIIBAhgDBxwwYTiOAAAIIIIAAAggggAACCCCAAAIIIIBAewLD7V3O1QgggAACCCCAQP8KLDznsjmH7J6/rDSUnphaemBSSsbScnqQJbY4MTtINUvNNlpqa5NSstFS/UkfTM1uHR/Z8r0NKy/b3r+1p+QIIIAAAggggAACCHRfIOn+LbiDJ5B6+/4u7eBrsI8AAggggEAXBY566YrjhvZLT7fUTkvS0rOToXRGK7crm01aOV1tJfv+8KTd8Mtr33ZTK/lwDQIIIIAAAggggAACgyxA0Ku3rUvwsbfe3A0BBBBAAIGKwOJlK+bvP698fjKUvNUsOdxnedqMh+2Zc8Zt/tBuWzCyyw4e2WkLh3fYAcO7K8kemZxhGyZn20MTs2zTxEzbPDXD1uw4xP5r94E2lT72VWoqtY2l1D69dbNduXbVRZv9e7CPAAIIIIAAAggggMB0FXjsG/N0FehtvQk+9tabuyGAAAIITHOBxed8dGzu5Ohbzcpv8WoJnQAAIABJREFUKiXJPHGMjW63E2Y/YM+c/UDldd7woy0pbZ8atZt3HGq/3HGo3bh9kY3vmVPJJ03T7WmSfmHb0NTla1deMt5S5lyEAAIIIIAAAggggMCACBB87G1DEnzsrTd3QwABBBCYpgKay3Fsau77k6mhC9yw6mNnjdt5h9xueu3GdtvOMfvXjUfZz7bt7Vi5d1h2+UvbNpcuoidkN8TJEwEEEEAAAQQQQKAfBAg+9raVCD721pu7IYAAAghMQ4HKnI6jtrJUsiNV/efNXWevO3iNaXh1L7Z7di2wf964xH687QgrV4Zlp/dN7Cmde9d1F67uxf25BwIIIIAAAggggAACRRIg+Njb1iD42Ftv7oYAAgggMM0Eli5fcWFaso+VzIaPnLnJLjn0p6bXPLb1e+bah+57vt216yCr9IK09H1rvn7tR8xWTeZRHu6JAAIIIIAAAggggEAeAgQfe6tO8LG33twNAQQQQGCaCGiY9aLJ/a+2JHmZqvzKA39l/+uQm200KecqoAVpvvjQM+0rDx9d6QVZLtv3to1MvI65IHNtFm6OAAIIIIAAAggg0EMBgo89xDYzgo+99eZuCCCAAALTQGBv4HHe9ZbYyfsPP2rvXPQTe87c+wpV81t2HGqX3/9c2zAx29Kp5Ndbt6TPYR7IQjURhUEAAQQQQAABBBDokkCpS/mSLQIIIIAAAggg0AOBZcOLJvcGHo/Yb6v9/VOuK1zgUQjHz37APvuUb5nKmAylT593gP2bgqY9AOIWCCCAAAIIIIAAAgjkKkDwMVd+bo4AAggggAACrQssG176irOuVo/HBcO77ROLb7CFIztaz67LV7oyKgCpMleCprZsuMu3JXsEEEAAAQQQQAABBHIVIPiYKz83RwABBBBAAIFWBY55+fJ/SszOdkE9vRZ9c2WtBEkTO7kSPC16oSkfAggggAACCCCAAAJtCBB8bAOPSxFAAAEEEEAgH4Ely1csH0rSV2uOR/V4rPQmzKcoTd9VAciPPem7plcFT4995ZWvbToTLkAAAQQQQAABBBBAoE8ECD72SUNRTAQQQAABBBDYK6C5EpMkvVJHfzH2i74KPLo2VLD0okU/rxxOldMVi5etmO/e4xUBBBBAAAEEEEAAgUESIPg4SK1JXRBAAAEEEJgGAmOT89+dJMmTlsx6yE6dd2/f1vh5c9eZ/gwldtD+ByQf7tuKUHAEEECgfwXeaGabzCyt/rmhf6tCyRFAAIHiChB8LG7bUDIEEEAAAQQQCASedsYVT7ckvbiUpPb2RT8N3u2/w78Yu8lGkylLrfy/nnHGx5/dfzWgxAgggEBfC7zczA7wanCat9/K7qvN7B4vmPmZVjLhGgQQQGDQBAg+DlqLUh8EEEAAAQQGWGC/oeTDJbPhVx94Z18Otw6bZmx0u/3ZwbdZKUmGRkaG/iZ8v+DHx5rZB81MPYVcryG9/qJ6Xu+zDa6Agip+u6v32FOarG747BCoaRKwxeQHRj63ri2/YmatfHb1d4Hfg9Dlp0BcK/m1WLXcL/uAmT3VK8WbzOxk75hdBBBAYFoKEHycls1OpRFAAAEEEOg/Ac2LmCTJS9RT8E8Xrum/CmSU+OwD77KZpQlLLD39yJdcfnhGsiKdVuBCAYpbzeyvzSzsKXRi9bzeVzqlZxt8AfUee30T1VRAKnx2mricpG0IPKOG/avM7IdNfm4vqX7m/R6ErngKxE2ndvYDj86AVwQQQGDaCxB8nPaPAAAIIIAAAgj0h8DseVNnJ0my30lz7q8E6/qj1PVLOZqU7eS5/1NJOHPGSNFXvnY9phSgaGRTurMbSUianghofjvXI02v6pXW6nZd5MJGnwtd+ieR62N5RpL17JR6rPm9+bQ/CL34nltHUEHEZj63b6iT3wvrvD9Ibz8ySJWhLggggECnBAg+dkqSfBBAAAEEEECgqwLDpaE/1w1Ombeuq/fJI/M/mr934ZxSkv5pHvdv4p5vMzP1bGxmm9dMYtJ2VUDz2/lbO720vm1mYaBF+TUanHuxX5BqXsqzSJuCdH5vPu3PLVIBu1iW8xvMWwHadp6jBm/TN8nebGa/9Ur7ITNb7R2ziwACCExLAYKP07LZqTQCCCCAAAL9JfD001cstsRO9nsJ9lcNapf2hNkP2LzhR82sdMxRL11xXO3Uub2rXo8aZh1u76wGHxIz058/NrPPhok4HkgBDasPt0YWTtLckGEQO5ZXmDfH3RP4lyBrtU8jc3i+JrguzCd4e+AP9RwfWf27UH8fvnvga0wFEUAAgQYECD42gEQSBBBAAAEEEMhXYHg0PV0lOGHO+oEacu1Uh5LUTp67t0fn0H576+reK9Cr5okLNwUZP2pme7tu7n1XvdfU++f5ZnaTmQ1eV9VQYfoex4ZJN9Jj7tQIWSyvSDJOdUngmki+jQy91urO/hbLx3+ffQQQQACBaShA8HEaNjpVRgABBBBAoN8EkqHSk1Tmp87QlGuDuR06um1vxVI7rI9quLZGWTXU8KTqojNhsnCVYy1YkbWpJ5E/T6FW1Q03P40/j6F6aypvrcDt8tD7WlW5Vq+uTufnl1dl0tyLMvDnE1T5VE6Vrd7quP7cjcrDpX+pV1edl5Xq6eoeW/jDvedeGx02rTrFhl430mMuDFBq+HZsyHWWldpQbeTq7ftm7ctBHv6zICPlEwbQlL88Lo9k9mPPU2nUFlmb8lX+Lj9n7Mof3jfMp5l2Dq9t9vi+6o8F/nX15nJU+f1h6WrH7/oZ1NlX++nzqc9CaCQrnXfPcJ2s9r3tzP3Pltq82XyUofLy/65SGfX5rPUZUZuF995XuOpOVrvW+vuq1j39/Dv1mYk5ql7yUPl1HzYEEECgYQGCjw1TkRABBBBAAAEEchNIy5VVoA8Z2ZFbEbp947GR7dVbpP2w4rXjUHCilf+EhkGwWgtShIuYnOBu7r36adz8c/rP82+qASR/iK/ef1M10KI0sa3T+bl76D/tKtPnqisA+4EbpVE5VTYFuPSf/Cxbf+5G5aG5CVWXb3nDmXVew+QXuZs3+Bq2Tb3LFFwLt1jPRpdGdfLbQ+djebj2i1mpDdVG9ZzcPRV40jx88vDvLSPlc3Xg7Z4hd32tV78tXDoF1RSoUr7KP8zPlV/vK11WYMnPu147u3u38/qF4GKVM6tsSro8SK92fDg4l3WoIJ7aTwFePXOhka7TebWZ2i7rs+ryVzl9c3m5TW2ufNQTu14+ukZ5KWCp9vE/DyqjPp+31shHbRbe25XDvcbaVT8c1Pr7qtY9Xb6d+MzUclS95KHP5KfdTXlFAAEEGhEg+NiIEmkQQAABBBBAIFeBUpIsVgEO36/aOzDX0nTn5gtHdlYyTkpDY925Q9u5ro/koP+M/2eTPdAi2XT8lP4TrsCBHwQIb6L3lKZWcMVd04n8FGzRf9prlcndT6/6T36tAKSf9pxqXfxzvdqPDZcOezb6ZYkFJj/vJ6gGduq1n7uknpMCYgo81duUTyPDjOvlo2dFQbVYMC12rdL9sMHnsNvt/NVIARUwj23qSeoH6ZUm9izErtU5BfGa2fQ8KEAX2/QZVnCunrk+e/oc1tvUHn6QOpZe5anVezp2TdY5tat+OKj3d0Otv68a+TvK3T/rM6MfBlT3eo7KZ77LjFcEEECgEQGCj40okQYBBBBAAAEEchUo297egIcMu96BuRanKzdfOFwNPtreXp5duUl7mWpex+9EstB/VBVsUU8h/Qe4CJv+k97oFhtaG17bbn4KmjQbbFEZFAB5f1iYyHGtQEksaBzJYt+pWBvvezOy0+zQ67C3nHq13eblq0BSM966VPV/vZeH29WQ3jBA5t6LvbqV2f3VimPp/HPf8A4UjGokuOVdUtlV0Olr4cnIca12jiRv+pR6LYYLxmR9psMgctbQ+aYLUeOC90XecwGzyFvRU/UCfLqokTRKd3H0Ds2fbKZdY8HgTn1mFHxvtO7N15IrEEBgWgsQfJzWzU/lEUAAAQQQ6A8B1/NxbHRwg4+P1S0p8rBrrWytIENs03+gFTTSvGAK+mQNGY5d261zCqRp4RutOqsgaWwVbvUCaqT3o8rYan5filRQeWllc7dKuPbDwI8uU9Cy1R5WaisFjd09YoFF95579QOBkWJHT8WGTT8rklLPRBgMDOscCwbHVlQPn8N3BffTvcJzSqL76VlQfQ8yswsiz7RbrVj3DTf3PDkvv9fmhyLBGwUytQK8S697x/LV+axAX1iG8Di0CN9v5jhcMEbBqFiPw3cEmcY+W0GSxx3qWZSNzOTj2sQ56VwYBI4F6RR0DgNm8jjXM9dnK/bsP65AwYHfbipbrH6ttldwq32Hrd6zU58Zfzi4CqXy+O2ifbnKcvO+UrODAAIINCBA8LEBJJIggAACCCCAQL4C5TStLGwyvmdOvgXp4t0fq1uqhR+Kuikw9YJIsMYvrwIB+s9w3sOxFSzQKula+EabgnBahTsWhFAAst7Wan4KUITBEZVBZfMDfdpX2jAYp3KFvcyyyqprXUBTr6/NStjh87HhtmEPx6x6/KtXFgVZw7ZQcCq2ovqZ3nXalbG/AI3MQnf5yNitzq6efgoeKqil+QC3BHk2c6iyh4FVBcH+IFhMR/dWfRT0DLeYWZhGx91s59iCMX8WFELBegWi/M1vR/981r6efwV53131cW3i0qtH7d+5A+81/KEgtiiO/o7yA+L6bOl+sUCzl/W+XT0Lfru5vzvCYKier079yNLqPTv5mdkHUN3R8+u3i/blKstOB17De3OMAAIDJkDwccAalOoggAACCCAwiAIlSyoBuQcnBzf4uGFyVqXpUisVOfioMuo/8grWxHoC+Y+fghMajp3Hf1L1H3kFGmPbVZGTx0fO+afaye8UP6Pq/icj59ypD7sd7zXskeS9tW9X7SFrF9DUa2wF6X0XdHAnNvRagbgwMBNaKJjjyqvixHpLXp9RThdU9t/WwjtuC++l8zFbnVdQRSuz+70YXT6NvsbKrjbJWoBF9wp7LIbBy9i9u93OsaHXYVuGQ3/DdoyVO+ucgmdZK17HevTN9TLStWEQVIFZ/5nyklfad4F/ImNf9Y21m/IOt2eEJ1o8bvWeseeu1c+MH2hUNfT3vOad9YP6LVaPyxBAYLoLEHyc7k8A9UcAAQQQQKAPBKaqwcfHegf2QaGbLOKGiWrwsTw13uSleSTXf1IV3NN//BUMCYMofpk0B56CBL3cYoEDd/9fuR3vtd7iCe3kF6t7raBgVuDEK250NyvYGk3chZN+TzOXfdhjMwxEh8GcI9yF3qsC2GnGHy/ZE3Zj7q3aPiHzyIlY2bOCQO7yG91OE6+9aOdw6LWK57dl2I4fa6L8LqkC0/q7QYFLBRnV4zUMJLq0Wa+xldxvyUrcxPkwCOcubadnrMsj67XVe8aeu1Y/M1+OFE7tovy0kriCxLHPVeQyTiGAAAKPFyD4+HgPjhBAAAEEEECggAKJWXXY9ewClq4zRdow4eq2t5dnZ3Ltei4uCPn71XnsYkFIDU2MLQbS9cJl3KDTAahO55dR7MKfrjf0WvMGhsOgmx2qWw9hcb0EvN+QgIZeh5/l86pXKvAYtmNsqHa9G6lHXSuLMNXLl/ebE/A/M+pNrDkdY5sCwwoSK1j8wVgCziGAAAK1BAg+1tLhPQQQQAABBBAohkBq96sgax+t10GtGMVtpRT37dl/72Ule7CV63O+Rj0DNY+d5lrTf07D7YTwBMcDJ1Bv6PXLghq3M1Q3yGrfYRgw2/cGO00J6PMc9mRVDzj1egvnpdSUBFm99rJuqgBmbPGYrPSc755A+JlRu2tRpdjf464Ufx15Ptx7vCKAAAJRAYKPURZOIoAAAggggECRBMoju9RLxm7cvsj2pIP39WUqTWz1tr2j5yYn0u8Vyb7JsqgX4F81eU2vk3d6/rJO59drj07eLwxYKW8t3KEtHKobDrmuJmv5RUGUn7R8NReGArGerOrBHM5L+fHwwgaOXS9KP6meh3Al8diq4P417LcnkPWZUQ9ILQak9siaVkPPQfiZbq80XI0AAgMtMHjf3ge6uagcAggggAAC01PgzpWX3pNa8vNd5RH72bbfGziE23aO2ZbJ/axctnt+9W9v/3mfV3BrAcofLnTiF+lo/6C6f3PknH+qnfw2+xlV98MVe/0ksWBmsz3L/Px6uR+bM049HlXfcKhuo0Ouw4BUYmaxP1pIpNZcmnKo5d6uU2w+wNiz5u6jZypcLKRWbzN3Xa9eYz1Z1eMt3FoZch3WW70nFciKLSIU3q/ecb3Fo+pdPwjvd+ozo/bQHKOaVkNByHALe8GG73OMAAII7BMg+LiPgh0EEEAAAQQQKLJAWrZ/Vvm+t/nJRS5mS2X74ZbqtFul9B9byqA3F2lxCPVArRfA8VccdiULA3DhUD83pNOld6+6ZyubhnTGrlXA5x2RDNdEzvmn2snvh35G1f3YKr4u2Xvcjvf6I2+/nd1YkLVeezZzPwUrwgCagkp/EmSSNeT6p0E6Hcaep0iyJ5z6wRPOmF0aOadTei7Ua1MLavjbHf5BdT8roBj70UCra2cFrtWLMAzI/nvkfnmeivVk9cuj3oq1FmPy0/r7Yb2z8qgXSIwFK9UjL+uZ1ryjm/yCDMB+Jz8zWRxqHwUhw8/24M6DkiXBeQQQaFmA4GPLdFyIAAIIIIAAAr0UGN08+ZWy2eQvth9m6gE5KJuGXP+4OuR6YmfypQLXS/O9KUh4azVQo6CSv/Kp/sOv4E0ssBaunhtb5VeBDJefev/9os0FKbSYhR8sVd4KYMdW1G2k91ar+cXylqMCO36QRPsqr97zNwVq6wWB/PS19mO9897oBcgUnMkKltXK138vHE6tQFPYYy5M465XMCkMTOt5UiA57BGq9tQ5LX6hZyU0+o7L1HtVYErp3HOmuuo5/s/qcOIXemm1G+vFe753vdrMtaGmHAiDM6q72lSubtO9VebY5+TzLlFBXmNDr/2ihZ9r/71a++rp6G965vUcuk1eatNwiLd733+NPUsK+Ktd3aY20jP0rWrAN3yWXLp+fO3kZ0afDbmrLXwjfU7UJupd7G/hj0r+e+wjgAACjxMYftwRBwgggAACCCCAQEEFbl518cYlyz9+3Z7S0PKvPfwMe+3C2wta0uaKdc2mp9vWyf3MUlv96xsuqqzq3VwOuaRWUKCRwIAKpyBQGBj6RiTIpt6FYfCm3copqBEG88I8NZwwq+dVmLaV/DRkWvcIV/Zt1FA9jjq1rYtkpHL5ZbvAzNoJgmk4dRhsDG/7D+EJ7/gjkcBcWEYv+b7dsA0VDNSzF7Z/o+7KeP2+3B/bCZ9TBb9coEu9Vq9+LGllT+kV9Kq36Rkp2srpbuh12FNRdWknKK4ennLxt8+Zmf40u30q8neRyqt2CNui2bz7JX2nPjPqyah2Cdsmy6HV4HNWfpxHAIEBFqDn4wA3LlVDAAEEEEBg0ASGy8kH1fvxnx5akq7fM7fvq7dpcoZ98aFjU1VkYiLJGhJalHq20stFPZz+NFKBr0Z6uEWSVU6FvaSy0vnnw95z/nv+voKd7/VPZOy3m5/u0Uo9FJAKA7cZRWzotHph1qvLvIZyyk4U6wHop5ZDrTkstWq66t2JTYHbevX17xMOS1c5Yz0o/Wv8oadqq1bKLpNGnkP/vr3az6pPO8+lgs/NtEutuqrn34dqJYi896vIuX4+1cnPTKMOembbeQYavQ/pEEBgQAQIPg5IQ1INBBBAAAEEpoPAL699201m5U9N2FDyyQfcIrr9W/PPjD/LdpZHk3I5/dJd110Ym7+sSJXT/HX1AjF+eRW0OD2jV6F6qb2gTgBCwQn1wrvIz7TBfQ3rPrdOWgUeX5lRvvDSdvNTfWXRqJ+reyd7PapOKke9PGO9I0OPesexobDumi+4nRqvKmOzAaVYcFzBQz1njQR+1TafiJRJKy7XCpSFgdRmy656Zn1OIsXp+amshYHqDcmuVVCZyamWq67X3yGNfGbebWaNrIyt++nvhbCXbK2y9st7zT53qlfsM9NIfdUmembZEEAAgYYFCD42TEVCBBBAAAEEECiCwLZNpfelU8n4jdsX2X9sfVIRitRSGW7Zcaj9YMtiSy3dPLq53EqAraX7tnGRerTpP5zHVQNDYVBA/7HXOQUBNK+i/jNc6z/5yk/D+xRg8IdbK1CkgIze0/BfDX313w+DPVlVUq8clUP5+0EOlVFBTUWvmxnm2m5+LgCplWhVvyw/lU2ry9Ya+qxh6/7WSHDNpVc9VAYFCH0X5aG2i81R6a5t9FU92/w2c9fpXKP5K6Ck9lOZZOWXVfkpL/e8/bE39Nndy72qjU+qBp3COisPPR/yyAoAZj2n7tor3I2813plV7n1DKh+Spv1OWmnnb3iPGFXi5So/G7T/jZ3ELyq/mEwWeWvtbK4/zyq3cJ66BZ6DvUZl4NfFqXX/dQm+jvE/7zrvdhQeOWn3n/yVH7+/fWeyus+V7qvv4VlC6/102oBIv85VLnD8jSSXyNp3H0buadLW++5U3lrfWbkLSel8dtE+cul3mfFlYNXBBBA4AkCyRPOcKKbApVhVZEb0A4RFE4hgAACCCCQJXD0yz/26uFk+OoFw7vtE4tvsCP2i60LkXV1/uc13PrNv31p+tDknGRqMn3THde+rZW5zvKvSHFKEH7H0n+e2+mZ0+n8iiNFSRBAAAEEEEAAgR4L0POxx+DcDgEEEEAAAQTaF7jzG+/4ylSafEVBvHf87lTTa79sKuvb1p5uCjyWy+mqO669tpFhqP1SPcqJAAIIIIAAAggggMDjBAg+Po6DAwQQQAABBBDoF4E7vnHN6xS82zAxuxLM64cA5K7ySKWs6x7dv7K69fjI1jPMVk32iznlRAABBBBAAAEEEECgWQGCj82KkR4BBBBAAAEECiKwarISvEtttYJ56k24ZXK/gpTticVQ4PFdv/sjU1nTqeTX64e3vGTDysu2PzElZxBAAAEEEEAAAQQQGBwBgo+D05bUBAEEEEAAgWknoOCdgngK5imo94Z7X2Zrdh5cOIe7dx9or//tGZWyqaxbR/e8gMBj4ZqJAiGAAAIIIIAAAgh0QYDgYxdQyRIBBBBAAAEEeiegIJ6CeZbaag3BvmjtafaPDx1rU2kx1nP78sZj7M33vtTG98yxctluUlnXrrxkvHdC0+JOWoXV3272D1rY73R+LRSBSxBAAAEEEEAAgcEQKMa38sGwbKQW4cqJ7hrawUnwigACCCCAQMsCy4aXLj/rPWnJ3l0yG14y6yG79LDVNjaaz8hmBUIvv/+5dsuOQys1SlO74vZvfPNS5nhsuYG5EAEEEEAAAQQQQKAPBQh69bbRCD721pu7IYAAAghMQ4Fjlq9YNlRK/8ksObyUpHbqvN/a6xausUWj23qisX7PXPvXh4+26zc9NZ2woWQqtY2lqYnX3X7tJTf0pADcBAEEEEAAAQQQQACBAgkQfOxtYxB87K03d0MAAQQQmKYCJyy74qA980srrJS8Wr0gxfC8uevszxfebkfO3NQVlXt2LbCVDx9l39/6ZCtXh3ynZl/dOjTxlwyz7go5mSKAAAIIIIAAAgj0gQDBx942EsHH3npzNwQQQACBaS5w9DkfPrI0sd9bk7R0fjKUzhCHgo8nzH7Anjn7ATtu9riNJuWWlPakJfvVroPtF9sW2U3bDzUtKqOtbDZp5fKXyiN7PnjnykvvaSlzLkIAAQQQQAABBBBAYEAECD72tiEJPvbWm7shgAACCCBQEVh8zkfH5k6OvjVJyhcklsx3LAo8HjPrQTtq1gY7ZGSHzR9+1PYf2m0Lh3fagpGdlWSbJmbZhslZtnVqhm2fGrX798yxu3cdZLfuGDMFIN2Wpun2NEm/sG1o6nJ6OjoVXhFAAAEEEEAAAQSmuwDBx94+AQQfe+vN3RBAAAEEEAgElg0fs/ysk5MkOc3S9EWlkp0YJGjysHxHOR26zsrp99dsuW21rbpqd5MZkBwBBBBAAAEEEEAAgYEWIPjY2+Yl+Nhbb+6GAAIIIIBATQH1iJxXHn1RuWxHWzo1lpSGxsxsfpqWx5JySfuWlsrjSVIaN7PNaXlq3JKhcUvT/9o2MnEDPRxr8vImAggggAACCCCAAAJG8LG3DwHBx956czcEEEAAAQQQQAABBBBAAAEEEEAAgRwFHpuoKMdCcGsEEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEDqu2djAAAgAElEQVQAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBExgevCpRIwQQQAABBBBAAAEEiiuw8JzL5hyye/6y0lB6YmrpgUkpGUvL6UGW2OLE7CCVPDXbaKmtTUrJRkv1J30wNbt1fGTL9zasvGx7cWtHyRBAAAEEEEAAgccLJI8/5KjLAmlG/rRDBgynEUAAAQQQQACBQRA46qUrjhvaLz3dUjstSUvPTobSGa3Uq2w2aeV0tZXs+8OTdsMvr33bTa3kwzUIIIAAAggggECvBAh69Up6730IPvbWm7shgAACCCCAAAL5CSw7b8bS+cdekJTSt5slh/sFedqMh+2Zc8Zt/tBuWzCyyw4e2WkLh3fYAcO7K8kemZxhGyZn20MTs2zTxEzbPDXD1uw4xO7aVekYuS+rqdQ2llL79NbNduXaVRdt3vcGOwgggAACCCCAQEEECD72tiEIPvbWm7shgAACCCCAAAK9F6gGHS1N3pkMpWMqwMKRHXb87AfspDnr7YTZD9i84UdbKtf2qVG7cfsi++WOQ+3mHYfa+J45lXxSSzdbOfm/BCFbYuUiBBBAAAEEEOiiAMHHLuJGsib4GEHhFAIIIIAAAgggMBgCy4aXLj/rLX7Q8aiZG+3chXfY8+au60oVb9s5Zlc9uNT0qq2cpluSNLny9mu++QGzVZNduSmZIoAAAggggAACTQgQfGwCqwNJCT52AJEsEEAAAQQQQACBogkc+ZLLD589Y/RqS+xkle3YWeN23iG3V157UVYFH7+68en2k21HVG6XpumtU8OPnnPnykvv6cX9uQcCCCCAAAIIIJAlQPAxS6Y75wk+dseVXBFAAAEEEEAAgdwElixfsdyS9KpSksxbNLrN3nnYT2zJrIdyKc/duw+0y+9/rv337gMsKac70qHSBbd97cIv5VIYbooAAggggAACCJgZwcfePgYEH3vrzd0QQAABBBBAAIEuCiwbXrL8zBWlUvIW3eSF89ba2xf9zGaWJrp4z/pZ7yqP2GfGT7RvPfL7lcTlcvmq8ZFtf7lh5WXb619NCgQQQAABBBBAoLMCBB8761kvN4KP9YR4HwEEEEAAAQQQ6AuBZcNLX3HW1YnZ2aPJlL157Bd25oK7C1XyH2xZbFfc/5x0dzqSlMvpqjXXXHsq80AWqokoDAIIIIAAAtNCgOBjb5uZ4GNvvbkbAggggAACCCDQFYElyz/+xVKpdN6C4d32kSO+Z0fO3NSV+7Sb6bpH97e3rT3dNk3OsNTsq/+vvXsBtiwryAO8zu2ekccMMyADLRqcqLEgMoCA+AIyPhBiFMESFSQVKlKCliZA8dBoIsQgakAsMYoGS1KloGIUCSrGByMiGnwEZ8AYREWCMDDymAczw0z3Pan/zt2wWKxz7jn3nnt7393frpo6++zH2mt9a5+G/nvtva785V99nADyoKrOJ0CAAAECBNYR2FrnYMcSIECAAAECBAgQONcFLvvaF74owWMer/7ef3TFaIPH9NM9P+m68sOXvnbnUfCM0rzvYx794nO9/7SfAAECBAgQOFoB4ePRersaAQIECBAgQIDAMRa479e88BlbZeupJ2bz8j2f9vtnbWKZdQgTQP7Ap/9OyePhs9n8Kfd9zIv+8zrnO5YAAQIECBAgcBABj10fRG/9cz12vb6ZMwgQIECAAAECoxD43Ef98INOn5z94VYpJ5/9qW8sj7j47aOo16qV+L3rPr1837seVrbns7J9pjz8ql992m+veq7jCBAgQIAAAQL7FTDycb9yziNAgAABAgQIEDiHBC4/eebk1osTPD76Ln957ILHdNQ/u9Pflcff9aqdPpuV2YtLufzkOdSBmkqAAAECBAicJQHh41mCd1kCBAgQIECAAIHjI3CfRz3qSbMy/4JLzvtw+dd3e/PxqXhT0ydccmW5x/nXl9mJ+b0ue8yjntHs9pUAgaMXeEgpJcOo85Rc/sv6Zxx9NVxxhALujRF2iirtT0D4uD83ZxEgQIAAAQIECJwjAg+8/AV33TpZnp/mftupPykXnLjl2Lb8/Nl2efo9/min/rPtre+91yNfdOmxbYyKE5iGwBeVUj6zakrW71F9t3ruCrg3zt2+n1zLhY+T61INIkCAAAECBAgQ2KTArXc++X2zMrv4Cy98186jy5ss+2yU9YA7vqc8/KK/yejH2528/WwnVD0b9VjjmhkFVo8MG0aItZ8fKKW8tpTyvFLKV65RvkNvE7jfAucfL6V88h5IbR8ZvbcH2CHsTh/l/m9/F9mWvt1rqc/Nb8lvaC8x+wkQWFlA+LgylQMJECBAgAABAgTOOYHLn3i7UrafkHZ/x6k3Tab5Tz71JyUzdm9tl0df8tjnXDDyhj24GRm2qLp3LqU8opTy70opv1ZKSYDyrEUH2/4JAl+/wPlbSylP/4SjP35DRuoZvffxJkf97fN37//2uvlNvLTd2Pme44Ylv6X7DF98EiBA4KACwseDCjqfAAECBAgQIEBgsgKXXXy/R85mswsuu8P7yqnzb5hMO+9y8uZyvztcvTP68W63XPCNI2/YPfdZvwQoP1hK+eMVRu7t8xKTOu2BS1qTQNd7CJcAjWDXsrDwQaWUsf3On9yM0sxoWQsBAhMVED5OtGM1iwABAgQIECBA4OAC89nsG1LKw+70dwcvbGQlfMlF79ip0dbsxE4bR1a9TVYnwUseKd3r0eFNXnOKZX3dFBt1DrXpiSNr62Oa+tQjZ5tdvhIgcNwFhI/HvQfVnwABAgQIECBA4FAE8jhyHktO4Q+70zsP5Rpns9CHXPjOnUevy1a5PJPqnM267OPazy6lzKr/Uv+HllK+v5TywU55CSD/S2e7TasLfKcAd3WsER6Zx6oze7KFAAECRy4gfDxychckQIAAAQIECBA4DgJ3u+WCR2ZSljxyfcl5Hz4OVV6rjhed/MjOo9dbpZy8+aLbQta1ChjXwe8vpbyhlPLdpZQEjX/SqV5GeApfOjALNv1Csz2PsX9zs83X8QrkN/DXTfW+p/nuKwECBI5EQPh4JMwuQoAAAQIECBAgcNwEtk5s3St1/uzbJ9ea5pJgNcvW1skpPfL4N6WURy4YAfnte/Rk3muY2bLrmX8ze3DeG5lZn9d572GCzpyTc+sZiFN2JsJZ9hh4zs2EOcN59fv6su/nm/0psz5mj2autPviUspvNkducvTjQXwyE3Pts2x27dYyx7azP7fH5H2EWXJcrId+yHrdbzkvfRn/lDscN3xme+6nde6b3Usf+CMh/E81pWxy9ON+fis5Z7CpJ7gZqjnsGz6Hfmptl00kVfdXyll2bPYN18pn+qu3pM9zT2R/fd/lnOHPhtwLy5a6XmnPcB+lDkP78rmf33HOqeuV9cGurlOOSz3aY9OutG+oU32OdQIbERA+boRRIQQIECBAgAABAlMTmM23PjVtOnXedCaaafvorufdeNum+ZlT7b5j/j2J8bd12pDRj4v+gp2QKCPFMrlKG4wkyMmsz9mf45YtKT9/mf/93XNybr2k7EyE81dLgoYvKqVkpOGwZNKduty0o96fMl+xe91F7RvKWufzR5uDNzH6sW5HTPfjk8lV6vYnPM+M272ltcyxFzYHtsfkfYQJb15XSqnfiZr1e++em2A5fZy+jH8vwM/23E+5b/YTKjXVXPvrT3fO2MTox/3+Vhb1UaeaO5vil6W1TQjeW3Jv1f2VYxYdm33f0hTS++0klMtv9SW7/Vzfdzl9+LMh90J+970yclxdr7Qn91Huodw/Q/vyue67ORN65rdf1yvr11dty72cYDPHpR7tsXFO+7yaokKzulkB4eNmPZVGgAABAgQIECAwFYFZuTRNOXX+9B65HrroY4+Tz3baOmyfyGdG+PTe/ziER3UzEwIkJFplyXE5vrcMwdoQmvSOGbYlAEgYsEooddFusLFXudm/yQDh1zuP7h5k9ONh+Qymm/r8rN3gsQ5p2rITnK6zpK8zYvMol4TwP9FcMPfIXqP0mlM+7uumfisfV+geX3qvAOiN7Pv8Tjnpw157c/4Q+g2n/c9hZfczbU0ot+w+qE+J7bIAsj72Rbv/OFFvW3c9v6dXd056XCklI8Cz5JiE6G1bd3d/3EdGO1sIHIqA8PFQWBVKgAABAgQIECBw3AVm5cynpQ13PzndkY+XnLxpp5tm862pjXwcbr83DSvVZ0a51UtGNq0bJOX4XqCR4K8dyVdfq7eegCMBwbIlgeeq5WZkU69uy8pftu/fNDsTxOz33Y+H5dNU8cBfE9SsGjitc7HnrnPwho59QSeE3+/ox4P+Vt69ZpuGx/4TnrXLF7QbSilf3NmWTe1vPtt65/9idX6C4nX/XMjp+Z1+X1XOotVVf8+Lzs/2n+vcp5l0K//wMiyZpf4w7uWhfJ8EVhIQPq7E5CACBAgQIECAAIFzTWBeZjvh46nzJxw+DhPpbG3vtHWCffy7e7Qpod/zm2MyWjIjhzKDdmbUzudTmmPytX1/ZAK/+tHKHJNJP/5FNSt3Qq12JFqCgQQEqyypW2b6HuqWsnujO9u6rVL2omMy+nEIgYZj9jP68Sh8hvod5ufwOGtM8jh1wp70Q/q2noE927K/XjYRONXlrbKeEXA/0By4n9GPm/itpC6DUXtPpYrDvuHzz3fr/VtN/fP1SzrbvqKzLZu+tLO9PT+/o+F6OfxnO+ekzvev6pn1dlRmTktoud/3fH6oc93eprwrMv1YL/mzJZNu1UteIVAvuSfrezXr+fMubVv12nV51gmsJCB8XInJQQQIECBAgAABAgQITFDg4Z1RQU/YHTk0zDSUz5/cDf1qgjZofHy9czcUzDEJ74Yl4UveRdkGL21AMBxffyYcSWDyQ6WUoW4p+1H1Qbvrbd06h6y16T81R+9n9ONh+zRV3MjXOjweQpohoMqkRnk8O2FP+mF4zHW4cLa1E75kX+9x4eGcw/rMux/bkHrd0Y+b/K2s287YtjPYt/d4wtFF4W5CunZ0cRtU1qMF8yqEdrRgfrPp86H/04as59heABmvVZb8Y8IQBiawbv8xpFdGgvy8K7JeUr/ee27rY7Ke+6C+V7Oetqdtq7wCoi3PdwIrCQgfV2JyEAECBAgQIECAwLkmMCvzd6XNV99ywWSbfs2td9xp23w+u3qyjVzesId1dtdhYb37jfWX3fX68eY2zMgj3/Vf8uvT2xGZ7Qim+thhPaFoHXwM29/QGWGXfZsMuXKNNjBdd/TjYfsMHpv6TNiVQGa4H4aQpi0/I9wyCi3v+htmLR5mUG4DopzbTnbTlncY3xNWH3T04yZ/K/tpY/s+xpRR//5673usr1Pvz2+jDRdfXx3ca2s7+VJ1eDcwXOUfFDLiMP+YMPw5kXut9xuvr3Wnznsec69+U31QtT6UPWxKQJt7tbYb9vkkcGgCwsdDo1UwAQIECBAgQIDAcRaYlxM74eN7T084fDx9+90uui1oPc79taDumahl2dJ7NHIIjtrPzGa7bMnopXpJoNiWMXzvhVL1ub3163obd7e1o8KyedMhV2/046qPi6c+h+2zhGdfu55WjTDtFZCRdHlfZx5jTX+mv9s29s47W9t6ox/XeTx/k7+V/Rj8Ruekf15ta9/32I5GrPf33vdYP9rda+sQQleX/OjqXoHhRw+sVhLm16Mtq11LV/M4eBucZhToMBq6Pfnl7YbdezV/niUsT3Dea2/nNJsI7F9A+Lh/O2cSIECAAAECBAhMWmAY+Xjb6MApNnUY+VjK/B1TbF8p5YGddr2zs22/mzb5rsyDBAB/tt8GrHFeRj+2gc4z1zj/oIcexOeg1+6dn9Fj+5mQpFfWUWxLOPVdzYUSWh2V60F/K7n/2kfH69G09XoC4R9r2lrvb0clJghcFN41xZz1rx/o1CDvHV20xC0jLHtLwvIE5/F6Xu8A2whsSkD4uClJ5RAgQIAAAQIECExLYLv8fRp09a3THfn4D7fe4bY+m52Y6mPXvceZ/88Gb9RloxHXvcy1655wFo7PrNv1kvDiqN4TNyaftHnR+wVrn7Gt592lCZrq5Rn1l0Nc38RvpR0pmD7ICNT2fY95RDuhW73k2CFobf9c+JX6wJGv512dbQibEHnZY9Rxe2in7+um5rfd+tb7rRM4kIDw8UB8TiZAgAABAgQIEJiqwJn5mbekbW+7qZ2nYDotvurGu93WmPltQet0WrbTkl4olr+07+cRyR5NQpy/7O3Yx7aDjrzqzea7j2rseUreH9fO1t0+jr1nIfs44KA++7jk0lOe2NmbUaEJeIaZmvOZyUTGtrQTzRxkZuZV27ap30r9Xsbh2pnYpX6fY7YPx7UjdR+8IKSrH7keyh3rZ14H0o5gTV1f1plUp25DwthMkJR7NL/hNsDMsQkxe39u1uVYJ7AvAeHjvticRIAAAQIECBAgMHWB951/w2vnZ2Y3J6D72OPJ02n1tac/qfz5jad2GnTTRz7yqum0bKclSYx7odgqI3vq8GjZev4i307mUDMmMFt2fr0vE5vstWSiiUVLQpV22eQIz7rsF9Rfdt9zuJ9Hajft01TrUL+23nnnZkKbdrTdoVZin4XnN9COfsy7O9ttqxRf38PL1vf6raxyrRzTCwkzOUz9Psccl8mesrxu93P4yLFfNHzZ/Uy729/xh5pj8nXZBE69UYdtmZ0i970pI1jz+6mXjEJ+er1hwXru0cyK/U86/5CQUx694DybCRxIQPh4ID4nEyBAgAABAgQITFXgmlc+54b57Eze61Zef909J9fMN1x/z3JmPivb2+W33/4bz96ZXGcijcyjlem33uQfbXDWzjodgl6QsApNGwYkoNrksNlMNNELQJ7cmYAigcphvcOuN/pxlcBikz69R7Af3+mkeGVW7k0v7YQfi6wfsOkLb6i8dvRjjDL5yLJlk7+VXOdPOxfr3d/1YXFuJ1fKuxzr9znWYWIbViYgbkcJt6Mjc702tMy2ZZNEtZ45fhh9Wdd/k+u9UbV5dHrVP79imRCyDZ0v3mQllUVgEBA+DhI+CRAgQIAAAQIECDQC27Ptnb+Yvv66T2/2HP+vr7v20p1GbM/P9P7yfdwamJAvf+nOpAkJJ3rv48ukDO1opDYQS7tfvTsDbBuE5PtX7s5wnKAmoV+9tO+NS0D1v3ZHxA3vmhuOT10ThGQUWiaQaK81HFd/pryEIrnuEGpm/fn1Qbvrh92n/755bDOPa+61bNLnrZ2L5fHhoU/ik1l839wJZjunrr2pDcDyDsHh2iks98kf7z7GunbhR3BC7rv63s+91b4Hsa1Gffywb7+/lZzfC5DrezuGw30+XC+fL62/7P4jQ/17r+/9/N7rcK3Xzt4s2m1omUvGJ271bzXr+YeO1i6PNOfYw1zy+oheAJnHr+sl9ci9GNs6mIxtjO9SH1xK6Y36bA7xlcD6AifXP8UZBAgQIECAAAECBM4Ngbd+8K2vuu+d73vDVTfe7YI8en3JeR+eRMOHR663Szl9u2vLcXzkOqOQlo1EavspYdEPtxt33/+YUKUODxJQrFL+RU15v7QbBOb8Ycnoy1cMX5Z8XrhkX70rZb9k9796e7v+0+2GDX/PqKkfWLMPNumTR0cT8NTWaeIqNpugyIQmdeB1lNfeRP1TRl5LUN/3e5WbsGtTv5VcqzfrfALkegbxp5RS8ohxvfxR/aWz/gfNtvRVXWa9O/dQ71H5YXRve15C9lWC9owoPIrlh0opj23uxfyZk+A9+7JkJGPu1fZ+3d39CR/H8X8PPqERNoxPwMjH8fWJGhEgQIAAAQIECIxF4IqX3Vxms50RLD/53geOpVYHrsfPXPO5O49cl+3t1/zpFc/4hwMXOO4CEpjknYqLHo39ps6jnPtpUcr/kmZE4H7KWXROb4KI3rEJbNoRnr3jDrotAeeqdcq1Nu2T8HOVJXWsR7+tcs5ex6zb9r3KOxv7E7r1RjMuq8umfiu5RkYX7nX/tAF/zksIuqw/M9q4Xl5Tf2nWE0wuWjK6tx3huujYensmcznsUY/19Z5Wf9ldzz+e1CM0O4d0N6W9R1n3biVsnKaA8HGa/apVBAgQIECAAAECGxK48aZbnjufz2/43WsvLW+64R4bKvXsFfMXN921vPoDn10ymc72ebc88+zVZOUr90ZIrXJyAorH7RE8ppyEYgkn1w1ieo+NJhhJALksHOnV/frexmbbE1YIQ/JoeTtSrClmY1/j1pt1d7hAr02b9MnIrnbm7eHaw2f6NCO+9nqf4XD8qp8JdzO6ba/wLPVb975atQ6bOK732O5Qbu/+3uRvJWXtNUJw0W9/UWiY8Czl1ksbRtb7lo3yW7etuRcS/O/Vpvr6m1hPiJzffbusMzI85+Y+XWXiq/Y6vhNYSUD4uBKTgwgQIECAAAECBM5VgZ3JWOazjIIpP/KeLyi3zI/v/4XOBDMvfPcX7nTlfLb9gre+8rs2Hcocxm2SmWtXCfMSPOQv0AlU7l9KyQy7q47iGYKGh+7+Rb4XGKX8vE9uKH9RyJeALddO8JnwKee1S8rPvoQVeUwy5+y1XFdK+bzdcusyY5OyUvfv3quQJfvbdzL2JhhpT49Bgo82hMu2RW3apE+CnjjX/ZW6pJ+G4DlBYd2W7G+D0Tc2bYhpe0zb9txbCTbT1vr+HK6f/kj96lGo2ffupqD9XLspYudrW05t0js+29IXcarrn+05N4/J95ZN/lZiGKf0V2yGJfd3fme9dy/mmNx3bZ1z/guHAqrP1LcXsqaNi8ofTt+rrblmysnvOLNHL/ozIeXV76LM996EO8N1h8+2Txfdl3mlRNvfw/sycw+mftnfmsV5+LNj2ejwoT4+CexbYLbvM524H4H5gpP0wwIYmwkQIECAAAEC4xC4/OT9vvar/3cpW/d5/F3fUp509z8bR7XWrMXL/+E+5aXvfUDZns/fcdUHr7x3yWPlljEK5J1t7cilhDS999ONsf7qRIAAAQIEPipwfP/Z9qNNsEKAAAECBAgQIEDgsAWuOH3rLSd2Jh/4hfd/Tvm9Yzj7dR4Z/5n3fe4O1OzM6W8VPB72PaN8AgQIECBAIALCR/cBAQIECBAgQIAAgRUE/uI1T33DfF5ekEeXn/+uh5SrbrzbCmeN45C85/E57/xn89R9u2z/yJWvftZrx1EztSBAgAABAgSmLiB8nHoPax8BAgQIECBAgMDGBK78lac9cz6fveSW+YnynX/3ZeWdH7nTxso+rIJSx//wzi8tN8/Pm81L+aWrfvl/HIdJZg6LQ7kECBAgQIDAEQsIH48Y3OUIECBAgAABAgSOt8CVv/Kq70iId9P2eeXp73hkefctF462QdfcesfyXe/4svkHTt+uzMvstVf+8q8+rpQrTo+2wipGgAABAgQITE5A+Di5LtUgAgQIECBAgACBwxW44nRCvO3t+RUJ9Z709q+a/+61lx7uJfdRet7xmLq95/SFszIvb3jPiQ89VvC4D8izc0pmua1npl00y+3ZqZ2rEiBAgACBNQTMsrwG1gYONdv1BhAVQYAAAQIECBAYg8Alj33OBXc/ffF/PTGbf2Pq86i7vK1826k3lfNn22e1enmv40ve+6Dy399/7516bG9vv+rq867/l9e88jk3nNWKuTgBAgQIECBwTgoIH4+224WPR+vtagQIECBAgACBQxe47NEveuJsNn/xbDa74LNu/4HyrE95Y8nn2VjyCPh//H8PK2+7+ZPL/Mzs5vmsPPOqVz31x85GXVyTAAECBAgQIBAB4ePR3gfCx6P1djUCBAgQIECAwJEIfPZXv+Betzu59YrZbHb/XPCLL3xn+VeXXHlkIeTbb7pLeeX7/2n5nev+cdmezxI8/uXpW+eP+4tff9qbjwTARQgQIECAAAECCwSEjwtgDmmz8PGQYBVLgAABAgQIEDjrApc/8XaXXXzf7wgqKlwAABuVSURBVJ5tlW+fldnFqc+DL3h3edwlbyn3u8PVh1K9hI7/7Zr7lj+4/p475We0Y9ma/9h7Tl77XI9ZHwq5QgkQIECAAIE1BYSPa4Id8HDh4wEBnU6AAAECBAgQGLvApZe/6OI7XVyeWrbm/3YIIe/5SdeVz7vg73f+u+wO15Tbb926r2bcMt8qb7nx7uXPbviU8oc3fGr525vvvFPOziPWJ8685PoTZ37wHa981uEknfuqsZMIECBAgACBc11A+Hi0d4Dw8Wi9XY0AAQIECBAgcNYEeiFkKnP+7Ey59+2vKZfd8X3l7ud9uFx88iPlTiduLpecvLHc5bwbd+r7gVvvUK45fYdy3ZnblRvOnF/+/pYLyttuumt584dPlQSQwzKfz2+Yz+YvFToOIj4JECBAgACBsQkIH4+2R4SPR+vtagQIECBAgACBEQhcfvI+j/6ah8xms0eU+fzLt7bKgw5Wqe23bM9PvKZsz3/nqmv//A3lipfdfLDynE2AAAECBAgQODwB4ePh2fZKFj72VGwjQIAAAQIECJxDApc+9odOXbR9/pdvb5fPKfMzp2ZbJ06VUi6ez7dPzba3sl7mW9tXz2ZbeXz6Q/PtM1eX2Ymry3z+f68/79bXeqz6HLpZNJUAAQIECExAQPh4tJ0ofDxab1cjQIAAAQIECBAgQIAAAQIECBA4iwIfe2HMWayESxMgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLT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AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6yly09ILBRWWmH7P0AuM2pN09dKev2vJyTQsBAgQIEDj2At75eOy7UAMIECBAgAABAgQmIvCkph2/UH3/9VLKB6vvWf2W5nv79edKKZ/Zblzy/cJqX4LL11Xf91q9814HbHj/gzZcXopLmQl52yVB5je0G5d8v2h338s7xzy6sy2bPr+z/VWdbTYRIECAAIFjJyB8PHZdpsIECBAgQIAAAQITFMgowzZQ+8Wmne1IuASL7WjF4ZS8E/ERw5fq89mllLuWUma7weT3V/vq1W8upbSBYsLPx+2em/PvX0r5zfqkEawPAe0bd+uSAPcppZSHVvVe1vb7NG1ICPudzbZ8TbnxT1nxzDWGaw+Hv6GUkgmD6iUhZu9x+a+qD9pd/63ONpsIECBAgAABAgQIECBAgAABAgQIrC3Qvk+wfuR6KKz36PWidzX2HvkdHgceyhs+E1Tmsek6yOw9rl3vH87NZ8o96seuh0eUE8gO9cpnb+RiXdd2fShn+GwD3t57JdtjhjITKubR7dq59/h3vX84t30/5KJrDMf7JECAAAECBAgQIECAAAECBAgQILCyQBv2JTzsLW1I1Qspc15bXhsO9soetvUmvlk3DBvCvOFz0+98TLmLjIZ2DJ8JEHNsO2nNULf6s61nL8Qdws6h/GWfPcv23ZK9UHnRuyGXXcs+AgQIECBAgAABAgQIECBAgAABAp8gkDCrDsCyvmgEXy8M6x3blteGap9QiWpDRkK25+81uU11+s5qe/6y669ybC84bK/Zfo9LG8K212q/t/Xcz3XbevTKqB+97vXpslmx2/J9J0CAAAECoxbwzsdRd4/KESBAgAABAgQInAMC7WO4eXdgJpjpLa/vbOy9L7Bz2Dm1KcHjr6054c5hAb2sU/DXVdu+olrPat4n+f5mm68ECBAgQODYCggfj23XqTgBAgQIECBAgMBEBNpHbDPRSzsib/j+ik6b2/M7h5xzm350RC3OxDHtZDTDTOUZ9drOSG6W6xF1nqoQIECAwMEFhI8HN1QCAQIECBAgQIAAgf0KZIReO6v0umXl/N6j1+uWM5Xj89h4G+gl/MtM3cMM1ZmlOv8dxZJRjO07M1OPBI9f36mAWa47KDYRIECAwPEVED4e375TcwIECBAgQIAAgeMvsKlHpvcq58EHpHrAAc8/ytM/p3OxJ+wGgH/T2bfupnUmnBnKfvmwUn0mePyG6ntWf8Ij142IrwQIECBAgAABAgQIECBAgAABAvsSyKQi7ezVw+PV+/msJynpTXLSvltyqHTCtMzAnBGDw9K7/qLQLaMu29m0e+2qJ1kZrtObbKWd9CXH9tozlNF+ZnKctv5124bj0572uPbavbLaUYxDefHPvkWT87ST3/SMjGAdNH0SIECAAAECBAgQIECAAAECBAgcSCDvamzDr1Xf35iwcNm5CRrb/fmeYGwIKRMG5vsQgtWhWUK09vwcV9cv4V0dHtYBXy8sTJ2HADLH9tqQa7YBYJB75S3CT4DX1r2+9tDu9pjetXsBZY6Lz9CWeMZlCBd79U9d49u75rAtvhYCBAgQIECAAAECBAgQIECAAAECGxHoBXxDMLjXBXrhYsoblpQzhIpDuLXXZx0+Jhzc6/h2fx0+9urXHr/oey+8Wyd8TNsXlb3X9lWvvaycXhnpl4SVy85LkGshQIAAAQIECBAgQIAAAQIECBAgcGCBXkCW0XmrLouCrDq87I0AXBZ+tY/8Pm+PsKwtq7521lcNP9sRkL3wbp3wMYbr1n1oS+/asV61LSkn11609NoxXLv1X1SG7QQIECBAgAABAgQIECBAgAABAgSWCvQeuV70TsZFBbWhXUKs+rHonJdAa5XgbFFgttejwrlmym+vm2vnkeVl186+tLkdZdkLAHuh3SKXbE/42TtnCPqGercjNHvXHtrS867Ly3rOr0PYto69fh/q0h7rOwECBAgQIECAAAECBAgQIECAAIF9CbQhVN4XOLxDcNUC2+AsIVYvBEwYlmPbMC5hWkLHva6b/TmuDd9SXspdFrbl3DxOPLwPMXVsr5tj6v29x4/btqaMVZZ4tI+359yEqql3G5AuCmGHaw3l1aFq6p4614+dD8e3n7lm6xiTXpvbc30nQIAAAQIECBAgQIAAAQIECBAgQIDAUoEEjQkc6/88cr2UzE4CBAgQIECAAAECBAgQIECAAAECBPYSyCjPOnTMekZOWggQIECAwGQFtibbMg0jQIAAAQIECBAgQIDAuAS+rlOdn+pss4kAAQIECBAgQIAAAQIECBAgQIAAAQIrC+R9j/W7IocRkBkNaSFAgAABAgQIECBAgAABAgQIECBAgMC+BdpJhhI+ZjIcCwECBAgQIECAAAECBAgQIECAAAECBA4k0E40k1mvM9u2hQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[245]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">lime_explainer</span> <span class="o">=</span> <span class="n">lime</span><span class="o">.</span><span class="n">lime_tabular</span><span class="o">.</span><span class="n">LimeTabularExplainer</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                                                        <span class="n">feature_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>                                                        
                                                        <span class="n">categorical_features</span><span class="o">=</span><span class="p">[],</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;regression&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Global---Model-Agnostic">Global - Model Agnostic<a class="anchor-link" href="#Global---Model-Agnostic">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Importance">Importance<a class="anchor-link" href="#Importance">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[200]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">summary_plot</span><span class="p">(</span><span class="n">sh_values</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Local---Model-Agnostic">Local - Model Agnostic<a class="anchor-link" href="#Local---Model-Agnostic">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Decision-Plot">Decision Plot<a class="anchor-link" href="#Decision-Plot">&#182;</a></h2><ul>
<li>X values is the model output</li>
<li>X axis is centered on expected_value of the explainer</li>
<li>Y axis losts features is order of importance</li>
<li>From bottom to top<ul>
<li>Output starts at expected value</li>
<li>Each line is an observation</li>
<li>Each feature's contribution is added</li>
<li>The top line is the final predicted value</li>
<li>Color of line comes from final predicted value (blue - red gradient)</li>
</ul>
</li>
<li>Plot of a single observation includes it's values</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="All-Observations">All Observations<a class="anchor-link" href="#All-Observations">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[201]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">decision_plot</span><span class="p">(</span><span class="n">sh_expected_value</span><span class="p">,</span> <span class="n">sh_values</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="n">feature_names</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Single-Observation">Single Observation<a class="anchor-link" href="#Single-Observation">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[202]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">decision_plot</span><span class="p">(</span><span class="n">sh_expected_value</span><span class="p">,</span> <span class="n">sh_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_train</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">feature_names</span><span class="o">=</span><span class="n">sh_feature_names</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[203]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">force_plot</span><span class="p">(</span><span class="n">sh_expected_value</span><span class="p">,</span> <span class="n">sh_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X_train</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">matplotlib</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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aOqTiIiIiIiIiEiOUKBGRERERERERCRHKFAjeWnZsmWsW7cu280QEREREZEsuOuuu9i+fXu2m3FcVq1axf3335/tZkgOU6BG0r73ve9RX1+fs9sTERERERERGe4UqBERERERERERyRFannuYOXjwICtXrmTfvn2UlJTwwQ9+kBkzZgDOdKH58+dz2mmnAbB+/XrWrVvHrbfeyj333APA3XffjTGGq6++mmAwyP3338+CBQt46aWX8Hq9XHzxxcyfP/+4tjd37tx0O+PxOD/+8Y+59dZbqaqqAqC1tZWf/vSnfOUrX8GyLB544AF2795NMplk4sSJLFq0iFAo1O01r1q1ivr6ej760Y8C0NDQwF133cV3v/tdLMsiHA7zxBNPsGXLFowxnHrqqSxcuBDLUpxSRERERCRf7dmzh8cee4zm5mZmzpzJokWLcLvdtLe393kssX79elavXk1raytFRUVdjnHefPNNXnjhBVpaWhg3bhxXXXUVZWVl3Z77D3/4A9OnT+fMM89M33b33XezcOFCZs2axWOPPcaGDRuIRCKUl5dz+eWXU11d3W07O3fu5P777+erX/1q+ra77rqLq6++msmTJ2PbNi+88AJvvPEG4XCYyZMns2jRIgKBwEC/nZJDdKQ6jCQSCf70pz8xZcoUvv71r/PhD3+Y++67j7q6un7/9pZbbgHgc5/7HN/+9rfTQZWWlhba2tr46le/yrXXXsvDDz98Qtvr4Ha7mTVrFm+//Xb6tnfffZeTTjqJ4uJibNvmlFNO4Stf+Qpf+cpXcLvdPProo0f9XmR68MEHsSyLL37xi9x+++1s27ZN9W1ERERERPLc22+/zU033cSXvvQlDh06xJo1awD6PJaIRqM89thj3HjjjXz729/mtttuY/To0QBs3LiRtWvX8vGPf5xvfOMbVFdXc9999/X43PPmzetyLHPw4EEaGxuZNm0aAOPGjeP2229nyZIlzJs3j//93/8lHo8f82t85ZVX2LhxI7fccgtf+9rX8Pv9rFy58pi3I/lFgZphZPfu3USjUc4//3xcLheTJk1i+vTpvPPOOye03Ysuugi3281JJ53E9OnTeffddwekvfPmzevStrfffpt58+YBUFRUxOzZs/F4PPh8Pi688EJ27tx5zM/R0tLCli1buPzyy/F6vRQXF3P22Wef8HsiIiIiIiLZdeaZ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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[252]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">xplain</span> <span class="o">=</span> <span class="n">lime_explainer</span><span class="o">.</span><span class="n">explain_instance</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">predict_fn</span><span class="o">=</span><span class="n">dtree</span><span class="o">.</span><span class="n">predict</span><span class="p">)</span>
<span class="n">xplain</span><span class="o">.</span><span class="n">show_in_notebook</span><span class="p">(</span><span class="n">show_table</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Intercept 26.001952797851573
Prediction_local [14.92710578]
Right: 11.824242424242424
</pre>
</div>
</div>

<div class="output_area">

    <div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<html>
        <meta http-equiv="content-type" content="text/html; charset=UTF8">
        <head><script>var lime =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PredictedValue = exports.PredictProba = exports.Barchart = exports.Explanation = undefined;
	
	var _explanation = __webpack_require__(1);
	
	var _explanation2 = _interopRequireDefault(_explanation);
	
	var _bar_chart = __webpack_require__(3);
	
	var _bar_chart2 = _interopRequireDefault(_bar_chart);
	
	var _predict_proba = __webpack_require__(6);
	
	var _predict_proba2 = _interopRequireDefault(_predict_proba);
	
	var _predicted_value = __webpack_require__(7);
	
	var _predicted_value2 = _interopRequireDefault(_predicted_value);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (!global._babelPolyfill) {
	  __webpack_require__(8);
	}
	
	__webpack_require__(339);
	
	exports.Explanation = _explanation2.default;
	exports.Barchart = _bar_chart2.default;
	exports.PredictProba = _predict_proba2.default;
	exports.PredictedValue = _predicted_value2.default;
	//require('style-loader');
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _d2 = __webpack_require__(2);
	
	var _d3 = _interopRequireDefault(_d2);
	
	var _bar_chart = __webpack_require__(3);
	
	var _bar_chart2 = _interopRequireDefault(_bar_chart);
	
	var _lodash = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Explanation = function () {
	  function Explanation(class_names) {
	    _classCallCheck(this, Explanation);
	
	    this.names = class_names;
	    if (class_names.length < 10) {
	      this.colors = _d3.default.scale.category10().domain(this.names);
	      this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length));
	    } else {
	      this.colors = _d3.default.scale.category20().domain(this.names);
	      this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length));
	    }
	  }
	  // exp: [(feature-name, weight), ...]
	  // label: int
	  // div: d3 selection
	
	
	  Explanation.prototype.show = function show(exp, label, div) {
	    var svg = div.append('svg').style('width', '100%');
	    var colors = ['#5F9EA0', this.colors_i(label)];
	    var names = ['NOT ' + this.names[label], this.names[label]];
	    if (this.names.length == 2) {
	      colors = [this.colors_i(0), this.colors_i(1)];
	      names = this.names;
	    }
	    var plot = new _bar_chart2.default(svg, exp, true, names, colors, true, 10);
	    svg.style('height', plot.svg_height + 'px');
	  };
	  // exp has all ocurrences of words, with start index and weight:
	  // exp = [('word', 132, -0.13), ('word3', 111, 1.3)
	
	
	  Explanation.prototype.show_raw_text = function show_raw_text(exp, label, raw, div) {
	    var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	
	    //let colors=['#5F9EA0', this.colors(this.exp['class'])];
	    var colors = ['#5F9EA0', this.colors_i(label)];
	    if (this.names.length == 2) {
	      colors = [this.colors_i(0), this.colors_i(1)];
	    }
	    var word_lists = [[], []];
	    var max_weight = -1;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = exp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var _step$value = _slicedToArray(_step.value, 3),
	            word = _step$value[0],
	            start = _step$value[1],
	            weight = _step$value[2];
	
	        if (weight > 0) {
	          word_lists[1].push([start, start + word.length, weight]);
	        } else {
	          word_lists[0].push([start, start + word.length, -weight]);
	        }
	        max_weight = Math.max(max_weight, Math.abs(weight));
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    if (!opacity) {
	      max_weight = 0;
	    }
	    this.display_raw_text(div, raw, word_lists, colors, max_weight, true);
	  };
	  // exp is list of (feature_name, value, weight)
	
	
	  Explanation.prototype.show_raw_tabular = function show_raw_tabular(exp, label, div) {
	    div.classed('lime', true).classed('table_div', true);
	    var colors = ['#5F9EA0', this.colors_i(label)];
	    if (this.names.length == 2) {
	      colors = [this.colors_i(0), this.colors_i(1)];
	    }
	    var table = div.append('table');
	    var thead = table.append('tr');
	    thead.append('td').text('Feature');
	    thead.append('td').text('Value');
	    thead.style('color', 'black').style('font-size', '20px');
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = exp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var _step2$value = _slicedToArray(_step2.value, 3),
	            fname = _step2$value[0],
	            value = _step2$value[1],
	            weight = _step2$value[2];
	
	        var tr = table.append('tr');
	        tr.style('border-style', 'hidden');
	        tr.append('td').text(fname);
	        tr.append('td').text(value);
	        if (weight > 0) {
	          tr.style('background-color', colors[1]);
	        } else if (weight < 0) {
	          tr.style('background-color', colors[0]);
	        } else {
	          tr.style('color', 'black');
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	  };
	
	  Explanation.prototype.hexToRgb = function hexToRgb(hex) {
	    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	    return result ? {
	      r: parseInt(result[1], 16),
	      g: parseInt(result[2], 16),
	      b: parseInt(result[3], 16)
	    } : null;
	  };
	
	  Explanation.prototype.applyAlpha = function applyAlpha(hex, alpha) {
	    var components = this.hexToRgb(hex);
	    return 'rgba(' + components.r + "," + components.g + "," + components.b + "," + alpha.toFixed(3) + ")";
	  };
	  // sord_lists is an array of arrays, of length (colors). if with_positions is true,
	  // word_lists is an array of [start,end] positions instead
	
	
	  Explanation.prototype.display_raw_text = function display_raw_text(div, raw_text) {
	    var word_lists = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	    var colors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
	    var max_weight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
	    var positions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
	
	    div.classed('lime', true).classed('text_div', true);
	    div.append('h3').text('Text with highlighted words');
	    var highlight_tag = 'span';
	    var text_span = div.append('span').style('white-space', 'pre-wrap').text(raw_text);
	    var position_lists = word_lists;
	    if (!positions) {
	      position_lists = this.wordlists_to_positions(word_lists, raw_text);
	    }
	    var objects = [];
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	      var _loop = function _loop() {
	        var i = _step3.value;
	
	        position_lists[i].map(function (x) {
	          return objects.push({ 'label': i, 'start': x[0], 'end': x[1], 'alpha': max_weight === 0 ? 1 : x[2] / max_weight });
	        });
	      };
	
	      for (var _iterator3 = (0, _lodash.range)(position_lists.length)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        _loop();
	      }
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	
	    objects = (0, _lodash.sortBy)(objects, function (x) {
	      return x['start'];
	    });
	    var node = text_span.node().childNodes[0];
	    var subtract = 0;
	    var _iteratorNormalCompletion4 = true;
	    var _didIteratorError4 = false;
	    var _iteratorError4 = undefined;
	
	    try {
	      for (var _iterator4 = objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	        var obj = _step4.value;
	
	        var word = raw_text.slice(obj.start, obj.end);
	        var start = obj.start - subtract;
	        var end = obj.end - subtract;
	        var match = document.createElement(highlight_tag);
	        match.appendChild(document.createTextNode(word));
	        match.style.backgroundColor = this.applyAlpha(colors[obj.label], obj.alpha);
	        var after = node.splitText(start);
	        after.nodeValue = after.nodeValue.substring(word.length);
	        node.parentNode.insertBefore(match, after);
	        subtract += end;
	        node = after;
	      }
	    } catch (err) {
	      _didIteratorError4 = true;
	      _iteratorError4 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion4 && _iterator4.return) {
	          _iterator4.return();
	        }
	      } finally {
	        if (_didIteratorError4) {
	          throw _iteratorError4;
	        }
	      }
	    }
	  };
	
	  Explanation.prototype.wordlists_to_positions = function wordlists_to_positions(word_lists, raw_text) {
	    var ret = [];
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;
	
	    try {
	      for (var _iterator5 = word_lists[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	        var words = _step5.value;
	
	        if (words.length === 0) {
	          ret.push([]);
	          continue;
	        }
	        var re = new RegExp("\\b(" + words.join('|') + ")\\b", 'gm');
	        var temp = void 0;
	        var list = [];
	        while ((temp = re.exec(raw_text)) !== null) {
	          list.push([temp.index, temp.index + temp[0].length]);
	        }
	        ret.push(list);
	      }
	    } catch (err) {
	      _didIteratorError5 = true;
	      _iteratorError5 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion5 && _iterator5.return) {
	          _iterator5.return();
	        }
	      } finally {
	        if (_didIteratorError5) {
	          throw _iteratorError5;
	        }
	      }
	    }
	
	    return ret;
	  };
	
	  return Explanation;
	}();
	
	exports.default = Explanation;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.17"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.transpose = function(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  };
	  function d3_transposeLength(d) {
	    return d.length;
	  }
	  d3.zip = function() {
	    return d3.transpose(arguments);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: d3_nsXhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (node = group[i]) {
	            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
	              exitNodes[i] = node;
	            } else {
	              nodeByKeyValue.set(keyValue, node);
	            }
	            keyValues[i] = keyValue;
	          }
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = d3_array(nodes);
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? half : x < -1 ? -half : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var  = Math.SQRT2, 2 = 2, 4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
	    if (d2 < 2) {
	      S = Math.log(w1 / w0) / ;
	      i = function(t) {
	        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];
	      };
	    } else {
	      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / ;
	      i = function(t) {
	        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];
	      };
	    }
	    i.duration = S * 1e3;
	    return i;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: null
	      };
	      scaleTo(+_);
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function() {
	    d3_timer.apply(this, arguments);
	  };
	  function d3_timer(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	    return timer;
	  }
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now(), timer = d3_timer_queueHead;
	    while (timer) {
	      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
	      timer = timer.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.c) {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      } else {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value = +value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * ;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 *  + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var 00, 00, 0, cos0, sin0;
	    d3_geo_area.point = function(, ) {
	      d3_geo_area.point = nextPoint;
	      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), 
	      sin0 = Math.sin();
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	       =  * d3_radians / 2 +  / 4;
	      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      0 = , cos0 = cos, sin0 = sin;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(00, 00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var  = spherical[0],  = spherical[1], cos = Math.cos();
	    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
	  }
	  d3.geo.bounds = function() {
	    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;
	        range[0] = 0, range[1] = 1;
	      }
	    };
	    function point(, ) {
	      ranges.push(range = [ 0 = , 1 =  ]);
	      if ( < 0) 0 = ;
	      if ( > 1) 1 = ;
	    }
	    function linePoint(, ) {
	      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
	        if (antimeridian ^ (s * _ < i && i < s * )) {
	          var i = inflection[1] * d3_degrees;
	          if (i > 1) 1 = i;
	        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
	          var i = -inflection[1] * d3_degrees;
	          if (i < 0) 0 = i;
	        } else {
	          if ( < 0) 0 = ;
	          if ( > 1) 1 = ;
	        }
	        if (antimeridian) {
	          if ( < _) {
	            if (angle(0, ) > angle(0, 1)) 1 = ;
	          } else {
	            if (angle(, 1) > angle(0, 1)) 0 = ;
	          }
	        } else {
	          if (1 >= 0) {
	            if ( < 0) 0 = ;
	            if ( > 1) 1 = ;
	          } else {
	            if ( > _) {
	              if (angle(0, ) > angle(0, 1)) 1 = ;
	            } else {
	              if (angle(, 1) > angle(0, 1)) 0 = ;
	            }
	          }
	        }
	      } else {
	        point(, );
	      }
	      p0 = p, _ = ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = 0, range[1] = 1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(, ) {
	      if (p0) {
	        var d =  - _;
	        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
	      } else __ = , __ = ;
	      d3_geo_area.point(, );
	      linePoint(, );
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(__, __);
	      d3_geo_area.lineEnd();
	      if (abs(dSum) > ) 0 = -(1 = 180);
	      range[0] = 0, range[1] = 1;
	      p0 = null;
	    }
	    function angle(0, 1) {
	      return (1 -= 0) < 0 ? 1 + 360 : 1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      1 = 1 = -(0 = 0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, d;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < 2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < 2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(, ) {
	     *= d3_radians;
	    var cos = Math.cos( *= d3_radians);
	    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians);
	      x0 = cos * Math.cos();
	      y0 = cos * Math.sin();
	      z0 = Math.sin();
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var 00, 00, x0, y0, z0;
	    d3_geo_centroid.point = function(, ) {
	      00 = , 00 = ;
	      d3_geo_centroid.point = nextPoint;
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians);
	      x0 = cos * Math.cos();
	      y0 = cos * Math.sin();
	      z0 = Math.sin();
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(00, 00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(, ) {
	       *= d3_radians;
	      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(, ) {
	        var point = rotate(, );
	        if (pointVisible( = point[0],  = point[1])) listener.point(, );
	      }
	      function pointLine(, ) {
	        var point = rotate(, );
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(, ) {
	        ring.push([ ,  ]);
	        var point = rotate(, );
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(, ) {
	        line.push([ ,  ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var 0 = NaN, 0 = NaN, s0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(1, 1) {
	        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
	        if (abs(d - ) < ) {
	          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
	          listener.point(s0, 0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(s1, 0);
	          listener.point(1, 0);
	          clean = 0;
	        } else if (s0 !== s1 && d >= ) {
	          if (abs(0 - s0) < ) 0 -= s0 * ;
	          if (abs(1 - s1) < ) 1 -= s1 * ;
	          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
	          listener.point(s0, 0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(s1, 0);
	          clean = 0;
	        }
	        listener.point(0 = 1, 0 = 1);
	        s0 = s1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        0 = 0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
	    var cos0, cos1, sin0_1 = Math.sin(0 - 1);
	    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var ;
	    if (from == null) {
	       = direction * half;
	      listener.point(-, );
	      listener.point(0, );
	      listener.point(, );
	      listener.point(, 0);
	      listener.point(, -);
	      listener.point(0, -);
	      listener.point(-, -);
	      listener.point(-, 0);
	      listener.point(-, );
	    } else if (abs(from[0] - to[0]) > ) {
	      var s = from[0] < to[0] ?  : -;
	       = direction * s / 2;
	      listener.point(-s, );
	      listener.point(0, );
	      listener.point(s, );
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
	        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
	        polarAngle += antimeridian ? d + sd *  : d;
	        if (antimeridian ^ 0 >= meridian ^  >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ d >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        0 = , sin0 = sin, cos0 = cos, point0 = point;
	      }
	    }
	    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < -) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);
	    function visible(, ) {
	      return Math.cos() * Math.cos() > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(, ) {
	          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ;
	              point1[1] += ;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
	      if (1 < 0) z = 0, 0 = 1, 1 = z;
	      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
	      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;
	      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(, ) {
	      var r = smallRadius ? radius :  - radius, code = 0;
	      if ( < -r) code |= 1; else if ( > r) code |= 2;
	      if ( < -r) code |= 4; else if ( > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];
	      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(0, 1) {
	    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
	    function forward(, ) {
	      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
	      return [  * Math.sin( *= n), 0 -  * Math.cos() ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = 0 - y;
	      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, );
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(, ) {
	        var c = d3_geo_cartesian([ ,  ]), p = project(, );
	        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(, ) {
	        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * 2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(2);
	      maxDepth = (2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + x, y - x[1] * k ];
	    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + x, y - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];
	       = _[0] % 360 * d3_radians;
	       = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];
	       = _[0] % 360 * d3_radians;
	       = _[1] % 360 * d3_radians;
	       = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
	      var center = project(, );
	      x = x - center[0] * k;
	      y = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(, ) {
	    return [ ,  ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(, ) {
	    return [  >  ?  -  :  < - ?  +  : ,  ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(, , ) {
	    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotation() {
	    return function(, ) {
	      return  += , [  >  ?  -  :  < - ?  +  : ,  ];
	    };
	  }
	  function d3_geo_rotation() {
	    var rotation = d3_geo_forwardRotation();
	    rotation.invert = d3_geo_forwardRotation(-);
	    return rotation;
	  }
	  function d3_geo_rotation(, ) {
	    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
	    function rotation(, ) {
	      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
	      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];
	    }
	    rotation.invert = function(, ) {
	      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
	      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * ;
	      } else {
	        from = radius + direction * ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
	    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - , dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - , dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var 0, sin0, cos0;
	    d3_geo_length.point = function(, ) {
	      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(, ) {
	      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
	      0 = , sin0 = sin, cos0 = cos;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(, ) {
	      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
	      return [ k * cos * Math.sin(), k * Math.sin() ];
	    }
	    azimuthal.invert = function(x, y) {
	      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {
	    return Math.sqrt(2 / (1 + coscos));
	  }, function() {
	    return 2 * Math.asin( / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {
	    var c = Math.acos(coscos);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(0, 1) {
	    var cos0 = Math.cos(0), t = function() {
	      return Math.tan( / 4 +  / 2);
	    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(, ) {
	      if (F > 0) {
	        if ( < -half + )  = -half + ;
	      } else {
	        if ( > half - )  = half - ;
	      }
	      var  = F / Math.pow(t(), n);
	      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
	      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(0, 1) {
	    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
	    if (abs(n) < ) return d3_geo_equirectangular;
	    function forward(, ) {
	      var  = G - ;
	      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];
	    }
	    forward.invert = function(x, y) {
	      var 0_y = G - y;
	      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {
	    return 1 / coscos;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(, ) {
	    return [ , Math.log(Math.tan( / 4 +  / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - half ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k =  * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {
	    return 1 / (1 + coscos);
	  }, function() {
	    return 2 * Math.atan();
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(, ) {
	    return [ Math.log(Math.tan( / 4 +  / 2)), - ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
	            x: x0,
	            y: abs(x2 - x0) <  ? y2 : y1
	          } : abs(y3 - y1) <  && x1 - x3 >  ? {
	            x: abs(y2 - y1) <  ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) <  && y3 - y0 >  ? {
	            x: x1,
	            y: abs(x2 - x1) <  ? y2 : y0
	          } : abs(y3 - y0) <  && x3 - x0 >  ? {
	            x: abs(y2 - y0) <  ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ) * ,
	          y: Math.round(fy(d, i) / ) * ,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;
	
	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;
	
	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;
	
	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * half);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransformPop(s) {
	    return s.length ? s.pop() + "," : "";
	  }
	  function d3_interpolateTranslate(ta, tb, s, q) {
	    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
	      var i = s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    }
	  }
	  function d3_interpolateRotate(ra, rb, s, q) {
	    if (ra !== rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
	    }
	  }
	  function d3_interpolateSkew(wa, wb, s, q) {
	    if (wa !== wb) {
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
	    }
	  }
	  function d3_interpolateScale(ka, kb, s, q) {
	    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
	      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] !== 1 || kb[1] !== 1) {
	      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
	    }
	  }
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [];
	    a = d3.transform(a), b = d3.transform(b);
	    d3_interpolateTranslate(a.translate, b.translate, s, q);
	    d3_interpolateRotate(a.rotate, b.rotate, s, q);
	    d3_interpolateSkew(a.skew, b.skew, s, q);
	    d3_interpolateScale(a.scale, b.scale, s, q);
	    a = b = null;
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = ( - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: groupSums[di]
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        timer = null;
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) {
	          alpha = x;
	        } else {
	          timer.c = null, timer.t = NaN, timer = null;
	          event.end({
	            type: "end",
	            alpha: alpha = 0
	          });
	        }
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        timer = d3_timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = root.y = 0;
	      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(, ) {
	      var n = arguments.length;
	      if (n < 2)  = 1;
	      if (n < 1)  = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    return domain;
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(1, base * n / scale.ticks().length);
	      return function(d) {
	        var i = d / pow(Math.round(log(d)));
	        if (i * base < base - .5) i *= base;
	        return i <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var rc1 = rc, rc0 = rc;
	        if (da < ) {
	          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
	          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
	        }
	        if (x1 != null) {
	          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.length > 1 ? points.join("L") : points + "Z";
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return points.join("L") + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - half;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > ) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / );
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, activeId, active;
	      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        if (--lock.count) delete lock[activeId]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id], time, timer, duration, ease, tweens;
	    function schedule(elapsed) {
	      var delay = transition.delay;
	      timer.t = delay + time;
	      if (delay <= elapsed) return start(elapsed - delay);
	      timer.c = start;
	    }
	    function start(elapsed) {
	      var activeId = lock.active, active = lock[activeId];
	      if (active) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        --lock.count;
	        delete lock[activeId];
	        active.event && active.event.interrupt.call(node, node.__data__, active.index);
	      }
	      for (var cancelId in lock) {
	        if (+cancelId < id) {
	          var cancel = lock[cancelId];
	          cancel.timer.c = null;
	          cancel.timer.t = NaN;
	          --lock.count;
	          delete lock[cancelId];
	        }
	      }
	      timer.c = tick;
	      d3_timer(function() {
	        if (timer.c && tick(elapsed || 1)) {
	          timer.c = null;
	          timer.t = NaN;
	        }
	        return 1;
	      }, 0, time);
	      lock.active = id;
	      transition.event && transition.event.start.call(node, node.__data__, i);
	      tweens = [];
	      transition.tween.forEach(function(key, value) {
	        if (value = value.call(node, node.__data__, i)) {
	          tweens.push(value);
	        }
	      });
	      ease = transition.ease;
	      duration = transition.duration;
	    }
	    function tick(elapsed) {
	      var t = elapsed / duration, e = ease(t), n = tweens.length;
	      while (n > 0) {
	        tweens[--n].call(node, e);
	      }
	      if (t >= 1) {
	        transition.event && transition.event.end.call(node, node.__data__, i);
	        if (--lock.count) delete lock[id]; else delete node[ns];
	        return 1;
	      }
	    }
	    if (!transition) {
	      time = inherit.time;
	      timer = d3_timer(schedule, 0, time);
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        timer: timer,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ), tickExit = d3.transition(tick.exit()).style("opacity", ).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = d3_array(arguments);
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
	}();

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _d = __webpack_require__(2);
	
	var _d2 = _interopRequireDefault(_d);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Barchart =
	// svg: d3 object with the svg in question
	// exp_array: list of (feature_name, weight)
	function Barchart(svg, exp_array) {
	  var two_sided = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  var titles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
	  var colors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['red', 'green'];
	  var show_numbers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
	  var bar_height = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 5;
	
	  _classCallCheck(this, Barchart);
	
	  var svg_width = Math.min(600, parseInt(svg.style('width')));
	  var bar_width = two_sided ? svg_width / 2 : svg_width;
	  if (titles === undefined) {
	    titles = two_sided ? ['Cons', 'Pros'] : 'Pros';
	  }
	  if (show_numbers) {
	    bar_width = bar_width - 30;
	  }
	  var x_offset = two_sided ? svg_width / 2 : 10;
	  // 13.1 is +- the width of W, the widest letter.
	  if (two_sided && titles.length == 2) {
	    svg.append('text').attr('x', svg_width / 4).attr('y', 15).attr('font-size', '20').attr('text-anchor', 'middle').style('fill', colors[0]).text(titles[0]);
	
	    svg.append('text').attr('x', svg_width / 4 * 3).attr('y', 15).attr('font-size', '20').attr('text-anchor', 'middle').style('fill', colors[1]).text(titles[1]);
	  } else {
	    var pos = two_sided ? svg_width / 2 : x_offset;
	    var anchor = two_sided ? 'middle' : 'begin';
	    svg.append('text').attr('x', pos).attr('y', 15).attr('font-size', '20').attr('text-anchor', anchor).text(titles);
	  }
	  var yshift = 20;
	  var space_between_bars = 0;
	  var text_height = 16;
	  var space_between_bar_and_text = 3;
	  var total_bar_height = text_height + space_between_bar_and_text + bar_height + space_between_bars;
	  var total_height = total_bar_height * exp_array.length;
	  this.svg_height = total_height + yshift;
	  var yscale = _d2.default.scale.linear().domain([0, exp_array.length]).range([yshift, yshift + total_height]);
	  var names = exp_array.map(function (v) {
	    return v[0];
	  });
	  var weights = exp_array.map(function (v) {
	    return v[1];
	  });
	  var max_weight = Math.max.apply(Math, _toConsumableArray(weights.map(function (v) {
	    return Math.abs(v);
	  })));
	  var xscale = _d2.default.scale.linear().domain([0, Math.max(1, max_weight)]).range([0, bar_width]);
	
	  for (var i = 0; i < exp_array.length; ++i) {
	    var name = names[i];
	    var weight = weights[i];
	    var size = xscale(Math.abs(weight));
	    var to_the_right = weight > 0 || !two_sided;
	    var text = svg.append('text').attr('x', to_the_right ? x_offset + 2 : x_offset - 2).attr('y', yscale(i) + text_height).attr('text-anchor', to_the_right ? 'begin' : 'end').attr('font-size', '14').text(name);
	    while (text.node().getBBox()['width'] + 1 > bar_width) {
	      var cur_text = text.text().slice(0, text.text().length - 5);
	      text.text(cur_text + '...');
	      if (text === '...') {
	        break;
	      }
	    }
	    var bar = svg.append('rect').attr('height', bar_height).attr('x', to_the_right ? x_offset : x_offset - size).attr('y', text_height + yscale(i) + space_between_bar_and_text) // + bar_height)
	    .attr('width', size).style('fill', weight > 0 ? colors[1] : colors[0]);
	    if (show_numbers) {
	      var bartext = svg.append('text').attr('x', to_the_right ? x_offset + size + 1 : x_offset - size - 1).attr('text-anchor', weight > 0 || !two_sided ? 'begin' : 'end').attr('y', bar_height + yscale(i) + text_height + space_between_bar_and_text).attr('font-size', '10').text(Math.abs(weight).toFixed(2));
	    }
	  }
	  var line = svg.append("line").attr("x1", x_offset).attr("x2", x_offset).attr("y1", bar_height + yshift).attr("y2", Math.max(bar_height, yscale(exp_array.length))).style("stroke-width", 2).style("stroke", "black");
	};
	
	exports.default = Barchart;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '4.17.11';
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;
	
	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;
	
	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;
	
	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;
	
	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;
	
	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);
	
	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;
	
	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;
	
	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;
	
	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
	
	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';
	
	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');
	
	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');
	
	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');
	
	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');
	
	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();
	
	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;
	
	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;
	
	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;
	
	      if (types) {
	        return types;
	      }
	
	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());
	
	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }
	
	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	
	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }
	
	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);
	
	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }
	
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;
	
	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');
	
	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }
	
	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }
	
	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	
	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }
	
	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }
	
	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }
	
	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;
	
	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }
	
	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);
	
	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }
	
	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }
	
	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }
	
	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;
	
	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	
	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;
	
	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }
	
	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }
	
	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }
	
	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];
	
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	
	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	
	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	
	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	
	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }
	
	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }
	
	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
	
	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }
	
	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }
	
	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	
	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;
	
	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];
	
	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());
	
	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;
	
	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());
	
	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	
	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;
	
	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);
	
	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());
	
	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }
	
	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	    }
	
	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }
	
	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }
	
	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      return index < 0 ? undefined : data[index][1];
	    }
	
	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }
	
	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }
	
	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }
	
	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }
	
	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }
	
	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;
	
	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }
	
	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;
	
	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }
	
	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }
	
	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }
	
	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }
	
	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);
	
	      this.size = data.size;
	      return result;
	    }
	
	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }
	
	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }
	
	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }
	
	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;
	
	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }
	
	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }
	
	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }
	
	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;
	
	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }
	
	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;
	
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;
	
	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);
	
	      if (isSet(value)) {
	        value.forEach(function(subValue) {
	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	        });
	
	        return result;
	      }
	
	      if (isMap(value)) {
	        value.forEach(function(subValue, key) {
	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	        });
	
	        return result;
	      }
	
	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);
	
	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }
	
	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];
	
	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;
	
	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);
	
	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;
	
	      predicate || (predicate = isFlattenable);
	      result || (result = []);
	
	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }
	
	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);
	
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }
	
	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }
	
	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }
	
	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }
	
	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }
	
	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];
	
	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];
	
	      var index = -1,
	          seen = caches[0];
	
	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }
	
	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }
	
	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }
	
	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }
	
	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);
	
	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;
	
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;
	
	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }
	
	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }
	
	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }
	
	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }
	
	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }
	
	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }
	
	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];
	
	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	            : undefined;
	
	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = safeGet(object, key),
	          srcValue = safeGet(source, key),
	          stacked = stack.get(srcValue);
	
	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      var isCommon = newValue === undefined;
	
	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || isFunction(objValue)) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }
	
	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }
	
	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
	
	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }
	
	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};
	
	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);
	
	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;
	
	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;
	
	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }
	
	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }
	
	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;
	
	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };
	
	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);
	
	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }
	
	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;
	
	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }
	
	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }
	
	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}
	
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }
	
	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);
	
	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;
	
	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }
	
	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};
	
	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }
	
	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }
	
	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }
	
	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }
	
	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;
	
	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }
	
	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };
	
	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	      buffer.copy(result);
	      return result;
	    }
	
	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }
	
	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }
	
	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }
	
	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }
	
	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }
	
	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);
	
	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);
	
	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }
	
	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;
	
	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;
	
	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	
	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;
	
	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }
	
	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }
	
	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};
	
	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }
	
	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;
	
	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;
	
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;
	
	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);
	
	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;
	
	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);
	
	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);
	
	        return chr[methodName]() + trailing;
	      };
	    }
	
	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);
	
	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;
	
	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }
	
	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }
	
	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);
	
	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }
	
	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;
	
	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
	
	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];
	
	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }
	
	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));
	
	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };
	
	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;
	
	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);
	
	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];
	
	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	
	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }
	
	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }
	
	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined : value;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
	
	      stack.set(array, other);
	      stack.set(other, array);
	
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;
	
	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;
	
	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');
	
	        case mapTag:
	          var convert = mapToArray;
	
	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);
	
	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;
	
	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;
	
	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);
	
	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }
	
	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }
	
	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }
	
	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }
	
	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }
	
	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;
	
	      while (length--) {
	        var key = result[length],
	            value = object[key];
	
	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }
	
	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];
	
	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}
	
	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };
	
	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };
	
	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;
	
	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';
	
	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }
	
	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          result = false;
	
	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);
	
	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case dataViewTag:
	          return cloneDataView(object, isDeep);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);
	
	        case mapTag:
	          return new Ctor;
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          return cloneRegExp(object);
	
	        case setTag:
	          return new Ctor;
	
	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }
	
	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }
	
	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      var type = typeof value;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	
	      return !!length &&
	        (type == 'number' ||
	          (type != 'symbol' && reIsUint.test(value))) &&
	            (value > -1 && value % 1 == 0 && value < length);
	    }
	
	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }
	
	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];
	
	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }
	
	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;
	
	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	      return value === proto;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }
	
	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });
	
	      var cache = result.cache;
	      return result;
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
	
	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }
	
	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);
	
	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }
	
	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Gets the value at `key`, unless `key` is "__proto__".
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to get.
	     * @returns {*} Returns the property value.
	     */
	    function safeGet(object, key) {
	      if (key == '__proto__') {
	        return;
	      }
	
	      return object[key];
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);
	
	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };
	
	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);
	
	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }
	
	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;
	
	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }
	
	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;
	
	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];
	
	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }
	
	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (string.charCodeAt(0) === 46 /* . */) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, subString) {
	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });
	
	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }
	
	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;
	
	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }
	
	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }
	
	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }
	
	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }
	
	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }
	
	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};
	
	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }
	
	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }
	
	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }
	
	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);
	
	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);
	
	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));
	
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }
	
	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }
	
	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }
	
	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);
	
	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }
	
	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;
	
	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }
	
	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };
	
	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });
	
	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];
	
	      return { 'done': done, 'value': value };
	    }
	
	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }
	
	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }
	
	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);
	
	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }
	
	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }
	
	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }
	
	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;
	
	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }
	
	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }
	
	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            timeWaiting = wait - timeSinceLastCall;
	
	        return maxing
	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	          : timeWaiting;
	      }
	
	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;
	
	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }
	
	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }
	
	      function trailingEdge(time) {
	        timerId = undefined;
	
	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }
	
	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }
	
	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }
	
	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);
	
	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;
	
	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }
	
	    // Expose `MapCache`.
	    memoize.Cache = MapCache;
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
	
	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);
	
	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });
	
	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);
	
	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }
	
	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }
	
	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }
	
	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }
	
	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });
	
	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;
	
	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	
	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }
	
	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	
	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }
	
	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }
	
	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }
	
	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	
	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }
	
	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	
	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
	
	      return func(value);
	    }
	
	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }
	
	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;
	
	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }
	
	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }
	
	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }
	
	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }
	
	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });
	
	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });
	
	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });
	
	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });
	
	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);
	
	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }
	
	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(object, sources) {
	      object = Object(object);
	
	      var index = -1;
	      var length = sources.length;
	      var guard = length > 2 ? sources[2] : undefined;
	
	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	        length = 1;
	      }
	
	      while (++index < length) {
	        var source = sources[index];
	        var props = keysIn(source);
	        var propsIndex = -1;
	        var propsLength = props.length;
	
	        while (++propsIndex < propsLength) {
	          var key = props[propsIndex];
	          var value = object[key];
	
	          if (value === undefined ||
	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	            object[key] = source[key];
	          }
	        }
	      }
	
	      return object;
	    });
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, customDefaultsMerge);
	      return apply(mergeWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }
	
	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }
	
	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }
	
	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }
	
	      result[value] = key;
	    }, constant(identity));
	
	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }
	
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);
	
	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }
	
	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });
	
	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });
	
	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });
	
	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length;
	
	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }
	
	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }
	
	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }
	
	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);
	
	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);
	
	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }
	
	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }
	
	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }
	
	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }
	
	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }
	
	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });
	
	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }
	
	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);
	
	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }
	
	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }
	
	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);
	
	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }
	
	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }
	
	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);
	
	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);
	
	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }
	
	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	      return castSlice(strSymbols, start, end).join('');
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
	
	      return castSlice(strSymbols, 0, end).join('');
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));
	
	      return castSlice(strSymbols, start).join('');
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);
	
	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);
	
	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });
	
	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;
	
	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });
	
	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();
	
	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });
	
	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }
	
	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }
	
	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);
	
	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);
	
	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);
	
	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });
	
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }
	
	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }
	
	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);
	
	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);
	
	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);
	
	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();
	
	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);
	
	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }
	
	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }
	
	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }
	
	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }
	
	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }
	
	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);
	
	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;
	
	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);
	
	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);
	
	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }
	
	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }
	
	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }
	
	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);
	
	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);
	
	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }
	
	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;
	
	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;
	
	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
	
	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();
	
	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };
	
	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };
	
	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });
	
	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;
	
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });
	
	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });
	
	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];
	
	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;
	
	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;
	
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module)))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _d2 = __webpack_require__(2);
	
	var _d3 = _interopRequireDefault(_d2);
	
	var _lodash = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PredictProba = function () {
	  // svg: d3 object with the svg in question
	  // class_names: array of class names
	  // predict_probas: array of prediction probabilities
	  function PredictProba(svg, class_names, predict_probas) {
	    var title = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Prediction probabilities';
	
	    _classCallCheck(this, PredictProba);
	
	    var width = parseInt(svg.style('width'));
	    this.names = class_names;
	    this.names.push('Other');
	    if (class_names.length < 10) {
	      this.colors = _d3.default.scale.category10().domain(this.names);
	      this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length));
	    } else {
	      this.colors = _d3.default.scale.category20().domain(this.names);
	      this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length));
	    }
	
	    var _map_classes = this.map_classes(this.names, predict_probas),
	        _map_classes2 = _slicedToArray(_map_classes, 2),
	        names = _map_classes2[0],
	        data = _map_classes2[1];
	
	    var bar_x = width - 125;
	    var class_names_width = bar_x;
	    var bar_width = width - bar_x - 32;
	    var x_scale = _d3.default.scale.linear().range([0, bar_width]);
	    var bar_height = 17;
	    var space_between_bars = 5;
	    var bar_yshift = title === '' ? 0 : 35;
	    var n_bars = Math.min(5, data.length);
	    this.svg_height = n_bars * (bar_height + space_between_bars) + bar_yshift;
	    svg.style('height', this.svg_height + 'px');
	    var this_object = this;
	    if (title !== '') {
	      svg.append('text').text(title).attr('x', 20).attr('y', 20);
	    }
	    var bar_y = function bar_y(i) {
	      return (bar_height + space_between_bars) * i + bar_yshift;
	    };
	    var bar = svg.append("g");
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = (0, _lodash.range)(data.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var i = _step.value;
	
	        var color = this.colors(names[i]);
	        if (names[i] == 'Other' && this.names.length > 20) {
	          color = '#5F9EA0';
	        }
	        var rect = bar.append("rect");
	        rect.attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", x_scale(data[i])).style("fill", color);
	        bar.append("rect").attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", bar_width - 1).attr("fill-opacity", 0).attr("stroke", "black");
	        var text = bar.append("text");
	        text.classed("prob_text", true);
	        text.attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif");
	        text = bar.append("text");
	        text.attr("x", bar_x + x_scale(data[i]) + 5).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif").text(data[i].toFixed(2));
	        text = bar.append("text");
	        text.attr("x", bar_x - 10).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(names[i]);
	        while (text.node().getBBox()['width'] + 1 > class_names_width - 10) {
	          // TODO: ta mostrando s dois, e talvez quando hover mostrar o texto
	          // todo
	          var cur_text = text.text().slice(0, text.text().length - 5);
	          text.text(cur_text + '...');
	          if (cur_text === '') {
	            break;
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  }
	
	  PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) {
	    if (class_names.length <= 6) {
	      return [class_names, predict_proba];
	    }
	    var class_dict = (0, _lodash.range)(predict_proba.length).map(function (i) {
	      return { 'name': class_names[i], 'prob': predict_proba[i], 'i': i };
	    });
	    var sorted = (0, _lodash.sortBy)(class_dict, function (d) {
	      return -d.prob;
	    });
	    var other = new Set();
	    (0, _lodash.range)(4, sorted.length).map(function (d) {
	      return other.add(sorted[d].name);
	    });
	    var other_prob = 0;
	    var ret_probs = [];
	    var ret_names = [];
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = (0, _lodash.range)(sorted.length)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var d = _step2.value;
	
	        if (other.has(sorted[d].name)) {
	          other_prob += sorted[d].prob;
	        } else {
	          ret_probs.push(sorted[d].prob);
	          ret_names.push(sorted[d].name);
	        }
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    ;
	    ret_names.push("Other");
	    ret_probs.push(other_prob);
	    return [ret_names, ret_probs];
	  };
	
	  return PredictProba;
	}();
	
	exports.default = PredictProba;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _d = __webpack_require__(2);
	
	var _d2 = _interopRequireDefault(_d);
	
	var _lodash = __webpack_require__(4);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PredictedValue =
	// svg: d3 object with the svg in question
	// class_names: array of class names
	// predict_probas: array of prediction probabilities
	function PredictedValue(svg, predicted_value, min_value, max_value) {
	    var title = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'Predicted value';
	    var log_coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
	
	    _classCallCheck(this, PredictedValue);
	
	    if (min_value == max_value) {
	        var width_proportion = 1.0;
	    } else {
	        var width_proportion = (predicted_value - min_value) / (max_value - min_value);
	    }
	
	    var width = parseInt(svg.style('width'));
	
	    this.color = _d2.default.scale.category10();
	    this.color('predicted_value');
	    // + 2 is due to it being a float
	    var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2;
	    num_digits = Math.max(num_digits, 3);
	
	    var corner_width = 12 * num_digits;
	    var corner_padding = 5.5 * num_digits;
	    var bar_x = corner_width + corner_padding;
	    var bar_width = width - corner_width * 2 - corner_padding * 2;
	    var x_scale = _d2.default.scale.linear().range([0, bar_width]);
	    var bar_height = 17;
	    var bar_yshift = title === '' ? 0 : 35;
	    var n_bars = 1;
	    var this_object = this;
	    if (title !== '') {
	        svg.append('text').text(title).attr('x', 20).attr('y', 20);
	    }
	    var bar_y = bar_yshift;
	    var bar = svg.append("g");
	
	    //filled in bar representing predicted value in range
	    var rect = bar.append("rect");
	    rect.attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(width_proportion)).style("fill", this.color);
	
	    //empty box representing range
	    bar.append("rect").attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(1)).attr("fill-opacity", 0).attr("stroke", "black");
	    var text = bar.append("text");
	    text.classed("prob_text", true);
	    text.attr("y", bar_y + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif");
	
	    //text for min value
	    text = bar.append("text");
	    text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(min_value.toFixed(2));
	
	    //text for range min annotation
	    var v_adjust_min_value_annotation = text.node().getBBox().height;
	    text = bar.append("text");
	    text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text("(min)");
	
	    //text for predicted value
	    // console.log('bar height: ' + bar_height)
	    text = bar.append("text");
	    text.text(predicted_value.toFixed(2));
	    // let h_adjust_predicted_value_text = text.node().getBBox().width / 2;
	    var v_adjust_predicted_value_text = text.node().getBBox().height;
	    text.attr("x", bar_x + x_scale(width_proportion)).attr("y", bar_y + bar_height + v_adjust_predicted_value_text).attr("fill", "black").attr("text-anchor", "middle").style("font", "14px tahoma, sans-serif");
	
	    //text for max value
	    text = bar.append("text");
	    text.text(max_value.toFixed(2));
	    // let h_adjust = text.node().getBBox().width;
	    text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif");
	
	    //text for range max annotation
	    var v_adjust_max_value_annotation = text.node().getBBox().height;
	    text = bar.append("text");
	    text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif").text("(max)");
	
	    //readjust svg size
	    // let svg_width = width + 1 * h_adjust;
	    // svg.style('width', svg_width + 'px');
	
	    this.svg_height = n_bars * bar_height + bar_yshift + 2 * text.node().getBBox().height + 10;
	    svg.style('height', this.svg_height + 'px');
	    if (log_coords) {
	        console.log("svg width: " + svg_width);
	        console.log("svg height: " + this.svg_height);
	        console.log("bar_y: " + bar_y);
	        console.log("bar_x: " + bar_x);
	        console.log("Min value: " + min_value);
	        console.log("Max value: " + max_value);
	        console.log("Pred value: " + predicted_value);
	    }
	};
	
	exports.default = PredictedValue;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(9);
	
	__webpack_require__(335);
	
	__webpack_require__(336);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(10);
	__webpack_require__(59);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(64);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);
	__webpack_require__(72);
	__webpack_require__(73);
	__webpack_require__(74);
	__webpack_require__(75);
	__webpack_require__(77);
	__webpack_require__(79);
	__webpack_require__(81);
	__webpack_require__(83);
	__webpack_require__(86);
	__webpack_require__(87);
	__webpack_require__(88);
	__webpack_require__(92);
	__webpack_require__(94);
	__webpack_require__(96);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(104);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(112);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(120);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(129);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(134);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(196);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(202);
	__webpack_require__(204);
	__webpack_require__(206);
	__webpack_require__(208);
	__webpack_require__(209);
	__webpack_require__(210);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(218);
	__webpack_require__(228);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(294);
	__webpack_require__(295);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(301);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(310);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(316);
	__webpack_require__(317);
	__webpack_require__(318);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(325);
	__webpack_require__(326);
	__webpack_require__(327);
	__webpack_require__(328);
	__webpack_require__(329);
	__webpack_require__(330);
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(333);
	__webpack_require__(334);
	module.exports = __webpack_require__(16);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(11);
	var has = __webpack_require__(12);
	var DESCRIPTORS = __webpack_require__(13);
	var $export = __webpack_require__(15);
	var redefine = __webpack_require__(25);
	var META = __webpack_require__(32).KEY;
	var $fails = __webpack_require__(14);
	var shared = __webpack_require__(28);
	var setToStringTag = __webpack_require__(33);
	var uid = __webpack_require__(26);
	var wks = __webpack_require__(34);
	var wksExt = __webpack_require__(35);
	var wksDefine = __webpack_require__(36);
	var enumKeys = __webpack_require__(37);
	var isArray = __webpack_require__(52);
	var anObject = __webpack_require__(19);
	var isObject = __webpack_require__(20);
	var toIObject = __webpack_require__(40);
	var toPrimitive = __webpack_require__(23);
	var createDesc = __webpack_require__(24);
	var _create = __webpack_require__(53);
	var gOPNExt = __webpack_require__(56);
	var $GOPD = __webpack_require__(58);
	var $DP = __webpack_require__(18);
	var $keys = __webpack_require__(38);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(51).f = $propertyIsEnumerable;
	  __webpack_require__(50).f = $getOwnPropertySymbols;
	
	  if (DESCRIPTORS && !__webpack_require__(29)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
	
	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
	
	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(14)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var core = __webpack_require__(16);
	var hide = __webpack_require__(17);
	var redefine = __webpack_require__(25);
	var ctx = __webpack_require__(30);
	var PROTOTYPE = 'prototype';
	
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(18);
	var createDesc = __webpack_require__(24);
	module.exports = __webpack_require__(13) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(19);
	var IE8_DOM_DEFINE = __webpack_require__(21);
	var toPrimitive = __webpack_require__(23);
	var dP = Object.defineProperty;
	
	exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () {
	  return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	var document = __webpack_require__(11).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(20);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var hide = __webpack_require__(17);
	var has = __webpack_require__(12);
	var SRC = __webpack_require__(26)('src');
	var $toString = __webpack_require__(27);
	var TO_STRING = 'toString';
	var TPL = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(16).inspectSource = function (it) {
	  return $toString.call(it);
	};
	
	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(28)('native-function-to-string', Function.toString);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(16);
	var global = __webpack_require__(11);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});
	
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: core.version,
	  mode: __webpack_require__(29) ? 'pure' : 'global',
	  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
	});


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	module.exports = false;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(31);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(26)('meta');
	var isObject = __webpack_require__(20);
	var has = __webpack_require__(12);
	var setDesc = __webpack_require__(18).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(14)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(18).f;
	var has = __webpack_require__(12);
	var TAG = __webpack_require__(34)('toStringTag');
	
	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(28)('wks');
	var uid = __webpack_require__(26);
	var Symbol = __webpack_require__(11).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(34);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var core = __webpack_require__(16);
	var LIBRARY = __webpack_require__(29);
	var wksExt = __webpack_require__(35);
	var defineProperty = __webpack_require__(18).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(38);
	var gOPS = __webpack_require__(50);
	var pIE = __webpack_require__(51);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(39);
	var enumBugKeys = __webpack_require__(49);
	
	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(12);
	var toIObject = __webpack_require__(40);
	var arrayIndexOf = __webpack_require__(44)(false);
	var IE_PROTO = __webpack_require__(48)('IE_PROTO');
	
	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(41);
	var defined = __webpack_require__(43);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(42);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(40);
	var toLength = __webpack_require__(45);
	var toAbsoluteIndex = __webpack_require__(47);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(46);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(46);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(28)('keys');
	var uid = __webpack_require__(26);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 50 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(42);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(19);
	var dPs = __webpack_require__(54);
	var enumBugKeys = __webpack_require__(49);
	var IE_PROTO = __webpack_require__(48)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(22)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(55).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(18);
	var anObject = __webpack_require__(19);
	var getKeys = __webpack_require__(38);
	
	module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(11).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(40);
	var gOPN = __webpack_require__(57).f;
	var toString = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(39);
	var hiddenKeys = __webpack_require__(49).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(51);
	var createDesc = __webpack_require__(24);
	var toIObject = __webpack_require__(40);
	var toPrimitive = __webpack_require__(23);
	var has = __webpack_require__(12);
	var IE8_DOM_DEFINE = __webpack_require__(21);
	var gOPD = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(53) });


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(18).f });


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(54) });


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(40);
	var $getOwnPropertyDescriptor = __webpack_require__(58).f;
	
	__webpack_require__(63)('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(15);
	var core = __webpack_require__(16);
	var fails = __webpack_require__(14);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(65);
	var $getPrototypeOf = __webpack_require__(66);
	
	__webpack_require__(63)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(43);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(12);
	var toObject = __webpack_require__(65);
	var IE_PROTO = __webpack_require__(48)('IE_PROTO');
	var ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(65);
	var $keys = __webpack_require__(38);
	
	__webpack_require__(63)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(63)('getOwnPropertyNames', function () {
	  return __webpack_require__(56).f;
	});


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(20);
	var meta = __webpack_require__(32).onFreeze;
	
	__webpack_require__(63)('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(20);
	var meta = __webpack_require__(32).onFreeze;
	
	__webpack_require__(63)('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(20);
	var meta = __webpack_require__(32).onFreeze;
	
	__webpack_require__(63)('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(20);
	
	__webpack_require__(63)('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(20);
	
	__webpack_require__(63)('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(20);
	
	__webpack_require__(63)('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(15);
	
	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) });


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(38);
	var gOPS = __webpack_require__(50);
	var pIE = __webpack_require__(51);
	var toObject = __webpack_require__(65);
	var IObject = __webpack_require__(41);
	var $assign = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(14)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(15);
	$export($export.S, 'Object', { is: __webpack_require__(78) });


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(15);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set });


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(20);
	var anObject = __webpack_require__(19);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(82);
	var test = {};
	test[__webpack_require__(34)('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  __webpack_require__(25)(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(42);
	var TAG = __webpack_require__(34)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};
	
	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(15);
	
	$export($export.P, 'Function', { bind: __webpack_require__(84) });


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction = __webpack_require__(31);
	var isObject = __webpack_require__(20);
	var invoke = __webpack_require__(85);
	var arraySlice = [].slice;
	var factories = {};
	
	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(18).f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var isObject = __webpack_require__(20);
	var getPrototypeOf = __webpack_require__(66);
	var HAS_INSTANCE = __webpack_require__(34)('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !isObject(O)) return false;
	  if (!isObject(this.prototype)) return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
	  return false;
	} });


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var $parseInt = __webpack_require__(89);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(11).parseInt;
	var $trim = __webpack_require__(90).trim;
	var ws = __webpack_require__(91);
	var hex = /^[-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var defined = __webpack_require__(43);
	var fails = __webpack_require__(14);
	var spaces = __webpack_require__(91);
	var space = '[' + spaces + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');
	
	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = fails(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var $parseFloat = __webpack_require__(93);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(11).parseFloat;
	var $trim = __webpack_require__(90).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(11);
	var has = __webpack_require__(12);
	var cof = __webpack_require__(42);
	var inheritIfRequired = __webpack_require__(95);
	var toPrimitive = __webpack_require__(23);
	var fails = __webpack_require__(14);
	var gOPN = __webpack_require__(57).f;
	var gOPD = __webpack_require__(58).f;
	var dP = __webpack_require__(18).f;
	var $trim = __webpack_require__(90).trim;
	var NUMBER = 'Number';
	var $Number = global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = __webpack_require__(13) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++) {
	    if (has(Base, key = keys[j]) && !has($Number, key)) {
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(25)(global, NUMBER, $Number);
	}


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	var setPrototypeOf = __webpack_require__(80).set;
	module.exports = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toInteger = __webpack_require__(46);
	var aNumberValue = __webpack_require__(97);
	var repeat = __webpack_require__(98);
	var $toFixed = 1.0.toFixed;
	var floor = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';
	
	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(14)(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(42);
	module.exports = function (it, msg) {
	  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(46);
	var defined = __webpack_require__(43);
	
	module.exports = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
	  return res;
	};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $fails = __webpack_require__(14);
	var aNumberValue = __webpack_require__(97);
	var $toPrecision = 1.0.toPrecision;
	
	$export($export.P + $export.F * ($fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(15);
	var _isFinite = __webpack_require__(11).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Number', { isInteger: __webpack_require__(103) });


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(20);
	var floor = Math.floor;
	module.exports = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export = __webpack_require__(15);
	var isInteger = __webpack_require__(103);
	var abs = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var $parseFloat = __webpack_require__(93);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var $parseInt = __webpack_require__(89);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(15);
	var log1p = __webpack_require__(111);
	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});


/***/ }),
/* 111 */
/***/ (function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(15);
	var $asinh = Math.asinh;
	
	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(15);
	var $atanh = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(15);
	var sign = __webpack_require__(115);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});


/***/ }),
/* 115 */
/***/ (function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(15);
	var exp = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(15);
	var $expm1 = __webpack_require__(119);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 119 */
/***/ (function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { fround: __webpack_require__(121) });


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var sign = __webpack_require__(115);
	var pow = Math.pow;
	var EPSILON = pow(2, -52);
	var EPSILON32 = pow(2, -23);
	var MAX32 = pow(2, 127) * (2 - EPSILON32);
	var MIN32 = pow(2, -126);
	
	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	module.exports = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(15);
	var abs = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(15);
	var $imul = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(14)(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { log1p: __webpack_require__(111) });


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { sign: __webpack_require__(115) });


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(15);
	var expm1 = __webpack_require__(119);
	var exp = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(14)(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(15);
	var expm1 = __webpack_require__(119);
	var exp = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var toAbsoluteIndex = __webpack_require__(47);
	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var toIObject = __webpack_require__(40);
	var toLength = __webpack_require__(45);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(90)('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(135)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(136)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(46);
	var defined = __webpack_require__(43);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(29);
	var $export = __webpack_require__(15);
	var redefine = __webpack_require__(25);
	var hide = __webpack_require__(17);
	var Iterators = __webpack_require__(137);
	var $iterCreate = __webpack_require__(138);
	var setToStringTag = __webpack_require__(33);
	var getPrototypeOf = __webpack_require__(66);
	var ITERATOR = __webpack_require__(34)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';
	
	var returnThis = function () { return this; };
	
	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 137 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(53);
	var descriptor = __webpack_require__(24);
	var setToStringTag = __webpack_require__(33);
	var IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(17)(IteratorPrototype, __webpack_require__(34)('iterator'), function () { return this; });
	
	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $at = __webpack_require__(135)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export = __webpack_require__(15);
	var toLength = __webpack_require__(45);
	var context = __webpack_require__(141);
	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(142);
	var defined = __webpack_require__(43);
	
	module.exports = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(20);
	var cof = __webpack_require__(42);
	var MATCH = __webpack_require__(34)('match');
	module.exports = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(34)('match');
	module.exports = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export = __webpack_require__(15);
	var context = __webpack_require__(141);
	var INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(98)
	});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export = __webpack_require__(15);
	var toLength = __webpack_require__(45);
	var context = __webpack_require__(141);
	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(148)('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var fails = __webpack_require__(14);
	var defined = __webpack_require__(43);
	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(148)('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(148)('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(148)('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(148)('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(148)('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(148)('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(148)('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(148)('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(148)('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(148)('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(148)('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(148)('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var toPrimitive = __webpack_require__(23);
	
	$export($export.P + $export.F * __webpack_require__(14)(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(15);
	var toISOString = __webpack_require__(164);
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var fails = __webpack_require__(14);
	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;
	
	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	module.exports = (fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  __webpack_require__(25)(DateProto, TO_STRING, function toString() {
	    var value = getTime.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(34)('toPrimitive');
	var proto = Date.prototype;
	
	if (!(TO_PRIMITIVE in proto)) __webpack_require__(17)(proto, TO_PRIMITIVE, __webpack_require__(167));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var anObject = __webpack_require__(19);
	var toPrimitive = __webpack_require__(23);
	var NUMBER = 'number';
	
	module.exports = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Array', { isArray: __webpack_require__(52) });


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ctx = __webpack_require__(30);
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var call = __webpack_require__(170);
	var isArrayIter = __webpack_require__(171);
	var toLength = __webpack_require__(45);
	var createProperty = __webpack_require__(172);
	var getIterFn = __webpack_require__(173);
	
	$export($export.S + $export.F * !__webpack_require__(174)(function (iter) { Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = getIterFn(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(19);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(137);
	var ITERATOR = __webpack_require__(34)('iterator');
	var ArrayProto = Array.prototype;
	
	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(18);
	var createDesc = __webpack_require__(24);
	
	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(82);
	var ITERATOR = __webpack_require__(34)('iterator');
	var Iterators = __webpack_require__(137);
	module.exports = __webpack_require__(16).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(34)('iterator');
	var SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }
	
	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var createProperty = __webpack_require__(172);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(14)(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export = __webpack_require__(15);
	var toIObject = __webpack_require__(40);
	var arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(41) != Object || !__webpack_require__(177)(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var fails = __webpack_require__(14);
	
	module.exports = function (method, arg) {
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var html = __webpack_require__(55);
	var cof = __webpack_require__(42);
	var toAbsoluteIndex = __webpack_require__(47);
	var toLength = __webpack_require__(45);
	var arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(14)(function () {
	  if (html) arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice.call(this, begin, end);
	    var start = toAbsoluteIndex(begin, len);
	    var upTo = toAbsoluteIndex(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var aFunction = __webpack_require__(31);
	var toObject = __webpack_require__(65);
	var fails = __webpack_require__(14);
	var $sort = [].sort;
	var test = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(177)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $forEach = __webpack_require__(181)(0);
	var STRICT = __webpack_require__(177)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = __webpack_require__(30);
	var IObject = __webpack_require__(41);
	var toObject = __webpack_require__(65);
	var toLength = __webpack_require__(45);
	var asc = __webpack_require__(182);
	module.exports = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(183);
	
	module.exports = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	var isArray = __webpack_require__(52);
	var SPECIES = __webpack_require__(34)('species');
	
	module.exports = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $map = __webpack_require__(181)(1);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $filter = __webpack_require__(181)(2);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $some = __webpack_require__(181)(3);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $every = __webpack_require__(181)(4);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $reduce = __webpack_require__(189);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(31);
	var toObject = __webpack_require__(65);
	var IObject = __webpack_require__(41);
	var toLength = __webpack_require__(45);
	
	module.exports = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = toObject(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $reduce = __webpack_require__(189);
	
	$export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $indexOf = __webpack_require__(44)(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toIObject = __webpack_require__(40);
	var toInteger = __webpack_require__(46);
	var toLength = __webpack_require__(45);
	var $native = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(15);
	
	$export($export.P, 'Array', { copyWithin: __webpack_require__(194) });
	
	__webpack_require__(195)('copyWithin');


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(65);
	var toAbsoluteIndex = __webpack_require__(47);
	var toLength = __webpack_require__(45);
	
	module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(34)('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {});
	module.exports = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(15);
	
	$export($export.P, 'Array', { fill: __webpack_require__(197) });
	
	__webpack_require__(195)('fill');


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(65);
	var toAbsoluteIndex = __webpack_require__(47);
	var toLength = __webpack_require__(45);
	module.exports = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(15);
	var $find = __webpack_require__(181)(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(195)(KEY);


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(15);
	var $find = __webpack_require__(181)(6);
	var KEY = 'findIndex';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(195)(KEY);


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(201)('Array');


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(11);
	var dP = __webpack_require__(18);
	var DESCRIPTORS = __webpack_require__(13);
	var SPECIES = __webpack_require__(34)('species');
	
	module.exports = function (KEY) {
	  var C = global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(195);
	var step = __webpack_require__(203);
	var Iterators = __webpack_require__(137);
	var toIObject = __webpack_require__(40);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 203 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var inheritIfRequired = __webpack_require__(95);
	var dP = __webpack_require__(18).f;
	var gOPN = __webpack_require__(57).f;
	var isRegExp = __webpack_require__(142);
	var $flags = __webpack_require__(205);
	var $RegExp = global.RegExp;
	var Base = $RegExp;
	var proto = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;
	
	if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(14)(function () {
	  re2[__webpack_require__(34)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(25)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(201)('RegExp');


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(19);
	module.exports = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var regexpExec = __webpack_require__(207);
	__webpack_require__(15)({
	  target: 'RegExp',
	  proto: true,
	  forced: regexpExec !== /./.exec
	}, {
	  exec: regexpExec
	});


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var regexpFlags = __webpack_require__(205);
	
	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;
	
	var patchedExec = nativeExec;
	
	var LAST_INDEX = 'lastIndex';
	
	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/,
	      re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
	})();
	
	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	
	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
	
	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	
	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
	
	    match = nativeExec.call(re, str);
	
	    if (UPDATES_LAST_INDEX_WRONG && match) {
	      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      // eslint-disable-next-line no-loop-func
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }
	
	    return match;
	  };
	}
	
	module.exports = patchedExec;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(209);
	var anObject = __webpack_require__(19);
	var $flags = __webpack_require__(205);
	var DESCRIPTORS = __webpack_require__(13);
	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];
	
	var define = function (fn) {
	  __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if (__webpack_require__(14)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(18).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(205)
	});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var anObject = __webpack_require__(19);
	var toLength = __webpack_require__(45);
	var advanceStringIndex = __webpack_require__(211);
	var regExpExec = __webpack_require__(212);
	
	// @@match logic
	__webpack_require__(213)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[MATCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative($match, regexp, this);
	      if (res.done) return res.value;
	      var rx = anObject(regexp);
	      var S = String(this);
	      if (!rx.global) return regExpExec(rx, S);
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regExpExec(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var at = __webpack_require__(135)(true);
	
	 // `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	module.exports = function (S, index, unicode) {
	  return index + (unicode ? at(S, index).length : 1);
	};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var classof = __webpack_require__(82);
	var builtinExec = RegExp.prototype.exec;
	
	 // `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	module.exports = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw new TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }
	  if (classof(R) !== 'RegExp') {
	    throw new TypeError('RegExp#exec called on incompatible receiver');
	  }
	  return builtinExec.call(R, S);
	};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(206);
	var redefine = __webpack_require__(25);
	var hide = __webpack_require__(17);
	var fails = __webpack_require__(14);
	var defined = __webpack_require__(43);
	var wks = __webpack_require__(34);
	var regexpExec = __webpack_require__(207);
	
	var SPECIES = wks('species');
	
	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});
	
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
	  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
	})();
	
	module.exports = function (KEY, length, exec) {
	  var SYMBOL = wks(KEY);
	
	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });
	
	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;
	    re.exec = function () { execCalled = true; return null; };
	    if (KEY === 'split') {
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES] = function () { return re; };
	    }
	    re[SYMBOL]('');
	    return !execCalled;
	  }) : undefined;
	
	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var fns = exec(
	      defined,
	      SYMBOL,
	      ''[KEY],
	      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
	        if (regexp.exec === regexpExec) {
	          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	            // The native String method already delegates to @@method (this
	            // polyfilled function), leasing to infinite recursion.
	            // We avoid it by directly calling the native @@method method.
	            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	          }
	          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	        }
	        return { done: false };
	      }
	    );
	    var strfn = fns[0];
	    var rxfn = fns[1];
	
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var anObject = __webpack_require__(19);
	var toObject = __webpack_require__(65);
	var toLength = __webpack_require__(45);
	var toInteger = __webpack_require__(46);
	var advanceStringIndex = __webpack_require__(211);
	var regExpExec = __webpack_require__(212);
	var max = Math.max;
	var min = Math.min;
	var floor = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
	
	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};
	
	// @@replace logic
	__webpack_require__(213)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = defined(this);
	      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return fn !== undefined
	        ? fn.call(searchValue, O, replaceValue)
	        : $replace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      var res = maybeCallNative($replace, regexp, this, replaceValue);
	      if (res.done) return res.value;
	
	      var rx = anObject(regexp);
	      var S = String(this);
	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);
	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regExpExec(rx, S);
	        if (result === null) break;
	        results.push(result);
	        if (!global) break;
	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }
	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];
	        var matched = String(result[0]);
	        var position = max(min(toInteger(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];
	
	    // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return $replace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var anObject = __webpack_require__(19);
	var sameValue = __webpack_require__(78);
	var regExpExec = __webpack_require__(212);
	
	// @@search logic
	__webpack_require__(213)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = defined(this);
	      var fn = regexp == undefined ? undefined : regexp[SEARCH];
	      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative($search, regexp, this);
	      if (res.done) return res.value;
	      var rx = anObject(regexp);
	      var S = String(this);
	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regExpExec(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var isRegExp = __webpack_require__(142);
	var anObject = __webpack_require__(19);
	var speciesConstructor = __webpack_require__(217);
	var advanceStringIndex = __webpack_require__(211);
	var toLength = __webpack_require__(45);
	var callRegExpExec = __webpack_require__(212);
	var regexpExec = __webpack_require__(207);
	var fails = __webpack_require__(14);
	var $min = Math.min;
	var $push = [].push;
	var $SPLIT = 'split';
	var LENGTH = 'length';
	var LAST_INDEX = 'lastIndex';
	var MAX_UINT32 = 0xffffffff;
	
	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });
	
	// @@split logic
	__webpack_require__(213)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return $split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy[LAST_INDEX];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
	    };
	  } else {
	    internalSplit = $split;
	  }
	
	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = defined(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
	      if (res.done) return res.value;
	
	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);
	
	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');
	
	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	});


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(19);
	var aFunction = __webpack_require__(31);
	var SPECIES = __webpack_require__(34)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(29);
	var global = __webpack_require__(11);
	var ctx = __webpack_require__(30);
	var classof = __webpack_require__(82);
	var $export = __webpack_require__(15);
	var isObject = __webpack_require__(20);
	var aFunction = __webpack_require__(31);
	var anInstance = __webpack_require__(219);
	var forOf = __webpack_require__(220);
	var speciesConstructor = __webpack_require__(217);
	var task = __webpack_require__(221).set;
	var microtask = __webpack_require__(222)();
	var newPromiseCapabilityModule = __webpack_require__(223);
	var perform = __webpack_require__(224);
	var userAgent = __webpack_require__(225);
	var promiseResolve = __webpack_require__(226);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
	
	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(34)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();
	
	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};
	
	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(227)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(33)($Promise, PROMISE);
	__webpack_require__(201)(PROMISE);
	Wrapper = __webpack_require__(16)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(174)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


/***/ }),
/* 219 */
/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(30);
	var call = __webpack_require__(170);
	var isArrayIter = __webpack_require__(171);
	var anObject = __webpack_require__(19);
	var toLength = __webpack_require__(45);
	var getIterFn = __webpack_require__(173);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(30);
	var invoke = __webpack_require__(85);
	var html = __webpack_require__(55);
	var cel = __webpack_require__(22);
	var global = __webpack_require__(11);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(42)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var macrotask = __webpack_require__(221).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(42)(process) == 'process';
	
	module.exports = function () {
	  var head, last, notify;
	
	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };
	
	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(31);
	
	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}
	
	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


/***/ }),
/* 224 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var navigator = global.navigator;
	
	module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(19);
	var isObject = __webpack_require__(20);
	var newPromiseCapability = __webpack_require__(223);
	
	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(25);
	module.exports = function (target, src, safe) {
	  for (var key in src) redefine(target, key, src[key], safe);
	  return target;
	};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(229);
	var validate = __webpack_require__(230);
	var MAP = 'Map';
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(231)(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var dP = __webpack_require__(18).f;
	var create = __webpack_require__(53);
	var redefineAll = __webpack_require__(227);
	var ctx = __webpack_require__(30);
	var anInstance = __webpack_require__(219);
	var forOf = __webpack_require__(220);
	var $iterDefine = __webpack_require__(136);
	var step = __webpack_require__(203);
	var setSpecies = __webpack_require__(201);
	var DESCRIPTORS = __webpack_require__(13);
	var fastKey = __webpack_require__(32).fastKey;
	var validate = __webpack_require__(230);
	var SIZE = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (DESCRIPTORS) dP(C.prototype, 'size', {
	      get: function () {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(20);
	module.exports = function (it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(11);
	var $export = __webpack_require__(15);
	var redefine = __webpack_require__(25);
	var redefineAll = __webpack_require__(227);
	var meta = __webpack_require__(32);
	var forOf = __webpack_require__(220);
	var anInstance = __webpack_require__(219);
	var isObject = __webpack_require__(20);
	var fails = __webpack_require__(14);
	var $iterDetect = __webpack_require__(174);
	var setToStringTag = __webpack_require__(33);
	var inheritIfRequired = __webpack_require__(95);
	
	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(229);
	var validate = __webpack_require__(230);
	var SET = 'Set';
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(231)(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(11);
	var each = __webpack_require__(181)(0);
	var redefine = __webpack_require__(25);
	var meta = __webpack_require__(32);
	var assign = __webpack_require__(76);
	var weak = __webpack_require__(234);
	var isObject = __webpack_require__(20);
	var validate = __webpack_require__(230);
	var NATIVE_WEAK_MAP = __webpack_require__(230);
	var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
	var WEAK_MAP = 'WeakMap';
	var getWeak = meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = weak.ufstore;
	var InternalMap;
	
	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(validate(this, WEAK_MAP), key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(231)(WEAK_MAP, wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if (NATIVE_WEAK_MAP && IS_IE11) {
	  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll = __webpack_require__(227);
	var getWeak = __webpack_require__(32).getWeak;
	var anObject = __webpack_require__(19);
	var isObject = __webpack_require__(20);
	var anInstance = __webpack_require__(219);
	var forOf = __webpack_require__(220);
	var createArrayMethod = __webpack_require__(181);
	var $has = __webpack_require__(12);
	var validate = __webpack_require__(230);
	var arrayFind = createArrayMethod(5);
	var arrayFindIndex = createArrayMethod(6);
	var id = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(234);
	var validate = __webpack_require__(230);
	var WEAK_SET = 'WeakSet';
	
	// 23.4 WeakSet Objects
	__webpack_require__(231)(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var $typed = __webpack_require__(237);
	var buffer = __webpack_require__(238);
	var anObject = __webpack_require__(19);
	var toAbsoluteIndex = __webpack_require__(47);
	var toLength = __webpack_require__(45);
	var isObject = __webpack_require__(20);
	var ArrayBuffer = __webpack_require__(11).ArrayBuffer;
	var speciesConstructor = __webpack_require__(217);
	var $ArrayBuffer = buffer.ArrayBuffer;
	var $DataView = buffer.DataView;
	var $isView = $typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW = $typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(14)(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, len);
	    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < fin) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(201)(ARRAY_BUFFER);


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11);
	var hide = __webpack_require__(17);
	var uid = __webpack_require__(26);
	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(global.ArrayBuffer && global.DataView);
	var CONSTR = ABV;
	var i = 0;
	var l = 9;
	var Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while (i < l) {
	  if (Typed = global[TypedArrayConstructors[i++]]) {
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(11);
	var DESCRIPTORS = __webpack_require__(13);
	var LIBRARY = __webpack_require__(29);
	var $typed = __webpack_require__(237);
	var hide = __webpack_require__(17);
	var redefineAll = __webpack_require__(227);
	var fails = __webpack_require__(14);
	var anInstance = __webpack_require__(219);
	var toInteger = __webpack_require__(46);
	var toLength = __webpack_require__(45);
	var toIndex = __webpack_require__(239);
	var gOPN = __webpack_require__(57).f;
	var dP = __webpack_require__(18).f;
	var arrayFill = __webpack_require__(197);
	var setToStringTag = __webpack_require__(33);
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = global[ARRAY_BUFFER];
	var $DataView = global[DATA_VIEW];
	var Math = global.Math;
	var RangeError = global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
	var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
	var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}
	
	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}
	
	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}
	
	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}
	
	if (!$typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    this._b = arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if (DESCRIPTORS) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!fails(function () {
	    $ArrayBuffer(1);
	  }) || !fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/ecma262/#sec-toindex
	var toInteger = __webpack_require__(46);
	var toLength = __webpack_require__(45);
	module.exports = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	$export($export.G + $export.W + $export.F * !__webpack_require__(237).ABV, {
	  DataView: __webpack_require__(238).DataView
	});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	if (__webpack_require__(13)) {
	  var LIBRARY = __webpack_require__(29);
	  var global = __webpack_require__(11);
	  var fails = __webpack_require__(14);
	  var $export = __webpack_require__(15);
	  var $typed = __webpack_require__(237);
	  var $buffer = __webpack_require__(238);
	  var ctx = __webpack_require__(30);
	  var anInstance = __webpack_require__(219);
	  var propertyDesc = __webpack_require__(24);
	  var hide = __webpack_require__(17);
	  var redefineAll = __webpack_require__(227);
	  var toInteger = __webpack_require__(46);
	  var toLength = __webpack_require__(45);
	  var toIndex = __webpack_require__(239);
	  var toAbsoluteIndex = __webpack_require__(47);
	  var toPrimitive = __webpack_require__(23);
	  var has = __webpack_require__(12);
	  var classof = __webpack_require__(82);
	  var isObject = __webpack_require__(20);
	  var toObject = __webpack_require__(65);
	  var isArrayIter = __webpack_require__(171);
	  var create = __webpack_require__(53);
	  var getPrototypeOf = __webpack_require__(66);
	  var gOPN = __webpack_require__(57).f;
	  var getIterFn = __webpack_require__(173);
	  var uid = __webpack_require__(26);
	  var wks = __webpack_require__(34);
	  var createArrayMethod = __webpack_require__(181);
	  var createArrayIncludes = __webpack_require__(44);
	  var speciesConstructor = __webpack_require__(217);
	  var ArrayIterators = __webpack_require__(202);
	  var Iterators = __webpack_require__(137);
	  var $iterDetect = __webpack_require__(174);
	  var setSpecies = __webpack_require__(201);
	  var arrayFill = __webpack_require__(197);
	  var arrayCopyWithin = __webpack_require__(194);
	  var $DP = __webpack_require__(18);
	  var $GOPD = __webpack_require__(58);
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });
	
	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };
	
	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };
	
	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });
	
	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });
	
	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });
	
	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });
	
	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
	
	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });
	
	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(242)('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(15);
	var aFunction = __webpack_require__(31);
	var anObject = __webpack_require__(19);
	var rApply = (__webpack_require__(11).Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(14)(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export = __webpack_require__(15);
	var create = __webpack_require__(53);
	var aFunction = __webpack_require__(31);
	var anObject = __webpack_require__(19);
	var isObject = __webpack_require__(20);
	var fails = __webpack_require__(14);
	var bind = __webpack_require__(84);
	var rConstruct = (__webpack_require__(11).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  rConstruct(function () { /* empty */ });
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP = __webpack_require__(18);
	var $export = __webpack_require__(15);
	var anObject = __webpack_require__(19);
	var toPrimitive = __webpack_require__(23);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(14)(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export = __webpack_require__(15);
	var gOPD = __webpack_require__(58).f;
	var anObject = __webpack_require__(19);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export = __webpack_require__(15);
	var anObject = __webpack_require__(19);
	var Enumerate = function (iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) keys.push(key);
	};
	__webpack_require__(138)(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD = __webpack_require__(58);
	var getPrototypeOf = __webpack_require__(66);
	var has = __webpack_require__(12);
	var $export = __webpack_require__(15);
	var isObject = __webpack_require__(20);
	var anObject = __webpack_require__(19);
	
	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD = __webpack_require__(58);
	var $export = __webpack_require__(15);
	var anObject = __webpack_require__(19);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export = __webpack_require__(15);
	var getProto = __webpack_require__(66);
	var anObject = __webpack_require__(19);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return getProto(anObject(target));
	  }
	});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export = __webpack_require__(15);
	var anObject = __webpack_require__(19);
	var $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Reflect', { ownKeys: __webpack_require__(262) });


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN = __webpack_require__(57);
	var gOPS = __webpack_require__(50);
	var anObject = __webpack_require__(19);
	var Reflect = __webpack_require__(11).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export = __webpack_require__(15);
	var anObject = __webpack_require__(19);
	var $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP = __webpack_require__(18);
	var gOPD = __webpack_require__(58);
	var getPrototypeOf = __webpack_require__(66);
	var has = __webpack_require__(12);
	var $export = __webpack_require__(15);
	var createDesc = __webpack_require__(24);
	var anObject = __webpack_require__(19);
	var isObject = __webpack_require__(20);
	
	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = gOPD.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = getPrototypeOf(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      dP.f(receiver, propertyKey, existingDescriptor);
	    } else dP.f(receiver, propertyKey, createDesc(0, V));
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export = __webpack_require__(15);
	var setProto = __webpack_require__(80);
	
	if (setProto) $export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export = __webpack_require__(15);
	var $includes = __webpack_require__(44)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(195)('includes');


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
	var $export = __webpack_require__(15);
	var flattenIntoArray = __webpack_require__(268);
	var toObject = __webpack_require__(65);
	var toLength = __webpack_require__(45);
	var aFunction = __webpack_require__(31);
	var arraySpeciesCreate = __webpack_require__(182);
	
	$export($export.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});
	
	__webpack_require__(195)('flatMap');


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var isArray = __webpack_require__(52);
	var isObject = __webpack_require__(20);
	var toLength = __webpack_require__(45);
	var ctx = __webpack_require__(30);
	var IS_CONCAT_SPREADABLE = __webpack_require__(34)('isConcatSpreadable');
	
	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;
	
	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
	
	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }
	
	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }
	
	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}
	
	module.exports = flattenIntoArray;


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
	var $export = __webpack_require__(15);
	var flattenIntoArray = __webpack_require__(268);
	var toObject = __webpack_require__(65);
	var toLength = __webpack_require__(45);
	var toInteger = __webpack_require__(46);
	var arraySpeciesCreate = __webpack_require__(182);
	
	$export($export.P, 'Array', {
	  flatten: function flatten(/* depthArg = 1 */) {
	    var depthArg = arguments[0];
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});
	
	__webpack_require__(195)('flatten');


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(15);
	var $at = __webpack_require__(135)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(15);
	var $pad = __webpack_require__(272);
	var userAgent = __webpack_require__(225);
	
	// https://github.com/zloirock/core-js/issues/280
	var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
	
	$export($export.P + $export.F * WEBKIT_BUG, 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(45);
	var repeat = __webpack_require__(98);
	var defined = __webpack_require__(43);
	
	module.exports = function (that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(15);
	var $pad = __webpack_require__(272);
	var userAgent = __webpack_require__(225);
	
	// https://github.com/zloirock/core-js/issues/280
	var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
	
	$export($export.P + $export.F * WEBKIT_BUG, 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(90)('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(90)('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export = __webpack_require__(15);
	var defined = __webpack_require__(43);
	var toLength = __webpack_require__(45);
	var isRegExp = __webpack_require__(142);
	var getFlags = __webpack_require__(205);
	var RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function (regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(138)($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(36)('asyncIterator');


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(36)('observable');


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export = __webpack_require__(15);
	var ownKeys = __webpack_require__(262);
	var toIObject = __webpack_require__(40);
	var gOPD = __webpack_require__(58);
	var createProperty = __webpack_require__(172);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = gOPD.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(15);
	var $values = __webpack_require__(281)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys = __webpack_require__(38);
	var toIObject = __webpack_require__(40);
	var isEnum = __webpack_require__(51).f;
	module.exports = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) if (isEnum.call(O, key = keys[i++])) {
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(15);
	var $entries = __webpack_require__(281)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var aFunction = __webpack_require__(31);
	var $defineProperty = __webpack_require__(18);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(13) && $export($export.P + __webpack_require__(284), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(29) || !__webpack_require__(14)(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () { /* empty */ });
	  delete __webpack_require__(11)[K];
	});


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var aFunction = __webpack_require__(31);
	var $defineProperty = __webpack_require__(18);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(13) && $export($export.P + __webpack_require__(284), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var toPrimitive = __webpack_require__(23);
	var getPrototypeOf = __webpack_require__(66);
	var getOwnPropertyDescriptor = __webpack_require__(58).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(13) && $export($export.P + __webpack_require__(284), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(15);
	var toObject = __webpack_require__(65);
	var toPrimitive = __webpack_require__(23);
	var getPrototypeOf = __webpack_require__(66);
	var getOwnPropertyDescriptor = __webpack_require__(58).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(13) && $export($export.P + __webpack_require__(284), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(15);
	
	$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(289)('Map') });


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(82);
	var from = __webpack_require__(290);
	module.exports = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(220);
	
	module.exports = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(15);
	
	$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(289)('Set') });


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	__webpack_require__(293)('Map');


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(15);
	
	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { of: function of() {
	    var length = arguments.length;
	    var A = new Array(length);
	    while (length--) A[length] = arguments[length];
	    return new this(A);
	  } });
	};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	__webpack_require__(293)('Set');


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	__webpack_require__(293)('WeakMap');


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	__webpack_require__(293)('WeakSet');


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	__webpack_require__(298)('Map');


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(15);
	var aFunction = __webpack_require__(31);
	var ctx = __webpack_require__(30);
	var forOf = __webpack_require__(220);
	
	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	    var mapFn = arguments[1];
	    var mapping, A, n, cb;
	    aFunction(this);
	    mapping = mapFn !== undefined;
	    if (mapping) aFunction(mapFn);
	    if (source == undefined) return new this();
	    A = [];
	    if (mapping) {
	      n = 0;
	      cb = ctx(mapFn, arguments[2], 2);
	      forOf(source, false, function (nextItem) {
	        A.push(cb(nextItem, n++));
	      });
	    } else {
	      forOf(source, false, A.push, A);
	    }
	    return new this(A);
	  } });
	};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	__webpack_require__(298)('Set');


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	__webpack_require__(298)('WeakMap');


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	__webpack_require__(298)('WeakSet');


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(15);
	
	$export($export.G, { global: __webpack_require__(11) });


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(15);
	
	$export($export.S, 'System', { global: __webpack_require__(11) });


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(15);
	var cof = __webpack_require__(42);
	
	$export($export.S, 'Error', {
	  isError: function isError(it) {
	    return cof(it) === 'Error';
	  }
	});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	var RAD_PER_DEG = 180 / Math.PI;
	
	$export($export.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	var scale = __webpack_require__(309);
	var fround = __webpack_require__(121);
	
	$export($export.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(scale(x, inLow, inHigh, outLow, outHigh));
	  }
	});


/***/ }),
/* 309 */
/***/ (function(module, exports) {

	// https://rwaldron.github.io/proposal-math-extensions/
	module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      // eslint-disable-next-line no-self-compare
	      || x != x
	      // eslint-disable-next-line no-self-compare
	      || inLow != inLow
	      // eslint-disable-next-line no-self-compare
	      || inHigh != inHigh
	      // eslint-disable-next-line no-self-compare
	      || outLow != outLow
	      // eslint-disable-next-line no-self-compare
	      || outHigh != outHigh
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	var DEG_PER_RAD = Math.PI / 180;
	
	$export($export.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { scale: __webpack_require__(309) });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	// http://jfbastien.github.io/papers/Math.signbit.html
	var $export = __webpack_require__(15);
	
	$export($export.S, 'Math', { signbit: function signbit(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	} });


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = __webpack_require__(15);
	var core = __webpack_require__(16);
	var global = __webpack_require__(11);
	var speciesConstructor = __webpack_require__(217);
	var promiseResolve = __webpack_require__(226);
	
	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(15);
	var newPromiseCapability = __webpack_require__(223);
	var perform = __webpack_require__(224);
	
	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var toMetaKey = metadata.key;
	var ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	} });


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(228);
	var $export = __webpack_require__(15);
	var shared = __webpack_require__(28)('metadata');
	var store = shared.store || (shared.store = new (__webpack_require__(233))());
	
	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new Map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map());
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};
	var toMetaKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function (O) {
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var toMetaKey = metadata.key;
	var getOrCreateMetadataMap = metadata.map;
	var store = metadata.store;
	
	metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
	  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	  if (metadataMap.size) return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	} });


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var getPrototypeOf = __webpack_require__(66);
	var ordinaryHasOwnMetadata = metadata.has;
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;
	
	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(232);
	var from = __webpack_require__(290);
	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var getPrototypeOf = __webpack_require__(66);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;
	
	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys(O, P);
	  var parent = getPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var getPrototypeOf = __webpack_require__(66);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;
	
	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;
	
	metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	var $metadata = __webpack_require__(321);
	var anObject = __webpack_require__(19);
	var aFunction = __webpack_require__(31);
	var toMetaKey = $metadata.key;
	var ordinaryDefineOwnMetadata = $metadata.set;
	
	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	  return function decorator(target, targetKey) {
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	} });


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export = __webpack_require__(15);
	var microtask = __webpack_require__(222)();
	var process = __webpack_require__(11).process;
	var isNode = __webpack_require__(42)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn) {
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export = __webpack_require__(15);
	var global = __webpack_require__(11);
	var core = __webpack_require__(16);
	var microtask = __webpack_require__(222)();
	var OBSERVABLE = __webpack_require__(34)('observable');
	var aFunction = __webpack_require__(31);
	var anObject = __webpack_require__(19);
	var anInstance = __webpack_require__(219);
	var redefineAll = __webpack_require__(227);
	var hide = __webpack_require__(17);
	var forOf = __webpack_require__(220);
	var RETURN = forOf.RETURN;
	
	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function (subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function (subscription) {
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function (subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function (observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  } if (subscriptionClosed(this)) cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() { closeSubscription(this); }
	});
	
	var SubscriptionObserver = function (subscription) {
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (core.Promise || global.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function (value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function () { return this; });
	
	$export($export.G, { Observable: $Observable });
	
	__webpack_require__(201)('Observable');


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global = __webpack_require__(11);
	var $export = __webpack_require__(15);
	var userAgent = __webpack_require__(225);
	var slice = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
	var wrap = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout: wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(15);
	var $task = __webpack_require__(221);
	$export($export.G + $export.B, {
	  setImmediate: $task.set,
	  clearImmediate: $task.clear
	});


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	var $iterators = __webpack_require__(202);
	var getKeys = __webpack_require__(38);
	var redefine = __webpack_require__(25);
	var global = __webpack_require__(11);
	var hide = __webpack_require__(17);
	var Iterators = __webpack_require__(137);
	var wks = __webpack_require__(34);
	var ITERATOR = wks('iterator');
	var TO_STRING_TAG = wks('toStringTag');
	var ArrayValues = Iterators.Array;
	
	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};
	
	for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
	  }
	}


/***/ }),
/* 335 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof global.process === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !! caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(337);
	module.exports = __webpack_require__(16).RegExp.escape;


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(15);
	var $re = __webpack_require__(338)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 338 */
/***/ (function(module, exports) {

	module.exports = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(340);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(342)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./node_modules/css-loader/index.js!./style.css", function() {
				var newContent = require("!!./node_modules/css-loader/index.js!./style.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(341)();
	// imports
	
	
	// module
	exports.push([module.id, ".lime {\n  all: initial;\n}\n.lime.top_div {\n  display: flex;\n  flex-wrap: wrap;\n}\n.lime.predict_proba {\n  width: 245px;\n}\n.lime.predicted_value {\n  width: 245px;\n}\n.lime.explanation {\n  width: 350px;\n}\n\n.lime.text_div {\n  max-height:300px;\n  flex: 1 0 300px;\n  overflow:scroll;\n}\n.lime.table_div {\n  max-height:300px;\n  flex: 1 0 300px;\n  overflow:scroll;\n}\n.lime.table_div table {\n  border-collapse: collapse;\n  color: white;\n  border-style: hidden;\n  margin: 0 auto;\n}\n", ""]);
	
	// exports


/***/ }),
/* 341 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map </script></head><body>
        <div class="lime top_div" id="top_div9ZU7YDZ0TNG1OZW"></div>
        
        <script>
        var top_div = d3.select('#top_div9ZU7YDZ0TNG1OZW').classed('lime top_div', true);
        
        
                    var pp_div = top_div.append('div')
                                        .classed('lime predicted_value', true);
                    var pp_svg = pp_div.append('svg').style('width', '100%');
                    var pp = new lime.PredictedValue(pp_svg, 11.824242424242424, 11.824242424242424, 45.7125);
                    
        var exp_div;
            var exp = new lime.Explanation(["negative", "positive"]);
        
            exp_div = top_div.append('div').classed('lime explanation', true);
            exp.show([["LSTAT > 16.95", -5.50529641376858], ["CRIM > 3.72", -3.4953266791022015], ["RM <= 5.88", -3.303642287599497], ["DIS <= 2.07", 0.8020734300320679], ["0.54 < NOX <= 0.65", 0.47689537870042653], ["CHAS <= 0.00", 0.28595260457298477], ["9.69 < INDUS <= 18.10", 0.23825930105819787], ["AGE > 94.50", -0.2329841309536403], ["5.00 < RAD <= 24.00", -0.21452402148829672], ["ZN <= 0.00", -0.126254202020607]], 1, exp_div);
            
        var raw_div = top_div.append('div');
            exp.show_raw_tabular([["LSTAT", "34.37", -5.50529641376858], ["CRIM", "18.81", -3.4953266791022015], ["RM", "4.63", -3.303642287599497], ["DIS", "1.55", 0.8020734300320679], ["NOX", "0.60", 0.47689537870042653], ["CHAS", "0.00", 0.28595260457298477], ["INDUS", "18.10", 0.23825930105819787], ["AGE", "100.00", -0.2329841309536403], ["RAD", "24.00", -0.21452402148829672], ["ZN", "0.00", -0.126254202020607]], 1, raw_div);
        
        </script>
        </body></html>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Dependency-Plot">Dependency Plot<a class="anchor-link" href="#Dependency-Plot">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[204]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">dependence_plot</span><span class="p">(</span><span class="s1">&#39;RM&#39;</span><span class="p">,</span> <span class="n">sh_values</span><span class="p">,</span> <span class="n">X_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Interaction-Values">Interaction Values<a class="anchor-link" href="#Interaction-Values">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[254]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">decision_plot</span><span class="p">(</span><span class="n">sh_expected_value</span><span class="p">,</span> 
                   <span class="n">sh_interactions</span><span class="p">,</span> 
                   <span class="n">feature_names</span><span class="o">=</span><span class="n">feature_names</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfkAAAJFCAYAAADeVo53AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjEsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8QZhcZAAAgAElEQVR4nOy9d5hURfq3f9cJnaYnJ8KQg0hQQgMCIgLmiDnruuaAec1rDmvYXV1dc5YVYVUUw5qVJMEWQTIMcWCYnHo6nnOq3j/OAILo1+/7+ynXy577uubq7grn1NTU1Oc8Vc9TLZRSeHh4eHh4eOx9aHu6AR4eHh4eHh6/DZ7Ie3h4eHh47KV4Iu/h4eHh4bGX4om8h4eHh4fHXoon8h4eHh4eHnspnsh7eHh4eHjspRh7ugH/jUQikQ1Aqu0H4KZoNPrJnmvR3kskEnkUOAnoCgyIRqNL29J7A68ChUA9cG40Gl2zp9q5N/ILfb8Bb/z/pkQikULgdaAHkAbKgUui0WitN/Z/W/6Hvt/A7zz2PZHfc5y8bdLz+E15F3gcmLVL+jPAP6PR6KRIJHI28Cww7vdu3F7Oz/U9eOP/t0YBD0ej0a8BIpHII8BfgAvwxv5vzS/1PfzOY99brvfYq4lGo7Oj0WjFj9MikUgJMBiY3JY0GRgciUSKf+/27c3sru89fh+i0WjDNpFpYx7QxRv7vz0/1/d7qDmeJb8H+VckEhHAbODWaDTatKcb9F9EJ2BLNBp1AKLRqBOJRCrb0mv3aMv+e/DG/+9EJBLRgMuA6Xhj/3dll77fxu869j1Lfs8wOhqN7g8MBQTw5B5uj4fH74k3/n9fngBa8fp5T7Br3//uY98T+T3AtiXMaDSaBp4CRu3ZFv3XUQF0jEQiOkDba4e2dI/fGG/8/360OT/2Ak6LRqMSb+z/buym7/fI2PdE/ncmEolkRSKR3Lb3AjgdWLRnW/XfRTQarcHt8zPaks4Avo9Go95y5W+MN/5/PyKRyP3AEGBCm6h4Y/93Ynd9v6fGvvC+he73JRKJdAfeBvS2n+XAVdFodOsebdheSiQS+QdwItAOqAPqo9Fov0gk0gc3jCgfaMQNI1q151q697G7vgeOxRv/vzmRSKQfsBRYDSTbktdHo9ETvLH/2/JzfQ9czx4Y+57Ie3h4eHh47KV4y/UeHh4eHh57KZ7Ie3h4eHh47KV4Iu/h4eHh4bGX4om8h4eHh4fHXoon8nuISCRy8Z5uw38rXt/vWbz+33N4fb/n2FN974n8nsP7Z9tzeH2/Z/H6f8/h9f2ewxN5Dw8PDw8Pj///2Ovi5MWjtvsLKWDX3039zPudPqvd5/2qa6nd5O0mbfvnXfJ+sQ0/Lvtr6u2uzK5pP7rJLu30tb0JKgi15ZltRc1tnxUYbeWMtnq6Utu/9UhvK6e1veoKdLal7VIGtT3tx+V35O1cT/xCvW2v4kd5Ypc8Te18jZ3L7Hi/az2BQuxyvx+X3ZG24767Xkuw45o/yfulej963f5e/kLe7urtUp4f3297nty5nlTbx8dP7ifVTm3e9XfZXX/s+jfZnid/ZZ78aZ5wm4y2Lc/Z1r7dlwfXwtn2t9jxyvbPP36/a5lfqqftJm3Xevyo/v/tfXaXtuP15/N2rccv5P24vb8u76fX3jWPH9XfXX/sqL9rmvpJ2q+51q5t/bm2767sL9fjZ/N2n7b7trCberuZ3P+H8iCY9olS6gh2wbPkPTw8PDw8/h9ndwIPnsh7eHh4eHjstXgi7+Hh4eHhsZfiibyHh4eHh8deiifyHh4eHh4eeymeyHt4eHh4eOyl7HUhdPw0+Gyv5sOVNhe8leKKESa3jvWha4Kkpbj47RRLqxzePS9E2AenT0qwoVHRlFQM76Tx6Sqbw/YxOKi7zl++TIESPH9qkCWVDvd9lqIgJEhbikxG0T4EDTFFELjhiCDTv0tzxgEB3pmTpKJOckBvgwGdDSZ9leSAngZrKmyeuDKf0nydO15oojXhUNvocNmJORx5QJC3Po8z5dNWrj4zl86lBjf/rQ5dKBJJSToDhoCgX9C7i0FlpUVrXNG5o0ltvcWDt7Zj6jtNxBOSTRvTjBiexdy5rdx4fTteeaWODevSnHRSHrk5Bm+/Vc8FF5UwcFAWALEWm/tu3UQmo7jn0S6Es3U++HcdH79TjxAgHYUGHH9WIV++10i8xXFDvjTw+zUySYf9huewfnkrl97djalPbGbr+iRKgS4UKOg3PIdls5sACOXoWK02jrUtdguycjRw4KDT2vHV65XYKQfdAGUr/EGNdNxBAJ32DXPGA3144eLFtNSk2e+IEnpEcln2WS2dBuQw740Kkk0WQkAo1yDZYJHb3k9uiY/NC5t2hPcoxfA/dCH66gaQCtpCyzQBQij82SapRovcsgAtmxKgQDcE0pYIKfGFdfxhk/iWhBtGp9pCu3TA3hGull0WJCUTyGqFGTCwWmw0U6AsN6RPALqpIdPu7+fPN7HqM9vbqZkKUtD36r70ubw37/aahhYUqITCzNbBUggEMm5vb0dWtyyS6+IgFTn75jJm9lGktiSYPeojnBYLlZaY+T7yI0XItIOvJMCAF0ay9MyZ1L6/mUCPbFTaIbMxRqAshLIkSsHo6jNYcuxnxH9oQKYcnIYUwq/T/7PDWTLqAwbMOIbYV1vY+sQyADrfP5R2F++LE7dY3HcqPV8bS86YDqw68kNin1YAiqKL+xIeXsLmK2ehbIlKO2BqmMUBsiIldHpxHOuPnE5yUQ3CVhTeMIiOj4xm8/mfIgIGuk+j4cWlkHbAlggB2af1RjiS1rdWIzSB0TUHGbfc8dq/iJwLBtD44HywbeyVDShbYvbOp3TaiZh9Cmi+fSbNf50PliT3lpGEzulLy60zSP1nLVgOWpaJku69aE0jfDpajh+9Sy7O5maybzqQ0MVDUPEMTedNQzUmyXvzFPQueQAknpxH642fkD/3YvTu+TQN/ieyvAFjZGfCL5yAsW/J9nlMSUn6n3NJXvs++uCOBO89DOOw3gixI1DtxzjLqsjc8ynOjLX4bjgY87KRiCy/m9eaJH3UMzBr/Y4Kgzri++ZqjEBg5+t8vwln4hTUtxvBp0PGhoyD6FmM/u5l6P067FTePuSvMKccYduQG0TcfyLaJQej0ha8NAv14AewXyfEnccjhnbf/aS9aAPcMw3mlcNNx8LF4yDo+2m5lgRc8hws2wxTr4U+HXd/vR3strM8kd8L2NIsOevNFELAv04P0CFHQynFY7MyPPR1hslnBhndTeeW/6R4Y6EFwIB2Gl+W25TlCp44Icil/05QF1e8c34WuQHBEc/EcJQb0yltyDUVqRT4FYzpbbC+yuGW47P4enGazxZlKMwRXHpokEfeiTOom8HWWofnrs2nQ6HOk2/HmLEohSFg5AA/E0/JoXyTxX0vNBLp62fskCD3PVNPJiMpLTTYUmUjFGQFYb/ePr7/IU1xoU48ocjOEtx/Swn3P1LD8CEhFi5KoGvQ3Oxw753tuf+BKqq2ZDh4XDYjDwjzzFPVjD8kl2OOy0MIQTotueP6DaRSkhvv6kTHMj9Lv2/l2Ue3IB2Fkq7QX3VnJ955uYbK9UlXlAIgHYFyFPsfkM2WdUkuv6c7j12/hnTcwTAhk5RoArrtG2L9D63uH0cqBo/PY9HnjQAIzY3TPvWWbnw9qZLaTUk3Xlup7eJKW8z3sONLGX5Se56/YBHSUQw6ppR1cxu4ZNIQ3rxuCZvaxHyfcYXUronTuDGJ4RM4SRvdcNuKVAhToFsOOWUhmjfGQUG4yCRemyGQaxLMM910CShFVpGPRE3ajT0WipIBedQubNgh8gZgu2UFrsgbQR1pW5CGrHYBEltT7pTT1p+CtoeHjHTj59nxwIBqi2/XYfxb42j8oYFFf/6+LV8hhHDjzyVuG6VCMwVC4T5ESMWAvw+l2x97892ZM7DjFvWfbAUJ+9w7kM0vrMFuzjBoyhhWXbWAdGWC4pO70PxVFclNrai0Q9nlfdj6/Cq63TGQ7MGFrLp4DlZlAj3XRDZl6PXSgWx5dAlOUxqRccg/ujMFJ3Vl/eVzGLL+DIShUfHnb0mVN9Nr8iE0z6xk9cHvgYLS6/cnMaeSxPwaMCA4oJD06iZUyqbDw6MouWZ/ah7+juq7F6CSNnq2Sf+Wy2j5YD2bT/8IoSv0PD/2JndMZZ/Wm2C/AhrunYeyJMFxncgsrUMlbILDSii850Cs9c3UXfoJOBIyDkqCMHW6JK+l5Y7ZtPx9AQB6pxyyzuqLvbia1EdrEVKitw8jW1KQslBJG82no+W2iXtFM+GbRpF1SQQRMsnM3EDTWW8TPHMA4fvGI0wdAKUU9d3/BqZO8MwBJB/4GmxJeNIpBM4cuH3uUlJivb2U1N2fIxsSGCO6kPXW2T8v7svbxP2rclfcLx+1Q9yTGdJHPAUz1+2o0D4bX/mfMUK/IO5+HdJt4t6jCP29y38i7jKRRp7yNHy0FLJ9aI+cukPcX56FeuADGFCGuHMCYtjPiPvijXD3O66433gMXDJ+9+IOsHAdnPYYjO8Pf//Dz5fbGU/k92Ycqbj/ywxPzbN46eQAR/Vxj6T5fI3N2ZOT3DLOx1WjfExeZDHx3SS9CjUak1ATk2RsxdRzQ/x9Rpqv19pMPjuLw/cxGPdUjO83O4RMMIXCSSt0wC+hOCzQlOIf5+awodrmobfjaBpcf1yQx99L0K1Yw0orXrqhgOI8nf/MS/LEW820LzAI+gX3XpSHaQr+PqmJjZU2Ew4O8crbzaRSikNGhpj7fYJ4HHwmDNzHx/dL0oweFmDedyl6dPFxzUX5/Pm+aq64qJA58+IsWpygQzuT664q4aabNpNOKzp28nHu2QVMnlRPQYHBhZeUEAhoxFoc7rxhAxlbcf6l7RgyLExddYaHbttIIuaglCtM197bmS/fbWDpghYU4DPd/yFNKXr0C6FpcMKF7fnrVWtAQk6+RlONja6DoSnstHuIjGkIjruijGl/3wS4gu7P0sBWGAakEhJNKfLb+2nckqSoc4D6jSkATri5B1l5JlNvXYHQAEsy8e1hTLrse9IJh3iDRUnvLMJ5PuJ1aerXJ5CWg6YUB/yxK/NfdK0Z04CcDkGaNriWb+cRBVR8Uw9AVrEfHEmiLuNaiO39tFYkQQgMXaEciUCiMu6/li9Hx2p2QCkMv4ZMuNa5CChIKMyADgJk2kE6rpjrtM1AUm0/EGfbjBQo9JGpSVM6ppROR5ax6vHlxCsTIMGXY2A3W20HFLH9QcPMNXCabPztAmS2Jtnvr0MJd8tm8ZXzyFTEUWmFv30Aw6/jKwoQ7Bii+esqCo8pI7a0EasmRd6QAmqmVWDkGJSe0pXqV8sZVX06C4d/gFWbxCwKkNkYQ/h1Ss/oQtULayg8phPd/jaCYK9c1l0xG7MkSKc7h5Ba18LSYdMYsOgkNL/G4s6TUCkHoySAqksCED6oPR0ePIC1R7yPjGXo/MI4Cs/vS8Ory6n44xf4eudhrWwkMLwd2cOLaXhiMUZhAFnftlrULovCa/an8f4FyFgGs2ce/kHFxN8ux7dvPqXPHoqvXyFbj3yLzIKtoAlE0EArCWH0yCM9txItY4EQ5FwTIXB0D2rGTUbT3EOc9PZhZMbGyPNjr6hzx2rIxOxXhLOpmfCNo8i61BV35UjiD84i8eQCcl+egP/IXjvNR5mv1tF0+KsIE/chLTdA8MoDCN1yMNAm7u8sJXX3F4iQif+2sSQueofsWZei9y7+6fy2vIrMvZ/hfLkG8/qD8V0+ChH+kbgf+RTM+JG4d86HgE5w6W3bHzwAnEUVrrgv2LCz5f4L4q6u+BdMmouSQLcijPIHURl7h7j36+ha7sN77H5y/mGTK+5z17jifvE4CPl3X1YpePJjuOcteOKPcPqo3ZfbPbsVef2uu+7631zk/wXu2tMN2BNoQjCmu8GwMo3z30qxpVkytrtOr2KdkwaY3PRRmnmbJH8a4+eoPiYvLEjTq0hna0xRGILn5lpcPMJHzyLBTR+mCJmC184KkbLh63KbgE8jKyBIpMEwBMmUIuPAp4vTXHZYiJNG+Jk+P82M5TanjPQzf7WNrgu+WJjiiKEB+nfzMXgfPx98kyArIHjz8zhD9w1wwtgsDEPw4rutHDg4yJZqmzUbLa45L5/KGov6RsXWWode3XwsXprmorPz+HxWnPUVNueemsfTLzYw8ZIissM6s+a0UlNjc8nFxXz1VQyfKZgxM8YJJxbQ1GQzfVoj/QeEKCg02Ld/iHmzWli2JEEyKRkYCTP2iHwWfRujNSZRwLyvmhl3bAGVG5IkExKpBKbpnnXVWJtB1wRWWjH+5BK+n9lEJqUo7ewj1mjj2Ir2XfzEmx2kVFSuS9F9/2zqKlwL17ZAOZLCdj4SLQ5GwF2q9/l1YvUWuUU+0gmHVXMaOeDk9oQLfGxa3IJyJHXr4gSzDY6/ty/fvV1Jot6i67ACEk0ZzKBOsimDUFCxpAVNA6S7Up9usbZb+I6jsGM2QodM3MEX0rESDkJAJma7J85pAilB2M5Oh2tJh7bVBoWr5q5Fr0kFcttJbaAy0t0XaPssFKALtG2n0SlAKmTCwcgyKBlRQsvqZhoXNqActpeRtnJPP9TbTrAToNLStfSFwgj7ELpgy+vryNkvn9Yl7nZJ6XFlyLhDankzKunQf/JBrH9gCbmDCkkub8Qs8pNa10r+2HY0flZJzsgS7MY0rYsasGtTOC1psBSGKYkvb8bfOczAuRMwCwM4cYu1f5xJj+dGY+T6WPuHryg8tQdmgZ/lw99GxW33ZLO4TWCfPHp9fhx5J3Rn7VEfIBM2uSf1oP3tQ6m8aga1Dy8k+/AuJL/Zil4SJLO6Eae8ERI2KmkTOqYbzuZWdNsh+fEGAMKn9CbzXTVWeTPtXjqMksfG0fLcIqqPn4a9pRWzTwEq7ZB93VBSH69HbWxCphyyju9J8dQJpN5eSfPNXyOkwtcxDD6BnuNDbmhCtaTRsnzItIOW6yPr0gj5k07Ef1AXhKnjVMVoOnEK9pp6Cj49F3PwDmFU8QzJx78hduG7YEm0LJPgxBHItQ1kv34KCLDeWUrijMk48ysI3n84gYeORC6pQm5oJHD9QTvNa86KatJXTSNz1ycYJwwgOOlsjLG9ED4DJ5khdegTOBdPgY3uShkD2mMuvRn1wjz8z5yO1st9YHAWV2Cf+jzyrg+hthUcB5IWokshxszrMO+bgFaSvf2+MpFGXvwanPkcbKhHHTkAVlaj/XAXvDEPdepTUN+K+Oc5aDcdjSgr+Omk/MMmuOJleGA6nDESXrsURvdxn7h3R2MrnPUEzFgOH98GB/X9+Ql/99y9u0TPkt8LqY8rzn8rydaY4s0zgvQo1IhnFBf8O8naesk754YIGHDapAQZG2pbFQrFujrJMf0M9m+v8eAXaQ7fx2DSWWGiFTbHPB9DFxA2FfFWCJmgZdzJPdsH71+fR0GWxmmPNlLZIBnYVaO8wsYQ0LXY4OU/FRDwCRpaHG5/vol0RlFVZzPxlByOOCDEhkqLe59vxK9D5VYL6SievruUF6c2M39xCgEU5wkSrZI/X13M3X+rpVtnk6EDAixcnOTuW0r5YWmSvz9Rw8jhWQzeP8hzz9UyalQ2y1em6Nc3QFl7kw/fb+KiS0sYsF+I+XNaeHdKHdn5BuGwwYVXlBIMajxy+0Y2lKdQbcvFHdqbBPywaV0GgGBQ4GQkpuHu1Z94UQcaqjJ8+kYVmiYoamewdX2KULaOTDtYKYmmC/xZOqYGrQ3ulolQEl0DHEVBWYBYbRrlQE6BQazBQtMUdkrhC2pMfG0QHzxSzrpv6tEcyZG39mHA4SU8MnbmdjE+8k89WTB5M82b4mBJMAXSBl22KaOUru+AregyvJCKBXWuUGoCISWqTcsNE2TKIVDgI9WQQbcdlFRsW0HVAzoq47hPDtuOjZXStbYNCOb6yTRlUJa7J55usgBXqM2Ahmq1kbjWvaYBlqLbWd3RDEHF9AqcurT7T6wLNMtd3tdNAbZCOe4xugLQfBp9buxP9ZdbSaxsJmefXBq+qgIHzDwTYTkQd8gf046B745lze3f07Kgjta51XT980Diq5qpe7+CgsM60vDuRgZMH8+KP8xENluYOTp2YwahQafbBlH52FJ6PT+a4tPcpdjql1bSMG0D+75/BE0fb2L9lbMpOacXNY98jx233YcaQ9B98qHkn9yThjdWsXniTGTSQfk0en90DFsu/xqjJEjiu1r0XB/W+hb8nQI4FXEAQuM7kX1kF+pvnYOyJEbXbFRaImwbGbMIHd6Vdq8cQeyVJTTeOhOZsDH6FODrX0T6uyqyxnch/vISEJBz3VCs6iTWwq2oNfUgJY4jMPIMzNIQ9oo6hE9HhH3oXXPJfF+Dlh+gYOpJBMZ12z63pD9fS/O50wheOJjwHWMQRtvyfDxD8un5JB+djTGkA+n/lCMKQ+TPvpCWo18j64ljEEmL1N2fI3w6gbsPxThyn+3L8rFDnsd/wVB8Z7hL+c6KajL3forzxRrM68bgu+LAnS33o5+Gr9bumPT6t8M39zqMcADrnv8gF1fif/sCnMUVOFdNRc1bD6YOtgNpG9GtEP29y9AHlO00d8pEGnXlG/D6N5AdQNwzAS4cjcybiDiwJ6K8Cvbt4FruB/Tc/QS8ZJO75z57NfzpaLh0/M9b7tuYvwZOfwyOHQKPnAN+85fL7x7Pkv9vIeQTnL6/QcqGc6em6JQrGNxR56QBBk0puPDfKcb2NLh1nJ9lNZIVtQ4D2+vUJWBxpcOmJsUfhvqYvszmxflpzhri5/6jgkxZlGFLM/h8IG1wNAgISNkweV6Ks0b4ufSILFZvsZm72iYr6Fp59THJjMVpJowKkhXUOGxYkHVbHbY2OCxcmaa6QTJ+aJCjRmWxrtJm01bXEv56fpKHbyxmS5VNxVabRMpdsVi6IskNlxbwwWetVNY4lBTqLF+R5rijc+nR3c/UtxpJpRV9+waZPTPGH84vYuMmix+WJpkwIY9Jr9ahlOLg8bk01jsk45KiEoNpU+rp2z+LQ48t4IdvY8SaHRSCZKtNqlXSY98A9TU2tg2aoaGku3S8/LsYR55VSmuLQ01Fqk10FemExAxoOJZCKfAHNdeSabNCNV0gHXcLJLfUpLXRtaTTSUk4z0Q3NKyUg2Mp1sxr4IwH9uXbKZtRwIalMboOzmPNzFoMn4bh11k1o44T7unLis+qkbYip8iHHXOXZ82wibQkSrgimW61CWQZOLZE2RJDEyhNoKS7jWuYAjvhIByJEgKEtuMcf0NDZRSaT9vhyLfNmjcAKZBp1xQvHlxAfHPCtcgFiPQ2E93dttAcCHYK0fnYTjSvaqZxccOOZXlAa7PeEe7ev9DYvpfvy/cReWU0zYsaaJpZTahTFsn1cTSfwB82UY0ZQv3yGD7nKGJLG1l5+Xzs6jjt/9CbXo9EWH7ebPIP7UAsWo9M2JCxSa+LoZI2Ku2gBQ0KT+xK3dR1CE3Q64XRCN0NSFp32Ww6XDcAf9dsVhzxEXrGJvbRBmRaujOtoTGw9nyCffKpuGwGDa+uxL9/ESrpkHtIGbX3LaDg4n7EPtqI05hA1qcROIiYhfLp+PsUIFfXk/hwPdLQ0HJ9EMug5/lQMZvSZw/FLAlQffw0Eu+vBUOn8K/jyCysgroEanMLme+rUUEf7b85m/T7q0lMXYFTk8DXIQspFZpy0FrTruWeG8DsU4RqSaH3KUHvlIsxpANath/fkPYo26H1zq9oveMrcl87gdAFQxCa5or7P74hdvoUhKkTvHw4yee+A1uR/9Ufyby/ArWpCfnJKpy5GwneexiBh49C7128XeCd8jpSD3xF6PmTkOW1pK9+l8yfP8aYMIDgpLMwxvXeYbkf8U+cC9+EDW2We792+Nbdgf+asWg+A7mxgcwf38D3wDHYF7yGvPMDqI654ylpITrnY8y8HvOBE9BKc7bPmTKVQV76Gpz+HKyvRTx0MvrbV8DAzqiRDyC21CN6liCePAft5mN2b7kvrYArXoH73oPTDoDXL4OD9v15yx1ASvjr+3DlS/DkBXDdMWDoP1/+l9mtJe+J/F6KEILhnXUO6alz5fQUiyolh/QyGNvDoH87nTPeSJLtF9w+3k9+UOO5BRZnDzZZUSNpSsG3FQ5H9DGojytenJ8mZGr86+wQGxsl326SoINfCOIS2oUFrSl4ZVaKE4b4OefgEEGf4KulFo6EkA8aY5JPoilOGBnAZ2qM7O8nFBDMXZamNSH5emGKAwcGGBsJ0q5YZ86iJOmUYvHKFHdfXcjS1WnqmhwsB1qTikRcceTYMMtWp6mqlzQ1OegajB4ZpqjI4PMvY8STkvxcnZlfx7jqqhLycg0mT23kiCPz+HZ+KyuXpzjlzEKi81opLjHZb3CYF56qpn1HH0edWMSCWc2kUxKlXEu3rlmRm6uRTiqkBKUEPp8ABUvmtXDO9Z1ZsTBGc61Fdq6BbUkyadAc15LPpBQde4XQfYJks4MCTJ+7fB5vla5Hs0/HsRzMgEYm7lDSPURrvUWixWHrihbSjRksGwK5PpZ8VkNOkUmiwaLHiEJaajOs+LKWEWeWsSnaSCbuMOi0MqqWtYCuIR2FEBpKSmRKklXsJ92cwR80cByFZgjk9u93EuA4aI77gIKhu452QmCGNGTSdlc6FAgTNFuBBsIGmXEfYowck+IB+TStibV9kY3C0TX3vQDdAc0U6GEfvc/pwepnV2LHbDQUuubOy7oNUgNdE9ta1fawIRj60oFk75PL+seXk9jYSqrN0153FCpuQ9gk8tlhZGqSREd+RKB9EBEwGfjheLZOWkvd9Ap6/X0oW55Zja4crBUN2EmJke9DpiRmSYBA5zAy6VB8encKDu8EQHxxPdXPrqDro8NZPW461tI6VNzCKMvCabYAQfd/H4bmN1h72HSMogClt0aofewHZMJC1SfIHtuRxmeX4rRY7ooDkHd8N3KO7kZ69hZUfYLwKb1Ib2xFxW38ncL4uueCppF7Th+a75xF4sN1gEboiO7kXDGQpj99iapLIptSZF82GKs2ja9LmNb7ZuOsqkcrCuEkJf72AZZnvYsAACAASURBVGRFMxqg5e8Q96yLBpP96GHE7pxJ4dsno5rS2OWN+AYU0XjcZOTWVvI/OQdzv3aoRIbkP+YSO+1NhKERfn4CNKeI3/c1wtQRHbIxu+WSuOFjjDyT4ANHEHhkZ3HfRurhGWgdc3CmLSZz+8cYx/cj+K+zMMb3RvjbxP3INnFf3+BW6luKb92d28V9G+lTXkS0plDPz/ypuH99HeaDPyPupz0H62oRfzkJ/Z0rYVBnd8/9hCdgdRXiLyejPfMHRKefEfcrX4V7390h7mP6/rK4A9S1uM510XXwyW0wovevnd5/Dm+5/r+VWFpx+bspvtsimXJmgAHtdMrrJBNeTXBAZ51/nhBgyVaHE19LcHxfkznrbdbWSxJpxcCOGmGfIGlL8gIar52ZxeerLc77VxwdRbjNku+WB/WNbtdPvizMmH0DRMszXPBkM7atyPcrNAShgGDyzQXkZ7tPq0vXZbjtuUY6FhrUNjk8cGk+vTqZbKmxuOKeGtJpxZEHhfjjSXlce281SUvS2OQKxqlHhom1SGrrHTZVWqQTkluuKaL/vkH+9WY93y1M0BqXYCtCAcFDD3Wirt7myadqaF9qYupQuSXDBRcW8+xjlZx0RjH5RQbPPF7FQeNy2H9QiMfu2kQ64WBIRV6Zn/pqGxOJY7t9KwSUlGgkmiVlPQKcenlHHr+hnHSrQ3auRrJVYqfdZXIhQEkYd3ops9/cit1m1OrScbe2NR3TVDhpSSAgKOwYoLo8QecB2Wxa3AxS0WdEHpVLWkilFCU9QjRuTGC3Wlz78Shev3wRjVtSFHQO0rC0EYQgXBYiXhFHaO5DiaLNk992MHIMnOYMhoKCfbKpXxd399GFQqKh2TaGbYMEp815SXNcS9UXEFgJCUrh87WFtrUhFOg65PTKoXhQIWveXIewJRoCJcDRBEbGwZRQfHApDd81cPQXh/PRkOk4wnXoNH0aTtrdApACNMf9prk2rcfINjh606k0zq8levoMMluTaI7CVKB0QfawIgrGtCOnTw4rL5+LyPZhZBv0+kuEkgmd+Wafd/C3D2JmadR8tBUfNlrYh1Hkx9qaILhPLjJuYzelEcDAeccR7JkLwNpLZmKtbyY5c4sbmtcrl0CvPGKfuxEawf75tLt6AJU3fkOHh0aSf+4+rOj3JunyJgJlIURzAj3XT3JTAg0HhU5wvwLE5iacxjSiLAezWw6ZeVVIW1F4e4TWV5bj656NvagambDQu+fjVCcoeGA0rc8uxF5cA6ZGzpURwpcOovb090h/X4NpSowOYWQig14QxF5Zh+bT3a2UQaXIimbCN4wkdPlQtLCPhvPeQ2sXJu+h8SQ/XkvLzZ8jqloITRxG1s2jIW2TemYBiUdmYR7YldAdY9FKwsTO+TcqZRO44UBaTp2CURyAeAbzsF6EJ5/+897yS7bSMuxJjKDAd8PB+CYeiMh2PeGdZIb0sc/AF+U7KvQtxTf/eozwzt7ycukWMme/glxchRYSCEe6y/JdC9HfvRR9/047l09lUBPfgFe+gbAfcddxaFcfirJseHUO6v73oVcpclUNFIQxvr/zp41fthnueQdmrIQbjobLxkNW4KfldsesFXDmP+D0kfDAGf/zA8Gvw/Ou/2/nte8srv8ozb2H+rhkuEk8A+dNSbKlRfHOOUF0DU55PUG2H7rna7wctUhlFCVhGN1Np0eRzqvfZnjtzCw65wlG/SNGY6skLMABwj4FriMxEw/zc8sx2dQ0O5z2SBPVTQ65piJoCGwFz1+Tzz5l7r5TXbPDbc81YduK6jqba07P5ZChQZIpydk3bSWRUJx5bJiDhmRxyyO1dOqgs2S1haYU556Yy3cLE+zfL8D8hUmqamwevbOUju1NHnq0ilBIY8myJFZC0rdvgBtvbI9lKf71RgM/LEkwdFCIeXNbOfGEPKZPree628oI5+g8/dhWcnJ1Bg8K8dar1dgxG0vXKO3op64qjbBcq1IBCCgrM2isthhxWAF9I9m8fP8GrKRkzAlFzHynBr0t7Eu2xcyXdfGRSkkaKjOAwlAS2faPriyHYJaGjqJ9zyw2LGohN1+npc7dy/cLxQFndGTu1Eo69s1mS7SBS6cOAwmvXvI9qZiNns6AEAi/gcw4BAICKyVRUqLQEI6DEdQhlnG/xtUURM7vzrfPrwMB3Q8rZeP0iu1fy4omkKaBsNw4dc0noC16wLDdEK3tJ2tpkNMpi3DnLDQBlbNq0CynzWNOITWBEoKAI8nbrwCBwq8L6ubVooRwnekMDZWUSN3dHiDjuJZ/QEMmJR1O7UrkqQOYM+ZjsvfLo/K5cgxHIfJNzJIgMmlTcnApLd/UkI5LSk/oTLI8xqCPDyG+tJH5+00nnA9pS8dKKgy/gqSD5ndj+/OPKSO9opnsEcVktiQY8NlRyJRN9WOLqbxlHgiBMjTCYzvibIhhlAZpmVOFUJA/oTOZVc10nXo4gb4FbDjtYxr/vQ6BJNw1hL2xBVtpGGVhVGsG0ZRE18E/siOp9TH0ZAq7IYPymeSd34fEpGVoSqIsif+A9ogsP1ZFjED/ApJTloMQZF8xmOyJEVrumEFi2irstCLQIYSybYziEPbyWkSbuIviLJymNPn3HLRd3AHS31TQcOo7lK64FBEwaLnqIxLPfUfhV3/AjHTYIe6juhC6cxzGgHZkvlhL67n/xn/+EIxB7Wi98F2c5gzhO8aQenkh+SuuQYR+Gv4lV9eQvvczrOnLUYXZ5Cy6BpHTJu6ZDJnjX0R9vGJHhX1L8c27FiMntPN1llViT5yCnLXWddA0ActBdClAn3Yp+qDOO5dPZVBXTYZX5kCWD3HncWjXHOaK+2tzUPd/AD1LEHdOQK2tRZ7/Mtq6B9G6FO24yLLNcO80+HoFXH8UXH7Irxd3KeEv78I//gMvXgZHD/519X4d3p78fzv7d9A5vq/BzR+n+aLc4eg+BucOMalpdQ/POaSXwc1j/SyokHxe7nDXYX5mrHNoSEB5naJnkcZthwY4b3IChGDKOVnM2eBQ3iDxKTBNQUxCEJi/1uGzZWkuGBPg7INDLN1os7paoqQiZAj+/U2KsmKdnu0NQgGNw4cFKd9sU9MkWbA8TX2zZHh/P8eNC/PeF60sXpHBEXDswWFmR1McODhAeYXFDyvTRPYP8s28OBeclc/Wapup01sYNjDA2IOyeefdJo49Oo+Nmy02b8pg24r99sti0MAQBQUG0z9oZkgki6++jNFvQIjPPmjk4EPzGD0uh9UrkyyYF6f/fiG2bkyhJLQmJOFcE4lC2QpNuNZlc7OksMRkzeJWeu0XpnPPIKu/b2XTqgTtynzEWhwKSn1kkhIloaXZZtjhhWxe2YpSAonApylCeSbppHttBSQabUq6BKnfnCIQ1rEtdxt86PGlZJKSTYtbELZk9dwGhp1aRvt9w6z5TyWWbqApGHVRVzZ+14y0JPtPaE/Nipg70WgaSrQ5tgmQSpDdJUz9ihaELmjYmEBPuw8V7oOMoKhfLsmaFAiBFFrbPrxyl/TFDpFXCvJ65ZDVIUTtwnrsuIXh4O7ts2OP3TE07IY0Wsomtqplu7O+AERGtd1XIZTrKyDcRQY0v46vJAAJx92Pn74ZzVE4uQaq1cGXbWLYDsEu2YSHl6D5dRo+3kK/l0dR99oaVpw1A2EK+kwdT9Wr5ShNgCUxck1U0qH9JftQ/85GjHw/WJJ2F/Sm9YsK1h33Ic0fb8LGIPfozmS2JlHVCdrfNZSal1cibIWebZA1pJju045CpW3WjphKy6xKTCHxCQfZnCYwvjNWVQIznoLWNBSGKHnoQBqeX44Z0lApiSMFRpaOnLsJISWBER0peGAM8enrwHZwVtRgL64hcFg3Sv5zKukP19B09ac4K+rANDB0idEhC7mxCdWcRsvxY/YtJlWVRkpBySdnEjqzP8LX5jjnSOpPfIucO0ajF4doPPpfqLRNZmsKX1kWree+BUD2CycSnDgCURQicfcXJG7/nOAlEeQHy7G/XotVmcB35n7YX60j64HDMPZvv9McJFfXkLr2PTK3fIhxTF9kUhK48WCMSBlOJkP6uOewz3sDyt0QPvqU4ltzG/7rD0H7kTOaXFaJdfoLOLdPh6oWhO2gKYkoy8P48lrMh05Ca5+7o3wqg7xyEpz6LKyuRtx/Avq7E2FIF3h1tustX9mEePxMtNuOQ3XIRR70MOKM4ejntYWxLd8ME191w+FOGgqvXw5j+4LvV1rh1U1w0l9hxRb49HaI/EzI3f89v/1yfSQS6Qq8EI1GD2n7rAFPA/1xg242Ac/9qDHDgflt7y+MRqPlkUjkVuAioHs0GlWRSORloBvQFddOrAZmR6PR23+mGZ4l/z+QshQ3/ifN9OU2k88IMqKLzocrLM6fmuL+I/xcNNzHSwsy3PxRioeP8fPUnAwLNztIBRcPN7n7iCDnvREnlla8cXYWL8xN8/AXSfwOlOQLqpslua7DNSEffHFLHl0KDZ75uJV/fJDEUJKCgECYguNGBLnq2Ky2PVd4d1aCZ9+L0S5PIz9b464L87EsyXk3VaEUdO/hp28ng42bLXp3M3jrkzgCQe+uBo21Ng/eWspjz9axfrPNny4vpLTA4P6Ht3L9NaU880wtddUWF19SzIEHuuEytbUWTz1di65DMuYgbIeCfJ1rbilD0wQzvmhm2tQ6Qo5NvNnGFhpmQEMqQSjgirAQCl0T2A5kZwusuMNVf+nOC3euR9MgHnPQLBupaewzMMy6xa1IW6IJQZ9BIVZFYygEhukKfU57P9Wb0mjSPRUnaFuIgI4RMkk2ZVCOQtMF104ZzCtXLCFWESer2EdRzxwGjctn5uNraGqVCFtx4CXdWPHRVuo2pxlzZXe+eWw1wlA4tnAta9tBA0xD4CsJkG7z7PZh46Qc1wkOsE0NLWAi4m6EgZFt4rRk0C33VEDRFjqndABBbvcwHUcUs3LSOnyW+3An29badVvhaALH0NCAvAKD9OaU61T3o/367cv0fg277URA2eLQ996BrHlqFb6mDKLZwk45OLpAGIJAtolqTNPnmRHkjmnHguEfUXBQKU59EmdlPTlj27Pl3Uq63bYf8SWN1H9QAX4d2WqjOTZGro+yG/qz+cHF9PjHAWy6Zg5+XSKTNnppiERlhg5/GkD908swcn30+vRYKh9dRP0LKxFK0fWlMeQd3ZWqG2fR+OoKhKGhte3LhI/rTnhsGTU3zkLYDrbQIS+I6XPDFUVaYnbPwewQovm9DfiFReCgMor+cQiJmRU03DQTzbHdPfz8AMWTjiX5+hKS76wEiSvqzSlkizt2hE9HhEyMXgU46xoIXz+S1mgNmW+20Lly4k5zQutzC0m8voTs64YSu+QDQtcMRwvqxG/6FOOATmQ/ccx2wXa2NBM7ayqqMYkubYShE7jrEDKbWojf9BmhicNwolvI+fyP25fp5Zpa0vd9hvPRCsyrD8I38UBkbZzYyKcIr70B+4zXkB8u39GgPiX45l6DkRfeqZ1y+VbsiVNQs8rB1Fwv0bSN0jT0KRdinryzZSxTGdQ1k+GlORDyucvy2yz3SXNR902HbsWut/zofbbXcy56BTX5W7Smx9FWV7n77V8ua7PcD4Xwr7Tct/HFEjj3STh/LNx1yv8X57pf4rdfrt+NyB8FnBSNRi9o+1wQjUYbflS+PBqN9tzlGt8AK4CXo9Ho7B+l3wWUR6PRSf9DMzyR/5W8t8zi4mlprj3Q5MaDfJTXSya8muSgbjr/OD7A95UOJ7+W4IJhJhkLHp6RwXEkpw00eeOsLP76dZpHv07xzMluSN4pL8XQLCjMhfoEhDJqu3X3+NkhThkWYs7yNBc/1YJQkjwTOpQaFOToPHR+Drkht/QPazPc/lwjZUU69c2SBy7Lx7Ek19xfSzhLYGmCTvk6/Xr6UdJm+ldJBILsoKAwW3D/zSXcfl81jXHFhCOy6VisMeWtJu7+czvuuHMrTfU2l19ZwgHD3QnEthVvT2tk1qwYZaUGm9cmGTEqm7MuKAVgzaokT/+lApmwsZRA06CkLEBVZYZwSJBocp3FNAEOAlMDv67oNzDI+tVp7LQkEbPp1DPA5jVJhozJY8msRhxL4fcL9hudw3efNgICXUlKuwQI5RqsX5EEy8GfTKEXBpGWoqhzgKrVraAgmGtwwRP9ee6Mb9F0jU6RPOrm13D8o/vzyd/W0rQxjmYKRl/QhVlPrUP6DAzLIphnkqxLI/W2iUYqpKGTq9tIIbBaLPR0Bs0Q7oqCpmH7TXeJP22hNA1lGui2hZG0cXSBbrvbFxIIFAfIxCzKhhey9asqDMe1yp22BznTljiGeyqjCJuoVotAuu34VKnQXb8995Cc2jRCgGUIfI57tO0xVafxSc6/8EnISIVCoGVr6I3uka4D3hpLyYQuLDzmC5y6BC3fNtDxhA50vidC47xaVl0yl9H1ZzCnaDLCAJmU4NfQ0zb7ThvPmj/OJFRkIjc1I21FeEgR0gLl00msjeHDQfl0BpSfSWp5I8sjbyOA9rcORLcsGp5Y7HrnK/f3tv0+Otw/jKYHFyAb09hZAYweuaR+cA8javengTQ8HCVrVDsy0a1kUgLNFJQ+eyhZx3dn60GTyaxoQNckIsvEf0R3DCVJvbfaPUmwfZa7517kLstrhub6IGwT9+tGELpyGFq2n8phryAllEX/sH0ekA1JqvZ9muD4zlizNxE8cR+sqUswDuiEpZn4Du5G9pVDAUj/ZxWtZ05FC+poxUGCdx+Gebwbz13f/W+ga4jmBLlfX4jRr9T1lr+3TdyvGo3vqtGI3CAAiT99gPPOIvR1NTsmpX1K8M37GXG/agpq5s7iLjrlo/bvgujTDt8jE3aUz9ioq9+AF2dD0ETceTxcc4i7/fT6N664dy1C3DVhJ3EHkJvqkd1uRrvnOLRlG+GLZXDdUXDF/4W4O9I92Ob5L+DVK+DQ/f539f937Fbkf+svqGkF+kcikX0BfizwuyMSiQwCluFa/2f/xm37r+f4fibRK0N8uNLh8JeS5AQE867MoqpVMe65BF3yNRZcFeaz1Q4raiXvnx8k6NOYsshm9JMxrhnjZ/oFYa6fnuSDFTbzr88lJ1ujodmNf7aDgnTbva6elOCil5sZ0cfHh3/OQ9M1mjKwaatNbhDOeLiRNZWu89Z+PXy8eEsRlhRkhzWu/ls9W+ol15+fTyyu6NHOoDau+OKbON06BRgxIABK0ZKUVNRJHn6qnj/fUExAKGbNSzDruzSDB4X45zN13HdPBwIhjaf+WcNHHzejlMIwBKedUsAlF5dQUWXToVuQmV82895b7iTca58gl93Q0fVGNtyY9MbqNCPH5NCaUOgBHYnAkaCjcBAk04rlPyTp1S+Iatu8r9liUVDq47sZTfSOuB6+6bRi8cwWjDar3UFQtSlF3foElz3eB59jkw74aU0oArkmVeUJSru5+5LJFocpd6ympGcW0pYkN8fRQiYr5jUz6g+dQbnL/ku+bEAA4UIDWzMo6pHlLntb27wHwdQUTdIkv5s7uUrN3ZtGgZZlIJTCcOSOweNIpHQd6RCuQ58SgCbw5fhQlmTzvFpMqTCyje1L9Qgwfdp2T32/DlLTSPm3pW27gUKl3UOJVNttlQOlh7bnu/Gfomckql0AJQRGWMdsslBA8Tk9KTy0A6sunEXDx5uJr2qhx30D6fPWoYT65rPxoaXkjWlH9eR1rvNZtomvxO8e/SqgccoafI0x5MYmUo5B6c2DSW2M83/Ye+8AO4pr6/dX1eHEOZM1yjknksiIJBAIMNnkZDDYgAkmZ0wOFjmaYJLAIHIQySJIAiSkEYoI5SyNNHnmpI5V3x89CHMR1/b3rq/93tP+62hU3adPn9O1qvZee63So/sgTIGZd/E9zYAPDsNZ2MySPd6IMg9lFu0Pf0PLI/MQTrToC8uTBCUJ4rai+cppJA/sRVBdgpGQOHObSO7ZheTONbSOn4VtKfwv16GEgdmvnPgpw8k+M581VY/gfxeNFWmb2PBqgrcW47y1FLNLClFqI1MmNORRS5sQhsTcsQZhQOLIQXRaeRHpq0cjS2IEdTn8xU2EOf9H80DrRR8hVIhaWIfhu+g1LWTeP43MGydj79MHf2EDygvIHvsi2SMmYFTGSD16BJk5F2EfOQwhBMHM9aj6PEaXFLFTtkfGJMUz/kJh9weR/atILb+G2PVjEaUJQs/DOfRx1PiPkd8D/MBq7JbbSS6+7kcAr76rwzvwAfztb0NPXxkhVsFDdCrBnHklxsRzUN9swLr+oGi8FxCeNwGdPg9e+hpxxzGIlocQF45BPP8levDV6AlfIZ75NfKTK38C8ADqkPshZSEfeB9G9oTl90Ya8/8swG9shjE3wxeLYfad/2qA/9n4l4J8bW3tVOBPwKOjRo1aNWrUqIv/ziEnA8/V1tbWAkNHjRr1Dwn2bov/++hRJvns7AS79zTY8cECM9aGvHFqggMHmOz8YJ51rZrPfpuiU1py2SSXKeemGNRJ8tUaRe9b2+lbKfnm0hIacoqTJhR4+5wSBnc30C60OVBSJikQgf6kOT473NhEPC75600VxOOSfAifznb5xc4xznqwhb/OieRcq8sMHr6kgr5dLZJJgwcntrO8PuSw/ZIsWuZx0C5x+vSN8ciEVvbdM0XfriaGBqU0C5Z7PPJCKxf+thInG2AaMPs7D8/XvPt+Ozdc3wXDELz+WjNP/LkRv4MMN2J4gttv7Y4RMyipiTHpjSZeeznqqe87OIkU0HNAEqTAdTUrvytw6rmdCTSERlTjDjWgFLGMQaGgmfN1jlOv6IXQGs9RCFNixyWLZmYxTYEwBJ4XpbLT6SiFLgyDfKvPx4+tpmt3m1SljQBaGn0SFRab1jgYHWDYsKaI0yFK1LainWFHdWftvHY2r3c7dOE1jWsKKCCdMTEswZr5eTTRw991SAKEIPRCUrZm4+JIH11YRpQ+B6qGZIglBNINUB2tdKbnY3pRCUITnSwCekG+roBhSYxiCFIQZIPvy+0AdD2gawT6WhM0e8SdgNCQ+KZEhlE2wC6xKN+pEqlBd+j9C61xp9ZTWJvDGFGGV1fECBVGq0toSkJDYuqA2X3/woaJa6k5rjepoeX0uiqaXItrchSXtdPvjh1ZfcMcZFziNzqEWRepNQk8Wl9ejipPUX39LlhdUzQ/t4TeT+9LccZmijM2kxzbk4pTB5L/fD3LxrxJ6Gm01sTNANo9KAQkx/UifeoQjNYCdjZP6tA+1DxxANnJ68ELUbZNbGgF3lfrEbPWYIRRO2LyjJHoyjSZA7oSPD8Xd9p6kgf0IH5AT7yFjci8S1C7AbNLCllqIdMWNOQIlzcjS2P4wkSkLZJHDKbTih/A/fvIPTuf5C8HE67Jot1ogdd+21QKExZgug5mv3JK3z+dzJunYG4fqdiZw6rwPllJS8WteB8vI/3EEZQuvSwCd/kDfBTumw5hiFrSgKxvicC9bwWpZf8F3I94Ajd2GeH7iyLuxYAOcF9y/Y/BffGmH8D9qxU/gHt1CebXV2KvvQO5Uy/8C17HuvMX6LhFeP4EdMl5MGE64rajInC/6ADEC19F4P78V4inz4zAfe+fgjtLNqL2uQ2+rUOeuTusuBeuOhxKEv/cpArw4VzY6apIe/7j66BL+T9/jv+h+JdbzdbW1v65trZ2P2A74IxRo0ZtVb2/o35/OHDdqFGjPgQ6AeP+1de3LcA0BDePjfHiCXHOfM3hmo88rtnf5uEj4xz2TIEX5/j86dgEF+5pc+ifC9zzizgnbG+ysV3T45Z2ljUoXjktxe/2inHwkzl+u3ecMUMtkgLWtmnKyyWtCpDQ0Aajbmxh9vqQd68rJ52QOAiempTnnLFJ/vhGjgffzaGUJmYJrj41w/FjkrghfLXAZXUTDOxtMfGDHEftl2TM6BR3/amZffdJU5qSGCLqPZ+zyOW5t7IcfGAJDXUeY/dJsbpBM/WrPGvXRXV5FWiWL3W4+Y5NNLdEk15pqcHll9Ww75hSRMLgr+8186dHNhOGmk7dYhx3ShUDh6fQQrBpo8eSeTmuvbMXiZQkkJIOKRQKWUVldxvP07z6ZB1lFSaGVrQ3BVR1i3agOlCRQA4QSINCThGzIAw1oWmyYWYTuiLBBY8PJ1NloRG0tWmMmCRAkMhE6fbGjV5kLNM7zYzXNzH69B4s+rRxC6paCYkyDJrXFBi6fxVK6QicBTStdRFhCFLiFQLsYrTIUgrMEhtlSNavcFBZHwxBaBgdaflI71yLDqMYIbbs1rUEQoUZalwrEgCS32cBNFSM7rRlAQKAgGTRx7UNPKtD7UZB6/zmLRkC21UYvqbmtH6Imjje8iyWr7BjksCKVhjx0Kcwp4nSUwaT2a2alk83MeihXbfUhVdcVYtdk4gWVvVFhNLEKkxkMUAh8JJxHCyGfDiODX9cQLzSotef9mb9eVMJPYW9WxdyX20mXNJE/e21+Nno2zYJ0Y1F7B2qqXloX/yZdeSf/5bAMKi8dU/8uZtpfXQengcVl+2Ivz6HsWgDsdBDCUmYSVIz6Vi81Vn0pnZyT8xDZGKE/apxp2/E/2Q1MudgdUshMxYibUJjnnBpE7IsjrV9Db4D5vAaOq+9mPQ1o5GZHyusaaXJPTmPzLk7YvbO4M6qo2nPJ8he9zmxAaWUTzmL0jdPwdwhAnetNf6k73DOehVjeR3WUUMpb76O+BmjfgTuAKrNwX3z20jfoFDEGFgdgfsNByHKOsD9yCdxY5eh3lkYnT9hIx4/ieTSrYD72AfxR976U3CffgX2ujswdokU+MI/z0BbEqYvicD9hemIW49CtD6E+P1YxITp6CHXoJ/9AvHUr5CfXonYZ/BPJ8AlG+GUR1F73oSatR5x2Ejk/af+34G7H8BVL8KvH4eXL4brjwXj3+vo/i9991GjRnUdNWrU98oDWaL07ziFvgAAIABJREFU/dYbJmE/4J3a2tqDa2trDwYOJdrZb4v/pdivn8mcC5PM3xSy958KjOxiMOW3Se78zOOCt4qcuYvNm6cnOed1h5HdTG46yMYNYdcHczz8hcvZu8f47LwS7pnikkwZHDbSJiNgXZsmlpS0IAiNCEB+/WQ7d31U4IVLyihNCgIpuPe1HEfsGuObFT4X/KmN9oJCCMEx+6a4/TflNGcVOUez2REk05JbHm3miP1SHLhXiglvtDNwWBwpwAZqqiXLV3m8NaVAabnJmtUeV5xXiYPk0Web6NzZZL8xpTRu9ulaY3DdTXUsXR4BnJSCww4t4/Kru2HEDObX5rjt5vVUdLLYvN7jd1d3p2efGBqYNbWdFUvy3PpwPzp3tQilxCcilG2uC9ASGtY5NHsRG720k0lLg0+3/klCBMpXiI5adSAlvgApNAqBKk2wYbXLU9cu4+SbBpIqiVLaxSBSnwtDEIbA6ADQVPcSSqps3rt7OYdfPSBijSMYcWCnqK7tKir7p7F0SGgaaAQV3RKYKmqFU0IirGhKEBpahE2QsOnSOx6ls2MG1YMj216p2dJzL7SO1PI6PodhG0gnRKZNLC8Szje+Z8oIwZr3NyDM6NqUFJEcroJ0IaAYN9CWJNYjSdDoodEk2gO0ELhJyfrX1xArs7ByPlqADkNiYYC0JWH/UrweGTY+t5JYTYLqI3uS2bESiNjjDW+to/t5g1h0wmdYQiG8ANVYQEtJyZ6dUYHAqrBZdvAkVKipOro3a3/1Gd0fGo2bDfHXtGPkCjhT1iGKHh1UQ+y0pPrGXWB9O40Xf4auTqOq0iQyEuf9FXR6aAx6QDWZ3SppvPYrbHxI2vhlacLyNFUXjqThqNfJfbYBw5akfzUcs3sSZ0UWUfSI9UhhlFqItAWNedSy5kihbvsahARzlx6EyQQ1Hxz3E3D/PpzJq5BlMaxhlcRwye77BMGiJowBlVR997ufgHt21ENkT38NlfPxy0tJ3nkw0vwpi1ytaCR70NPghcjSGJm11xC7cSvg/vaC6ID+lRgzLiVIZUicvtMP51myCe+gDnD/cnmkeVzwEJXpH8B9tx/2h+HmdryLXsectQQxYQbilq2A+9NTEU+egfzsKsS+Q356U5ZshFMfhdG3wNBu6JP2iYifr/zm56bI/z7WNsI+f4jc5ubcHQni/AfEvwLkdxg1atTkUaNGTQZeBD4YNWrUNOAr4P3a2toVP3PcycCH3/+jY9yQv1kkbIv/hahOS947PcEvR1js+kiBb+sVMy9IsapZc8ATBQZUR3X6txYGLNisGX9oDCngwrcdDn86x+BOkpkXZ0jZ8HVdyD4DTcpN8JUmFJDVgnjHwn3idI+Tn27n5lMzlCYEhiV46v0CmQR0rZScPL6FlZuiHfb2A2yeuqoKN9CUpCUFIQklXHRbPScdnmZ4f5sNGwKSVRY5V5O0JIP7WbQ2B8xa4vHtMpe1az3u+UMNJWUW193ZwMEHl9CzT4zZM/Mce2Qp4++v59PPs1vuRf/+ce68rxexuKB+g8/8RQ6L5uUwDMHvru1JWYWFAl5+op71qx2uv7cvffraEXlNRMpugTSIlRiETki7ZROEmmTGoL0lIN0phucobDuyYQUIlUSgMMKQYiCo6hpDKs0zNy7ngLN6EI9HaW4NOPmQdJVN3HHQQrB6dgs7HNEFFWom3bOCyj6paGyoKOlkIzRMm7Ae5Svs0EcZBtl6J1LeIxK2KZo2CNBSkHA9/LhN/TovAuqMTXZZLqqd64hIJ5RCqmhHrwyJkgJTKQylcZXu0LWP7qcWoNG0LGkDL6Lj678h28lQkyr45JIW7cuzSF+RbgsILRGRrUyJbQtyH20kMCRxHSD9AEdYjJy4LyU7VZP7ooHqI3rQ/NFG+t22w5bvsu6FFWhfYWQLGMsaUFqALQiExYA/7420Ij8CI+uQ3K876U4W7e+vYfCsYxEZm3xtA3p9C/ESiRkEOO0RYz7VN0ksIWi59WsS+/eg/OY9UEsbkW0Fav58EN0+P4H8R6sJJi6g+PFaFILSi7cnXzQJcoqYk6ftrhn4VhwzaZDYqZLCswsIFzRSIotYmSgFT1NUc5eZGNZ2Uc09/ouBVC+/gOLiNsqv2x2zJvWzz3X2sW+IDSylpdvdsKyecFRvwlSS8mcORxgRCdJ/fzG5XR+mcMkkgjYfY8/elC/5PeYO3fAXNvzofGplE85ZL5Pf5QG8xc1IA0omnY6sSEbgftR/Afd+ldgNt5NcdiPhm4uwT9sREbd+APcRt6K/+C/g/uXl2Ovv/BG4Ky8gvPBFgq5XIT0X45YjInC/ZCzixenooX8D7lOu3jq4L62LwH2vm2FwV1h+D+qc/dGPfo64/Wjk39OZ31q8Uws7Xw1H7gyTroLq/xzY2iaGsy1+NmatCznhL0UOHGByzyE2d37u8fxsnzdOSzKsRnL+m0VmrQs5ZJDJ49Nd2lzoWiKYd2maqrTBxLke57+ep29K0JRXtIbQXNAkgd4V0NwYfVWGCZeOifPW5wVA0JpX1FQbnLF/gsc/KPCHkzLsNzJ68FxPc/dLbSxc6ZHPK4q5kKqE4MHrO3HdPY1sNzTGR7McgnzImFE2zS2ahctdhCFJGZprL6xiQP84V9y0ifqmgJsvr+be8ZuwLcHFl3TmwccaGTo4zhmnVGB2AG+2LeCGy9bgFENMP+Sos7uy35gMG9a43HvjGtxixAy/7Pbe9O6X4LaLl7FhQxBZtYaRw5zwQ1SgUYZB0o78KoSGYosHgSKekhTz3/ehaVKEFJWBlIKKzja9RpawaFY7g3dIs+zrFtxWP1L1koKk8gk65Gj9mM1+p3fny+fXUVFl0r4yCzGDnY7uyjcvrSVMWOCF9BycZOOCLAKNoUKEr5AGOHYM0/ORSuOZBsmEwHEhNAw6dzLwljTjIn5wnOuYP5QpCWwLw/FIOz6BKdEa7FAhA01ggDKMaPcvwHJDwo77G3dCTCK7ZBMQfdO01HtU1xVQCYNQCMp3rqR+bjPlLS6+iMx+/FyIWRXHSJrsu+IYFlw4g40PL6Fij2o6n9SXHudFqVnlhXzV4xWM5jxGEFDExiyPoZ0Au0eKwc+MZs5ek9BCYqYkiXyBql8PoetNO9N45yzWPfAdEkVKRO2DQczGdcAUmqT0SB89gNS43rSOn4W3IY9rxqgZvxexwKf56in4jS6BkPjaIjO2G4UpG1CexhIB5acOIj+rAWdJG3HhQqAiYLcEqhgii27Ej0iYmIMqCVc0k7poV1IX7oosjZN7cynN102jx9wzfmSp+n1oxyd/31c0XvsV6a4SbVrYF+5J7vFvSOzahfLnjyD4cAnOHyajCz7G2IE4L8wjee2+xC/cHSEELRd9jNEzQ+bS3VCrmvBum0zw1kKs8/dEjO5P27jnMXfrTubzs/CPewb1xvwfLqBfJfaMSzGropW99gLaet5B+tljUQ9MRn+6BEwZmR05PqJrKcar52Ds8eMecuUF6MtegT9NRRkGvkwSW3UjsjwJL3+NvuUdqMkgbjoK9h28dYW9pXVw61vwwTy46CC48CDoENcJ9rkbVjZgrvvjPzNFRla1V06AN2bCXy6CPbZS6//fi21iONvin4tupZJf7WTx2sKA2z/zuenAGDt1NzjhpSI9SgXXHRBDa3jgS48x/Qw8X7GuHe6b6jG6j8GhQ21+uZ3NxG99cjlNz1JJLoB8APkilJVB6EfWpdNXBQzvY1HIhVSmJXVNiq+W+lxzXAnj38iRKyp26m9hmYK9t4uhEcxd4ZOIC5pymjnzi1x1dgXPv9HOJaeX880yj0WrQsbsFsfJa7J5haME074usPcuSY45rIQvvszz7id5Tj6hgtqZeTZt8rnqihqmfZlj8qdZdhiZIB6XxOKSYSOTzJzWjvBCFqwI2FTns+c+GTp1tlm8IE/ga6Z/3kbPgQmOOa2Gae81EfiKQBoQKFKVNkEuYl172sAPQCiF72kMSxAWo4yFEAIjUBhlUYo8VOA5itZNLuPO6s7CGW3YsQ6WW84j7jjk4wmkiERpQsNgzfx2dhhXw+q5bUgvJFFisn6th8h7kXGcYSAsGUm2avAtC8MPEKEimRT4QVRfTyQkhUCQas5hV8RoaodUTRzV5KCM6DoloAzZIZAjsBSYQYgvO1rewogUGJgdYwCJxuwoD6A0sQ4DH6khM7QUWduCDDUt1XEqB2fwNxUxl7bhJEzwFAJJ3+u3o+nTzSgnZOiju5EeXMrS38/CzftYcZNhT+8BoaLxyUUsPfg9ck2KVFebXC66d9IWqEJA76tHsOz0KRgZk1CYJPN5jEGVVIwqZ/1JH5L/sg5XW6RwSe3bnTDUqGYHhUnFfjVUXbcLhbeX4S1oJH7EQFrntBLLGKhJi8m/sZRAWrjKRPbIoHMe1sp6HN9CJgy6PLYfLeNn49U5WHhYhFhpA6tXBrW2FREqRMzE2q4G1Vokeep2lL94DPGD+iPiJqros+nwN6l+bCx2/x8Tu7Qb4Dwxk+xxr1Cc2wh+SPyQAZRPOhldDCg8PIuyK3bBOed1/EmLiV22NwqJN2kpmbdOJnb0sB8MZNa3432+BvnxAtxL38HYv3+kLX/IULLnv4da2kBySAnB6RPQ322OLqBvBfbS64ldNRb5N4p33iNfYHyyEJ77Cta3RLBU9CO2/KTfYT1wPPJv9OFVEKB+/zIc+yjMXw/XHYbvSKwL98HY0Ig+/jFYXIcYfzzipqMQfX6qjc+yTXDJBLj6FTh0e3jxfBg7covTm5q6BH3zu8gPL966Nv3PxcrNMO4OCBR8cA0M7Pr3j/nXxlbFcLaB/Lb4byNmCo4ZbhIz4ZRXXPbsZXDt/jbnvumwullz9f4xdu9lcs80l5q0pF8FtBQFf5rh4QWaY7ezOWPnGOtymk8X+ezSw6TZBSfU5ByBERdUpwSFIqxtURgxQRzonJGRqc18j9+OSzDtW5/PF7jsPcwmZkmG9bEZ3NPi0zkucQPq2jRrN3iccUSGpye2cf/V1UydVeSrbz0O3jvJ5jqfRFKQK2g+mppn9M4JDj0ww9QpWWYucNlxVIoFc/IYUnDmGVU0NQc8/XwzgwbEqagwKS0zKa8yWTi9nQE7ppk7p0DtzDyHHlmBCmH9GpfQ13wzI4uVNDj1vM589k7zlpS9X4xatKLatCZEEiAxlMKOS4QTYCiF6kh7Bx3Al8gYeAWFaQlWzG3n1Ov7UbfOpWmdA66PMCSubSNCFR1vRqz4TSsKdB+aJre+QOhrDrhkICun1GNqRWgaODmFDDt6uQ0JCCzfRxcCZNJEKYG0DfoOS9O+No+SkmRbgZxpYecctPG9K11UV0cIhFakCj6FVBypNGYHI14ZoC0Zae9IgaE1pV2TFLM+lh8tFNAay1PYdQ6eAC8mMAS0ZAOSOR8hIbAMRAjdftmLjc9GeuYiZrD986NZ/+Qy8ovb8dcW6H7JENSiJpYfOom2d1fj2gl0wiIQEp0NiHVPolo9Ej2TFL/cSCgkRqtD0TfAlMi2HOHcTdDu4msDJQSdzxlC4c1l0ObgiDixwaXEikW8BQ1U3rk3ZdfuxvqTPyTe1IqRK2IOqEBlkhTqA5LDMziL20iqItb+fXHriqQ7W+Se/zayzpWQkC7WwDL0piy6xUGmbVTnUnLtgvIzh1H+0rFbwP37aLl9BsIQlF+125a//QDuL6OzLsbY/uQmraX0yt0oe3AcWAatJ72Bt6GItWgN8Wv2w75gT/KXfIBIWmQmnYbZ929AdnUz3gNTKby7guS4PiReisBdJGy8phyFc97CwsFY0QHufSqwv7ua2LUH/wjc1bJ6/NOeQT/8GTL0o9170Y8Ide93gHuvyh/GBwHq0lfg6Edh3nrEtYchJl2E3pCF12ox5yyDRRsR409A3HwUom+nn4L78g5wv+plGLfdD+Ae/7GNa7j7HYhd+mJce9g/PjG+NgOOGg+/OxjuO/3vW8n+78RWQf7fS/vbFv+vCCEEZ+1sM+WcBA986XPbZz6fnJPiu/qQg54uMLRGMvPCEkIhWNEEY/ob7Nnb4I5PXXa+Pwto7j8qxeOnpJm5KmC7GkmPCgPTErQ5sL4Iw/qYhBo25WBZVtDmavpUS0osuPvNIl0qBNWlkpPGt7B6c7Tr3WlwjCevrKS80iRpaOasDnhzap79dktwz1PNPHt7JypseP6DPL37xxCeZuftYoS+4vwb61mxzueaS2uI65Blq31KusR5971WFiwo8sujyvnVKRXcdd9mPp8W1el33auUdJlJscHjtDOr2FwfcM2V6xi2c5q+AxMYBmhPMfndJv7yfBPnXt8jUpMLA0IkSkg808AUGqGiXbpjmhhxY0uRyfZ9hBRbiOelNXGkKSjmIoLexLtXcezFPRm+awmBaeGXxLHMKJ0OoJRChZGN7YblxajuHWoqOlsINFppuvZPRkS8eAw01FQbCKUIZbTLFTkXicbxoXFxG6EhsZoLhEKQbGgn/Bu1Li1Ad7CtLU/hG5LQlCjLQIkojR8mLIKYBZrIIU4IsuvykZGNFngSEvmQeFFRNCVe0sAKFeUNDraraK6M43dJIXyFNgSJHqnI6U4IEsPL8FtcVtw4l/TQUmJGQNstX7P+918Q61/KgMlH4BSgZGQ5Ohf9bvzNBXSgKN2+DG1b2AUHsyqGIRTKVyTdIrrFIbFnV8K4TcZwyT4xD9G9hCxJtBakkiFV4/el27QTCTdkWdvlEeymNmSnJGW374O73sHPKqTnkZ/Tgt0lQc/l55Cd2YjtFAnXtGFXWATaIFmmEUqhVrYiS2JYO9RELo/790aM6ErJjfsiy37co+2vbqPtwdlU3rNf9D24AcXHvqZlwL14k5aQfuFYdGmSwkvfYQ6qpOTGvfE/WkLLkPsJ5m9G9iwl9txJKF/TNvpJ4ufuSskrJyBLo/dRq5txzplIfqd7MQdVoWI29k0HIypShGGI88s/U6i6EUmIiR+Be93NJFf+AbNz2Q+/j+X1eIc+gj/sZvQnSxBagRciypKYUy7B3ngXxugBW8arIEBd8jI6fT48OQ1x3WGI9ocRVx0Cz30Jpz2OmZGIh09FTLsGMWbo1sH9jMdhtxuhbydYdg9cfxSU/lj3HiC8431oyCJeO/cfmwwdD857Cq6YENXeLzoEtlYa+A+KbTX5bfFPRdHXXPKey8fLAl48Ps5b3wa8Ms/nzdOTDKqWnDWxwDsLPY4ZYdOrQnDrZI+ULfj6ohRDa0xmrw0Y90Ab1eUGNeWSmasCnECTNGFUd8mSVWG0gxXQ2daUx0AZglVNmr41khNHJ3jywzy3nJJh7+HR6tnxNDc/1czsOUUcQzKyr0W5Bd06W5x4WJrTL6mjICXdyiUpqdl37zQTXmkhNA1+dWyGmlLBX15tpUffOHMWOMS9gLvu7E6nThbrN3iMf6Ce7UcmOOWECiY+vpFlyx1G7JphrzFl3P3HOloaAo48ooyv/9pMS2OkutZvZJpsXjN8kM3nbzd1KL5FYJiIaaSnCIFARanxjPZQhQBLKQLbivTkFSRSgm4Dkqz8Jhu1iaUN+o5Mo5c00JIXNBQNpAnJlETV5fEsEy0lAoglJTQXMYIQkbGxci5BoEn2y5BdV0BpsLyAAXtVsO6j9RTSSeK5IvGqGMWswjMNkJJEW45k0iDvamIFDyNp4IQCyw0opuKYfoAMQwylCQEtJGHcxnI8LC9Apy08JImcG5nFioiQZwUaBVQ0RmUD1S+Fv9khUfCQPngZC8+QOFVxgnxAus0jjBuU+ArtarAE9k4VdBpYhj93M8GsOnxD4JanGPX2gaR378zGZ5fx3a+/wkyDbguRSQmFkOpjeyFbi+Q+W48bCiq6GmzeKDEJKE0rut65K41XfYnK+ciKGOUX78S6G2pRGFQe34deEw4k/8K3NF01BdXiEIYCJ5mk+uSB5CYugaJLwTGw0gaBB51P7En7i4sJgw7xHt8l8MDSPtI2EHETc0glwbIm0hfsSuri3dAIFvV4huFtv9nSgfF9bDrmLeztqim/clecZ2ZTvH0KxogakjfuD5ZJ6/GvYu/TC6fBJ9YzjVG7AtVcpNAqKfvz4bQ/vwixsRlrcwslE0/YIlmr1jTj3T4Z/7X52Ofugf37fRCVKTb2fIjKySeir38HNXEuCnBJYRg+6fXX/QjYIQJ3/+JX0X/9rqOFLLJ8JRnD/OB8jL1/bKuqggCueA396GdgGogrDobrDotklSfORN/8NjrnEQ7sjjX54q3X3Fdsjmru734DF4yFiw6Gsp8nI6qcg6q8CHHZwRi3HfX3J7+lG+G4+2BAF3jqt1tdNPybY1tNflv8Pw/LEBw2xKRbRnDKKy5jB5ocOczkpL849CmX3HhgDEMKHpzq0qvc4P4j4zwzy+fhL306peDwETaHjLB54vMiG3OaA4dYLG9UeCFsbNdUlQviUpD3oKAFrqeJac3ug2xmrwqZtdzn2l+mueu1HK6v2bFfVKfff1SCxpxm9UqXujaNtiR1Gz0qy0wOPyDNlGl5iqEmX4hEaX59SilfT88ze7FPKASD+9g0N3jstXuab5b4fP1llrFjMlRUmIzeI8VnU3N8NjVL/54W6aTkmzkFunWLccpp1TQ2hfz14za69Y5HrVaeJt/is8vepXzxRQ5bhYSh2EJS85HEYwIRamxLoDyFIy3sWCQ4E1hmpD0uBb4HQgq69E3QsslD+Zr21Vlspeg/poZUqUnjRh/f19hBCBp8O1KoC3yNoRVCaXxfYQUhGkHX3atoW9yGXXBQtkn7hiLSj/ztvWQCnTCgGCKCKP0fWibJ0siWVoaK0DShQ07WSSUww4C4ExBYBtqQmIHCDELcVDzKCMRsRBB27OIjYRtTaUw/YuabgcYpMaDVw/IUpqdxKmMEWmBIQUVVjFwuICy1kYEmYUisCpuy3TrhzKhDTl9HWJdHdCtBje5BsaAZclckw7rg+CkI0dHy50QEQ6vSxtzUSn5eE8lySbxYRGU98sRI9UkRb2mnOGklRU8Qdi8nXWXR9tE6PE9iVMTodt4gNh/yGrnXlmINriQcUEPRkcSVjzdjI0axSCG0KRnbneLiduLaJZxfTxhKAiFJWT4UfQw0RomNNbJTVHM/aQTlLx1DfNwARNxExk2aHp1P2TH9Mcp+SAcXJq+m/Ym5lO7XmdyJr6BbHNKPHE7i8tG47yyh7ay3Sd95AFa/ctrunEGiqZH4VfsSdq8GKUkdPZDcTZ+jMaiqPRujZxlqTTPule/iXPQW5t79SLx0CuZhwxBJmzAM8cd/hrxzEny7KfoNp0oIQ0nisWOI7fMDSU6vaMA//VnCS1+HNU2Re1PRR1SmcK0S4jMvx9jpB2c4FQToy19FH/UIzFmLuHIc4sPfI0YPREyciT6+oxZ/0UG4k5Zjf3wBMvNf+tdXbIbLXoLLX4KxI+Cl8+Hg7SD+32upqaMfhcYc8v2LftYKd0u8OC0C+MsPh7tO/rvn/jfFtpr8tvifi6E1Br8cYXLLpy5LmzT3HxbjoncdNrZrbjgwxrAuBjd86JB14aNzUvxlrsfL8wJmrQ05b88Y+w22eLPWY20Wdu1lsLpZY0hod8EBduxmUNeqKWqBH2ham0N+fVCCGcsC/jrP44JDknwyz+XL73xGD7OxTcnuI+I0tYesXuXRVtT4hmTuPIexo1N0qTaZt8ChpFRStylgc7PmzONKmT0zz8rNIS15TcqEsrRk39FpptQ6zJqVZ+z+aWIxgz12TVFfH/DJp+3IQsCvLuzKUw9vYsT2KfbbP0OXbjYffdyOaQssoXEdTb4l4ISzapj+dR5LR9ZrQimE1hSVJG5C4GvsMMRyPPJmjFDKSFwGvm/DxsmHGKakpMIi3xIJt+QCQUlljFRc0H1khrpVRXD9iKgsojpyR3caVhgiDInhRm1zu57QndWfbiLm+VGd2wsRhkAECgxJrDqJKvqIQGMWHIJkDNfVxHNFhCWQToiWAmUIkjICb9MN8c0OURovWjD4tkloGqQqbVwPbDdSvjP9gJSjsIuKYtpCS4EdKOLFEKk0TlUcURZDFUK6H96d1s/riRVCGFxKMe8Tq3dIJzX2snpku4eqSBFUZNhl+XEExZC6t9cx4NJhOOvyrLphDoYJqtXrUPnTxIsOwvOJhy6iGKDiFmF1CalinlhzO6EWhJZJPoxT0csifcZw6t+vQygojTkU34zAvdPEw7H37kPTnbOwWvNIz8Xul8HDBtvE/zaSRY7bkfOg0po0RYRSICSyfyXC9Uie2AHuhwxAJH5cL85+vBa7d4bYwIhYp/Iujfu9QNLNQt4j/cgvSF65DyJt03bqG3iTV5K5fi+CP80g9+K3WDt3o+Lr30B5kpZfvUv6+EHkz3kL+8Tt8UNJ+oAeuFe+F4H76L7EXzoF6xc/gLt30nMExz+LmctFCnU9yzE+Og/n6Xlo0yDzwrEI24zA/YznCH//2n8B9zTme+eh9x1GuDZL/LJ9os8RBOgrX0Uf9SjMXoO4qgPc9x6EeHUm+oTHYN5axF3HIW47Bu+GDzBPGoU57m96z1fWw2UvRgB/4Iio5j7u74M7gJq7Fn3ZROQb5yEH1Pz8wIIL5z4FL0yFd66EX+z0n5ye31aT3xb/s9G7QjL1N0m262Jw6kSX8YfG+WZDyLinC+zT1+TTc0t4e6HP8S8UWHBZCeMGGXyw2KfHLVkySckzp6eJB4pQQZ+qyNktYUcM7GkbFLsPsdBAK4I2LXjmwwI3nZAikxDc/kaB7p0MUnHByeNbWFMf1VsvPqWcnYbGsIKova5VC659oIn990qx84gY2VZFj64mq1a4PPVWjl+My1BpwYb6gIUbNVO/LpCwBWefUMq6zSGX3bAZz1NIKTj+2HKO/mUF61Y5rNkYcPxp1Tx670byuZBddklz9/geGCmTfCAwbcHmOo85X7Rx9OFlhHFji2Wr1BorDGkPREQSZ0mNAAAgAElEQVRG0xArt0m4kRiPF4tIYqkyY4t2e8tmF8/XpJWLlhK7NMbCGW2smN3K2LN70HNwCm0b6EBT1TuBadDhzR711RMqnI7e3YXv12EXXYKKVNTHLgRF20YbkpJYVLc37Ui+1gpCqnrGCIWMWPhpGyE7WueEwPMh3u7ixQwQgsCKsgihITE9HyMIKTT5yCBa5EgNpdkQEUJohJFkbaBItvuEtiSfttCGJGyMXA+a/ropyk6kTNLr8oRS4JdJZF0WXZ4gmyrBs2MMfmJ3ZMygbPsKhCEorMqx/MraaKHU5nZoAYRYhMRxsVwXa1A5HhLL0MTqWrEHlLPJLMfUIYEPqZEV9J5zKpvumosIFTFc4gNK6TLlRLp/fRrurDrqxryM6XrEd6iKatc+uE0eVnuWEImNh11uYCuHBB4yaaG7l1MQCdLHDaJm2YWU3LwfsmLr6mrx4ZUUFzah/RDniZk09/gjpu9S8vYplH5wBtZuPfFrN9C0458QYYid0Hh3fo597m746RJK7xoDUtB28cdYXRJ4L8yhdMrZJE8ehjdtLfkd7kGUJ0gtuYrY7YciO1rd3DMm4Jq/R70yBwBdkaL4iz1IrrkJ5+YpKAXx40YgWvJ4RzyGN+Qm9OTvwOwA90wc85OLsTfdjdxnIO7jXxM7ZxcA1DWvo0t+F/WlX3kwIvsI8sYjEG/ORo+8Dn3/x4j7TkR8dR1i7HDUB4vQSxswL943uinrmuCsJ2CX66F7BSy7F/5wDJT/fGr+b0MpFe3id+6DPGj4zw/8dl3U++54UHsnbN/7Hzr/f1r8fw7kI9n7ba//t15bhuCYqgU888s4l0xyyeWy1JRIBo/P8+zUdbz36zRz1gd0ubGVHbqZ3HyQTWM+ZMjdOR6b6XPmdvWs2BDQPSWIGQrP0TiBwNead5cEyBIwBDQpaNOC2yZk6VYmGNrN4J2ZLu/WugzoanD8XQ08+E6Ogqs4fI819OlmYoUa4YQ0uHDy9fWMGLSRHp1NVq0L8JQm2+Dx1qc5qquKDOpsUHQVm4vw5PNNdO9qs8vQHGs3+lx1/UbefGMuWmtGjy5BasXLrzaT9QXdeuV46O4NOEXFqlXzGH9PT7oMiGR4hYSZ09pZtKSOSs+jqndEatI6evBiOiTsqKG3FyFlQdJ1Mb2AwDZpbdNoNHZcorXALbjYBZeYCihmQzr1SVBo8Xnh/nkcd01/fBkxr9tW57BiBhV9IgY9gNQar8OPZuP8VoQU1Awv3SI3a3ZY4fq5gKpOFkW/A8QTNrkNOUSocNJxwhYXGTej2jpgeJHN6/d8AysM8TuIeTJUGH4Q7e4dH4GmvN4hsCXtJQZkovuRyXrkK2M4cROEID00AxrCJARNEdgHsciGN13waEnHyZw9grxMEJZJ7K5JqsZ1p7a2lrAYorVm/sx5NLy2BqkUColJiEKSpkBYliR5ze7kVuVJEBDbqYaG8nLCmAmBptlI41WX0f3WXZh7/pu4DVF/vDd+MN1nnk5it2588+ZUGi/4FGUY5PasAmlgmOA0FYh1TeDKWPR5D+iK3pxDILCOGII1ohPtm0K6f348mVvH8M3Kb7f+fM2aReury2j5y1IavltG646P4Lw0n3bfpmzqr7F370ltbS3aD2k56mUaj+uGmLKU+O92Z+UV29N0/zysoVV8t2wxDfu9gDd9PcXSgLKZ56K0ZOOBLyFTJsnFV7LgmM5bwL22thb/2RmEz82MFqWdS+CN39BQ1hmjfyXFp2bhfbAUTEn8nB0pbHcLevJi5M2Hob0AYUrMyRcx/73jMfYfTLhoMxt3uxfdmMc6ejjLb30JfdcHiMsPZs5nv0L+4UiklMx77zP0r59B3Hsi3zw0DnHQCIQQ0fU89gXWjQcze/7c6OYc/xCbC+2w9B646VhqV3z3D89X6u05eGUXQF0b8s3ztz7e9dnwmwci9bpLD6P2ot23SNz+u+fb/+71z8U24t22+B8LL9A8943PbZ969CwTVMQF01aHnDnKoikb8OI3PpYpOH8Pm89W+NSuj3zYL9/HIonm6S9cupRLFm0OyYdgGAKBRoXQLaFx8iC0olKDpTW9uxhsaNO0FaE0AUO6m6ytD7nwFykO2znGX78q8PCE1qjXXETSucfun2JET4NnX26jpT0EGbW1dak0SCUE324IiVmCjAi54sJOPPpsC34+JBPTlJaa7LtXiilv1HPWdb25+Y5NnHBsGWsWF9i80eOCK7sRi0keerieilLJVx82IQKF1rD73mlWT28l6JSkZZ0DSmMZAiWAQOFLg1LfwbUtTMfHMy2QIP0QW2riCYPBO2f4dloTPVSB1V4CLQQV8RDVtZQd9y3nqwnrkI6HUfRRUmKFIUqzBeidZIJkvoApwSq4dB/XjdXvr0cbUd1dak069CgIA5WwMdodtJQkbUVWWYhQUdKSw7AlRRG1zdlugKk1xQ4eQNwJcSyBocG3TAxT4BkmsYJLzA0ob3Qppg0KSZO4E6IEVDS5OD1SqBYPBJhxA1WIZHGNBhfRKU7eDeliK1ZiEgs0e949itV/XEhhaTs7vL0/VQd1A2DqAR/h1hcZcGo/Vlwxm1gS/EKITYhtKFKGR1umnJ7nDqTp9pkkksDx2+NtLtD27mqMTsmon70myY7LT+C70sco5CAxtJxh35645be+8cCXyE7ehFeWotvde9B2+wyMlnba2i2qzx9K/cOLqDy6J7z3LU5gYqLo8uWp1B3yKuzWh17vH7mVJ6jjOVqbZcP5n+MtbaZTH4H+dhOp+w6hWO9R/Gg1Xd4+esvY4kvzKT45m8QeXQg353FkkuK7yyi7YS/8hZtxXltM5to9cW79K5kPzqD9hcVkn19IKsxStfEKZOqnqe1C1dUQBOg2F/fssRTfW0HZ+DEEHyzGmzAX2buMkgt2QN/6PoQKa+UtqGenoy57HXPedciR3VGtRZybJuNNmEP8hjHEzt0NYRqEfa+EwV0w3v+xV5n+cD76jx8gP7nyJ9dT7HcTsfd/ixxUAzOWwYmPRM5w/4QmvFrVgDrqEZi/AXHMjogXzkJuLa0/7Ts45wkY2AUePhN6VP3D7/EfEP8Wq9lt8f+jsE3B2bvYLL0sxak7WszdpBjWWbKsUfH2Es3Ze8bZrafkoS9cljRofrO7RUUC7vjMY/z0gFuPTXPYcJtyW7BjjUFMabwQMGCTJ2gWkb57o5TUS8GyTSFhUTGkRuB4mhnLAnyl+fNfC5xybyudu8V4+b6uVFabxNEkQsWbn+S465UcJ5xQzhXnVVCeNnAQrGsKWbUhoFeFxPUV7dpg/IP1dOls0bmLRWmFyei907z1ahNtOU1TY8DVl3XipYmt9B+ZoqLK5LF7N+L7iro6nz1Gl3DyuV2iHnQB06fm6L9XOWZDgWSVDULghxrhBQg0oRTkTBs/1ITlCQSauOMRCoEKwfcUvYamKeuSwO1eQUoGSBXSUpT88nfdmDW5OTKeERHBzwhDzHIbt6SjJUoIpIrAXgdhdF4Vqe6JDllaK2mQGV4RpfhzXmQhK8BxIutZww/QpsQPol0+mi2699+Hk7CQRB0DplIYgUaGEekv0e7jJQxc2+gQ4ZFkWjzcmBEZ4AAyKVGFEFFmYTS7IKAQKhKGxNlcxLck/Q/uxsanl6FiErsyRuXYSIQkvyZH25wmBl89ktW3zkegCAoKA0WIJB46qOGd6XzmQBofmkdM+ySPH8zm55aR/2QtDjY1J/fFqkrQ9dKRtL+3imIuynT0euGALZ9R5TyKk9ehDIk1rArnw1XE+pagOpVidU7Q8sIShNAkeybQgcJSAfbxw8k/PBPPTlJ5yY5bfX50qGh4YC5Ld/gLKZ2nqnk99nadKP/uIuyjh9H+wGzKfj/qh/Fak79vOvHfjiL74Cya31qHiBmUXr4L2T9MQQhB5+9+ixGHsEslGw99C10M6HRINaWX7bJVgA/nb0A35VGx7/9PUPXUwRQueAf31YWIhEG6MoDXvkHs1BPz1sMRFSnUzZOgcwYxrCvuUzNpHzweXfDILLqE+AV7IkwD9c1qWN2IeGQrliSL62DIT8VktOOjN7Txf9g77zA5qmvb/86p0Ll7evIoRxQQQsAACmRhwAQnDBgwmGiCycHYBINNusaYZAyXKMBgg0kmGCyyQEiEQUISQllCYTQ5de4K57w/aiQBErx3v+9dfK+t9X3ATE119emiqnftvddeS4zoD7a3vhyo1f0/BnjlePgn3o8adXmgr7/kNxhPnrV1gO/Nwxn3wo9ug+uOgb9d+r8twH8ltgf57fj/jq8K9ht6NfPbBD/cJUR9XPDkxy6egu/uaFB0NCf8pcAji3we+2mC7+5sUxkWTKyW2B6UfPANQUYIeoBQRNIpDTqEYFWrj600o6oEPTnN8jaftj6f8+/t5dq/Zrnu/GoGjQpTV2MSURqV8/jdI33c9UKBS8+r4aqzKzHDBhkEbR0ecQGOq+jTBosWFxk5KkRVpcl7HxSYvm+c4TuEefihTh6e0cVR30sy45EuJk5OEo5I7r29hdZWh4Z6i6l7JfnhKfXBF5KA2W9mGT0tTSRXxjVEYMPaX+aOO2V8y8SXJk7RR8YsLOUT9vpnux3N+zM72eWASgaOTyKSYSKOg1Q+91+ynMl7xzGyJcKZItWj4/ghI5C+df2AMBUykH5AiMMPHgb6NhY3e8FLpYilLdqXZBFxC8MPWPkhoZCuh+l6WKUywlN4m3xupUD6avNnEEpTigZa+54hQQrMYtCXFxoiJQ8tNGgVtAl0wLL3bRlI5EoIShvgaw0+mNUhfE9TMSxGNmFju4oBhw8ivyJD4ZNehv1ip83M6CXXfowRMQknLfyMixUN1mWisU2FaUBmdYnYoAgUPdCaVY82Ex6TAscnOTJK52Mr8TIOtT/ZgdbzAga6WRUmvmvN5uu7++dv4AkTVRWn+rjRFN5aj/dRM/k1BSqOHonb5xHfuYLiIwtwzBCgSf9iT3LPrURWRYhNH7zVPVP8uIMVk58k99BCBtQVCRXypGadTuy3hyDiIQovr0bELML7bnmt++46vNYCPb98G8eKUHnTfnjvrKX0/HKqXz2O9J2HUF7SRdv5s3B8i4aXjqTqummovy/GOmPKNu/d0pEP4hkh6MijUxGMvhx9hz+KuXMd4TFJLOFg/mwfzEdPQs9fjzx5Cv7rSyBTgjP3I7vnnZRnNBF/6RRi9xyJrNniMKfP/TNMGIQcXrPV++olLYhxDVtvX96OGFEVSPau64TXFsMp+25z7V+GuuctVMW56L99jHz0NMxPr0WO+dJ7aA1PzoXxFwVkwcW3wJGT/yeT6/7L2B7kt+O/DV8V7DMl6CwLpgy3kGg+blYkIoLdBkuWd/js9ccC77VqXrs4yVG7hqiOCsamBKYPDgJtCDaUQYdBhiQdhkG3EKzr9ImhGRgXtPdqOvOaD1c4HPu7HsaPDWMkTPbYI0YyAmHPp73F5Zybu3h2bon/vK6evXaPkrckvquxlcYpK8oIZr6e5bBDU4TDgtlvZdi5McF//HYQBxyQYObLGWpSBnff28Ge+6colRQh38e2gy+J/Q9M8Z0f14IR+K6/81aWYbslsD2FmTABgdYCW8KgiBsYvSgolTXFeDhgxvdnys0rizSvKnDEWYOIpm182ySdy2EXS7z/nysxtSIXixAbVUG0IQ5hM5hTh0CxLhoYyABoU5JZnQ0sYiMWQmnyGwsgIDE40e8up5CZMkIptJR44RAiFMzO00/oExpcUwaMcT7vLKexYia+KbFcj3Deoxy1cEISQeBYF8+6lMKBdS1KB4cs+IiIQagQZNCFso/tKrLzu+mLh0nYgs4XNmCPTGBKwaDTg3lrN+PS8tx6hp85hhUXfAAoVEEh+rP4qFdEj6khfcgg2m9bgFUu41bEseImtfvXkPdCVH9vMNgG9WeMw2vJU1ibBzSDfrtFUU4pReaBRWgtULaJWtFFZJdqGJBEWwa5F9eAEFR8ZxiqtxxUanYfgvvkJziVFVRdstsXxrVUwWXjZe+y5sBnqAzlSLZvJHbVfiRfPwVzfO3m/fpubaLiwt23SM32FOk88QXKfQoznye0cw3Za94mcfk0at48AVkdpe3Ev9P2vWcIV5sMXHgyoV3rce+Zi3XkRGRt4gv3qvYVmZvnoFZ2offaAaEVbl5Tfmk58fN2I7J4Oe7yXmLv/Azj5KmoO2dhnDwFEQ+jTn0UbUgK980ndOHeJGafhbnrwC8cX3VmYe4qxK3HbPvLYsnGwCzmS1BL2pDj6oNf/vAK/GTvzXrzXwU1by3eiF+gzn4McfJeyN47kMfuufWO6zrhO7+Fa56EJy+Eu0//2rn6/63YHuS3478d2w72BoYMCFsDKwxcV1NyoDIKA5Pw4qcuY2/Kk0Pw3i9T/HjPMHVRwdBoIBLjCUGuBM2eIFkhKckg2PdKQVdOEZeaCgva+zR5V/P03BKr+jQfrfXYb98EIwZZRA1N2lB8tLDEMVe0U5E2OXx6gsiAEBZgao32NTlPcO1NbRz5gzROwePdDwsATJ0WBPvDDk2RCAluu7WNRG0IyxI8cm8bSgXB+eBD0xxyVDWi37Tlg/eCYFqpXdz+LL/kQd0OceorBb4MFPDKSpKJBuV20U91+3hOhneea2fs7km0p3GkQaxUohQKkY3GUFKy9KMM0hR4poljGijTwFMaXfY3q9NpKSHjoKXAJSjxTzl/DFUj4vS1BYFd9bvMubaNb0gMpSlY1mZL2S1+8AKpAtlZw/UCdzoNdkse1zIRvibe54AMfM03+c5Hcx6eHbjLCQgYloBjAX0uwpK4QOXwBAVLYChFwz51tD+/nuyCbhpOHhWoBQKr7l4KGgYcNpDiyix2JHioMgmMdyxDk+0BlXFwVvdhoKi8cgrxXarofHAJoZRB5vWNeL0O9efsSPOpr+BjImxJ1SlbnMxyf/wIzxHo2jg1Z00g88in6BUdFNaVSf1gGIVVOUJVJuW/foJr2Vj4VN0+ncwfP8IrKJLHbjEwyb6yjmUTHkO/sZw6Ognv0UB6yQWEjt35Cw8C5QXtOJ92Ej9mLFppsg8tpHnMvfgbs8QPHoLX5WDvNZS6JWcS+e4O9P7uA9ZPfAhzYJzUbkkqfr03Ukq04+He9S7W+Xt/4f50FrXTPu1hnBtf7+/q9tsG7jaE5E4hzDlLUT/ZB+vQsZi7DkJnivgPv4f86d6ULn0eva4btetwUksuIXT8LtucOdfn/QXqksjpX2G/uqQFtpXJL21DjK2DbBEenBWYynwFVKaA/+3bUI3XQn0K2Xwzxh+PR8ovhTlfwe0vwa6XwZ6jA1vYadvwmf8XwfYgvx3fGLYV7Cc0GNTEJdKUuCpwFB2clqTCYBtw4xtlRv82x9B6k/lXpjhtrzANEUGtRUD+0rA+p+nUUJMWZLSk3TDIakHRgbjUhBR0ZxWZMrQVNQ+/XaZhZJjxI2wG1ZhUhDQVhuKZ1/P8bXaRdFpSMzJCXYWxWVe9pSj4+dUbwVW4Gu57oBOlNFIKpk5LcMutQzj00Apmz87hmpLPVpf5y4x2NhFbj/h+Fft9p6rf1jPgFgzfJUnMDZjbrmmy4MMcsYTByHERPEMSLRRBGkG2TVBW9wW8NKOFpkc/I1IsoWIhqqbWU0MpsJUVktHjo/R0OPiuwjVMhK8wfY1X8oNWphD49BPyhMBOWGghsCMmicFRyoVgu+F4CA2eFbD2bd8FscVNzvTV5soAIhj9k54KMn1LYvgBN8DwNOWoiWsGvXotwS56uBEDqQIpYABd1ggDYgiEIdBKYziK8mc5CgmLsONjKEF0Yhqj6DPyyp2D1/mK1X9cSsPhg1j9i48AjSorgtkEQdQv4qWjOD0uzrxWbOER2rmG1odXkmpMkyuY1B8zjNL6POnDh2KmbbLvtAKa6tO/KJva/Zs5KCTlEliGIjQuDabEKWlUcxYQVJ89AX95N6qs8RrSsLgNJ56g8pxJyLCJ11Fk3Qmv0HrSS9QaPcQiHqk3TyV+y6HI5BflawH6bmsidc6uuEs6ad3nUbJ3zSM8JoURMfHeWUv6+r1JXbsfxVnrWb/TDErvbGDg3ONJnTQeNX8joeOC8+T99WPk+DqMnYKMWRVdei9/k47pjxE7dRKhni5KMgGzA1+A6Jp1WCdPxZxzCaVnlxG5cCoA/oNzYMJAsoc9jJ7xDkJAaPaFiMS29duV58HTTYE07TagO7OBm1tDxVZ/CzL5OpgxCw4YD8O2LvUD+Nc8h6q+ED1/HfLVizDn/BJZn9p6x48/g8lXwLMfwLvXwpVHgm1uvd+/ELYH+e34xrGtYD9xoMHYOpOCL1nVpRlaIZk6TBIPQd7RnPDnArvfkefAHW0W/KqCc/aP0BCGmAj69a4QLM9C1oTKhKBHSLpsSSbwUCEuNDiKohcEysfnllhaNBCmYNouEabuHKY6rAj7ioUrPZa1+Lgpk4qYJB4JCGh5X1ByQCYtNrY4PPxI1+YgLqXgmKMrGTchQsGB3jLMnZ3lP29vQakgiP3wR9VMOSQdaNMDc+fkgyAMmMpDCcm6NWWKGZ+KuCATjxMrFDaft5JhECk5VPb0oRWUKqIkRiVRYZvwxFrs/geGpR9lGTohKDuano9UKnhAME2E7wcB3XU3ae3gFYJtfRsK5HqCPr4yJJbjERkSQxsy6L37Gun5CBFk49IPCIMQEPN820L4HobnE8m55KMWpueT6i6hTYEWgZStFoJUTxmvLhLIlhpsrgp4CRPdWiY8NIYPhDUUSj7KlBhS0PuPZnIrM1TsX0+oPhhran5uPX7eZdTFO9L9agumGWgL2PR/Vjz6eg3qTxyJ6ClgaZ/IyTujXEXfn5ehDYnTXgClGXjxRFounIWLBUIw6HdbetfFNz7D7Syj0xEqTxhD5r5FGMUSxZwguU8DmVltmDaod9fiWRYhXCp+P53szXMp9/hUnLkT3Q8vYfn4RwgtWE2l6iH2q/1IzToNc6f6bd4rXmuO/LPL8df20vqtx4l8axhm3MCZs4HkFVMJ6yLmYeNoOfwpui54g6rbDqDhhSOxR1dSumMu4TP2QIQttNY4t76NfWHQzy69voa2ne7DW9VDzds/xr3xVYo6hjmpDluVEabAXvwrjNP3wn1pBTIdxpw2FG9pO97lz1NekyNy/UEY3TnEITsivy5QXv/3gJdy7vRt/31pC4xt2GYFQC1pRe5QC7fPhAu/vfXfZ36CV3sh+oaXEFcejtl6y7arBYVyYAl70HVw1rfgzathzD/dNe4bwfYgvx3/NHw+2B8/yWJ+q2LSQIPJw0xW9sDctYr9hhscPMbENmB1l2LKnXl+9GiBE6eGWXR1mksOClNlQEyD40NBCZbngFjgJNkjDHpDkqwO3i/sa3xXEw4J1rZ5zGqBN5a4pBKS35xXw6iBJgMTID3FihbFBl/gejBmkIWtFI4h+WBekU/W+rzzUYE/PbYl0EOgYHfEYRWUtOCAIypZMC/Pz89fy+LFRbTWHHdiDQ0Dg8xZaXA3Ee/wkWgUgvb1RcolTaXpkUkF/XHD86nr6SVeKNGdStCbiFPUJplej+OvGEG2JFCmSaKQRytYtagQWL96ga+9YQeucZ40UQJsz8fvt4jVngIDFj3+GR0fdmK4bmBUo6HQ6YAUGP2BXxCI1yDACdtoo5+dD/iGRBsSZRrYZQ9lCFzLAEPgS0BpfCOovijLQDkB21987t9h00BaApGy0AJMDYWESarg4COIDItDR5kd/mO3zed86XULSE2spO2BFcG6DdD9k7QRXUabBlZ9lLAdzO0bdVE6X22l5vtDyKx3qD18AH2vNhMZW0Fst2p6HloKaBL7NmB8ToGu69xXAzsWTxKfUIGIGPjreil2uNiDImgtqDxtHM5bn+GWBV4kTLjKotijiB0yjHXHziT7qzepVR3E9htEeukFhE/YdnkbAvZ851mvIF0PXfaI/3A0hTs/xEhYxI4aA0taKY0aTPN+TxDedzCDPzmF2KGBxKzqKVL+y0IiZwUCNP7sNehsGXYfQtdJL9B9youkbj2Q6LeH0bvLXXhr+ojYJWI6E5zD3Yci+mfnS7e+S/jMPSn+8h8Udr8VahMkVv4S8fYS0Brj/hO+9j7Xt78GJ07Zumy+CUs2brtU7yv0ig7Eqo1Qk4ApnzOy2diLt+f1qG/fhthjOLL7doxfHbHt47+yAHa6JBDRWXQznHLAvxSx7v+G7UF+O/7psE3BT/e0WXFJjON3CTL73QYb7DvK4rXVmrdW+Zy6h8VBOxgINDOXewy/Ics1r5Q4f3qU5delmT7aJAlENLgaOkuCtWVBulJS9qBHGmSjkoKAiCXQpcAcxVSKDSXJ3e84/OcLOX7/ixpO/WGK6phgaFrgedCKwdJWn9qoxjEMzKiB1IrePDz7RoErbmilXA6y9ZaNLtMPSHDcMZW89naei64chPA199zRwvXXtfDppyUaaoxARtYIyGsKMKIWlq/ACkrzblnhOIrhFT6RYolUNocTC9OTimP2W9L6UtKVhVULs+y8VyrodVdHsXwP7YMvDQzfRwmBLntIHWTiXsjGdTVIiS8FUmlkKZiLNgfEMDyF5bgQMhClgN1vlB3oN75Ba4QXZMnlUCh4yBECw1dYro9d9ilFTExfgRJ4IQPXFIDEsySW6+NEDHSxn+1vAmi8sEQ0FzCTNn3LMxhGcB7KEZPaehtTa5y8R3hEnOQugS1p78fdFNfmGHfNJJrvXoZEocoacxPhDgc1cQANZ4yh64FPsbVL8oydyX7QQWn2esraJDQgikzaDLhkZ7rvXkjZDfr8wx7eknm6a3spfdqDjljE9h9E/ollgYtcLE5kTIqeJ1YhpcYuFFBCEsIhdvEUcr9/j2If5P6xmuSq1aQGSCpeP4X4HYcjK7atcgfgfNJB6z6PUnpxBfETd8SduQocRe2C0/DmN6OHVdMxYwUMrGDwopNJX/xHgWQAACAASURBVLonwt7iDli6vwn78DHIhkDl0Ln1LfwpO9A28X5kOkzNK8dSuv4Ncqf9DavSJEqG0CX7IN4I5tety78VfO55zXgLWyle+TK6JUN4XAXW774PUqDvfQfG1CEHbF1m3wT11IfQV0Tc/BWEO0AvbUFsa3xubTeiOo64+9UgixcC5Xn4Zz6CGnwpdOeQH1+N8eJ5yPjWbQ46MnDCH4LRuDtPgT+fD3VfvdZ/VXxjQb6xsXFYY2Ojbmxs/O7ntq3s/++JjY2N7zY2Ns5qbGx8srGxsa5/+0mNjY1/6P9ZNDY2vtXY2LjtIdPt+F+PLwf7T9oVewwxmDrc5L4PfT5Yr7jukBB7DZN4SnP7bIe6azI8udDl6bOT/PxbYRoiUCnBUkGwX9mnafehvkbSm4duaZCLSjxTBMFeB0Yx6bjgnRUe0y7upGhIHrihnoOmRKkwNFGlKCLoySg8W5J3NKGkRUM6aOctXeXyo7M3MOOJbhxXU5Ey2GdanB98t4I77unkrIsHkIgI6qskDz/UyQfLfCJhydAdYyADglina2CGJQNqTVQ/c13mHbxPOrAtQXcqgR82SYxMoiMm0VIZqTWeYXDfjetYsTCww3UxiCRM0pm+zTK6Wogg2zYk0WwB4SsKVUmUICi/a4VnSArxKPleD+n5gQKeKVGbihT9gjqRmqC9IJQm0VdAGRI/bKGkwC46KEMSLTi4VsA9iBZctAjMaAQaoQK7WWX0P2AYAl0GEAFpH0HFtxoQjsIQkEuYREo+uuRjAM7KDKN+PWnzNbP4qnmEaiM4qzJoR2FYQRYv0YQND2FJ8qsL2FZ/q8E26G3zqT1uBD2zO6lqrKDz0RUIU1L53aG0XTUXgNDwBKEhWxjonWfPxMfAi4VJHz4EZ1k37rwWcuuLJA4ahO9A8uCBFJ9YTFlbKGlg7ZCm/dUODHxqw1kS1+xP6t2fYk766jKxypbpvvh1Wvd/DBG1MKIS/+NWqp8/msr7D6fwp08o9gpyjy6m4pAB1P31e5gN8S8cQ3s+pT/MJXJB0EN3Zq2h78UNFOd3UfW3H2IPCNOz8534i9qJVriEejoRlVHs67+L+s0/ADAP3wnvow1kD5mBjBgknj6ByM/2RLdnkN+fhD9jDjg+5r3bmHn//Foufwamj9t2EN6EJV8xI7+kDTEwCZ91wpF7oB6Zg0qfj370PeS9J2KuuBE5cetxRLSGh9+CCRdDXQo++T18e5evXee/Mr7pTH4p8MvGxsbNtZLGxsa9gFOAA5uamvYFZgCPAjQ1NT0EjGtsbNwTOA2Y19TUNO8bXvN2fMP4crBf0a2ZMsxgTJ3Bla84bMjAjKPDTKgPAu4ZTxUZen2WyWMsTpkWZmKd4LhdLFICzH61u8VdmowBdWlJVw66DElfSCLDAtsU9GWCaGa7Ppc/nOHw67oZsUOY805MUxMVxLQi6vv0CpO8NOjMK3o9yZjBBkcdlkBoeGFmjk5P8vjzvZTLigP3T3DoQUnuuKeTU86pZ9WSAod+K45VculRBtlSMGrmmiaG55PTklgYqnNZ6ru6iZXK9CRimMNSSEvSZ4cxNmZIjkhgKh9DKcz+2fdPlnt4UjJohygeQYZd0duH1JqybWNK8LVA+H4wt+75lGORwKFNaUZOr0e6gYud4QUSt7Ls40QCMpU0DCpGxHH6xWFE/z9mIVDF8y0Tq1TGUAq3n3SHFtieT9k28A2BaxuYrtpsvKMBIxE8NPgm2FkfaQhaPuzEUBov71OMmwydUkuhvYQZt7BiFnVHDgWg1Faka047O1w2gZWXNAEK5erN4jeRfvGb6uNG0nHHQmzfJX7cWLqeWIPszlFQNhX7NwRZ/MUTKbzXQqk7qFwMuW//zdejKnkUXv4MZRgY9THK724gMj4NA5IY6TC9f16OEJDcuRJd8rF8F29YDZ2nvoSBomJ6HellFxA+eTfEV5SstdbkHv+U5nH34TVniU4fgvvGauJn7kbNuychh6ZoP/0fdF71LvHjxpEkQ+L6bfe4nWc+RQ5PY+xUT+amubQf8gShqQOpmnEYuZOfJn/l61gpg+RwQeieo6HoY/0+sFr1n1oApiR/+lNkvz0DlfdILjgPc8pQ/Ftfxzhv/0DY5hd/g3QU+SXL2M9DLVwPK9sRf/zx19/wSzbC2K3L9WppG7Ingzp6Mt6Eq1Enz0Ac1RiMxJ269zYOROAlf+C1cMfL8NIv4eYTIfY1Dxj/Bvimg3wzMA/47ue2/QS4oampqQjQ1NT0EhBvbGzcNGh5NnAX8DPgV9/gWrfjn4wvB/uNOZgy3CARkpzyVJmQKXj8xxEGJAUbehUH3lPgpbWK8YMsWroUC65MccS4oIxvaCgqweJejYpCPCzoLUKPadBlSULhoFec1xJbaaSnOOuuPm76e4FU0uCac6sI98+/G1pTMAxaioJFGzWfflrgj9fXE5EaA3jyuSzHnbuBx5/vZfp+CfbbO85dD3Rz+vkDePGZbuJRwZhawe67RTGUJuS6OJaFLHt0zesimi+SjUZprUqTj0Tp2Oigffj+cTW0mlH0uj4MX4EhiJfLGFpjKIUvBCsX5dAFB8c0KYVDCKVwbIuiYWHHgtE8ISDSl0MqTTkaQQMjp1QhDIESAtNTuCEL4So826Tfvo1YTTggykHw/oA2DMxSUMr3bYtY1qEYCRj9Eo3QGsvxMfunsnxDYMYtlARDgfY0oPEFyLKi+ohBFLtKCA2lmIntaYZ8fzAOAq+jxJALxiP61c6W3rgQw5b0vbger6eMZQePHgYay+gXv1nnkNophd9TRGqFO6SGysMG0/n4amKDQnQ+vgo/41J3yhiaT38dhYGRtEhNH7T5Ouy57E08bUJdgprTxpN/bhX+gmbya4pUHDUCp9MhskOC4kPzKRs2EkWst5OwV0AOSlHz4o+QlV892+0s6aTtwL/Qd8McYt8bhffaqmCKbYc6UtfuQ98fPmL9jg+ic2XiDSaJfQIdeXOXgds8XvG2OZiHjaNt9wcp/WMVMTuPOaaKnr3uR6/pIRIqkrhiGvbHl+Pd9AbYBtZJk9Guj97Qi1ICkQhhnbgb4ZN3xaiKodd3o2Z+inHqNLzZK6E7j7zmsK+9f/W5f4axDV/r8qYLZWjtgxFbs+bVe2tgRRvqljcgbiPX/AfGgycjzW2Q/FwPbnw2YM4ftiu8fwPsNuJr1/fvgn9GT/4G4Befy+YHAeu+tM9aYNMVvBKwgDeamppy38wSt+N/Ej4f7E/YxabPDexpuwuaY/9SYsd6gwePCREPCWav8bl7gWKtIzj7TzlmnJLkk2sqmDxIEicgcnUWBSsKEE8LfF+Td6E3alCwJGa/xGxXnyZpaBxfM6db8LsX8oQMCKcs4oYm3h/kupRk7nq46pYO9tglTNpUTBwTQvjwxN8yHHfuBkoadt0lwj0Pd3Hwt1NkHEHJ1ewwwgpEY1AkcnkGdHXjGgbr62rIR8NUJoNMXwXPHyQSBqdeNJAWGcUzDaRtUDJN4qVSIF4DCF/jV8fJRKOULBuhIZXJUgqFcPuczedUWSam44LWOGGb5W+1E6sNYZWDfRSgDIEyJUIr7IRF5yc9+Pkg0zV9vcUOFzCKDsqUFOMhpIJQ0cfyNGVbImwDx5JEsy6+JSHv4RnBw5Kf89AI7JJCmoKutXlC5UDvP5+0qK2N0PPCOlzbxPZg6AUBc9ov+ax/dDWmp+l9Mxh3045GEBjSRP0ijKoiOaWW7oeWYJccwvsOpvW+ZUQHh8i5NnXHDEOVFbWnjcXPueSX9AGahiu3SMcC9N27AI3AcTR05IjsUo2ojOILg+I7zSAEld8bht+aJ+SVsaRPeL9hlAfUU33lnl9JrFM5h+7L3qR1n0exdkgjyw5qdQ81c07CyfhEDh3Bhl0epvDiKgbOOpaQKhO7aDLOHe8SumCvbR7TeWMV3uJ2+n7/IYlLpxAbG8N1DEqPfIwpHJLfGUR82eWY5x0QXFcfrMU4dTLu6yvJTLoNlMY8cyqR6w6m/PB8Iuf3j83dOQvjJ5MRqQjqjEfBMpDn7L/NNQCo7hy8swJx89FfuQ8Ay1thZC3CNL6w2b/pZdRT88AQyOfPxWz6FXJI1baP8d7yYOb97SXQdCNcdDh86Xj/zvjGg3xTU9MG4CNgk0NDMzDkS7sN6d8OcCbwOrBPY2Pj8G9kkdvxPxKfD/YnN9r4UrLrQMn8jYrTn3Y4dJzFtYeEkELzSafm5WaY8rs+UhHBG5emeffSJKMqBDHA0rCmFzb6groaSSaryWhBMWUSUppoGPIO9PRpQmh6W8v0IaE2TKzCZNgAk4hWRLTCE4KVWcFLH7tUj4jQsr7M+adUMmW3CPQH+2deyyHCBjNn9rHbpAitnT7vvdlLuFyisquPVKlEx4g6uiuSlI3AD176qt89Mxi5e+KujdTV2xx8UIKuZAJd9nEiNo5pEC8HdqpCa/LdDmEnELophWyE51O9sYNcIk4xFg169BCQ5XTwsLJyXhYzLIjkS3ghk3DBCd5XBmp2laMSxOvDgeqs1pie2jw+B2AoRaozRyEewjcN4n0OlusjXR/tq8B7Pueg+0v1niEQ/dl92QCrrKmYWkvvqgyJugjlkERqGHPeWLr+vg5XSmqPGISZsCg155mz10toVzHh5ka8bgcr/DnxG6mxTU3Osag+YjClBZ0Y2sc8bDSRMSm67vkUI2aQe78dP+/ScN4ENp4WMOcxJHUX7bz5c2XunY9X0uj6BNVnTCBz/yL0hh7yrR4VRwwlv7gPMwT5m2YjCSSEE8/9mMK7rXgFReqELUI6m6C1Jv/0UprH34e3rIvwrrW4r62m4pZvUf3SsbhrMxTfWkf+yWVUXb8PDa8cjREzKb+2GmtCDbojj3XE1sctvrCcniP+DGPqqH3nBNyXl5D/z3kI1ydaDRX/OInQX09DNATz496pf0ELcFpKFE57CuugIPM1b/8+pT99jDV1CMboanSuhP/Auxjn7Y9e2wVLWhEn7PnVbHlAX/g4VMeRh078+pt6ScsXSvVq9nK8gZegLn8WjcR4+2Lk4Ttv+7WZApz7IHz/ZrjiB0F5fljttvf9N8Y/i11/I7DJbuhPBJl9BKCxsfEQoNjU1NTc2Ng4ADgDuAK4CLjzn7HY7fifhc8H+59ODhEOCcbUCF741OU3r7ucvIfNCY0mGljYDVVXZXh8fpkdB5os/HUlfz01TlUIogRl/E87NZ1AXaWgMw8bLJN8WZNISmK+R1ELRMZDhU2WN7usKEtWdmt2GhMiiiaiFKavKErJ/PU+bRjc+adu9pwU4e7fDmD8aBvhw9JVDqtKFnOXuwzQJda+sJ5UNo9Xm6AnleCym0aSarAxCbzg28sGJSGJhPvn2T3NLZetIqo8xo8w8CEg0sUtyoYk5Lqbz5GpFKlMjnCxhF1y8EMmVR2d9FZX4FhW4O4ng1l30w+y844WD8P18CyzX2O+XwPA9eldlaW4MhB72VQ18GVQYhCAEwlh+gq7UMYNW/TUxyhGLEwh8IQgVPTJJyykBtVfBQHQAsJeIGnrhCWmp3HbShTiJvGyj9dewqoMZHfHXL8rG+5ayvs7P0emOU/tQQPofqmZ4KlBbxG/USWojCFjFoU312M6DtaoCtr+8hnpfWvJ9kL90UPJL+yh4uDB2AOi9L20DtBUHTNyczsAoOdX76AwKOc1kWoba2gCih7lnEa1BYXFqJdHakWZEG5tBTJfoixDpH+2MzLyxdKyu7yLtkOeoPeqt4nsOwhv9lrCBwyj7pMzCO0/jO6rZ9NyxDOEpw1k8JJTiX1vNEII8n94n8hJk3DvfZ/QedO+sEa/JUvn0c/Qe95MpFRET9+Fnsn34D75CaZ2SF0xmdjqq5D7bBlB0wUH909NeEYIc7dBJD+9GPH2CoQAQ0pKt80hfOE0ANRD7yH3HY0YXo177hMAGLd/dYaulIInPkRc8tXqdJvX0T8+pzqzePvehNrnJsT4BuSV3w6qBXuO3PYLn/sQdrwYik6gN/+jaf9WY3H/FfxTgnx/Nt/U//MsgkD/WmNj4yzgdGATU+N24PKmpqZCU1PT20B7Y2PjD/8Za96O/3nYFOxXXhrn/L3DVCYkg1Pw0IcuTy5SnDUtxOQhQUn+2EeLDL0uy/trPQ6eGOKz/6jkhiMihCVEAAPB4h7ImJCMC1oNk/V56AmbDCk5JPDpUhJd1lSFBT2GZNZqH6vCIm1qQkDU9/FcTa8vsKtD3PRQD/c90ctFZ9Vw/S/rGFRnEHZcBqxqw17bjUjadKRTeMkQWgiq62yuvH7oFr9IpelzJMUymGawtVTWzHqmHbWkE0NreuNxzKJDORRCmcHt7JkG0b4cIcdBC0GxIkYpZGOXXOKZLPlYFM+0grl3pZAaom4Z6SsyVamAfCdEILlLIEUrUyFM1wcBVr9CnTJk8CCgwTcNMskQtuNTv7qHbCpCIWphJSw8S5LqKeOEzKBELwVW/4y8Y4BVUhhJi/amTpK1YUquj2dJBk6tYf0fl1HOOFimZPGP36H1z6sZ+ttG/LJi3K8n0f7UWgwJytOB+A2CkPQpN6SpP2UH+p5dhaU8oifvjJ91yT6xDE+YaMdHGIKBF0+k7ao5gfgNgsF37bP5+irOXofTVkKnI6R+MILMjE8wpaLkGth1YbKzW5EoomNTeHYgYVtx0wFkb36PckaRPntLBqoKLj1XzqJl6p8wqyOIvgISTd3Cn5L4+RTyz69k/bgHKC/sQIQM6v5yBLJ/Rl9lyxRnzCfyg7F4r67APrlx8/+X3L3zaJ14P+boNLEDB0FFhPzPZ0JvkVDIIXbn4di/PiwweCGoIjhPLqRv0HUIpYjOPY/IldMREQv9aStUxnD/sSLwPdh3OFop/NvfwLhwOjpbgr8vQkwd+fVs+d++HATc/4cgz5KN6I/Woeovhs86kXMvx5h5Idz/NnJM7datjuZuOPJm+Pmj8Kdz4P4zoTK+7WNvB9A/ofpNoKmp6TPgwM/9fs7nfp5BwKr/8muO+tLvJ/83LnE7/pdiU7A/aTeLhz5y+c3rZXxX8cD7DqYhOGEPm+eayqzv1Uz+Q45dBxo8eWKUnx0Y5cRpYa54Os9DTQ6mBl8JVuQgEYaQJ+hyJQnTYGymgBgao9kRbOxThIBQ1GBlXpMyTGpcl/ymLNfXtHSCCJvMXVhi3pJWpu5oMaa5jcLaLLlEhEV1A4m4PqlSie6Mxu7/MovFDAyh8TUIIQJBEBnY0uqYiXY0vaEIrjAxHUVNArpyUeK5PJGaMOW2AsNXb6AYCVMOhyhGbBKuQ6SvEKjSWSaJTBbPNlEREzNTwhMau+SSLDj01qUpR0NEiyW8cPD14IZtOjOQ6O9zml4QoJUgmJcWECp5GH7w2U2tSfbk6auK01dysVyFEzLQRjCuqExJuBgcw+gn25tjkrAsg6k0hYRFNO+RHJ3EXZPH6dBIx6fhpFEMPH0H3trrJZLjUnQ9vTboIUclbiGoRkSkgwgZlFpK0JFFej4yFaL7wx5qfzSc5uvnU3vQIHqe/Yzw+DSJKXWsnf4UIIjtVoOZ2iLN2nXOqyhMXGFQN62OvtmfUVzRiyoq4rJAN2lqjh+B+8QCPN9Ch0JERqfoXZUjceQ4rIYYWmuKz6+g6/zXsMdWYo9I4i/toOqvRxKaNpjyog46j38R1VWi9pFDKb69AaMqjFm7xSil+OA8QtNH4D3/KfZPdkMkw7hLOun+6Uvg+lTP/BHeS8vI3z8PERJIQxO/bh/cu+Zi/3Tq5uP4i1oonPc8uquA5RYRQ9NYjZ8bQSt5yMN3pHjru0QumoYQAv+FhZCOIqaNxLv8b6A0xn1fz5bXt7wCx359OR9APf0R+pl5aNNC3noMcpMi3ovzUNJE7DHsczsruOc1+NUTcNZB8Nh5sC0/+O3YCtvFcLbjXwabgv3qn8f59SER0jGJgeLZTzz8iMnAqCCCZl6zz8gbcxxyb46ygjt+nGDhFRVMHRrcDhHAcQQbfUHYgi7LQGnNii6NY8Hek8I4hqC7qDGBPiXZGAshVDCfLTXYviKqFY5l4GXKZJ5eSe+GImsbqjlrxiRGjY5gK4XlebgIitLgvoc7AlEdrYmHBabvIy2J9jWG0Ji5MoWwiS8lWSyUD9VJiOORi0Tx1wes+0w6QTadwFCKQiSKKvtYrovhK+yyg+04WK5H1gzjmQaWIbALDn7IItqXRwtJX0UCv5/FbCufeFcWv59Z7xkSLejv12s800R6HqavSPQ6eGGDcsgkkimQTUWwXMjHA5U/w1MoVFCtCElC/Tr5vevzRG1Jbk2OUsQk5io6n99AcUkPvikZfskEBp0xhtyqDNmlfYy9ZhJrf/tJv2e8v1n8JqLKeDs2UHfqGDr/uIiQckmcPIG+d1pxPmqhqCyi41LIpM3AS3em56/LKRWDzzX04QM2X0vehgylBZ2osEV4Yi2FZ5aj+kqEi3kSZoGMmUZICFeYKA22domevyf5W9+jrGyqLtoVd1UP7Yc/SfelbxCeUIX/cQvx0ydR+8EpmOOq6Tj3NTZOf4L4UWMZNO8nhCcPIHPXfCou3H3zOrSvKNz+PpEzdsN54EOsMybTd83btO/zJ6I/Gk/6tgPJ/uQpCv/xFqCIHDycdNevUMu7sM7ZC2EZqO4ChXOfIzv9PqyjJhK957uIXJnQQ1uCtbesFQBx0lT8T9sJHbMTAP4tr2NcOB2URt/2BgxJI7ehTrcJ6vmPoTuPuOWrxW/Uqja8iVejfng3CI3cePOWAA9w6z/Q44cEmvUAi9fD3lfDo+/AW9fAb47ZHuD/C9ge5LfjXw6bgv3aX8a56YgItilwyj6eKXENyeC4QKJ5ZblH7dVZjn+sQHVS8PJFaV4+M87ARMAuDwPtvmRw0SHh+awJh+gpCmZ/5hJtsJiyU4i8EPgCSq6mJRKiYBl4m5juBY9xn7Uw+bMNrE2lWDllBKXaGBfc0EFeCwyhQQrKlgVaM3dmDyf8bD2eFoTCgkQIsAJ7WF8JIimL0VaZSLmEFgHRbMUGn/T6dtI9vfSkkvi2iRsOIXSgEe/KQIPeNwwwJfEBEaQfjLZFikV6K1K0J1KgNcVoOCCOdWdwQxaeHayrQgQBHIKZegSBip4QIMC3Av6D9DV2PyGvHLEJlzzivQXaByRxIia+EYjfhJ2g3++jMRS4cQO/5JNsiARGNEUfWfQprsqC1rhhi6rJAaFq8VXzsStDyLyHyntYcQPQGGhCho80JdkVeaK1FpSDknzWtaj98Si6Z26kYkKCzodXgBBU/WA4rRe8DQis+ijRHbewtzvPmYmPiaqMEh4URv/jUxKdrZSFjTh9Kp4jSO5bH3jGCxslJOnTJpB9eS2hHSspPruUlj0fRpgC0ZPHGllB/ZIziZ0yicz9C1k/7gHwFUOWnErq7F0QpiT7+FLsiTXYO1ZvXkf5+WXI2hgsa0ePb6Dje0/jLmij9p0TYEU7vQc/DMvaEUWX+G2HEH/uZOgt4j33Cdape1C+5z0y434PviK55GLCZ0/BPfExSIQw9tvSo/d+8TwAzjNLCJ+9J8I2UfPXo1d1In+4K/7jH0LJxbjjq4M3gL7sSdhnB2TF1iODyvHwj7sXNfpK0CBfuRAxqBJZ9Tnb2wVrYdlGlC+RI6vgqsdhv2vghL3hnV/DjtsQv9mOr8X2IL8d/7KwTcEZk0M0X5ng5u9FKXkalKKzqLEtybAqiUbz+McO6auynPNskV1H2Cz8dSW3fy9C2AQfWB62KBqSpFKYJnRkNBs7fN5Y7zF+gs2EUTYFBFpDDoMOyyLd08ceK9diK8XCHYdSHpJmQ7tijW+z++4xfAWrUwk661JE/MCe1U9HiJRcHEPS3qcpO4oRXR2Bpr0hyeYUbiJM2i0zdlIUtGbY6mZ8LTAqw8Qj4AuJT6CJr4FkvoBVcihHQriGQeXgCEIHhjUh1yOezREtlnHswEJWG4HGfbwnC1KgpERk3WDkzVdBtUIFQV70D927lontekRyHuWoiWMGfvHKEFR0lahszZBLRft17MHwASEwS4H4TskUhDxFdmEvhbhJNOdiGpLoHlXYJni2QWJUErfPoePVjYy+eMfNnvF+LtD89/rH5tT4Oiq/M5TOPy7CdstEjxhJ559XY3llcn6IqiMGI2yDARdPpLysm2JLCYDBt03bfN0oxyP/wuqg8tDeS+jPc7AqbUrDBlCMV5D522oQkNqvAZV3MT0X87AxFO6fh2uGkKvbKb25FqvKRuTK1L55AhW3H0x5cRcbGh8h99inNMw8ipq7DsKoCqRttdb03fIhFRd+cXwvf8scwqfvSs8v3yK/NEfqxv1InLITvQc8gPPIR4hcGXv/Ycid6omcF4zVuXfPQe47itxBD+I89jHxmacSvev7yKoYfl8RvbID84qDvvA+6u1V6IiF88xiwmf0693f+jrGufsF1YBLnoZ4COO7k/gqqCUtsKwVcefWKnjqztdRFeeiX1qEfPynmIt+jSg5Wyvd3foy/Oxb6IXNiIsehCXNsOB3cOZBgbvhdvyXsf2sbce/PGxTcM7UEO1XJ7nusAhCQqns4ziQjEgSYYGnNHfPcaj6VYarZ5Y5dmqE5demOXeyTV3Zpcc0abZMXA8cNNJR5LOw4DOf2a0+FRFIxQThQpGDVqxhSG+Gt4YP5qPBDZTKoCREhSLq+rw2t8iCLkGl52CFDNYm42Qti1HDbUTCJmfbCKXJCpOF6VriSSNgs9sGbc1lyqkI6rllmL5Pe00lzYMbWGPHkb0lDAN643Fs18M3JNFc4F3vmwZKSlasDMxnNnnChxyHqo5uMpXJwOtdCjKxMFJrhAoeLrrj0cAzvl+lTmqN10/y0+h+pztNLBdY0RpKYTlef6/eR8dMEr0FSvEwrtpCpJJFDWEJCCoGxymEDUxXkxoYBV+TW9xLsjGNrwXRgVGW/W4RwpTUTK2ltDYfiPsQjM1Z7p2qLwAAIABJREFUhsa0BNk2n8q9avCac0ilUBMHkD54IB0PLCVSa9Pz3Fq8nEfdaWPZcNKrKCQyYpI+etTmdfVcPgutIK6zpMNFCtEUbjhCvsUj9cPhlFrKRIZGKc2Yj2PZSDSpC3al55aPMPJF7FEpWNtD6ob9qX7teEQ6QtvxL9B27AtUXLYnA2YdS2jSFwViim+uQ3tBuX0TnA834C3tpPfSNxG2Qe3bJ+A8Oo/MT55CdvRByKTigzPQwiB6YX8PfVUXxd/Own1/A+HL9iU+64wvyOg6Rz8IpsS+7FtfvEl6injpCkLH7ISsjqE39qJeWIhx+jS8D9ZAawZ50Ve4yPVDn/MojK5D7rhFpEd9uBpv2M9RFzyBOH0fZPftyKP72xFfGp+jtRf+1oT+eA26I4v4/fHw1MUwoPJr33c7vh7bg/x2/NvANgWX7Rem59oU5+wdYmPGp1RW7NRgEPs/7L13mF1Vvcf9WWvtcvr0mUwy6YEkJAECoSpIkSKCgJViAYOgYuF6BbGLV6+iIk0UlaLCFa6gIHhFpIOUwCTUEAKB9Jlk+py621rr/WMPUV7jfe99b9GL83meeZ5z9sw5e5959tm/vX7l+81IlIRIWy68L6Tzy2Uufzjiy+8osK+KKTQ7xFIwKiVaSIalJBvH1BqWqAFmuMGbn1jLsRs2sa69hdt2mc14NsO4ctiS8QmqmroU2KxCRZqsMWz2smyUHp3VGgJ4/IUQd6iMqxNC18Fr9shbzWAt9X83NnWPa3t+C0Exi/EcopYc0lqagwkRG21T7XvS2nm+WifMeEhgvFhgVHoIwAiJNBYRa1RiEMZQLaVp0yCfo55NU/f50TJRxicoZHd4x6elgHT8DQS5aoDf0IQFh9gVkPXwwphcLabc7BEKgYw1uWrAaHuRyFMIa5FAlFMIY6g/O0a95FAyFpFY3Gk5VMPgtHpk232ssWy8Zh3TT53DS59cAVhMQ8OrRjS6AT3NZOc3MX7zOpwgJLN3F9uueYni/DzV0GXKqXOItjXoPH1XwFDtHQKg85NLdnRx1x7eSuOihylRIfBzqPMOw106FXyHWEviZwYAQfuHd0NvLEOosR0Fht92M1o64Cpyb55N1/MfJvPWXRj75go27/ETnNnNzHhhOcWTFu5UHGf84l6az1m243fJxnFGT/hXjHLIzcmSO3YuY/v/EHPnGqjF+GcdQOvGcxFZj+SpfrwTFtL4xn2U97wE2VOiad1n8E7a8zX70lpj734RecJrZ9eTIMBaSOqQOSfNaOgrHkCeui+iJY/56A2pKM0Xd+4HD2DKdbh/LeKb70ifj9XRR34Xs98/w/Q2ZN93UJee/JpmPLum74/GNNbCR6+BOMQKB7GoG/H2/f7i/ib5jzMZ5Cf5u8NzBJefmGPd+QVK0vLIyzFZZTl4roPnSgwQa8tX7w7pvqBMEhqOPSDP7WcUmVWEYOLCOeS5NIzlgL5+3rp+E8+3NHHzGxeycU4bncoSOel7YSxblEcNxcJZivGCC5EmrxOSBF4plSg7DoeM9pF4LqN+htBT1AKLG2um9Pi4xtA+NIYTJ7y06yw2tHfg5BR+LQRrUNagSR3l8nGqIT9aKIAx1PPZtAYqBSpJUptbKZDWkKs2SJTYkbqPPI+m8cqOcbwgk6EwUibIZYg9B2vTxkIrQJh0nt+NEkqjYZrutxbtK+REE56WAi0Fka/wtaZ5qMbQlCKJlBgliABPQ5iRWCkotvtEm2tEYxGtR3ZT21SjOLvA5p+/ggk0cz++gLEHt+P6AmvAxSCFxXUsdS9L10mzqT3Yh2M1zokL8GcVGfnRavAcgrWjmFAz9Zwl9J19PwkOSEH3V/YhqYT0H38z1YN+iMAw2jkN/yP7U756NWK8RmPU0HTkNKorR3EKkvjXLxC7Dj5JmnIPEyLjMm3l+yl+6SAa92xk8+JrCFb00bPivbR97SBkfufNYtGLI4SP91N4725Ybahc8jjb9/wxdrRO87cOJXl6G+Etq1FRiGkp0vzgGRS+dxzCc2hc+gjeYbOp7H05yYpNuFPz5L7/dsRO9pV89nYwFvdnr+2O119O+w+cA2bgLOjA1iP0j/6A+uRh2C2jsGoT4vg9di4nO4H9x19Acw6OX4r+/C2YjnOwz21F3nsuzkOfQXaW/vxFr1rMrh+Ao74Otz0B134Ec+x+yEV/H17v/xtMBvlJ/m6Z0+HS++kSi3OW6UW4b21EVw4OnaewUhIbiDWMx5avP65ZNWh5+PMtXHJchjZr6KjU2GNohD9M6eLyxfO5Y8ZUtpQFfXXBcM6lxWhmFSyBUlhrSQTc/zJ0N0mm6IhpYxVUoumoN1DWcsfUmciMoqdaRSaGgWyGUceFNQN4QYRpzpJJIhqOQyIE9boldhVN9QbNrWnXvQWsFWSDEGks62f1MFgsTMjPWpqrtdRQRglkolGvCts4imwjQBjD0JR2VJKOpOXqAVYImrePIqwlKGTTVbxSKG3SOr2FKKvQEpzEkIQaYSDIOrhYsvU0je9WE7L1mJbxBgPTStRzqZZ+TgnqRYdibEn6G1hHIqoxu3xzb2p9DZp2b2Xthc/SfnAXm7+1eodIzw7xGxsgij46skRPD6DiGGdagcHbt9L2lqmUt2m63zmd8gPbaDpsKv7sImM3vgRYmt4yg+r1z7O96zuo+9cSNZeoUKLRUOR3KaKaPUx/laBsUR5YBO2nzyd6dAsySjBKIRshupCj9R/3BinpP+Zmhs+9n44rjqD71rfjzm35d8/D8Ut6KZ21B8kLw2zf71oat71I7sR5uIs6qC6/FceG6Q3NB/elbe05uPulzWfxY5sIr12JfnwTuSuOJ/uJAxGOQB2xc9MY/b2HELtPRWVfewOQ3LiSGJ/spybEb372GPLAOchdOknO+2Wqm/CDU/7i8Rtj4PrHsMcswXR+Cvud3yG+egJO30XIQ+bv9DXWWnihH+57Fvb5LBSycNRSePeBqTHNwr+sdz/Jf47JID/J3zUz2xW//FgJO6b5xalZOgvwwEsxh8xRHLvQITJQTBKGfY/vPRwy/8IKHUnMR9e+xOmvbEI7ihEp0SoVNbVZQWRhIICxZo/RsmZZSdPuWRpS4WnDhu0JT+aKjPoeXbU6EpjSCJjdBBtkhnXNJZrrAW/I1CiMVXmuswuaM0RZj43tbRx6bEu6GheCUChqGR8z3CDbmc54RxOytTM3bMUquSNFGrsOXhCBSIOVEyXYoo/SFj0xA+9GEX4QEuRy6cVda/K1IB03AMJ8liDrw0TK3os0TYMB2pOpZ3yzQBhDoRLtULgT1qISg5NYallJfrhB03CdoamlVOluPCbKOMx9+3TMaISONNm5RbJTs4QavI4MQV+d3b62F/1Xv4iSFhMa3D8Rv4nndTL1rPmM/OwFPBuTX747UV+d6r+sJsTF1CJERjHt3D3o+8g9RFoBglwmIjzzJnKnLsH75tGEowZbzFB801TKP3wax2piP4O/S5HRX29CCU34g8cxE0Y43gkLoegTJQplNVvf8HNyR8xi+jOnk/uT+vrO0MMNxi5bSfWGNYhGxOBRN1A4exmlf9yH6Ker4OnNOLqB7myj6dfvpfi94xA5D2st9a/dQ/mQH+PsOYXSM59EhDHhp36N+8mD/6wcoO9dS2PB16AR4930R6mRJAiov+ly4k0NcBXOgdPR168g+frvYPkBxO/8IfbGXth92s5X4kBy92rM7M9ggwT+ZQXijXORo5ehPvuXU/t2wxC853KoBYj7V8Nn3w4rN2LPeQv6zjXoW59F7Dbl3/3fTfIf53UX5Ht7eycfTz7+Tz0e2/wUS6YrCq7gB298kbMO8Hi6L+FNbZu56X1ZtuQyLBouk3EE793L4/MrAlxX8IZTpkFTngO6BHUEC1rrhBF8+V0FIhf6q7DbLj7rxgwHz1LsGjWoOIolTekY2sZikYwv6YkCPKMpjdXJAi02pJz12bYlZtHGrbQ0AuKGIZOEFDOC8vaImQs0iavwEk3geXT0+OSStEvftRYtBNp3mbZtgMjzCB1FrlpHT2jPu4nGKEkUpGo0bhClY3ZC0FqvkDhO2iEPaCnxwxhhLV49IMilK0GpDVakjXhGCrSSYNNLSug5SEeCYaIj3+7IAFgBxWqY3lw0ewid/m7bLZvAQLYnj9OT46kbHibKurQtTUfbBq9Zg40t1k2DmDNhiSeyDo2+gH69HeEphIVNsxvE2+pE5QTlGvRohNWWDef/jtqPnsIiEDNcMsumghT0D44w+tHfEyuPyLWI1f0wWKXWoQmHAuK1oyirKTmNVLcAi57eSryyj9EXA3K7txHct5GR6/ai+VP7IDy10/PNGstTV/ye7Sfdxqa5P6L/9mfJ7dNJ9NAmtv90H8xj6xk/9npcE5DduwP3vMOpzi/gHZrqyvc+soLaqTcQXPwI4dQc/v5Tqc/7BiNfuA3342/EXb4fvb296GqD4KRrqfrnEB5+Bba/zPaP7InatYvoB39gNHMu5eyXqT/Yh/EV2bfOIO75HNUv34KoBdjjr8T86knEAXNw7vrkaz7Lqnv+QHLKj0i8M+GI78KmUdh7JmtufDfq1o8jc/6ffXabaOzFd9CYdjZ29qexD66lurANntqKue0ptu/SQ7D8JuLP/4a+Y2egTtz9b+b68H/l8V9C2InU1+uI190HmuR/niMuHOWik4vsPsPh2T7Nod+v0NKkePacPHO/NMZx67Yx/W3d3LDNwXMsb+rdwF6ZiLtmz+LlOrxSt4QWLJJsk+Cjb8zyg9/WKHqwuBKgulzeOl/yvQcS5k93eGVzTCGKscA+9QqDrodfj3i5tZnp1QrjbQU6t1WYHZehr8yWGd3scWCJkQ0NHit7nPaOJv7t5wOUKnXGclnawgauMeTnFBl9qUIoJVNGxsiUawzMmkLZ8enp2065p5WOl7cR+x6JkjQPl0k8BxVryq0l/CBExQn907poqtbIVGu4YZpmr+U9jCMJ8znyoxVK4yG1vIsfaQRp7V1ZkwZ8ISmGMSQWYyzGTTv1hLE4scExMNyRQ2YVnS+PM9TuUxyLKLmK7LQcI6Mhi0+dzsp/2cTxL7+Du7tuIJeVJGWDrccIoORENBJF50GtDK+uM+fzi9n2uUfJ2hA9tZnRIYEThZj2InMv2ZfB0+7AjSKq+RKmpulavivdlx9Mf/6byDhhuNCFh04NblxD/vAewmcHGV3TwMlIWk9fQPWHT+KbCJNx0Y5LQIbsnAL+vGY6r3srMufu9PxKNpcpX/sslWufQzb5lM7YnexRsxg9/XZkk09+zxZqlz6GqSVkvJD8L9+Hc+wSTDlgeMZFtK39JDiCyjHXkDw/jPAlrohx378Md/l+qImVb/yzFcSf+w1sHQcpEPvNxPvJqZiiR3jYlSQvjJDgIoXBm9+E62kYqiJcCZtH0+7OjiLyc0cjP3Hoaxrlkp8+AufdBANlQEApA585Gnne0X+xXm9Xrsd+9hdw31pQIOZ3pbawtRC9z0KS7QFmzQDOKXvjLD8AucfO7XMn+Q+xU/H+/zVZ20km+Vumf8zQ3Zxe0JZMVcxtl8TAVU8knHFojt8PFEjuGqJtv272meHwy23dTH9sNUvf7NJRsRQ2RdxbUeSAhe2KoZpBFSXlcUMjNoxWBUmTT0sS8GS/YqrRxEoSCcmo61B2XbqJcBPNXvM9bhmUdFnLJifPQr+M1ZoN2zTFxDA7k7DioTLGVdQdByfRjLo+XY06NtBEjpP6yzuKKJehtW+Y0bkzqOeymEqEnTCVMUqReE5q49qIccMYK1M9+lwjwAJhLktG14g9hUg0QqTpeCyEWQcvMGhPEmR9SmN1jLC4WhBnFaqaEBYcvNCiNcQO+LGl3OzRMhaRqcWUsy6JErihJs46ZKbmaLxYpvXt0+n7zWaK03O8fNwdZLOSuJihOMun/NggAoPQBhdLbTihsKyd2sPbkFGMFZbm0xYxeuFzaC1oPmIaI+//DSo2hHOmMO0f9mDzxx4it6ydvvk/JooVBQKKS5qIHu3D92IcpajdtZHxUQVIpj3wTgb3vw7XxsS+jw4gac2TKUoKR82i9ZtvQsjXXmNtmFC7bR3lq59NG+tOWsCUm4/H26uL+LkBhg76KW4W1HNj1FZlsfWE/BTI3f8p5Pw0aMtSBu/EhVTPvQN9yzPoqsaZ3UTuwqNwj1+M8Bz01jEah1+OffBlSAx0FnAuewfex99E8A+3UF18EUmcjio6TT65ZR2oJzYgVAQvD2NrEbgKccxi5I9ORXU37/gMZv0gZvm1cP+LE/OTAg5biLzqA8jZf+4BD2BrIfzTrdhrH4LBKvQ0IfbuQazpw3S3kWSLJH/YgBzTOB89GHXi7ojMzm+OJvmv87pL108yyX+WILZUA0tb4Y8X6eX7+bT48E/3RrxvL5cnW0t4QcLRTsDPn4zZdXaGinSYLQJsaKhqyQyriYC8gn9ZGfGJw3IIBWt9n72mSm58oEHOE7TECXXPZcR1mVOp8XymQJxx0J6iKQzZZbc8OrZYJ51Nr+4zg/bBUYbW1znklG5aTczzA6AUhL6LpzVGKbSxOFhiz8UxhuFiEe0o3CimrVFloK2F5rFUtx5rkdoQZTyylQAtBZlqqm9vpCBfrhF6qRStNelcvNLpa7xGiPEUsSMpVV61jzW42qY+98ZONOVZ4oyaGL1L5+6lJdXEt5CpRSSOAm3xAkOcd7DGkl/QxNwz51PdUkNuqZCZ30z3+XsSbalTOiBVvlMYnFYfT2oamxsU9+mgcs9mXKtR04ts/d4aOt45i9hIGtc/h44hXjSNBU+8k6QcYY1l7JN3EWyoUsk1E/p53EdfIked3JGzCFpbGR91KBzWg3RgaL+f4dgEeeBMdJjGO08mtH5+f9q+dchrAny0eoihT93LhulXMv79Jym+dzdmbvkIHd8/EsezlN91AwN7/Bi/RVL87IHoQgE7VKewR578s5/ZEeDtSI3o8oewv19NcN3TJCHkv3U0za98Bu9dexJ/6x7qrZ8h7PkS9qFXkEcvxB/+Z9x/O4vwG/cyKs6jeskTGCPx924nP0uSbRc4z29FVBqwuh86izg3n4kXXYF7+9mo7mZMkpB8/XaS0tmYOefDfS9CZwmu+yCO/jHOPZ/eaYC3v30as9+XsaWzsFfcjZjejJheQhQzJDOmEczZhXB1GZb0kHn802Tu/hjOyXtPBvj/YSZX8pP83bNtzNDVJJF/cqE+aanHebc3OGaxz1VPJOzarXi0UkI8MMzBR02jrSh5vq2JmauGWJ20s/y4AjfeOMrmTJZHX0744gl5bnsuYloTbBmWPLkhpiQg1+bSNRCw1qZz6E1BgMznGE0k05s9ikMBD946wK5z2ymXFc0KNvdrOqQkF8a8NGho7vBYUo7ZUgapJA5p8K27Lk1BghQOoePgmNTcJshnae4fYWxGlnIhTzaKyFUbuEKQOAqjJI2MR7HSQCWGxPfxgpDEdRFhRC2fpThWS8fqLDua/hLXwW/oVD0vjImVmEjVp0Y9jbxLbAVZ0nE7aS1aCdxanKbtDTixpl7yKIyGjAuIxyJaj56GVw2IhKJrnw5mXH4QtQ1V1n+6l3gwFZoXWHLL2gnu3Uilogmf2oYZDxECgsGYBQ+cwOjFTyCtQXgONeOy5Na34DT5VH63EYElqWukK2iPRzBpwYEg20T1kVGikYSeqw5j5JKVFJMq1nfRzUUavSMopXB0ROfPjyN3xCwgdYqr3vgC5aufIdlcofiBxfQ8ciruvBZsOSC6fhXRVY8TrCsThg6tPz0Ob+9uRvb9ISKOaTp+Ot71p4GnSO5+kfjqFSR3rEEs7EaPRiAF+W+9Be+Q6TSWXoh9emtq8zurFffqk+G4xUTvuJZqxwUkxgEsblcOf9cS6pnNiFoF+sexYYLIucjlb0Be+h5k7o+d9qZ3Q7pqf2ZrusFVcOr+yMtORv4Fpze7fQw+dxP2pl6ohTCnDbFXD6wbwEztIOmahn54A2o3F/cbxyGPWPAam9xJ/ueZDPKT/N3zp6n6VyllBCcucZnWBD94IuIbR7p8uC/PobUKi7ZXuOTlPCfOKbDmuQHa9+tk2UyXGxzFopLllbLg4NmKqx6zHNYu+M2QZiMO+yQRawKHLhRTw4g+z2OglGNOVOeZfImOeTkGBhoMh4I2xzDgOTSHhkwQMTSrk+xwjd/dNsI/fWEaP/nKy4zLHK3WUMllcIKYyHEY296gZ1GW9RvAbzSoFHKUKjW8ekL76Bh97W1M39qPozURLvFEyl5NaNM7QYjJZ9FS4ESpP712HVwFDQQYJmblU/17aS3aE7ihpZ5zEUISTzjZNPIuuVqIFQJhQUiBsZCJTDpCpSR+PaaRdylVY1RiqVdilLSsP/luwmyeaGLcK9uTau6X/9CfyukiEJFGagNYgqeHsK6CJKbrvKVUb1xD9PNniekgd9wMyg/04c8qMnbp40T3bySDISNjaC8SmyzZmXmi8YBgbQMdaeY++i5GvvQH/Oc2Ezk+uT3bGHt8nMwebdintoIQ+G+YSuPhLVSufpbaLS+SPWQGLV84gNzRc0AJ9B82UPvaXcS3rsY5bC7x3KnEQ5Ku37wbs36Ekd2vQDqG0nnLUB86iOhb9xJf+wSiKYPzwX2R01sIf7QSWvL4bT7Bp28HXYOsi1p+AM4V78Dctpr6ab8gKd+AQeF4Dpn9ulBrtiJbSGVhxxtQbiB2n4a68lTU/nN2nOemGmA+/Qv4ySMQxoCAXTrhyvfhHLZwp98Xay1c+wD227+FtQPQkkUs7Ern3duKJDOmkYx58HINZ/kSvJ+8F9FR3Ol7TfI/z2SQn+Tvnv5x/WdBHtKU/Rm/qHH2/j4PrDdIJVgzq4V5K0c45e0lyuMtFB/bzJQSrFkfs2yxzwubYl7C4ZQfl7nyAyW+fPEgCztdVg7BFitZsKvL8OMhuzcl9DU8ym15CoNlMlrz6FrNLFfh5iTlZ0apdbXixQEm55JEllxOIusJ69ZU2WVpEflKyPphaAhFT9KgkknV7LxGDCJdUVuVpsDDfJbSWIWxYoFKoUCx1khTzokmyPmUhisTjXMWaQxhNoMXRhOiOZaynyFXbRA5EifRhPksuXKNIOuAFiSSiaAPsavINWIaOUWuoak2+XihRkzI4iptCV2Fby1OlFBvymCKLn5D07BQ/tU6mt42C/HgCMOPDhBsb5AMhwhfIjaMkwrZSuK1w2ma3EAwbvASg2zLUPv1OpKnt1FVeYxVUHBpmpNh28IfoNcOYWhCCEkyowMZxhQO7sZ/+wIGT74LkEz//BK2n3wb3oYBaiKHn4Hxp6soaVFJgswLtJZsWXAVIutSXL4709csx5lSwGyrEF70INE1T4AUeMv3IXPBEYydfz/JhnG6HjuN4LonqZ57J56XkP/QUpLe7YTf/y7ue/Yke/MHEIumUD/9JsLfvIATBTjjw9g+QShLuPd8DLHXVMI3/5CG/3kSHCQWZ1YJp02gNo0g+oZhrAZDFWjOIb94DPJLx7ymOS65bRWc/XPYMpZuyHlw7tHIr52I9P5CE93afjj/Ruwdz4E2iF07YXEXDFTRPVPQ+Xb0k1tRi/N4170Pud+snar7TfK/y2SQn+Tvnv4xw5Rm9Wfb3zA73XbQTMVVTyTMb5f8fsBnWbuLeWqEX/hNzMsoXlhXx8s6nHp4nn/87hD5osP6cXCsodMaSlM9nOGQPsfhS3u6fHOlZIv06Y4iNkmfmdbQnsRs8TPs0hIhBhpgDJEVuL6gud1jYH2D7cqnPQy46V8G+Mp35rH23BfRwidrDZHn4GlDrBR9GxvIfJ5EKTytqWcyFMJ0Rd0+NMrGnm46hkfTBjopCTw39Ze3kIlihDZIF6TWNPwsuUZAlHVpGq2mkrTGkngO2lVUCh5Wps14yoARCfXmAoXqKEobpLbp2B7pTYABXA3GpCI8RaMZ9xzq1uI3EuoFl55L92fLpU/TNK9Iyx5tbLj+ZUrtGTKeJQqcNNWOQveVkc0ZRFWgGwalLHa0QTxap97aSqZehQD86x5FYoliQyXfRlyTeKqBqgY0nbmExHHZcPJdOK0Zss2W4Kv34uFij5xP9Ps+TCTIzCui1wyhWlzM6gTRnCN7xCzar3oLaENyx1qqVz+BfmA97tsXkbv2XagDZmKG6gydcDOqp0jHvadSOfs3BNeuwncD3IwieXYQ94z9yP7yNETOI35xgHr3BcixGhk0ojmL+txbcL5wJPGSS6gfdRU6kVgEKu+R27cLtWo9Ip+Fl0ax5SC1ej1oF+Q170P9Se3cbBvDnHkd/PYZ0BPdl/vORl79AeTinp1+N2ycwLf/DfuDe2HLOHQXEXtOgzVbsV0tJC0tJIObkNtCnOX74912FqLg/zd/Qyf5rzAZ5Cf5u6d/zDCz7c+DvBCCD+7r8/NVERcc4fHt+1L1N3VgO+O39nHmu5oZfKWEHmnQuzbDV5c3kRXQloFGBCdfXeXg2HDres1BLYIVw/CVXzaY2uGwcTDhsE741ThscjL4AnJa81Li8sYey8iWBoV6SPPuzQytGCHX6lEet5SkYEsmz/N39LPv0e3Ufj/KWKJoNGcpDlWJHQXW4mCI3LQBL8762CAgyvoUyjWaxyuMNRVoGy0T5lyUhdh3yVQDYpV6xPuNiFoxS+w6mLoFpdAT/vFWpDPyRirqJRftpjr41qTjc1YIwqyT1uVzLtLoVFVPih0iOkHOoRhqnCjNHMSuIN8wjHYoymvLjK+r0H7mDGadNIdHT3mQ7pLE9wwxAhdDjCWWLqKiyS9ppvbUKD4RoNFTmpgyW1J9tI6bb2GwViRPg6RUILe0ncYDg3hoWi88jPJvNjB8yyYKh/eQ6cnR+OkzGBzkbm1U79uCEhJXGcyGUfAU2SUdhFvHcffvIX5+kOBzvyP66UrkzBa8M/Yhf91JiGIa5OIXhhg69hdk37OQwqf2ZWTxZejgTMaFAAAgAElEQVRXxsiJKt7p++OeexhyXhqE4x88RPTF38JwDYnETm/Df/Cj2FgTHHUl9a/ci8bFIvAWt+ImdahHiHX9UA7SJrqpTajvvhNn+Rt3nMPGGMyV98MXfw0jVUBASw4ueBvy7MNeMyL3p9iHXsB+4WZ4+GXwZDr6llFgLHrGVBLRhFk9gvP+BWS+djxy4aR4zd8qkx0Qk/zds7Oa/Ku8f5nHLc/GvGORA1LiCPjRy5IZ83PUHxhkXanIHtUy1diyaUCzaBcPUdVIoK8OmSbFeYdnaYwluMLQX7Pst8DFNZY9DypR0gmb8jmaS5KsNgx5Hm0zPLQB6cDqTQmRUCxc6KFEOiHVTcSdvxxg6cFN+Em6rzDQqbiMUrjaoCOd6sonSaqM57kTTnYupfEKI01NqERjAC+OCTIuCJDGpJ7xgJNohLHgpKv3SnN+h3udCiOirIdWabo8cRRaCRxtydQajLanCmm1gkuurtPHGQcvmrCrxRK4Eh0b3DAh8l2UsSht6b9jC4FUtB/URdPiFopFGH9sgPwRs9J0Pwa/JAmMQjT7tB/TnY7UYfEJaZ3p4CzpItlzJrIREeDRyBRoPngK0crtCCyl0xYx+N2nGL5lEx3n7EHr6QsIf/oUjtDES6dTf75CYiRYQ2ZxG+3fO4LMvt14uzZDPYIV6wlXbMU2Ygp3f4jio2fjL993R4AP7t/IwJuuo/CeXXHXb2Wk45uY9WMU5iryfV/B/+F7sAIab7iYuvok0UdvQo9EBJkS7jXvwz1iDrV5F1Le9btE6xvI1izZN7WjUah6FbFpGDaNwEAF8a69cIa/g7f1wh0B3qzpJzng6xjnzDQtP16HY/dAbv0OzshlOB9/858FeDtew55zHabtI9g3fRM2DSP2no5wBGZqB/Fuu9IY9Ulq4Jz7ZrKbL8D79gmTAf5vnL/6Sn7ZsmWzgCeBp4AccENvb+8ly5YtWw/c09vbe8bE370f+Ckwu7e3d8Nf6XAneR3y7wX5KSXJofMcfvlMzCXH+bzt6hrbqrDvezv51dc28IbD27HPhdSBa+8P2GO+z2gScv1W6JCGuxsO3z3A494bNQcfmOe+VSE/XZUwx1pueN7QiiGwkhGrsMIyo1bnl6sd9nAEXTnBy1XBrFaHlx8ZpdRaRIeCKU2S9Y0SD13+Evsf18Udvx6l4nhUsj4tSqPqmiibRQHJhJ59mM3gJbV0NT9epX14NF3pa03oulgg8RycIEIkGuM75MZr1Ao5jBB4UUSU8/CCENcVEMaUSwVUPcABhP7j/0waM7FiT1XwnNgSuJBtpCv3KCNxY0u56OKFmlwYU5tosPMizei6MsZTtC1tQ48GtL64jT7rU3ukHwCFhXpIKF3ckXH453vI04QREt3RQudjy+l/162ETw+CzSIQ5OYWSXr70pY9VzB0wyvENUPPNYeTrB5k/L23gpDorhLhk6M4SHK6SpLLMeXWE6he/Qyif4z6+XdipYt/xn6Et29Avnsv1G6v1VmvXP4445+9j0KrwV6/gtq2GOEISm+bjvrZ+4gvuBN95cPpCtx3sHvPJFwzhrEaXxkaH/xXNA7KkWT270RtHkLmgbX9lKjAK8CunTiXvQd11KId+zVRgvniLfC9e9MbEQRMb4FLT8Y5ca+dnt/WWvjlE9iv/Trtqi/6aa29bwSacyQze0iqGVhTxlm+G5kr3oPs+fe1+Cf52+JvZSW/sre391DgQOAjy5YtywMamLls2bJXCzzvAFb+tQ5wktcv/16QB1i+n8fVK0LeMt+hoyDJuYJvPG7Z/Q1NbHt0HONJ2it1frsyYP5cDycwSAE9rmWLcrjgl1VaCpKHNhuyLtQiaLiCl/piWv20Nv1KlI49TfE1VcchavLID9UJXUWlqmmZV2RmhyBSiuqmBpWWPBsfH2aXeR7KGPJxTCglBAmJUvg27ZYPPJeWcgWpDaHvoZUkzvoUqjXquSwYS+S5aQNe1ptonJuYozeWTD0gdt20fg8YKbGhwYkNMtGgHIR91WNeTYzTaTL1gEopl2YGknRGvlCNCXIKI9PmO2zaidfkCiLPSRsBA02YUUhX4ndk6Dv993gHT0dgCbfWAUOGkFa/RmIEOdug7uTTRrxsBmdOK+M/WkVw8xoCPKzn4GYEjQ1VcjOy2OktiFgTB4a5K95F9SfPEF70BxLHJbAu4WBCdp8uVJtLloBsvUz9mGtoXPwwqiuH89aF0Jwjc9LuZA6ZQfDgZgBsoolvX83Qgkspf/JOmo6YgvuxAwm2hkihKZ48B/P8AFH+PPS37kFMKeLd+RHspw4nXtmHrNYRNUNcNqhpBXJvbCFXiHCHx5AD4/DiAFQjxAcOoNw2A/eZL+0I8Mn9a0jmfw7jfxi+dWdabz/jYGTlezibvr3TAG83DWFP/T62cCb2pO8jggixdBrCATOtk2jJbjTWJxjXx7v8nWTWfRH380dNBvj/g/zVV/L/L3KAB7xaIP0t8NZly5b9AYiBsb/WgU3y+iTWlpGaobP0l4P80QtczrqpzupthuX7ulx4f8TdLyX86xe6ePZDL+FOKyISjRtq7uqz9G9PWNDjsX2rZq8OuOrxiH+c7xHmFKJb0ftUgw2Oy1LPUkkkRgq6q3VGMxkqdcEuUYUnCwX2F+MUhWE4hq5EIl4eJfYK5KoNpjRL+jtbuO/rz9MybyrJlpDt2QztjQDhKloKsL0GzsRoXOQ6GCXTBjnXwQ8idBSlojRRjFapTkDiOiitQYB2FcWRMttmdpP4HiLRhPkMucFxVARuFCOFQAuwjsQxCYkEZUAlmthLbxQaeQevnpC4ksSV6UrfgKMtWoI3HiMzGaKMQsaGhiNpKjmMXvok8cYy46OQKUC2XKObGgqDqSsklgFaye3ajPviMGEAdqDCyFl3kiBJilmcMMGXCaHyyZ2zH8Ep9+Ng6LnoDfQdeiPZepWwuYRywQ4a8nu3I8t1ikubGbu7QV4EZC86luCW9Xi7tpL8ejV2LED1FMkcPIPKZU8QVkeJrn2CeuBjm/N0vXQ24a+ep3re78jIANckmJ+tgoKP+sTBON89keTHj1I75hq0lhhcnAxk9u/GeWYjogl4vh87Vk9H3/aegbzqvajdU/c557BrCH7+NO59q+DGJ1KrRAQsmoq8+jTkfnN2eh5breH792AvuRPWD0N7DrGkG17sx3Y0oad0kQw5sKmRNtHdcDqiJfff/ZWb5H+Zv5WV/N7Lli17COgHLuvt7S1PbL8ReM/Ezy/+Wgc3yeuXgbKhrSBx1F8e9XGU4LR9fa5eEfLevTx8mVqcXtmbcOgJbWyvKpYmNQak5OJ7Q2bNcDlmjqAsJV9/R46akDwxbPnu8TnuX5+QN4YEwfYxTZRXeMbShKEmJXnH0hmFSCyVok+bjhlrL7B1Y8gB75xC1hdpV/SGcbZM68T2V+hsTg1i2oOAsutSKCrCkZD28jiR61Iu5FE2TaNrR2GVpFHMk6sHeFEE1hL4Hoa0Ac9Nkh3pezcxCGMwjsJphGg3rc/nawkqikk8h1ouCwhEAmKizuskFi+MiTyHatFHGYt2JU5kEEIiADc2BFmHJND4jZh6s0+cTQ1mbKgZ/OpjJJvHKY0O0VPZQoaYEUoM00RiHRSWhvRJNlXwsoLECKJXxqnliljfwzY0NjZ0nDAdEySsP+UuACSGoXPuIVuvIo5ZgGM1QVXioJHPbaXkVjHT2tBLesBadGTQW6s40wokG8tgIfnNc9jv3kX44CaSbVVqHd2oI+bT+dyHqX7wJqLzfk2BMq6NEHv24D97Pt76LxPfs46Kcz6Vj/wbWktUXpJbnCXbYnA3bEOM1+H5PpAC9a0TceIrcB//7I4An/x8Bd6qNTQ+eCNctwIyLlxwPDK+Eue5r+40wNunN2Lf8m1s9kPYT9+IyLuIhZ0I30FP7yZcspjg+Sq2swn/ljPIrjoP9+yDJwP864S/lSC/sre39yDgYODIVzf29vb2AwXgJOD2v9KxTfI65v8rVf8qH9zX4/qVEbNaBRlHICVc/FDEW9/VgetLmsYC+lyH3fyEAalwBmM8Y/nxAyFLHM1dQwJr4YxlLoEjyBpLn+Ny/AFZfG2IW7NMCUKeVjmstsw3AU+RI98IqSepb8j2cfDjGKfg0lSP0Abi3bsI7t6IcCSZOGEklyEYT1CxBikxUtJwXRxpsRa04xC6DlLwxyY6rVFG4xhDmHEBQawECIERkKs0MEKAShXvak05srUYlWiijIvfiABL4ipUosFalLETHfiCxJNEvkPkKxQTo3RK4EWG2JNoCflaRL3g4WDx4oTMtmGyYyPkvZhyVTG89yK20YKDwcVQdgr4RBjPwUQaWQmRGEZVkeycIhgwOnW9i14YJhc1sEIifUmBBlki3A8uJbx7A0FD4jbqqIxkyv2nUHr6HOK2ZnK7tRK2t1JefivJlgqi2iDZMIoII5KfrcT/xBtRs1sY/d02/DfNIDe8hVruPNwHn8cVEe5nDidnLkMetivVvS5hvONrhKvHsQJ80SDn1cnOzOBsGIb+cdgyhjhyN9SWb+ANXoRz7lFIKTGbhkmOvIhEfQhO/TFeeQztZLAPfAanfAXOl972ZwYxthFiv3ATpvvj2KVfxj63BbFXDzIjsVNaiXedSyMskAwnOGceSHbLV/GueDdyr+n//V+ySf6q/K0EeQB6e3tXAf3Lli37UzPiK4Bbent7G3+lw5rkdcx/NMjPbVcsnqK4fXXCIfMcDpkt2VaF57cb3r58CqNelsNknQ2jloeGBS+9HNHkWP7wckJPPcZIwUk/LvOWLsu4p5gqDQnwr49HZKyhL5bMqtdoKEW5o8B4a45SkjCqXCIkutljxZ0j7HtYC0GSpsdL43XWz+qmUG2gE0PoOLQ2AnSc+qzHHUUQgsh109Enpcg00hq7kYJqUyEdfbMQOR6x62KVJPEdvDjtrI98l2y9QaIUUTaDimMa+UwqkiMFUhuySUwi0hsK7SoSJXd4zYsJjXwLhO5EFc5YEpEK5xggdiW5ckSUUSwY28rMyhBl3yd+5170Rc2MOU2YyFIgwCKJfZ9G3sMnwWrIRxXAYpDguZiXRnGUIXEc/LhBZdUozrxmmNmCFzZw0DiLWilfswatXFwfih9Zin/ILNx9piOEoP7EAG7JIXf0bPT2OtGqbcSfvQ0hBc4BM8jdeRa6vRm7aRRvcAjvst+S3P0KMR5iyRS8e88mvO5JRsV5VC58DGMk3rwiWVHBtzW8JomMY3i+H1rzODcux4u/j/vbj6OmtWCMIbnwtyRNH8PMPA/uWgNtBbj2NFTyQzJn7kt47+Y/O0/t75/F7P8VbOEs7CV3IqaWEDObEXkPPaOHYJddCVdXYLdpZB79BzL3fhzn1H0QWe/P3muS1wd/U0F+gouB81990tvb+9ve3t7v/BWPZ5LXMf/RIA9wxv4eV60IedMch2klgZJw1q8a7H9IM15GsudIhY04vHmxS3ksYV6nwnMFjis4/yCXJ7YZHnw24qyFkkpGUTSGdWPQlhEERuAkmgXjZVa5eQo9GRb6MeszOYok1LSgplzqNU1NKDwJbfUGL2zWzD5pDt3bhzCOohhFeEEIniIuRzR3pKN/gVIomdbKpbEkUmGlRCuFF6YmM5HroBJDmPFwoxhrLbHnkQkiYs9NHchijZWCSlOa3hfaoD0XrVR6Y+EqjEjT9U6sydRTj/uh7hLWTf/PwpKa2gDFsMGMxhBL6htQWAZzTWzNtDKSzbP5zmF6vnUAxW6H+JnB1DkPSaZgSQKLdCUiTgjxSByXvG+IGwYbxmil8KMAF0PPT46gsEcrbBhBYQhxKK8NcJZ0ovKKKbeciLfnFJyeVJ/dxAmN3u249z1D5uZH0D0tWAOZX52O7Mij2jKUZ32N6PDLyCVjJMKl7jUTqhzeNI949QiVQ68l6gtQnVlyB3eSc2uodX0om6AwiDBGfmB/nMoleBv/GfWefdJ9r9pAsvQCjDoTzv9V2iX/7n2QgxfjDFyMc9obkVKSOWNvgmtXYbXBDpaxZ12Naf4w9uiLYKj8mtG3aNF8GtslOpG4F7yVzMav4H39WOTcnbvITfL64q/eeDcxDvfmP3n+LGnafmd/++adbZ9kkv+/9I/tXNJ2Z7x9iccnbmlwzsGCKx7WnLLU4fqVCUliOOSwEr+7s8Iu2ZDedYY5wPQ2waMDhhEteP8bc1z6yDiXrDHce3qOp8KE2jM1XhGCzVLhWct41mORCFmfaKa2OfT6ObpGA6qOw9ROH7Ux5rm7h2iZWSLZGJBpz9AURqwstNNR28j2pB03iBhrKpDRBg9DJqcQxNT8DNlqlcRxyJFQzfokFtwkIVuuka83GG5uItcI0NLBTARtxxqMABmnafi4kMUPYoamlnAbAVJrYs8lW6lhpMQoifEUIkyIPYVfi2nkHRIH/MCgpcDVmo64Sld9HLes6Ss08ZLqhsgwUCjhNDQIQSPrUf7Zapo2bmEbrWgk2SYJ5Ro5neCYEA+PAI9mP0HVGhh8tFQkoSRDTNNJ8yh/9m5kf5mEVmIc8lKR338KdssY0x44GW+3duoPPIwquYRfv4vqlb0onUPkMsjL30PHG2awebdrqJ98A6p/HHvbAEYkeCcsQhy1hMpHfk+OKgaXYKtCeQ6ZfbpQ6/qRLQLzxCsQxGmpYpdO1NXvQx20y47zytRDzGduhqsegmBCP35Oe6off8SinZ6Lzp7duCJAzzkPuXkImjOI+Z2wYRBaiySzJvTjX6qm+vFXn4roKv3XvzCT/J/jb3ElP8kk/2v0jRm6dyJpuzOynuCkpR6PbUwYqFq+fmSa4jzjVyHLjmwnb2L2q1Z5ZRyGfYfnNyYoY+mZ6fGDuxt878QMo1aycgwufVeBiiPpjhM2GYVrLFv8DFFN/z/snXeAXFd97z/nnFunb9+VVr1asiVZXtu427jKxsYgO/RHh4S8UBNCSIAUQgvPgRRICBAeBAjFNti4YEPccVsjuciWZPUurbZNvfWc98cdi57YMu3h+fyju6Nb5t45M79zfuX7Y/lUlWsfCDn2OJ8l3VC3LHbXAG0Y6ypAarByiqE+SU8Y8IN1AemMErlWi5293VhA4FiIRHNof4RBkEpJIiWJbSGCLJ6ujCayrKwBTZLQcl2arpsllrkWdhhhpGC6mMNvhUDmnreDhCDv4DQi7DAm9B1kqkmlxMhMcjVW2TONPIUTplhJgm0b5rQOsWp6B5WwwV6/m/XlOWwv9DJd9PFbEY2ch0RgJZo0aiHv2ErdKZIVGkJuWRdaGyo6ICbLsE+wMi11QDkQagsjJFV8wq9vwNo/TbJ4iCxjUeDN9FFJwvD9r8Je1EV87SME//5D0n+5C7NrEvOa08mvXUKUKyKqdVrn/wsWMXrHFCkW8Yx+/K1/RvzQXtI/+AZ5WqS4WHOK5E4qkSvF2AfGkeM1zMYDEMTEQ32ofR/F2fzXRwx8ctMjJHPfjc7/IfzTbSAEvP08ZOtTWFs/8nMNvNlyALP2k5jcG8nv3kY0lSJWDCFsiZ45kJW+PRmgC3mcf38F3hN/jv0n53YM/HOYjpHv8Jxm/5RmqPz0vwavP9nhCw/GnDZPcd8uzRnzFF9Zl1Ca5dMXNyk2QlbVGjxW8LHqKWVtcLssbn00YkmXokdr3nF9wNxuyfNO8ClrjYWhIQTGt4ljw5IhRTGKaQaGdfjMbjYZNxb9sxwKRYvW/hai6HBgY52hIReZpBxugBPFlJotJgo5CrbJkuWCBCHB0pq662IEiNRQkSEoxcFKmdhzUFHCQGOayWIBaQyhkwnlCK2xDDitkMRSWFFMo+yDgVpPnooPQhu0ZWGnKTJJcYOUIG+jEo1RguHJCZTWzJoYYyqf58HeeWwuzWDCySONwGBoFSyK1YBmziG1Jf21KsYWTJPHPnd+JicsDPqxAzhpTBMXQ5ZEF2KhTxwGR5CLmmgEuRVFSjTJ6wB5+bHEu+tIoZHC4Az5DHz6HJK/+z6NWX9N/Pd3ost5Cl9+Kd6//h6t/QG5x56kcN8P4V3fJJ0IsRZ0EQoXYwTu2CEa8z9KvDtr8pP25BC+wCukWJsOwuE6bD9M6rnUSwNEV5xJftv7sYbK6ENVkiv+mcR6I1z8D5lq3cgc5MMfwGp+GuvvX4b0fjI+buIE89Hr0bPfjln0HswPnkSsmoHMKxqNAuGs2QRWN/G+APWSE/B3/iXu51+BOm1+p0FMh46R7/Dc5sD004/JA6wetujJCQaLkju3JnzppS6Jhr/8fsS8lWVmzLRZUA/wjGZSCypxyqNjmlee7vFPtzR5zbCmHsPf3NDgIy8rIoCeOGHSUlSNJDXQtbTACWGd/3o85vkn55g9mCnS7WgKxHRMfTDPWNUgHIXZdJjh8Sk2zxjAXtKNqzWxEsRh1srV0wlIgWjH3E074z6RCjuOke0Me6MkuckGoefScmyEECSOjYoTvDBCpTGh4wACK04yvfmci6nGyDRF25mYjR0ltHLZBAEByhjyaYBKNE/0DPHo3LnUfTebGLQfu0xBpgZpNFoIhpoT9DabTHk+e8slGo9MYIzBMQmmFtJSLhKDTUqKwCAI79pDEFlIT9KyfKKHxuimivP6Ewhu3kYoHKQjEcaQb4wTrvkMQgpyd/whuTv/N6mWiPU7ac74CyqfuwFvwzYSbJxNf4F55cnktu4gZ+rYxJjYIEjIqxq5QUneNHBa9Uw/3rcRH3gBzaFhmlY33h+dRv4rV5J+6W6S3rejB94BV6+Dogf/50pk8hmsB9+HXPGzWe3mvi3o538oK337y28hun3Eom6EZ5EOzyA69hiUpYlqAveWP8S7711YbzwVUfKf9feiw+8OHSPf4TmL1oaD05qBZ7CSh2w1v30i5Y5tCbO7LOZU4ON3RPQuL7O8PyWXJDzv4BSbPRdfGbaMaV53lsf9uzQrFrmc1C/4yG0hBoFtQTE1FFJNYKBWcrl1S8pwAXqSmEe2xzwmPPrCkCe0h5KGgq9IDYQtjVttMGdhjprtEOVcAt9jzo79TDs2ji+RkSbVhlQILAmBk6neRYkg1wrIRxEN1yG1bTCGSr3GgZ5uBBC5NlaUkipJ4jhIrUlcG7/azNTtpKRhBCLVxK5NLghBwhnbN3HM2H4aBZdESDb2zQCdlc45UUyQd6kXHJ5aZDqJwWumBL6NF8bUPZ8gdkmlIPAU8b4akqd0cwX543qwSakpF5sEVyQEuHjzi3gVSW8ygUvCWN9Mpr+8Cd1fRLdS3LiBJMV+/cnkd70f96OXYhxF68xPUHliA/zV9Rht2GPPxt34F8SeR2PZ3yH+7W4MCpQkxEGQ4nkRyhFwYBqnVqXpVpAHP4b4ypupf3KUtJqQe89puHc8hHF+H970ZZhswEXHIXd/DGvyH7HeeeHP6sfXWph3fRnd9xbMqR+EbYcQJwwjHYF5Sj++6pHUNNY7zyF/3WuIx2PEso5+fIefT8fId3jOcrhuKPkCz35mLs2Xr3Z4cGfK9gnNRFPzVxe4xAl8J8oxtqFK3XPoiRMGTUKj5JBo2HRIs9BO+cEh+M83l0gM/P4Xp7EEWBiKSUJLSHZ1F5FRwvjBiIsHEh7bnXLhyT5dZUUqBPu1RakeoOIYJ4rpO22I/pwhlybs3xOALfHjhDRKyZWzXuNojUGQsyDOOaRKIaIUYUmkTmnlfFQcYyxF78EJUjurpTdSZm1kDag4yaRtBViJxgkiAMK8x8zJCSLPYcWB3ZSDJvfNns/6mXMQ2pBaKouEC5AGnFZAo5QjsSVGiEzKNtY4YUzLtcg1Qw6VSlRdF78V40UxxkhE+6dKSkjX789i9KlGILFMQqgcpDK4ByYRwD7VhzycGXV2T6Iti9ybRlAYwvmDRH99E82uPyWc/1fo+3ZSU2XcyY9g/vbFDOiDNBZ/FAJDmkqSgo8oW9hpHY8WeWrIIIaZFazvvAUn/EfC/gHCz6+jdukXUM0mpfgA9nu+DHdvhaEKfO1NWOm/Yd30duRw98+MKfPth9AnvA9T/gPMv92BmNuNmFlAlHIkc2bRmrOA8PEqYvUcvHXvxrv5LVhXHI9z3gJMMyZ5cO+z+zJ0+J2lY+Q7PGd5Jpn1P05XTnLpcpuZJcnd21JetdrBVfCJLTbVsRDhSWwMqw/X2JBYKAXvua5J10SLe7an2Epw5WLFNx5PkVIgRGbC5jUabMDlJC/msOtw5ulFZsQhNz8UUC86WMawPZcjHWsy/+AYTdehphWTu5qsnGtRs22S1LBrsI+Fuw/g2rQ70aUYAWGYctwpZULHQqUaMZQj1wiQQoDWIARKG0r1Bgd7ukFkCnhWnGDHmSZ+olTWuz4IAUgdiwX79wGGh4bnM54rkEiFFu0VvqMAQ4pAGEOuGePXWwS+R+C2NfIx9Ad13DiL6VfzPkHJxQ8SLJXV/Es0FglSGFqVIkYIXAwCw6y/ex6pFrhP7idRNk3hoVNwCwJVcen71hXYc0ok26bwaGJd/k+kH7wF0ZvHueHNiIfeg+fE1Ls/QPiGb2JSAa7CoUG+GGKHLXLTh7FJcWnRGhxiemg+9ua/Rl2yImvtayUEf3Y9xcZ+8tFENiF67enI6X/A2vtxrN876WfGkdk7gflf/4Iuvgnz4n9E1FuI1TOz0reZA0THHkNrV4pWDs5VL8bb9n7s969Bzv7RJEFIif/6E2h9ttPWo8PPp2PkOzxneSaZ9T/N6092mGxqbt+axbVffFymIjdezjPXT6gPFelthswOQwp5yfpdCflem5ee6vGpW1v822tLSOAAgpwL5VSzYrpKguCuAyAHXL5/f4NXHq84OKU59VgPG4OXpOzFwh4Zopb32Lu5yZmvHKb70DSRUqg0RfsuxlFMPzpOsdumECcYA4kRTB+OiXwXA9SrBktrpnyP0PdQcULsOQweONxuHasIXRuVZC778lSNyHFQNsyZPEx5qoqWkvUD85CJJvYdUvb9ZQwAACAASURBVMsiURKVpiSWwgsSYtvCMgaVavxqghUnhDmXyFH0tjIF60hkE4/QyjT2PSJmt8aZ8nJZ0xuy3AJvaYXEcUmNADJ54frH78UYaOBgtEG0PQS5BQWGH34drX/4Ae72PYS3bMEj5MCMhbjhx7E+/3KaL/kPghVXIVsRuDZBXxeRsnF0E8fVUAvIxdMkWEyLblpnnoB//ztJD7VofuoBkjf/XxLrTfjbd5DgIBb1I+9+D1b4r1iffy2y9LPSsOYLd6IX/wlm1jsxNz2CWD6I6HKhr0wybw5BeYhoewO55lj8re/H/eprUOctOSIZ/NN4rz6e8BuPYRrRUY3lDr/b/M4Z+dHR0c52Z/vpbRsIY3NUx561wEJK+MYP6wB8aI1LMzKM5or40032aIERcEKtwVhgUAbWC5eTujfxrdEQJQWXDlXZgkVPl8IyWZGYbwwPlStcuNpj14Y6c5fvY1YYcPNogDaGShyxsb+XBWc1s7p0A+se3gWJZumQpG5lxnLb4pmUpuvMGMomMVKnpFKxe2uLvvmZhj1B5oJ3wojA97CCKNNMTxNyQUgt52cCNFKAFCzauxctJfV8jh3lbuK2ok3i2og0IXIdDIam7yOMASFwg4TUkm0BHIG2s+Q3NwhREvqjOjI1TBdcjJEYCUJrcmGLMV0kVjILOQhBjMJ79QrUoSqIrJlOLBXuwUlkW/EuyecRXS4CmH3HSxCP7aH2/T3khmySwR6ml82gVuhDOQ7Ncz5FXAfmdbP/BUvx5rhMTTjUl/djJSEkmhpF9oq5yD88m9At4J4+Cz0dMu2XCN//XfjMnYBADpUJBwZY/x8vQp628BeOH/Oqf0G/7vOIRf2IL76eNI0Q5x6L+cpbmd7aRFeKON94HRs+ey72W89C9OT/xzGpZpZoLisRfvuJX+33pbP9W739ixDGmP9xp//P+J27oQ6/GuqBZvX7Jnnwr7oo5575fPdd327wmftiHnpnkcV9isG/rlKJE15z52NErzqW/Q9OEU/HPLCsnx0TGiNg5/tL/NFXmrziNI/j5ypmf2CaNy6ArY+2WHF4nPt7utnie/zZcIOtD9a57M/m8eD1h/niYZ9jmg2qtk2UwqVzEvbvSTCTARUPzr6oi8e3hdy0VTGj2WTScTlxw2bcoQL78TGeYlo6FGRKftDHbDiEH0SkQpAKwXSpwJxd+wh9F5lqDvT10DVVRWLoGpsm8h36q9Nsmj+XfKOJ02ghU02ju8TA9nFqvR71SpHK/nHGeyp0TdcAQWUqYLLbI1+P0FLQNdHiwFCBWleJY5/cQe9kk735LlIXEilp5hwa5RynbNzMDreHyLcYONQiJ0O8vMBe3kt03z6UK4jSLARQTmvsZICZapIEm2mvSBQIzkpeS/OUq9h0n82yba9mw7H/Sfn0fljSz5yPrabuvw917iImkwqVi2eg33ste/yFLP3mmaQX/SP1Qj+BX8FUPOTuSdRxg+Q+fhG7rryJma+cSXrVnRSsKYJzTsR744kc/pv76fnUhXin/5xMeWMwF3wMbt+IuOEdiN4irPkYfO6NpP09hJd9Buejl2G9+uSjGsutzz9EdMNmyle/7KiO7/A7wc9NLvqdW8l36PB0KXiSUxfZ3PrY0bk5r1jpYiu4+pEYgMuXW+wjS1obDpqEPR5+klAcD3BciQK++l9N1qx0uGl9yFDFoksabt+eIBCMeR4zgwALuG6zIT8/zy03TXHu2SUKRtMzaNMSknIUcs9WzeoTi8RK0ZqMmL+6zMENNbQU2BhyJmV8oELzcEClz0KFKcYYWjGMHYih5KLSlNBzcJOUas5vJ+ClaEvR8lz8ICKxLIzIZs6Huyvk6q0jUraxawOZ0zyndSaI4zrYcdJ+Qu2OeSbzBghjaJVcBAI3Suhv1GngghBIR6KVIPZsnDBGGkOUs8g3YySZ0I1dsmg81Ja3DVO8NMJKUxr4eERIlb3RqAXOgAtAc3QMK69wZubRzZTagZjuy+YQ/9G1pFg477+AYPQg8Ue+R31wmPKrlhK98WsAWK86EV30EYebeFEVe+0ydq69kTkv7yd/1dXYhCRrTyG5dzf2hYvIr11C8+pNPzNOTJxgVr8P7tqEuO99iKEKXPx38OnXkbo5whf8K86/vfSoDTyA+8JjiL63teOy7/AzdIx8h+c0l6xyuOHho/thPHm2QgJffig7/o/PcqiHhnV93Uytm2BvK1OZmzUd0NBZlvrX18dcsMLl9idigthw6WLFeCzo65Ec9jy6WgGuMWxzfY5f4TP+RI1lI0X6wpBtqYMlwNGGg47L807zCdsm8MnH6jQdh8GCoSYlbpIyMdCFE0QMDlgY0xatkQqtDSdd2ENiKWSiSZTAa4W0ch5WHGdGN9UIozNXOSC1oem45GsNEluRODaJa2MQaFsgWgmyHdN3gyB7QCZrTCO1IVXZ/dc9i1Qp8tUG+SgkMQojIUohdBSha+G2YowRtPzMyCuZ9aVXFsg4QfgKqUSmcEdKHZ88IbkL56EtCdpQOaWPdNcEtSRH5aWLaN6+E4OgtbNJ+cxB0q+uAyGo37UPmcTk+iStYjf2tgPI3WPoUp7g5q2wfYL876/GpcXkR+5j3uVF3E9chzlmJo4ICB8exzp1NrLkkVu7lMY1m/hx76hpBJgl74atBxEbPoTIe3DhR+ETryJJFOErv4R7zeuxLj3uWYxikD05rBNnEt785LM6T4ffPTpGvsNzmvOPdbhnc0wjfOZRHikFLzneZsekZvt4ysJei+6cYPPCPsItU5x4jANll0IY0+5+yvqawENzzAzF3Rsj3ndFkQmlqMxyiC1FIdUMhCEtpZgciygECet3xDxv0LCvAd1BQC3noozh5usnyecVsWdxzw2HqdsOSyuGKd8DA1PaxghBbdM0BiiJLMteGCgOF0gshZvExAWP3mqNes4DBBhD7+Q0WmW93YXJXOlWklKq17Oe9MZglEJgkMYgEo1XbxHkXJwwwQhBYrWz7I1BS5n1ZpeCVsFjcHKKadsjQR15TwBGStwgpua6uGGC1GC7BgPoyRCFAUsi0xRpNNZQjgAHR6VU/vRkmsbNRIBm5on/5FvUKdL1xhU0rn4SlKBy0Syko0gbGjWUZ+pv7qP08sXovdO0ttTwJsYRGJLVC4h31GFRL8HjkzRVkeG+CZzPfg/zohNR87qxlnSjt01inT0PAHt5L8KziEb3Z/dyqIqZ9y6oB4it/ye7x/M+BB9+CfFEQvyOa/FufQvq9AW/jKGMu3Y54dUbfinn6vC7Q8fId3hOU8lJRuZZfH/D0a3mr1zp4FpwzaOZy/4FSy32CZvEUsxPWiT9Hn6cUJ4MsF0JAq6+o8maVS43PRwxt8+iLAx3bMtc9od9l+FW5rK/ZkOCNzfHjTdMct7ZJXJG0zfo0JCKrjDitsdTVp6QJ7YtGmMRtiNRWydJlcIWGl+nHO6vUD/QpNRlYYUJGIPQmkdHa4S+i5WkxELixzFV3yfIeRht8OIYYUyWv24MtXIBQ9af3WuGWYkYgDFZQh1QmgqzHvJtN37guZgf+4UxInPfSwED1XomTSsBsiRFIxVSa4QQTPke+Wb2mTgmxkhBUo0z738tQqFJkASHYnxC7D4f1eMTJhJnho8qOwQ3biG1bHIjfTS+sw2hBD2Xzib+zN2kWDSrAm3blI/NU6WMP2CTOybTeK8+MA3DFfRghfDWreTnOcgn92P+8Dyca94Md29GvOTELCKRZjMUIQT5tUtoXL0Js/UgZsEfQ8FFbL8K0QzhvA9j3vci4h0Nkqtuw73rbcgVM49q3P083BcdQ3Tjk5gw+Z937vCcoWPkOzznuWSVyw0Ph0d17BnzLdIUvvzDtsv+bIdqYHikt5vqwxPsaEhSIRieDmhqgTLwldGIi1Y4fO+xiDg1nD9fcigUdJUzl30lCHGMYYuTY9WKHAcfq3HsSUX6ooidxkFJcLTmgO1yxpl5QiPRQjCn12BZggX9gjoSL0mZHOrCDmKGZtoYQ+ZCl5InH2vSvzBPYinsIEYajR3FNHMeVhQfUaMTbVveKuSQSUrLc3GbIUa128Zqg5YCIwX5etQuw3PBGFqej5ECIwRWrEksAULitQKKSUAaW4ROdp7YViS2QiYpGpjK5Sg2somTt7wbbbUDBxIkWe28Q0KrWCJPQPGKRbS2VdFGUD6xF5mX1Oo2pdP6iDccziYisaFrzTDBu29AI8n9zfk4i7tIPvhdGn4XPR88g/A/HybCw1nWTTAWER4K6A72Ym/eje4rY73qZPQT+6EakJ68BDlUJL59+5HxkFu7hPDL6zDL34tY3I/Y9DHEZAOe/yHM2y8ifnSC5FuP4N3zduT83qMac78INVjEWjFAdOvWX+p5O/z/TcfId3jOc9FxDrc/EdOKnrnLXknBFSssNh7S7J3WHDtoUXIFGxf00to8xerFNrrkUGxFDBcMqYEHpwUlB+b1Ke7dHPOBtst+YL5LaFmU4oS+KKKhFGE9ptCI2Lw/5YQeze46dAUhtVzWbOa2703je5LAUlR3Nll6RjcLi+kRl/2EcZHG0Ng6jQa8KHPZkyT4wwVCx8GNY9xuj77pKrV8DqV1tkKXItOTV1l3OacV0fJdrCjJpOeMQZgspi8MSA1OIyDIuUhtMEpkKXMC3FZMakmCnEv/ZI0Qi9QoQj/TvE+lIPQdRJKSKIGlNaq9ILWP7cOorLudcjPhIAHooTLNKU2OgMKVS9jzycez/csW9h1PUKNI9ztPpHndFpjXhSzYtD67Dj0doko2wfrDyB2HEM0WrcBCrtsFUYJcPZNo3UFAMHvsUTzdQHzxDag3nYm+eh3mqu/CjArxbTtwXrqCZHQveryZXfvgQXr3bCBdPR8x+jeI8Tqc+2HMG84huu8g+rH9eLe/9VfWFa7jsu/w03SMfIfnPD1FyXHDFrdvPDqX/e8d75K34dq2y/6iJYq9totGsFhFmMHMZd9bjbBcgRZw3d0NLlrlcNPDEUtn2OSE4c52lv2k7zG7FaCAb6yPcWbluO6GSS44q4CnNYN9Fk2p6ApDbl0fsXh5jtCyCCYiFp1UQW+eJLYUNhovTRnrq1Df00BK8HXWFz41gj17YuJ85rKf1DZ+lNB0XULPRcVJpkVrIFUStxXipXGWvd52x6soBbJVPBhaOQsnSpCpxliKQq2JzgTvslC/EMSOzYyxCerCy2LxVjYJsI3BjlJyzawPfbnZauvZgRwuYqLM4gudKeRFSMTiPiyhURj804aZ+kGWSZ9WY+S9TxIIn+J5wzSv20IQSJRlaHz6flIsrFceT+0/Hqd8wSCt2TMplgzB1x7FIWRi0if2cxSZQo1PE771hViveh5y7WrSq9dhbngE1hxLdN0TuGuXY5+/kOjbj2O+eDdc+gmCYxZSP+8MGK9nLvorTya8bTeECe7Nf4Ao/+oayLgvXkZ4/SZMnP7PO3d4TtAx8h06ABevcrhx/dEZ+XMWWgQJfKXtsn/XWS5TLcOG3grNR8bZ1lAYIRiabBEgsQz8x/0RF690ueXRkFQbzhmW7G9BqSg45HmU21n2my2fFSvz7H24xsrnlemNY/YoFyEFbpqy33LpHcoy1g2CQwcidKSZ2ytoComfJkwOdaPCmOCpMtq2pvz4vpDlp1VIlUSHKamAVMrMyD9lVI1GS0WhWmdmdRKhNVEu6yKn0jTTt287QNJ2DwAVxcSeQ2WihlYSqQ2Rnf0rU00lCghwiLzs50cLSC2J14zwazGpFOQbMYoUATS+8DDKZHEDK4rbXeGhfjDGM0GWlJca0npCZXmBtBoRTaXk5/uYqYB4yyTVh6dQOqVUbKGxqH/lCWR3Dq9b0pywsB1DWR/OvAXCQCPEj6YYL83B/9Ozs2exahhSDfurmLUnY6oh1uoZuGuXk/7ddzGv/SziXRdif/ZVNL/+BJz/Ycz5Kwhv3YWY3YXzjdciPPuoxtjTRc0qoxZ0/0QIocNzG+t/2mFkZGQusA54GCgAPcBOYBBw29tbgLuBDwA7AB/4s9HR0dt+7DyfARaPjo6e3f77pvZ+S4H9wDTwTWAE+Ozo6OjdIyMji4BPAnmyCcnfjo6O3vws77lDh59hzQqHj9/YJEoMjvXMGtbYSvDCYy2ueSRhrK4ZGVbkHcGG+f0c++BmjnvhIM1pm0orYjAHh0O4b1zQXxD0lyQPbk1439oCp/59lVkLPR77oaYSJ3TFMfscBzsJKNRC9kwZVpYSbqi6LAgCmn7W5e3eB5ooWxI7iv+6doxVp3UjpzV3+B59rYDD0mVJotFkvdu9NCFQDhjD7OPKbL/Zwolj6oU8XhhlC++25ZapRkuBTDSLxg/yZP8A2vKQcZI1iSFrU2ssAXE7US4IaXaV6N43RdN1UbEmcTKXfy4IMoldJNWSg9M+fyPvUTrURCXZCjTVCkumKK1Je4s4e8eQwlBXHn4SYqSkurnBgBWBluz9ZOai7jqph8mbdtIgT+UdIzSu3YxREiGgcPlC0i9uROAgX7iCvO8w+fkfkGif7n+9BHnF3xNWyohtY6TksP/jtchPjKJmFIEssU7OqqD3T5A8PoFz6VKElNj3PIzauBU++GLEn1+GO9VAbztM+MI56Jt3oC4/DvtDl/7aeru7a5cRfHMDzvkLfy3X6/DbzdNdyT/UNs7PJ5tEnwd8BPjc6Ojo2aOjo29o7/e50dHRc4Dfa/8/ACMjIw6wEqiNjIzMBhgdHV3TPufNwB+1z/NPP3aMBXwD+PPR0dGzgMuBj4yMjMw/6rvt0OEXMFRRLBxQ3L05PqrjX7LKoeAKvvVYjBCCcxcq9voeaMOyXIIY8vHihIFmhOUIIgk3/aDRzrIPWT3PwRFw987MTT7lucxtBUjgaw/FWDN8rv3OJBeeWcDRhqFeRV1ZdIUh2yYNy5b7JK7N1O4Wi07pQm6fIlBtl32SMlkpUq7W8fMSL85c9kYb9uwOIWdjJwl136NrskrNdQn9LHlO6szYJ56NNJAKhZECK4rbQjeG2HOIn0rUM2AnKUJrwrybZdQDWkpSSzE8MUkDJ5OgbXeiS6ysVE8mKYmnUFozVcyhVCazKzYfzlbvrmpPU0AMFUAbnDRC2IJ9n96I8hVWj4e3az91ClTOHWbqfXcReT6FUwZgzySpUVjnzid4dAJzyyaMELQG+5h8w/UAWFM1tFDkrlhK+OBBvMsW/8TnLPaOY2yH6LoncC5dgnnFp+BT36d1/HKiubOzcrkXfBx/rkf11oNYbzwF58OX/doMPLTj8t96ApPqX9s1O/z28ozc9aOjo1XgANlq/r+jm5+U2LsEuA74v8DLn+blTgYeHx0dXde+9jjwaaCj29jhV8IlK11uWH90WfbnL7aph4avtl327zzTYaIJm3oqhBsm2NrIyuf6D2cuexv44n0Ra1Y63PxwhNaGU4cEuxtQzAkO+T6VVoBjDI8Lj+WrCuxYV+X4U8v0JjEH7EwpzksSph2bc9eUCUyWnFadTginY2b3CJomc9nXinkKtQblsnzKNmOkYP0Pqiw9q5dESSLLomdiinrOI/Ay/Xf5lFveEaRIUjfrO087o14LQeLapBoS9aNwgIpimsUs7m6OZOobhqamqUuf1BHYaWawQ9+iq9oEKYlcRa4ZUy/aTFZKSGNI2vOuNEjxkuz5JuU8NglW3kI4inBnncL8PKrsYschTlExccU3SRsxjVIJu9nC3L4pU7n732ci1u/GHbCJ5/SRjAX02YcRGEK/TLpoiPyLFhN8exP+pT8y8lpr2HkYXAs9uhPrqm9hvv4g4qZ3Yr/tHKKvPQKXfpy0u4J1eJqo0o39zucf1Xh6NlgLulFDReK7d/7ar93ht49nZORHRkZmAn3A2C/Y5fUjIyOjwB3AO37s9ZcBXwKuB9Y8zcsNA7t+6rWdwC+vsLRDhx/j4pUO3300IkmfeZa9ZwsuPkZx786UyabmjHkWngWPzO9n6rFJFs9xSPIO3UFEby4L7d59COZ0SwqeYP3OhPe9qMCklMxd4tKyLLqjmEqSULVtSjKlMBVwOITluYStVUE5DGm6DpFSbHq4imUJYlvx/avHWHJqN0u6NNM5F2EMzbyPEyeEu+sYAW4SZ2VlkSY3nKPleSitkcbQW6vT8px2DXxmnPONFhqJtlSWWNfOAUgt2a5/l8S2OtKYxq+HtPLeUzl3gMCJYvJBSKIV9byFbJffhb5NudpEC4gcRddkK/u32gBXoVORudxVpiAIgvr2AE8kCCVIhAJt6Douj6g3ibGxSLBWDeCcMES4o455cgyXzMsy8YYbUccN4h0+yNTmiKGLu7HHJjFSEg/2E+9t4swtQmqwVgz86EP+2gMIJTGr5lBKD8K9TyLufz/ighU4FywgvmkTiXYI7z1A4d+vIG2mxNsmfzmD8xnirl1GePXjv5Frd/jt4uka+RNGRkZuIzPUbxodHf1FfqDPjY6OjgB/DpwLMDIyUgZOAz4DfBuYOzIysvJpXHMvMPunXpvdfr1Dh186s3oUw92K+7Yencv+pce7FF24bkOCEIKz5in2FXxknLKqkmINeXhxwswoQdmClhD81wNN1rSz7E9d7CAF3LsnBQFV12Zeq4UAvv5AiOz3uOaGKdacnsPShhkVQc226QpCrr0jYPEyn8SzGd/RYsmpXTi7pmkqCyvVaCkZ6ymjJ1tYtiCXZrHvMEzZ9FiLet6n0GwxUSmSDyICx0HLzIBrS1KoNUnamfQqjI+U2FlRihXFpLZFamc/J0YI/HqQldFJcWTfSr1BTbikSMKcfaSTVGor8vWA1BI4cYIfp/TV6xyoVEgdC8tojCUxOhPA0QiilqagQkyU0gwUwreQYUr8xVGqlOh52yqMYxPub1DIJVgXLEalCYlyMMMV5HEDxE9OgK0oX31rlrz36jOIaxrv5CHiO3fiXbb4J9zs5jN3wvIhrHseRUYRYsNHEKvnZWV3b/4sKi9prp/CvfYNWC9cQe7yxTSv2fwsRuTR465dTnjN4xjdcdk/13kmMflzRkdHnz86Ovr9p7H/p4C1IyMjvcAVwIdHR0cvGh0dvQh4HfCKp3GO+4DlIyMjqwBGRka6gT8AvvY033OHDs+YS1Y63HCUWfZrltrUQsN/rsuOf9sZDocbsLW7TLxhnK1NhTSG7kMNYilwMHzhnpA1K7O4PMBJfYLtVch5ggN+jkozxMXwqPE4ZlWBraNVVp+euez32S6pEPhJwh4czr6gQqAF2kCYQGMsZLgiCGTmop8YqCDjFONlMXCMIZaKnVsCUs+hWG/QynkIMlW8xLJQcYpREi+K2N2TRelkmiJ0VuDmhBFWGBN7mYRuJk9rSGyF3wiPvCYQdLeaBKmNtgRKm6whjWuTa0UIBKklKDQj+pmmUmsROzY0oqwmPkqwjUZpTagcXJlizy5igoQwkpROHyDeUSXcMoVG0v2ek2h8ZQO1ScHgJ88hunc3EvDeewaNjTWSGx6jWemlGI5jZvQCgmTuEKavRP6yhQTXbf6ZeDz3bkVs3gdRTNzVk8UhkhRe/k/EO2pIYeDURUdkarOGNRuPaiw9W6xl/YiiQ/JAZ030XOdXUkLXXul/FngbmUH/8Yz4u4HLRkZG/ttrj46OJmQJfB8eGRm5gyym/xejo6NbfhXvuUMHgItXudz8SBYjf6bkXcF5iyxu35pQCwwXLLawlWH9vAEmHp1k3iyHOGfTH0SUXIHWcPs+w+IBiRSwYU/Key/LMy0l85d4NG2b7iiimKRMOTb9viE33qKlFEvsmB0NSSFJiHyblqXYt7WJtCSxLbn1m4dYfEoX80qaKdcBAWNuAS+KmIyy+nNPZxrzUWJIjKBQa5KLYkLHplxvkiqJFWf7BJ7LrsH+zMCTGXqpDXYQoaIkK6Uja6mKgdi18KstICuTN0AhComxaeYUUhsSJQl9m1w1IEWgLcH86mEmZY58GCOiFDvNwgpKPuX0NwTGxpEJpVccg8CQIplxQR/xI4eIscGzmDjjCwhH0dQuvg5Id1eRaKYfaWKUpF+O0ZiSFNfMhYkGJucS3rSFaH8L75Qh4sfHcM+ae+Sz1Vc/gAhbmJJL/cQTkVeOkH7jh5j/9Wmi9WMkTUnuljcT37sHE7SV+s6ZQ7x5gmRP9dkMyaPGvaIjjNOh00++Q4ef4fkfnuQjLylw0vxnXtP8lYci3v7tFv/wIp+XHu9wzqfrbBzTvO176+h+3TIefiLEbKuxfkkfTwSSKIXvvMzlvv1gKfjjS3Lk3z7OSSWNeyBiwfQ0+32fB0tFnp/W6IkTZp/SzWI/5b13wSoVsD22KQQRg3bKsbNsdm2sk6+HvOa9c/jSv+znh1aJ+bUaU5bDwp17SBwbq+KTahi3M2W8Yr1Jz8QUQgmq5QLF6TqJbdN1cILYs1FKENoOKgxRbaGVxHNwGgEq1TRLeaw4IT/dIvIUiW3Te7DGeH8eKzY4ccyCsTGaDZ9DM33sRBO4FvWuPHO3juGnEWPdeWbuq2PZMZZUHKqUGTgwjlECV8cYwB0usHe3YqhQZ97tV3Jw5HPso4fZgwGNuiSsp4SOz8xjLZJZvbS21ChMjNPc36LoBkyVhuhWE+QP7GGrs4xjRteSrvgr9EUrmbxrinjOAL3vOp7w5q10f/0KAMz9WzCnfhAsQfP1L0TO6sJb3Uv8is8hPJu0txvvlrcg+otMnf1Z/HeehnvZMQCMvfp63JEhSn808ksbn0+XeP1+pl/8VXq2vuPXmt3f4TdGp598hw5Ph4tXOtx4lFn2L1huUw00/9l2+b/1dIdDDdjZVUJvnGBHrFDGUDnQJJUCD8MX7gqyuHz7mFVdgi2T4DmCg55PVyvAwbAucVm8Ms/GB6aZf0yerjimVfbQQpCPE3alNmeeX8607A0IWzLdgJJMiYBcmjLdU6ZUbTBzroeODcZkyW/lqSoTXSWMlMg4RUuJirMVukhSWq6b9YSP2yt52wDUawAAIABJREFUIFUKbVkInaniJY4NbdEaIwS6vfqOcg52klJXPkgyV72UpErhhCnFIKDp21hBSoiNQ0IqFV49xEKTGnlEDEf3FrFJsV2Bc3w/YJCk9N32SpJ6TISDNeiThBBvOEzuwBiV95+ER0RzRj9qvE7+wG4aM4fJnT0L/dX7s/OedQxmuJvCCxcSXP8jV725YT3m9L8FBeb3zye64UmcS5fA1+9BT0TomX14d74V0Z/V0rtrlxP92Oo5v3YpjZ/TY/7XgbVyEAQk6/f/Rq7f4beDjpHv0OGnuGSVy42PRByNl6vkCc6cb3HLpoRmZLh0mY0Shofm9jP+8ASD/TaRbzMYhPiOINXwvd2GY2cqWrHhyQMp774kx7SULFzqUXccesOIfKKZcB1mlSXeoSaPb4+YFYdsrgqKcUTsWdQdm8Z4CFKSWJKbv3GIVEiOGRRMuS7SaKqejx+EyFqmFOe0RW3KU3USpYhtCyfJjLwTZqtnZTIteytJkU8J4GjTNvIyK3OzLVLrKVV5gROlRK4CIMi5aIBQEHoSKzUkVpZV7zciPB0xmc9RqsckjsAymkRnyXupEEhjUO1uePUDES4RhcsXMvW2W5EYVF5Sv3c/CRZel8RdUMZsm4Dt41SuvpLWO76DQ0zp0B6kjrEuXk5jaJjyZfPQn7kbLEV0/37iekrugjmE39+Ou2Yh5gt3Yi77BLz4eEys0GuOB0sg//kmom9uhOEu1JUrEaUfydQ6L15G9J2NR2R4vQvmEa0/SHqw8azG5NEghMBbu7yTZf8cp2PkO3T4KZYOKRwFj+w+upadL1vtUHAE390UYynBicOKvT1FrEbEiTMM9pCHGybMJ0VYgkkhefDRgItWZKv5y07wiIXgkXENAhqOxfxm1gDl2w82ERWHe74/xWnHOJjUMCtvmLAdusKQr36nxrwFLolvs+/xBpYyDDUa1B0nazwjBOOVEuOPT6GsbHUvMEyX8wgpCB0bO46PxN2FMUS2A2QqeKa9Ope0t9srdjtKsOKE2HcwAnK1gNjJjLwRgti2kaFmbEbpSEMaLInfjJi2fLQQOGFK6KqsKU5ksEkJPQfHJKQIVJdH/UCMbyWY7RMcumYHEkPPigLJm75OisK7fAm5h3cgPcX00vnsfdvdWEEmoxs3JPnXrUQ/tJv6lhalswYR43X08mGCW7djIg3VAPv4QeTn/gvzus8j3n0RzBmE7jzxA/txioboiw8jLj8e+x+vwFz3yE989mpmGbW4l/i2TFZWehb+RfNpfus3lWW/jPCbG45qwtrhd4OOke/Q4acQQnDxSpfvHGWW/WXLbWqh5mvrswSst5zqcLABe8sF5OZJdqQ2ljEUDzQxlsDH8O93tI6o30kpWF4ybDyscezMZd/ddtmPtlzmLs8THwy48IU9dOuEeikzkrk4YVtkcdb5lUwYRxtmDFmMb23gJwkxAgVUZ3YhwgQ/LxHa4LVCxnu6iBybwnCe0HVQSZrVxGtNK++BEMSWQqYpqXhKPR5EqkkcC68ZIOOEoL2vHaekKtvPbYUEeRcjJJFro6VAK4lKNVaiaflZhr1BZkZeG6RJsUiJbQuLLAdALepGGoOdxChbMJXmMQjcR3dhkoQUiX3Pk4hmRGvFXPS+GpWRAikWLTxaSxZSOrWPwCthzykh2jm85rIT0ANlcpcuJLjhSUpmDPOebyKuegniwy/FXLsOzllK9M93Ix/fg3zzGThfeCXqomWYR/diDkz/xOfvrF1OePVjR/7Oesz/hrLsT5yJaUSkjx/6jVy/w2+ejpHv0OHncMkqhxsfDo9qBdSTl5w4S/Gdx2PCxHDlChswPDBngLF1k3R3WUSexYwgRFmZy/7mHYbj5ygO1zQ7xlLedWGOaaFYtMih7rZd9qlmzHMp6RQ7SSnNcJirIzZWBYU4JnUUVceBMDoSE5eJpnvYZ9iJmXIdpDHszxXwWiH1WtZ2tlRv0splXfOWnlqh5bpYSULsWKhUEzs2sq0pHzt21kteCIQxyDQlsS2cIMZrRMSOlUnFepnYjdCGrukarbxH5Av8ZpSVzjk2OjUYIWjkHfLNGEtkDW+kMVltPAK7GWGhSYQgaIJHiMrb9F53JfpgA42g/M+XEGEhMQjPIk5g7K4JBi8doPi5G9FYBOUK6WSItXUf9YEZlC+bR/qh72b3dCgklTb5S+bjfvEW7Hs2IL78JsTb16CjBLYeQocJ1qFx7PdegHPVWoQQCNdGrlmOvnb9T3z+7trlRN96AtN+Zv6aBYT37SOdaD27QXkUCCmzznQdl/1zlo6R79Dh57BilkWcwhP7jq5l58tXu/g2fG9zgmMJVs2Q7O0vYVUDnjdLYA36eFHCYpWCEhyWkkc3hly4wuWm9SG/d4pPIAWb6pm7O3Qs5jVbGOCuxwK0r7j6piprTvRIEsMML2XScamEEV+6pkpfr0VoWUztbhEDgzqi7rkoNCI2/4+9946T7Lrqfb87nFCpc0/SjGY0o5zDKFm2guXsZ2OZ5wQ4J2xjzMXch0nv8oCPgQtceIC5GDDGCZBzxDjLsmylVs6aGc1oUk/nUOGkHe4fuzSWcQCNbNmW6jt/9PnUVHWd7rO71llrr/X7sTjchNxipMTFGkQYq1vNASn7xjTh40Fbh3QOXRlsHCGcx/ughOeEAClwEpLSoozBRJryoYzcOcaXV3FasjReI+0VVFpiYhUCvoAi0tS7BuqhvC9FKNUbFBqPQbLYarByV5tUGGpP28zBV/1734gWlClZYQytPUW9SeU0sqGZfP8nsCSgBD6KaDz3GPxn76BzyDP0nKMRO2dwR42Rf+peqgMd0j/4EEm+gvjC2xEve1K4kO/5Bk4qqs/thHO2EP3uc7/jOsufPQv7sVu+4zF1zBhy4xDVN4KsrGzG1C7fQu/TO45oLT1aBh7zT2wGQX7AgO+BEILnnB7zuduOrMv+BadGdAr48G2h5P+G82MO9WBmuEH0wBIHRURkLfVDGSIKJft/vCo7rH6nleCEhueOWU+kBIfSlPF+yf72qM6G01rc+s0Vzr94mFFnKUdrWCFoVBU7Mk2sQvC0Bg4dqFhcttSlxwENZ1meGMb0O+idkoe17O+8bhVlLfSV6pwQRNZSJDFRXuJVuAHgoZEsKYJwThwU7KSxmFjj+6V6bS3OS5JuQW+ohpdQxDEIQWO1oIokzTwI3sik35mPROFDdu4tldAs1hpUKGIMcrHN7Mf2opMQ5hfe9CVKghhPdcMB/FiNsfYB7PHrsUSI09bjC0vz/AnyfV2sgaS3Ch78z5yN8Yp1ej/ijr10X/EsxNNOO3wd7e9+lsommNO2EP3a5d91neWzTsHf+CB+ofMdj4cu+2+X7Os/ewK9H1OXfXTR0biZLmbnwo/l/Qf8eBkE+QEDvg/PPiPhi3cc2b78uiHJKWsFn7wj7Mu//JwY5zxTR00yd8cScU1RJJpNWY5XAmvhC3sc5x8bsXfBcmjZ8tbLUtoIth4bsRonTBQltX7J/qzjYsTBHhObUzZWBfevSprOgpYsJzHzcyVOSKwUyIbGtmpsm4SVfgNeN0np1WuMzi/j+8HYI6jahvpqDy9EcJ2Lgxt1qzzsRo/Tsr/f7sF6hLE4JbGRRJUGp1XwmBcC5Vzoeu/mZI0w7rc60kAZi3KeMpY0szLY4CYSiady4WPJIKm5Cueh9ApTk0QJ+P0rdFyNxrYGCoeyOVILZFURY+jOl4yc2kQ8/VQsGv/z2/HdkjRbobt1C0P/15bDpXo7NMTI8h6iKmPxxDNJXvukw9fQ/tkXqWZLoldtp9rdIXrWcd99obVEHDOB++p3BnB10hrKL35btys6aZz8y3t+PM5w3qNOmvyO8xnwxOFxF+SnpqYGx4PjH8rxfffde9hb/ki+j5SCSAmmpqboN5qjqwo7VgM8mVRo47hwkwLh2Y+itLChmbFr1vL882t0pWSu4/FSor2j7gxGCHY8eJCqprlvb0lVWmzp2H5yQkdrUmPpogCP8p5CSspexdhkDC4o0gkhGV1cYWg5qLEpF7rsEQIftGmxWmJiTSUE7UYDfNhjd0pSJTHCuZCxCwGCvhmNOOxFb7RA2iB/a+IIZRxGCYxS4MLzjZYM9wocAteK+up4DxXigySuQxIZh/QOUVQsPHc9znoSX+IRKFtiDbiR8PMZIh78+4uo3nsTCNi9cwalgMoyf1/J2KtPxn9zB1UcU/7DDcRllz0vPhdnI+R47fB1NB+5FUWJqTeInnUcN++86zuur7vjANW5f8zyqEI+7cTw+HU30Pv9r9J506c49NpteO9p/90tHLj8Q4z+yWUIJR/TNXzrJ7/O0sXvASW4d2v1iF47OP7pOv5+DBTvBgz4Plx5fc437qv461e0juj1Y7+1zPFrFNe9rcXuBcv2P13l1H3zXHrpGNfcXLB+tUerrBh7xWb+6ssZG0Ykv39Fk2tuy7n4xIgrtifo/7bI+VXOUAWnLS9yzfAQe2t13jDaYXdPMbqSs8sn6E0N3vy8Jn/w7kWSsmKtqRgrSxpVyXwSs2lEMduqs3wgp1VZnHMc+8A+mkXB/s1HYaQgjyIS6RmbWaTezcjqCZF1dLVGRRFjM/P0GjVwDpMmJJ0MIQnle6DWKeg1U5yWJJ0CVGi0a2UZDxy7kaHFNnFesjA6TM2UTEy36bQiTtkzS1vUMFsjVjqaE2cOYaWi7epMiBW6ImWhUaeZlWxgmcZvX8I9/99dbGyukLY7pLR5UGxhdPso7sZ9yLUxWw/9Covi14nOP4qZTSeSfexejnrDMcx9fB/HXv8i7NbfYXn8aFppBzPTwb/zpeQfvZuRv3wW8fkb8aUhG3sHUW+F7uRGGh9/FdFFmwHwzmH//KvYP/oC+k9eiHzlBQghsPfP0375RxAjKc1/fCFozfzr/g17oM3EB59PfPLED2tp/qd478n/4SY6v/klGr99KbW3no+Qj7ucbsB3MlC8GzDgkbB7znLMpDqi17ZzT6f0nLIu/IntmHec0V5ltlFjtpGQOs/QeERkHVVucMAxE5IP316yYUQyveyQUpAKT+YEQsCqjtnYy1DA3Q9UTC9atBT40YRt6zVHTyoSY1DekwtJzVsiBUsoJjalHJy11I1BSEDJ4Ac/WgcgNoZaWZBoiIwl6RXIftZfy0uGVjo4GUbuHrKblTbo2nshQ4UAMEmELg1egq4s2lg6tRSrFfV2RqU1kzOrQfFOS5LS9EfyYMXr/m9PQCQBjxUSBLSyPGwpxJr2fW2EEth2hRAeg4ZIUR1o4xCMX7GV7G0fxyFJP/9qujfMoiNY+PoC49sU7jXvx2uJWymIlxcoXIyLY2QzxrXD9oz7yv3ITSMgBDKR6CcFQ0y/d5Hq8v8f98lbiW/4ddSrLgQge9d1LD/p3SSvOIuhf38VxdQMB898D/Fpk6y/7pWPaYB3Mx1WfuZDZH9zPaNffy31t104CPBPYAZXfsCA78PuWcsxk0f2J7Jz3jKcCo7v3yTcP2M5Ye8CKyN19s1YROWw9SiUUe/KGFWwksMX7zeMNAXTS/3smFC+rmlwwzFbexkSmIlinvKMUdxyyaoRnLBJs2FcUTcGhKAQApkbbGaJheSeW7tYIRhZF7TqLUHQpmilQOjgj60jKgqEd/09eR+MbPIS50D64DfvpSQqq8PuckiBFwKrJF7KoG0vBbpyaOvoNWvoyiC9oEgiRhYyvBRYCY28wvYTkFWdQN8a1evwe7NCIp0jtQbhPU4qFq6aQRqLFxIpPAVJ8JWfyRB49PETFO++Ea0sFCrcDNQ05aGc1kiJv3on/rh11Owq4tITYKyB6xpEM8Z3QpA3H7sVddm20DS4fV04lw9eT3nOHyKfeTLRVb+KOGYCe2CF1Wf9E8X7bmb4m28gecVZLLz+8yz+t68w+ZErGH3npYj4yG4Uj4Ti0/eweOa70KeuZfT6N6JPXvOYvfeAn0wGQX7AgO/DA3OWrUeYye+Yd2glOG4i/IkduHaOlrd0tWZhX45W0MlBNyPaBwsu3CjZNWu58GjFgx2YXg6je6lzOCB1lrZXSOOR3rNcT1jnLeVQQruE07bGyMpSMxYnwEiJFYKlWp1CSi7enlApSZY7jBREWqCNpSsinBD04hiFRy0XFHFMtx5EbcpaRFKUFDpUCeKqCmI3eXV47x0fPkiqJCIqSh7aMVPWIZyn16wxtNTFi/CYiyTCe6pE0coKjJehYlAUtIowzeBNcHK1KtxsSAkWielaiiVDHDtMv4KQk+Ktx1tQ0uHrMaYQxJdspnPDLI3z1mAtjDx9PeLu6SDsE9Wp+zbiKcciJ5v4ToloJfhOiTcW+6k74KT1OC9REzHmJf+A/cMvEH3xl9HveCZCSYorb2f57HcRXbSZ4W+9EbNQcPDMfwTv2XDra0ifvOnRLL9HhOsUrL7+k7R/5fMMfeSlNN/5dESs//MXDnjcMwjyAwZ8D7z37Jl3R1yu3zFnKa0/nMlH35qm22hQeBBdy/CI4vwzUuojEWlmeN1lKZXxXLRFc8NBx/Syo6ockXEUUuBzS9tKorGI1Do6QpLt7jLdDBK4x23Q7LhuiUZZYaSkkoJCKlpZxn0jLQ4seSI8edtSKEWkQJeG0kmcELTjCDykeUGRJJS14MBnCRm6xgXpWu8QPNSoJx76ZQV72TRGlTaUuG2Qvc2TiCqJ2LJ/BicFaVaSNWKkcVRahkxeaAQwXJQ0y365vHL9bF8hCfv+FhUMV4wgKQvsSB2PoJApvnKERkOLef+NKAzxR15F9/oZ6qeOYXqW4cvW4w8sQz3G7ZjFEEFZIdcP4dolol+ud1fvQm4eI7/6AFI47IduQhw1QjT1DuRZm3CLPdo/dyW93/0qQ597BbV3XMLy/7iG2Rd+nNE/u5yJ9zwXOZQ8ugX4CKi+tZelM/8GnGfs1jcTP3nzY/beA37yGQT5AQO+B7OrnjSC4fqR/YncN2dZzWHbhOTQPavodsmG8yfYkHqkA7TkwrNr+JpizBjOPyFBAiuZ44b9lgNLjm98q8Owc+QI6nVJyxvKOCZ1lkpIDt3TYbeLkFIw1hTsvHaRWlVRCUEhJdJZjt4UkyjP7gdLWjWB8h4rAOMwOqjTWRnCtTQ2KNhphUQgjcUpTZmEKoGw4JQMXfWEjnoeyuadx2mJMmGfXpcGL6A7VEeXhmGbAxCXhu5QgjIOgcAoifPhZqFhDbWqAuFxDkol+/v1wWnOIbFOoJRHJhL6+8zJlubh0xCRwFy3D60MeqxB9/pZ7GyXeCJB3HcArMNnFfURR7c+ib/nAHLjCK5TIZsRvlNiP3Yr4vLj4dM3hyrFWRvQf/4iRC2m/OIOls/4a8Rkg5Gb34JvpExf+H7K22bYcOtraLzg+CNdco8YX1k6v/1lVl74LzT/5JkMvecK5FD6mL3/gJ8OBkF+wIDvwQOzR950B3DntGWsLqhFgqkP72fv8DCXPblB0i7pKclc23HmSSlzlWDIWIZrklok+PSdhou2KGZKuPLKBUaqilIIJo+KGTIli6XECHDA8ERMaWEkDVvZd9xTgFIMlRW5UkgP609qsVlW9KRiZCg0zjVqkqPXSWbWjOGFwAhJrSiJqgoThcCvvEdYh9UKq2UQuUGS66B4x8MauYRz2EihiwppXD/4g3RQ1GNqqz2MDCV5gaA9UgulfAGlUuGmAxA+qOt5GXoBykgHZb3+/YRDUIiIlBIUkIeRsPjkscPnotMgzqMv2IR3ns6Ns3S+8CDptiHElTeCVlgvkMJSjk0gdhxCHjOOe6hc3y4wH74F9/ffQK1vokSFrEX4Xknnlz5N53WfoPneF9L48+fS/vtbOfSUD9J6w5ms+cyL0OuaR7xeHinmnlmWLvw7zC3TjN76ZpIrTn7M3nvATxeDID9gwPfg0ezHA+xa8Bw/KenMF+y6Zp7VoQZbxgSiZ+kqyeZjE5SCPaueyDmKzHLMhKRXOk5rOXJgulCccnKNQgqWlwynbItZRjGnFQ5YmGzQ1DCcwB/8yi46hSA2Fevz/HBQlHXNxjynF0e00hBNtxyTsm5Y0G3Vg31rrBgqS6KywimFMsF9r0hjkl4OShJXBqMjlHOhy13Kw37xniCao0sT5ua9R/Tn5ss0ZmS2w3KtH9g91DsFeI/0UCoNOsz0m6IfzKXEiGCXCwIpPCISQaxHRNTKXtDnzwweyA72VQkjic4yNCXR+36B/N4lZKqonTpG0gR1aAnvPLoukL/ydEQrgQdmENsm8e0SUdPIT9wASz1KasQffT3CW8x0l+Wz3oVfyhm57a3Ik9Yy86x/pfPPd7P+2lfQeuNZiIcUAH/EeOfo/fV1LF38Hmqv387wZ38Bte7IRjwHPDEYBPkBA74Hj2Z8bjlz5MZz8lrFbZ84gN02SjVR49bPzqC1pKMVGzan3Hd/TpFqXKSY3lewaVSyTRiu/eoyPaUwImTDPSGYX3acfmqNbhQxMhr2sK/pKJLCUh3IiOY7JFWFFZKRogxjdFrSyRyNpYxOX3jHAyefXmNx0VLLw/53hSC2pq9XL0jLkkopilpKrZsHDXvvqSJJXFYo77BC4GVooPNK4JRCGoNVEuFA+uAjr0uDixQraY3UlCjrGVnq4kW4ESi0Rjf6fQu5wYlQwu/WI5wSaBUycyKNB3KnSbRFNxSiP5/fu2MJAIVFVgaFRW+bpHP9LMJYJt52BrU7d2DWjCKcRVU5vO4SVApkBXLzGG6+R/TuLyJ3zyGecTL+9M2oM9aTMUTn3oL67z+N1odeTPalPRw8+x9Jn7KJ9de8nOi4se9eAD8i7IFVVp79AfIP3MboN19P7Y3nPmY3FwN+evmxtl9u3759C3ALcCthWmgW+H+AdcAvTE1NvW779u1PBv4YqIAUeMfU1NRVP5YTHvCEYfec5QXnHFnz1I45F8bnRuH29x3kgeM2Mn5UxHXXzDB8dIP9XpAOa268sYMb0VTzkvtv67ByR0Erltx79AhjS4bOaMzK3oJK1ukhWV0wpDhOzAumiPFzBRZJY0Twxt/axh/96i7QCuNCc1yuNAuHKiIlKJH0FnK8EEyMaq6a8dStAyVp5CUjiafQCislSVmRJzEm0ggJynuyWkLkHMoGr/mgiicQzmO1QldVSN2VQFTBhz5rpiTdAqMVRgnGu12WVURUOfA6ONFJiaoDy1A3FYVWeAkrrRpx6Ym8D+19IvQNWBRaesRkjWK1i5WaUbnEAqPEpkBgcWuHAVj59B6EgOZlGygPTdO9/DyGv/wNeOG5iNEGWlX49eP4L9+NvfUA7qXH4j9xO9X+jPgN57PypHeDjBlaVyGfcRxzL/80xQ3TrP3si0jO3fDDWGb/ZfKP3En7lz5L/c3nUf+tSxD6sRvLG/DTzU9CJn/T1NTUZVNTUxcAfwh8GHj4p+ufAS+bmpq6FLiIcFMwYMCPlEeTye+YcygpWPvAIuPbmsy3JdvyLtXmEcbrYJTkUNdz41SXJanIveSrH57h1BNSTjxvGCdgJK+YTSJM21BzDis9N97YZTL1jMznNI1lVWvakWbN6cPsu2kJLySjI5JDaWi+ymPN4oGctacNhb33hQorBDtu6zBGidNhBK1RlKhegVMK50F4T6k1yhisVsTdgjxNUMZi+jPxh/Ghi16WBkRwppM+jL8V9Zj6aobuC+UMlTlOCawQxKUNe+6AMyEj196SRRGVknTrCco5pDGhVO+C4G1MhXWCyFUYNJVXNItlZCRQ3uDxlE89HYD2VQcZe/nxuN/8JC5OqO5fRmIRbw5GM7rs4Jdy/Eem8OtH4azNOAvmQIfsd79K8tpzaDU6lF3PwTPegxxK2HDLax7TAO+WM1Ze/lG6v/VlRj7zCzT+x1MHAX7AI+InIcgfZmpq6lrgDmD7wx7uAs/avn17a2pqyk5NTa38eM5uwBMF5zx75h9FkJ+3FJUn+/pBamdMUrY08rYFpn2MKxylEtxzwBBHgj2LQf99dFONi58yzL5Fx6XrBSUCt2rJlWTEGHpK0vaCelYRZaY/IiephGC1gnu/sYCyFtE1HKoFI5hcK8rlkg2ntnAijKU5Jbh7qs3o/vmgVOcdjSynaodSe2IqnBA4rVHG4oUgykpQAl0ZjJBYpYK6vBTgHU5rdGVCsLcO4T15PSUqDNr09/B92Gv3ImjaN4oS6RxWCbq5IyjUQ09HZDqi0pJ60q8KRArf7+eLqbAG5GIbg0Ipj0kbJGlf+Q6BbzTI71/CLJes+41z8O+9luLUbdQO7sNLhVg/gv3M7dTuvh83Pkz872/Blw7/9R0UVYxoxoxc+0aSV53DshlncWWY8b99FuPveiayHv0QV9oPprxqN4tnvAvZShi75c1E5218zN57wOOHn6gg32cf8HDj5VcTgv4t27dv/9L27dsHQ6ADfqQcXHYM1ySN5Mj2O++dtUzOtZHOce+qJisMfjRFRYJ22+EQ3L23Ynk2YyiCDdvqLM5WbBoV7F101Ke7LCQRW8qS0sFIVaFKS9Vx+NWCQ/UaLg3z7QAHli17d2VBnMZ6GqMRkXN0lcY5z/BkTCkEVkrSmsQ5TzKzisBjETSKAqdk3zXOgwtCPNqEPfKsniJl33jGg1EK188mTRQdbtRDCIT1KOfJGilpL0cIqLTAKUknSYIMbSRpZQWRsVitKJIITXhPpKddS6kXJUPNoJYrInnY0EbrcA56tYNFkfqMYmiEKMswKOxQA9epmP69G4nWpshP3wxFRR41adDGt5pU//3jmF/+MH7dMPbCk5DjNdxyTva5B3BeMHzzL2Ezx/R5/4QREWuTg9Sfve1RralHgi8M7V/7d1Z//iO0/vb5tP7meYhG/Ji9/4DHFz+JQX4TcNjTcWpq6sGpqak3TE1NHQt8EPi9H9uZDXhCEEr1R/6ncde05alzc5xxxUbuvLfgqOll9AmjHLMpQijJsLfMFoJznj/JaVsiJtfGIGAYx95Fy+zekiQRUDk9yPrkAAAgAElEQVSG8pxTqopt3YIs1Zx0QopQAi2C3K0UcP+8p20USgsoDMdsSah5R6YUlVTMLVis70vXOkuMI49jhIdcKyLrMFoh+sG9iiMQoXkOPJ2RBsKDMh7twnjbQ6Y0XklUWX17bO6wME5E2ivwAlzfW74XRSGTV5JWVqGNCU53SpJgcUDsHZ00oZGXDNkcIyKEAGdd/+cNHnWpz3BIYpvhewZZ10EY5/ijccsFy5/YzdDTN2F//9/g6Scjb34A4SyuW0FWEd/2W0hbYXSNzqs/hi8dcVJhWg06/3g7hy7/Z4bffh4T2yqUNY9yRf3XMbcfYvHcv8U9sMjYbW8hefZjN3c/4PHJT1SQ3759+3nAacDUwx478WFPmeYn7JwHPP54NPvx3nuWDuQcvdIlXz/E2knFZFWyc0GwOFdRGs9a7cilhDUJ2yYU42OK2khEZ7ZECWgbuOwowZ40YcQ4kqLi5npKu5kyN1sxIi1xf587kZ7l0ocmOQ/Hntni6HURTVNRKomJFLv3lsTOBrHZyuOmO2T1FAFkcQiiVqkgUOM9ZX9P30mBkYqoFZNkBdKAdOE5sTUI2y/Vl4bgNRuy+DKNUZUNXfbO4wXgHYWM+tUHj3SO2FusDkY5ijCHbxCUWpGWJfHiSlC547CkPdJZlLRI+jcZkSbpdtAmBzyViejtaiNHUoaPjWHfIsXpxzIkl/FOIk5cj37bUxFDNcxCQf6R+1CbRhCRoDKKKhP0PrOT9Te+iuYrT0eMpPAYeMB76+j96TUsXf5e6r/6JIY+9jLkRONH/r4DHv/8JIgbn7N9+/avETrn54GXAZMP+/+3bt++fTvQI2iA/OJjf4oDnkjsnrNsXXNkQX6h6zn34By90yaZuqMgXs3Yv22cbKFifwWTYzG1EcWuRbhj2nHcpGLCevbWNQcfzKl7wdiwIN21yqGoTr0omDtxnOlOxIna0S5gNDXEpaOHIvb+8OibdJ7LXr6Br+6VDOclD6Z1DILdD5bUjcULOPbMJsufmiVvhEAeGxPq4P1yvBMiBGLnMVpjEdRx6CIIz4h+Jg+hQU9XfY9yAVHR7+pvJKTd/HBHPB5sJDF5+JqUFicl2lsKHZF0LQpPgaadpiSlIRYWmRVY30J4j0EhCX72yldk1AAwYyPI+QLVy/CySXWgg2kb3HCT+ie/CcetofhfVzNiOxT1EeLj1+DmOvRe/VHKcgz5vBNp/NmzEX9xOx05hNSw7ms/h1D9XGK0cdhh70eFfXCZ1Vd+DKxn7IZfRB0z+iN9vwFPLH6sQX5qamoP8P1W9FX957zlsTqfAQMAHphznLf1yBqs7t1XcvbsIrWXnc6tX1xl8/4lpo9ay9aapzYaM3lUxPUPljTrKffMWJ59csx46TFaMf1gAZkmKy211RK3rs6+4TpirqDdTEkix/jxTebvWqE1VKcdKazxbDMFCEGrIVh/bJO1yxlDvQJGgEgyu2hpEhzknvTUEb78ryXdkQZCwGi3h1USXPCCy5IYKyVRZYK8rfV46xD+2zcSOEehI7RziL7qHECtV1GkiqKW0FzuIF1QuPN9LXvhwk1EIy8wUqM82FgRleG9SyK6tZh6WTHW61JOtHDTAqyjIkYpj7ceTQmTTdScxVXg17ZQB5dgooWZz3BKQVEib91DmTao1QVu2zFUBxwyc2Rv/xLROetpbcxYqafMPvtfEd4z9BsX0nvnN0JD4UNM/OhU7Lz35B+8jc6vfp76r11E/dee/O2biwEDfkgMVtSAAf+BR1Ouv+vzh9g31kIqRc0aDiYJrVSzYVuddesjRuqChrHEWrBnwXHcpGRiTNE2cM9tHYZyQ69yrNuWcmKnywMTQzS6JYWUdLqWaCKhZiyJ98H5TQlOXu0gPFz4/FAAG7KGmg2BM48VhYV6ZcmkoupUJEWJExKVCoa7GVUSoYqw71zFUTCksTY8xzvqTYnTEqvDaJw2DukdeS1BVcHaFkDgKWpxv8M+PPKQqLyyHiGCSl4zLymNQjiH0ZKhMijWVUpRxZqocgyVGSutJg6BLx0VGiWhQpFSkDYhpkQsZ+heD4lDrGmCkijhWZMdAC0pTtxKaju4VhPbs/SuOkTtecfSetmxFM0Juh+9H7F/ESGh9jMnQKwgf9gefD/Iu75w0A8Lt9Bj9SVX0vujqxn54itp/PrFgwA/4EfCYFUNGPAwrPPsW7BsnnjkQd47z8rXpvnW+klu+dw8tcUuB09bi/Rw3+6COJUUbct5JyQYC3NtxzHjikhAZ39Gd9VSkw6/qcVFT2px5sIyO1SM3lDHCVgqHatGMjweIWOBBDIEk0WBAM6/IvieVzMZwoUmuWWpiZwjNo75OOarH5snKUqsUsSVpejv5UshMFKAECR5gZUqCNVYR3c26wfyoHKnK4OTkuFuN0jbPqQ97zxVLSHOcqwSOBFK+mmvOrwV4AXUKoPXEgqP0ZLUlFgEnWZMVITmv8hZplWj30dgqVAoLAUxNTLE/CrDdMhkglwJPvLOANbhSsNIuYB/46VEew7ABcfCtbuxFbRecwpqU4uFv7yDpb0xyRmTNPbvQ65v9U1qghPdQ8ihejiYWT3SJfVdFF/YEUbjNg4zdtObiM56bIV1BjyxGAT5AQMexv5Fx3hLUosf+fjcrm8t0DaCu5M61gpOPkYz3RFs2xIx3FIsth2z+wuedl6NdumpxYLbr13lL35nD7lQWCnYvlmzd8mRZAVaCrT1rDlzOMyQD8Xs3l8xPBGRah+EaHzogq+Ab+4NDWK7b1klizWxd7SlJupn00tJxMyDOcrY0D2/GkrbwoTAmtVShIBGXlBphRdhn75EB/tYF/brdWWoIs3R83NhXr5PFfsggNMJUrjCh/ifZLYvoONDlz4OWROIHBQeIaESkk4rJi77FQU0SyZo1wNIHKrffWfRuHbJED26uh6KBY2E6oFltLAkFEgF2bKgVi3Rvn4RgWO1tQ5jJbN/eQ9ursvkG7aisgxWM9Qpa/CdCtGK8Z2HZe3NNJzC7KMP8r5X0n7rZ2m//lMMve+FtP7XsxHpYzd3P+CJySDIDxjwMHYfoTHN8lzJ5/7wfr41McZEXdDwlgtesJZGx9BKBReeVePBQwbbszzp9ITKwHlzq/zr/z7IacMl8WRKphRHN6GMJDtuXKGdJpzQ6dIeSnAIFmNNu+Ooj0RoH8RjPKC9J4skH741BKcD93cxYzXq3pJLiTahdC+cI84LyjgC50l6BUKEjnkgmNN4F7L3WvrQVBxlGpM3aggkXoIwDqcUtSzve8eHIfbOcBPhPFFlg31t//sq73FK9H3oHVaAzEpU4Ug1mEhRSE1Wi1DOB/tbFMhwHbyHCIuxoDBYofEiIhMpdZXjgSjvYktPdM46xljEXXQc4l9uAC9o/sXz4NzNsJwx/8HdDJ03yuTEIvK0jehdB+H0jaiRNDjRNf9DkG+loYox1znSJQVANXWAxXP+N26hx9htbyG+/LGbux/wxGYQ5AcMeBiP1H3Oe8+tX1vkb990J5SG69eNM+Id465kcaxB03l27S05+9SU1a7nwnNq3HtHj0ZpWBSSl76gxWv+6lTwHp1IFvcWdJFM39sBBFtTx6fuCtK2h4xiy8YIFyl85dHekxqDBOaTmI/fXrI0X9JbMSSbGzSVp5KS2DlQgm3djDQvKUfqJFVFlsQhgEkZxsSkQOcVJlJUKmTyjiCKs9Jq4gkB18QaYR3ztSYIQaNTIZynTBOi/t71t/3pBCaWpL0q7PUbh1WS2Jfo0lPXniKOWGjWqWUV2gUBHo+kJQyScEOhcRjCV+cFHsWSHCbudgFBZ/MWRCNCLrSp06V37Ty1Zol618swt02z8IBGVhVrf+dsaus03D8NR0+gOx3it1+KbIUyffhafPsCP5TJz7WPaD15Y+n+wVUsP+cDNP7fyxj+5xcjR2tH9L0GDDgSBkF+wICH8Uia7nqrhiv/aDdXf/gQJ56QcNILN+KVQq5UPPXpI3x9KkMNK0CgE0GKo3sw5+//534iHHdPDnHeSzYihKDbc4yvi1icLtDCk0/WGTEG00xQ1jGmHB0Lx2yM6DpBZkKGvD7LWUxiFuOYLWOST31mCaUFk0fXqHmDFYLIOkQkGKoM9Swj2dQizQvyKEL09WJd3whG953sdF8YByGot1TIwLXAa0mVxujSsNBsERtDbCzCOao0ptbJMP0GMi8Fwgfxm0a3wmhBbCyF1NRdiXSetJ2TxxGdVkqzXTKZr+IRODzNyiDxOAQRtn/L4MM/D4VV4cYjjugsCESsqD+wh1WGKdHo2NHt1Zj92/tpPOcYTL2OWtOAhQ5EiurfdiBx6Jec1c/gq+/O5Jv9TH6h+4jXktm1yNLF76G8ajdjN7+J9GWnP+LvMWDAo2UQ5AcMeBj/VbW7HTet8le/dA9DEzGv+r1t7L9pEX3BWlLhGakMF1+xhnvuyWnVJBeeVeO6a7tsWuhw4OYlnv+UmNpoRM8KnPOsLFf0jGB4MkFbxyiW/Y0aNWPYRcRppqDZ0HgPY+OKpRx6XhJZx6Zezv5GDT2ecNk2zZ3XLOGt56ijE2weZtq9CGIywnvisiIaT8NX74gq0/eDj1HOoZzHeRixZZCxBXpJEjr168E1zsQRqqzII82GlUVUYamSCOE9qjTkaRwsaAnqdGGrwB8ewcuiiIYtKRJJtJTRS2KyWkS9XTFZtZE+lOyH2hkCh3NhTz6hwiMQwWaGiAqLxDlBre5wyzlDfpWVeJy6WKU3to72P9zOeG2Rod+9BDmU4JXCz67ij12Hed8NlCpFxBrZjHDtfrm+/R/L9YQbg0dA9p6bWLrg3aQvOY2RL74StXH4Eb1+wIAfFo+7ID81NTU4Hhwf8fHi0ir9abIf+PwvvPcAl754HWvOOkRnJqc+EnHfgQcojUdpuOPuW8i7jso4ss5Bbv7CAl0luejyLk9901aasUBLz00HHNMHK4TwZE4gpWB9u8shIpySZJVhQydj2krwcNUM3DfrwXkiZ2kaw6pWjNcEa+uCbKlEasHWCUnW13tfiiJ83+ktLipWVzqhcx4QHiolMZFGFhVOSaSHOM+DKI4Q5IUj6ZWYVAeDFx9MZxCCTctLaOPC66xDSEER9ZvJRAjxwkOVaIQDoxVeytCIJ0EUlqpveCO9p1X0gnwtnnqnjUMidejsrxFU7UDQawyTUuCExBtPvWwjJHRoIJWkWSzSTcdZ99mfRbgcsXEUEUt27d4DS138URPQ7VKKIAo0vXs/RBLfq9j54O7D1/qeXTuCGE4a/ZfXkjeW9i9/jkN/cBb1t12IkPInYm0Pjh/fx98P4f2PVs3px8Dj7gca8Njx8amcK68vuPItPzjz+uYnZji4K+NFv7YF7zzv/bnrefo7TuTcj0Nn1XLra2P+/U7Lh76ZcUbT05zvMSVr/MJEh9e98wT+7ps5b/pUwUvOivnnl9V48ev3snWjZnVnh8kJxT/7Js/cP0/rokmWneRrC4JdmUDHgjcOlaw80OZOXeeY1Q7Se2pH17h/fIgT5lfYfGCFZ71sHb/xJYPNHEZKzlhZJS5KTrlzJ8tnb0bsXaFIImplSZYkwUc+L1HCQ2UwSUK72WCo3Wbs7Emm71qltbSK8g4vJGmnB0ry5J33saO+nrnJBstrxxiZWaLTqNHIcpLcElmPLiu8EGSpIrGOtXNtNlWL3K/W0tuQYgwUWjO8nLPFzLC7to5TFg7gG5qZbot1cpWOS5BUNGgzSs78yHrcckZjrUTP9rAXbqV33TSpz4giGPfTzDWOY8NXXoS74m+IH3wnOyf+hs1/th1+88Pwqgso/+gaVoaOYsPSf2ffeR9g/I8vYfmKf2Htjl9CTQZJWfdvt+Kf+1eIB/4Qecya//I6Wn3Vx9GnraX+9ose1XocMOAR8D1Hgh53mfyAAY+G556RcM9Bw65Z+wOfd9bTxrnvhhW6KxVCCk5/wQbu+NRB3nZxglWC//mhFV78jCbjxtFdqlh3dMLpmzXX7LIUHcMrzktIhOfjt1cs9Tyb12v2HDCcesEQ3UMFMrfsHG5i71vhunnB8bOrjDckeelZty1lcjyikpLlOGJDlnPniqaXW065ZIxex3LDZ2Z5zvaEjd2MUkraSYSwjqyW0l02eBE63T1hPt4pSVSWWCXxkabSGuE90nnWb0mDvrwNTXCqn8XXypKVuE6VKJT1xHlB3qyRlCXgUT6M+eE8ZSwRPqje1UWwnk2NZaVZIy4szdWS1ZGEhbhFXBkcYV5fY/HDNTyCjIQhVvAIypUSh0RvGwclKZIGDdemWj9BajvkQ2PUfuY4Oh+6G/oObq5bIayBxQ4uaeCTCFoprl1S3rWASiVqQ+twgAfgC3eBFI8owAOkrz2b7D038ThMogb8lDEI8gMGPIwkErzk/JQPXJP9wOfVW5qTLhjm5i8tAHDKc9bzwLcW+PkTBF4KPt+JGUphy9ERtrQsG8EvvnSEPcPD3PCJadJI8KLTNc57/ummks1bEjILxx2fUinFM5Kc5eEYM5NzyjgctyUJQmze896dnr2lZkuvRxZp2pFmQ6/Lk2sV9y569o/UWVk2nD/pGTYG5T1zrRom0rSbdYRxeCFCyR1QcSihCzzeeaxUlHF02Ixmdecq0jqUsTilkH2f+cnOKp0oPTz6FmUFeSNFFRXCQ1w6otKgq6BsJzxExoKvyIgRscMoRVRY6p2KKlasRHXSqkQCwlpiTCijAwUxTUI5v+XbWCQiM3ityO9ZokkbvXWU1PYoJ8YZevPZdK68F+oJ3jp8YeHgEkhwe5bxo01EIyK/9gDJOWuprt9PfPF3Oln7a3ZAM3nE6yh68mawDnPdvkf82gEDfpgMgvyAAf+Bl1+U8pEbC7LyB2dh5z1nkhs+P49zntpQxLFPmeDQ1TM87xTNdBzxvvfP8YrnNKnnhvtmHBsmNaM1+OTnlvHe8zvPSPEO/vTrJcbCpjHBV77Rob4uZaRXsadUHKwnbF3ucp9KOTPrMpZK7l/0nHt2neNGYTmOyZRkXa9g537DF+82bLt0nI4V3P/1BZSHNXnOog1jcsujQ4cb6kRwhWWhFVTdqigiLoJtrFVhCt8DK/cshTqgAGVskKwVMJr3KNAUscaLYDMblRVls4a0DumCXr5yoSIggaQMjX4ZMWUjotErUP3O/qHVjHYjJbUlUli6pKQYTDdk9nUyjEjwCIYJ+/V+1zxOKsx8jkUR7zhIQpfyqHXE565HNiKKUuN7BlHTcNc+xMYx/O0H8GMtRCMiu3o/tYs3Uly9l+SS7wzy7JyDox5505wQgvQ1Z5P9w02P+LUDBvwwGQT5AQP+A0ePK87arPn0LcUPfN7GE+qkDcXOm4Ma2hlXbOD2Tx7krU9OSBS85w7P5jUKCZjhiC9d0+X/fnqL+9Mme29e5thJzUkTgsWuZ/+i45KLmtx90HHpM4bp9Rznmy6HJhp07ltltus4WVUUYd6N63uSQzZiPC9YiWNi58g6hss2QbS2xgqSfXd1wvy9DeNnC1rTHan3Veoe0puH2VooT1ut0JUB3+9hdw6jNWYllN+dlsRZxUNtL9PDoyjvkH3jGYD6ao+iWUNbT5ForBRYJVEmBPK4slihyYnoNBKSrOwr43kavZIyVigPQnh6JEQYyq7FIqlRUJDghCQhlOulcxROk4qcrmjRGLE4FH7dCEIIms88mu5MKNXLRgT3TuO3TMA9h3ATLWQjJrt6P+mTN1Je/SDJU44+fH2dsbCaI05bf0TrKH3lWRQfv/s75+4HDHiMGQT5AQO+B6+4KOX91+Q/8DlCiJDN/9s8AOtOHiJpajbOrbJuWHB7kvKVzy6yZlPCoS587qouP/uMBp004RP/NA3Abz8tobSeO+ccW7emTNRg9+6CTGvOTi27iciQPHPUUB7VZJswxBI+sdOxZkPMUVnGoXqN/fU6G7sZcibnozeVcOooPSURQLW2Tquq2DM+grdhlA4fuu2FFiTRQ2FfYOIIL8LHQlQZnJJUUvX16hVR+W3XuemRUapII63H9p3b4qzESRHkcj0UcUSeKpR1h9X5KitxSFabNRrO9m8qPF5IotKy2kjR3mF0RIUCJIYQ2CsfYX1Qz3NKoSYSSqNoVKtUk+PUzxnHEKNGQ9d87ZxxymVLed9CCPK7Z/ETw1CPwwx8qilunkGPxYjhFLVx6NsX+HO3BwveLRNHtIbUuhbRJVsoPnznEb1+wIAfBoMgP2DA9+DyU2JmVx237zM/8HlnXDrKg3d1WJ4tEUJwxhVHcdsnDvL2y1KUhK9c2+WSS1qMW0fu4Y57Sy44IWJqTtKZL3jhGTFN5bmnUnQtPPeSBl+/peDcy0ZYPVQykpfsGm2Q3bXCDbOC4+baDNckxnraiaKpg578YhKzNi+4a9YzksLxF4aADvCSy5tsnV2kkpKVRgI+lNYBkmbE6aNV3/vdU8bRYdEZ1S+5V7FGlwYXKUQV5vIia5HeMz/aQvowAw/hAyXOSrJmDV0aykhTpBrpPF6EGoB1Cq0NRaxJ8woQSOGpIkWzU7I4VEN4R+QsJRrZ1Bg0GofCoQg/mNMRKsuprKTJKtHzTiLqdUKQl+EmRhpL/dg63Q/ciYglFBafOdgcGvZcbolPHqe6afq7SvX+yhthKEU00yNeR7XXnjMo2Q/4sTII8gMGfA+UFLz8opT3/ycNeHGqOOPSMaa+ELL5k56+loO3r/CCjR4vweYhQz/lxISDleBzX+vwppeOsG94iKv/9SBaCV59bsShSPPZ+wzP/5lRcgNrJjWlVjy9VrLQTHDLJRes82w6tgbOI7zno9OSQis293qUSjGTpmxc7XBmbLhuZ8VqHCGAjd0emw7NETnPTF/YRkDIvpVgiy4Pl9uRgiqK0GVwjpPW9fXoK1Tl8CKU3Sc6qxityGtJMMp52PBOfbVLr5ViBSS5xcvQjOjh8Ax80YioZSWm6JvWeIvRikZZMVzk9ERC4g0VCo8nokLVNBZNRBjJsxW4xV5f5lYw8rPb8N/aSUaD/8Pee4dZdtZ3np83nHhDxc5RrazuVrxISEIiSiTbwGIwYGBsnMb2M8P6We+M2fU6TfDseLxebM+OPWs/LGBwgLFsMsaAEEJCqBAKrVa31EGdQ+W66aT3ffeP93Z1NwhhrO4W4X7+0e1b5957qk6pfueXvl+184g/mW5O7bpR+nftRlQFbtUo7uA8bu0YSEG1VJK8eAPFlw4Q3n66VA/AfXtgTdNn/P9Mwldfij2wQLXz5D/7PYYMeS4Mg/yQId+Gt74w5pMPFyz27LMed+NrJ5n67AxVaQkSxZWvXMW+zx7jbZcLjBD8zSfmeOdr6yS54bEnc6JAsLYBn/pSB1s5fu0VCTVj+cBjBiEFN16q+Yd7OkxelBAsFBwtBE+nCSuPdXi0DNm+2GEylcwbwdrVik2qpBNojicxa/s5O/YV7NvdR0s/PPfIZ6ZZs9hmdb9P20nsoKeehyG9vqPqDpzfhPB2sUFAfaE9MLZxRLlXv6u1c6zytjVpnhPkfhXPKLXsKQ8Q5YaolzO7ZpS0n9OPQ29Q47z6nrPQrsfei94Jr2onvNhPqmFde4GZsE5IRYWmyhwBfnAuFxEKg5uoYy3k61cTUNIVDRqrJShJnwTx4AFcXkG3IFjfQG0aRcx1cGN17FMzuMkmTkiqmT7xbevJ7zlAdMZkvbMWDs8hNo5B7bufrj+F0Ir4p66j/+fDbH7I88MFDfKtVmtzq9Wab7VaX2y1Wg+0Wq3/+Yyvva3VanVarVb9jOfubrVa97darXtbrdZXWq3WT13I8x3yw82KpuTFVwZ85MFnH5xauTFhcn3ME19dBOCa169jxyeO8bKG4UQU8uH9iisvDhmvS8p6wGfu6fKTPzrCnsYIu++ZZnVTcklZsGQEn9xV8Y63TbBv1nHLS0YoKniJ7TG7IqW3t401lq1NR8cIMJYDuaBrJKv7GT0lqYRELuZsDSucElQIOvuWiFYk9LTXes+k79VnQUBeOdrzFcpZjJRYOfB872fo0q/CSWcxWlNbymFQli+lptbL0KUhT/0e+ikZKm0sSSen10jIYkWv5g1ZTunQCyRL9ZQgL/1UvrCUUqFKi2pXNLM+hQgptfarc5VCY0ApjPOrfvaaDTgkedwgoU8+Oob8+j7sNZuwaFg/SvG3j+O6OaIWEt1xEW6pAB3AYGXQWYc52SdYV0MoibpodPmauvv2gAUxGj+nIA8Qv+t6sg8+giuevfUzZMj54PnI5L8+NTX1UuAW4BdbrdYp5Ym3An8OvP6bjn/T1NTUi4DXAj/VarVeeuFOdcgPO//i1oQP3pt9R1GTm14zydc+OQ3AxEU1xjamLD44AytDdkcRX/rsAm+6s85c2/LZL3e54+YEEynu+vAJADaaisLCf/5SzvoNEesb8NhjXYpIc4Wq2GMC2kpze1KwMFnjsjInkoJD846JlSGXxxX9MORwLWF9L+PkkmVJKWykkP2cYHWNkXUJY4Os3AhBFWg6tZS5GR/MA2PJwxDpHN16iioNwgxc35QkHWTywnmFOllZoqzABGq5jw8QVI6o64cW26MJcZYPbhYcGNCqoh8F1PMMh0RhMNI71OmVIdpaakXBovY3DwUDmdylPgEFAocZaSJDQf9kSY0u6rq1uHt2Yy9dD0KgXnsV/f/nAejmUIsI1tfAQj5dIq9dB72Sar5AjsVUDx8nvH0j4oxqBB96ANaMIPrFcw7y+pIJ9NaV5B/b9ZzeZ8iQfw7PZ7k+BUJAtVqtFYACfhd4yzMdPDU1tQD8B+BtF+wMh/zQ88JLNELA/XvKZz3uyptHmT6UcfKg7+Ff8/q1LDwyx5vubBAo+L8+0+NVt9UYsxYTCL76cMZLro15pB8xd7AHlWM8ckwdsuydtbz+lU3ue7ziljtHWZouWZ9l7J+o0d6xxEMn4ZK5DlEg0MZS1BSkAaGxLIQB40XJLN6fXQtsuwsAACAASURBVEaStJdxbFFwxzbNZLdLXBk6UUihNVkU0etbnGMw0a4B6NYSdGVQxiAH+/LSOF+Wt45MhVRK+ueswwZ6OZNXxrc3aos9+o2EWifzvXjrEBaKmqbey5HWl+9DU3kb2sKQTkgKJIktWUhirBIEVIDEOajhbx6qR44jU00xVyKxNM0C3LMbs3m1V/N76RbsvjnswQWohbgdR9BNRe+4RbY24LoF5XROePHIt5TqAdzdu+Cmi5ZvEp4ryc9cT/bnDz3n9xky5Lvl+QjyN7RarS8Dx4A/nJqaWgJ+Avjw1NTUccC0Wq1V3+a1h4B1F+g8hwxBCD+A9/7vsE6nA8kNd07w4Kf9AF79kia6KHntJpBa8BUX050puPG6hMOZH8D7hZ8Y5Vi9zmc+4IfEfvnWEGMdf3Rfzh13NhHCEWlBphUvSwtOxBG2W/GKdZYsDqhLR+Ac95wU9EPNxWWfQimOpDGb2x0IJQsVxP2c/miK2LeEwBIZw4HRJmWosUKQhyFOeHEcKyWFkqCV35svfN/dCUGW+D8Xwrll8xld+El3p5VfhXNQaokJFCuPLFDEgZe3FcIP8iHo1GNq/T7WSS+8I721r3YO1e3TJyKiJFcaC4SUCBxZvYHGC+PY4x1UJAlERUlIbepx6BWYNAUEaiQm/vkXYB49BrUIu/Mo+rJRsjyAa9bjuiXVTE545TjFPQcJz5isd87B3mnEG1vnLMhHb9xK+bXDmEOLz/m9hgz5bni+yvW3AbcDdw6eezPw061W6zPARr5NNg9sAI6c/1McMuQ0b7ox4p5dJSeXnn0Ar/XqSR7+4hxFZti7O6N++Ri7PnGMX7g5pKMVf/C+Gd7+mjojhWHfkZJO13LxpOQLj+REoeDdt8co5/izB0oKI3jR9oh/uLfLxq11zEzBQuHY10iJ9y6xV0dsn29TV462gcu319i8QtHTmpNxzNos54jV6HaGGYlpF4LDDy1yhe0jneN4vUYxEKHJ4xDnvKCNAGaTGAmUofbrcVpjlKJXD71ynXPLK3jKOFTld93dwEe+0hKjJU5CkJV0myngkA5E6fXqkywHJ0E4cjmwqXWW6PgCBSEWwUgnR1h8Px7oO78ZUBAir1uHMobY9slFTHjVJG79BHap8FWDmib62Rb26Xk/2f/UNHrTKCEF/d1tbCenmssJ1tdx3QJ9+cTydXSPH4HKwOuuPWdBXiQB8Vu2k71vmM0PubA8b+X6qamph4BjrVbrl4ETU1NTL5+amnoVcCvw4998fKvVGgHeA/zVhT3TIT/sNBPJj1wX8pf3P3s2P7YyYuOVNR790jxPPt7jytes5onPHOfnbgiQCj56TLNxjWblpKYbKT59d4d3vbHJgeYIyjlGU8nLL1ZUxvGRx0re/rYJjrShdVOdEsEdosf8REJxuEdTW65apcA4SgQfOWzZ01Ns6PUwUtLWmoluH10ZFi4a42gtpuxW1Oe7COdla480U6ySAx17P3jnnGOpliKcxUoJ1tvIGqXIUo02FTiWxW+MAFVWCOOH86R1VEpgpKCfaJKlHr1minMCbQ1CO7pxRFxWfrBNOEqhENahAkHU86V9i6BelVgnByt/DrHUBSATKXL7WuiXROSU9RpyIsHO9HBLfkhS1gLUuhHkWEz5xX3Y+R7aGtKgR+cvd1POZIhQ4mZ7hLdvOrsf/8H7YbyGrMfnLMgDxD9zA/33PeQn94cMuUA83yt0fwD8EfDZU09MTU31gKzVal02eOojrVbrXuDT+JL+5y/8aQ75YeedtyZ88L4MY7+znv0Dn5jmyZ19rn7RGGuvHiF/aIabNyv2xxEf++gMP/nqOr2u5Ytf7XHDlRFhKMj7Plv9nVfHVMYP4E1MBFwyKbj/gQ40QjZaw1OVZj4IuJGcI42UMWMIAsnXT8A121Mua/i+/JFaytpexrFGjXuDEVZvb2IF2J5BOMd4P2cmiHy321qUtRitAMeErugojbIOJ32IVWWJlYKw8q/PpXepM4EvtQtrcYMbhlL7ITqjBXFeIIylPZaijKOsaer9zLvTOT9xb/C9/VodcqfwRXqHVKCwVNLPCUyaGX8DIDTukhXQKwkwyFV12HsCWzjsvlk/P1Dzw3pqMqH4+G7syjHU0VkCl+McFCdLVDPAPDX7rSI4n9sJ1w125rv5c9qTP5Pg+rXI0ZjyC/u/88FDhpwjLmiQn5qaenpqauoVZ/z7sampKTk1NfVn33TcHVNTU09OTU29ZGpq6uapqakXTU1N3fLNxw0ZcqHYvkGzuin5x8eLZz3u0uubLLYNQQDjkwHXvmEdj/zdEd59e0QkHX90b8FLbkwZxUFNcc/X+txydUyB4NgTS7Q2BqyrO546aXn0mOEnfmyEqb2Gl7xqjPZ8yVV5j6drMfpYj10zlpoxmEDijGO/DlgioF5WdJSiZgxLccSK6ydQgUJWgxUuZ7lseg4jBAtJhHAObfzQnVWK27dpjo+OII13ncM5on7uFXQGZXrn1+Wxys/UK2NRZUW/FuGUQFXOVwisozHfozOaIpyjnwY0en2MkGhnMEIuT97HoqA36Mc7wJaOiBw7kLU95UCHteRdP0TgkMQTEmY6qJ+/DfPwEZwTy0EeLaFX4tIEuf8Esqpo/PL1VF2DSjXlzmmibxbB2XUM8WPX+ced7Jxl8gDxz7bo/9nUOXu/IUO+E893Jj9kyPcN73zRd9azl0qw4rIGifbBcPNN4+TtihYZcSx5UCcc2dvlpTenHO7AJ77Y5c5bE0op+dT7jwLwqy+JKA38wZcLXnhLk1Q72u2KvtbcEpc8HUVUleVVayxSS5oKlIAP7a4otWR9r0ceaI5HERcttRmrBex7KkeGp93naqaiVlUcShI/FG8tRimcc7zwxhTnQFiH1cpPvpcVQWmolM+qpfMDeLqwnCp066KiiP1uuy/3+3W7VYcWsEqSxSFLtYSoKv3KHBXVoFQPEHW69HXsAzmC0khq9JA4CqUJqLBIiDX9x+aQtsIhSW0XbrsM9a5bMXtmcM4ha/486eaEtQI51/NZeaKpv3Obl+53BreYo7ed9oq3+6chK+HNLX9D0ysgPYdB/m1XU3xmD3a2d87ec8iQZ2MY5IcM+Sfyo9dFPHKw4sCMedbjCiHpn8jotSuEFFz9urXs+NhR/vVtIaUS/N4HF3jLqxqMVYaTi4ajxwz1WPCVfYb+YsnPvDAmFI6/eriknTte1kr4/AN9rmg16Z/we+57R2rw5BJF6dg432GyJslK6BtHPRDkUhL1MlaWJVOPZyTdktGsOMN/Di6aXyQXEmcMRRigjKFSioUDPS46dsKLzmhFEWh0ZRjt9aikXJawdUBYGOQgSOvKIis7uDEQA3c6CKwj7BfMrmjSSWMSU1FJ7yrnhEBYf8MQ9/uDs3OApSAgpYe0DmX8CqNFIpsx/Udn0JSgBPHSPOL2yxCbJ3BNP10vBkOAtDPCxeOIuS7uohWIekR1vOcldqf7BDesOX0swF8+ALUIuWoE+gVEGtS5+zMpxxLC115G9qFHztl7DhnybAyD/JAh/0SSUPCmGyM++JVvn81b69j3VMaV19T4xj/OArDttWvYc88M79ymQAo+sRAwVhdsXB8wLxVffThjy4aA/aOjPHjXUdJQ8PqrNNY6PvBQwVvfMsFsH67cmpALye1ll/nRmOpYnwDHlvUh/Qpwjq/akPkkZlOvRycMmA8CJuc69OsauiW5UjghQAjGen2Uc0ynCaXWA516y8N3LzDeGQRCBt7yAta15wc+8z5Dt0qiS+8X71fwvKa+VQonBdK4QQ9dMH5ykW4aExUloTH04ogR08XhV+sSV5A7RVyVAwMagcQS1PzE/wrmTv+QV9Qo9y4iqRACwplpuP1y/7WJxtkXpJ0hr9uEiBWVDKEWkX3+AFI4TLciuOnsjVz3qcdg6+C5czh0dyanTGu+k8DSkCHngmGQHzLku+Adtyb89QMZWfnMf6CPHMhpjGhue/1KHvy0Lx2nYyEX3TzB7JdP8sorNEeikA9/aJp3vKaO7Rt27ysYG1E0Y8HHPr2As47ffGWMsfB7XypIa5KtayVf/PISRahZYw37S82xOEQZy74o4Zqsx0ggOB4EbL0y5qLIsG9ijNkwYG0/Y04pLIIiDZYz8fHQsqKfcbKWYpRCWoNTip0nQVnrTWCEIMp8Fj3R7fhSuhho0AsGNwYs69J7PXr/WFvrj5UQ90vSXk6lFHFRML1ilH7gFe0kUCOnT0iED/JO4PXqx1IARmiTK2+4Y+uJ17tHIaoS1enBdX54zsYR4HD7pn0QzSp46Va0yTAHliAN6N99iDD1NxcuCc6+gI8ehldv84/PU5APXrIZ1y2opobbwEPOP8MgP2TId8GWlYqt6zSffPiZ9ex3P97jsq0Jm66qobRg3yNtAK55w1o/gHdbRKQcf/qQ4aZrE0Y0EAlm5gxveHmNJ5MmTz84xxWrNZeNw4lFy1cOGH7yTePsOOIohaDIHDeUXY6vqOEcHOw4riKnQKKMZacOaHcNq5c6LMYR0gGd0hfCm4nP5IFR7RjvdFmIY3paI62lUgpbueV+/PHREeK+363PZAhSDHrmA6TA+nV3QBAUBl2WVFoh3ekqgLCWsCjp1hOivGR2YoS942uAwYyAzelH6eDcBLkL0FSQ+CCbkHMyHkHgKPsOZQoqGRLKnGrTaoT2U/42qxCBxLzvfuiXvvp/3RZ0mSMmUqpS0b/vKLqmEBjyL58OtO74InRyxJtf4J84T0FeSEnyruvpDxXwhlwAhkF+yJDvkn/xom+vgPfk4z0u35oihODG16zga5/yCnjrrh5BBZKLFzusaEgeiRJ2fn2J17y4xlIGB4+WvOVVddpxxMc+cAyAX39FRGHg9+8p2LY9pRlAUNf0Q80L4or9IsQBr1phsBsbrM5zEIK/3+8Ym29z6cw8nTDkUC1h28w8VgjmjVgO8uViScNVrG13ONCsUwmJA5LcbxBYrciDgKCoqGcZSypZ/j4doCqHVWLgTIdXvCsN0vi+fKUEldY4BHFVkYcBVaA4Nj5KkFccWTHpRXRwpC5Hhnr5HHrEKCpk28sEC+BgcwUAxVyBciVybZNQZFSXbzh9Xn2DSAPM++7HnVgC5zCFpAhTwju20D9pvDtd6NsAxSMnKff4VoC76yEIJOIKf/NxLtfnvpn4p64n/5sduO6zb2sMGfJcGQb5IUO+S+7YFnJkzrLzyNmuYsY49uzqc+lVvsR8zcvG2ftwm6WZAiEE17xhHY/cdZRfeUmMkPCf/2aJN76iTmotpYOde0pal2imZjVLJzLedF1EqhyfeqJkumO5ZK1iLhdcf9sI7eMFaVZwOIkodi7x1ROCKxa61EKBMY76QocRYzAIlkLNeJazGIVEAx16gCozbA4rNi51OFZLOVlPUMYQlBUWvwK3enYe6RzrF+dZiBLObFI46W8YvFKeG8jW4jXqcXTqKfJUv15BWJQ0On2e3LiOxkKH2YlRrBAkrqQQmjAvwFkMAoUFFMx1EXjxmNGsoERSHPeBP712BaHLMFdvPn1OuQ/yYt0o9k++AKHCfu0ghUwIW2soOoLoslFc4RChov7TV9P+k2/41/7dQ3DZ6tPCON1zuz53Jmpdk+CWDWQfffy8vP+QIacYBvkhQ75LtBK87ZaY/353/6znjx7MGRnTNEf8+lacKrbfPsZDn/eZ4pWvXMXBh+Z586XglOAzWUzZLRgf07St4K5/aPMvf2KUgyNN7v7rowRK8I7rA6yFD36jIlZQOpic1BRa8XKV8VQ9xczmXN2oWFcUPku3DtXL6TRSNve64CAoS7pxiFS+HG5P7bzP56TWklQVeybGqbQizgqQEmksK+YWcUKwqrPIfNo4o1Av/I47g3l4cTqbBwjyijL2E/sAVaRJezmXPHmEbhIT9XOqQLM0klJzOW1igjJHOkuFokGbSijyFStQWByCDfMnyWWItIaSgHRDjLY57qr1y2flCouINepdt8DfTkEjwtyzh6wMkNJh6zGqyLG9CpGGNH7hWjrve9T3779+AF56xekL2j5/QR78AN5Q5nbI+eYHLshPTU0NHw8fn/fHP/vimK88WfKnf386E9uxYydRJM86ft2lKU8+6vu+UU0TjFqYL3jPKyIWA8U7/9Msr74tISotjz9d8vShkotchw88rjDG8sY1u6kcfH5XjnOL3HCR4i8+1WH8IoOcKbBOMJ8GjO2YoxCCiW5OGggOjdSJ85LRUe377EIQlQY9sIutlEQ4R5UZENAsCkol0ZWhCDV+es5hIj+YJq0jSwOslANLWZ+tG+klbu1gml5XvlKgjaNSyvfqnSOLQpJeQbOXeaW8WPvhPGORGAoClPRWlDmaJh3veV+v4xAUBFSE5CIidj2sVOjDJylVjC1PXxebG/TKhKfyWTi5hNg4jtlxjGq0CftnqKSD0uCEpMpKhJKIUPHQVx6A+R7iddeevtZ7TnCivnx5z/nvUnjnJeQPHMINBhu/V363h4+/Px9/O8QP4BrHD9w3NOR7k3ufLHj3Bzt87tdGGa9JTh4r+OPfPczv/OGW5WN23r/AQ/8wy9t/82IAPvorD3PDmzew4cZxrv/9RZ447vjtdRk79hlOVIKx0PHyao67xCSvuC7i3/zcBI1fX4K84q/uVBzY1ePRfSWNVNA52KNbwtYgY38WkAeKHetGebzS3PnUQa5baHP4FZfxyDHLnfsPkWReF14BYjSChRwBLNZT9oyNMBeFbJ9bIOnnrDkxQ57EWC1pzC3x0j07+cLFW7GBIun0EQ506Qgqw+JIhATSToGoLFktAK04tnKctcdmWXN8icObxthyYIbxbocv3LqdqJuxd/N6br/7MTa1Z6iMojGucPNdFl3CJezlaTYj1zcRhzus5AS5TunZiBG7wHSylo1busRPH6X/229j5f9yPc459unfI3nj5ax62ybcm/4Q97qbKKaOM3fJVlbHJzj5YIYYSxAzXarFkvEPv4HO+x5lxW+0cLf+LnLmvYixmr94P/2ncMul8HMvO2+/Q3Ot/0b9va8hvHXTdz54yJBnRzzTkz9wmfyQIReKF10W8iPXhbznrzs450hqkl73bKGctKHptU/37pORgP5SiVaCu97VQCv4LwcCtIKLVmlmneS+dsp73l7nEw8VfOPxPpM1QSOVvH8/7N6V81v/ZhVPnXBM1KEvJbIZUR8RjPYLXNdgpaBqJDTaXQ7MWwolsVoRV4akKLFKsmpVwFIc+r12IYkqAw4KrclDv9qWRyG9MATn6OsIId1gUt4NavSGMvCytMpYpHOY4JQTnSIPNEZLJIYy0KRZQYDXvs/iiKCqls1nJA5XD3EOMmJqdIkoMdMZCkNHN+nFERWKlC5M1AhOzFLVGpgZPwRpjnYACMdDmF7CGQGjNexEk2jbBOYbh6FdYBcLCCRyNCa7/wjhtavgc49DEpwO8AA7DsO200N954Pglo2U9x06r58x5IebYZAfMuQ58Gs/UmP3ccNdUzlpquj3LPYME5u0qc4K8nEzIFv05dmLJxX/9xsSuoHkkVLxmptiGpUll5L5tuBl20N+/U8XGEsEcaLYNWPZpwOcE/z0j9RZmi55YKLJ0RlLo10wnYREWYkRgl4Y0uhl9LsVcWnohaEfZTPG/1cJ8kk/LW8kyzazujJUWoMAnZe0aykC6IUh2nlFu2UJe+ltZREgK+cV7gZtAKMkOOcV8AJFmFcoa9EYr2cXqMGgHShn0bjl/f2QApGEaEqCvI/CUFQBGQpjNQpDsLZGtLSIGRuhmvVBPn/0JMZJdODgyaM4GeA6BYWICDfXcJ0cocHMZYhAIcdjyodPEF63CnfvU7B58vSFNRaeOALbTvf7zwfBzRuo7j94Xj9jyA83wyA/ZMhzIAkFf/SOBr/xt12Oty1BKMiz01aiaVPTWzqd3SejAf1BkAf4+Zsjbt2i2RnH/PXnOrzpBYpcKT708UXe/to6UgmWZkoWc3jf2xvcpyO+/FCPO14xQoCjkpJyZUI3CFnX6aKtIy0MohbQTWMu77ZpFiWdQJMNdOiFEJzYtcTEJh/kKzX4mvSlfG0qnBDIylcFcNANI4QQiIFNqhO+K2+0/xOijPW79QO9eislYV6iEZShIihKlHNIvMiORRBVlc/irfW69P0KB6T0yWVCJTSaCoXBIih1gMJQERKtiAiKHmblKGbGD0Bm9x6BUEM7hyePggV7cJFswRHJArtxFXrjCM55xT85nlA8PuMz+R1H4fozSub7TsKKJjROrw2eD05l8j+AbdMh3yMMg/yQIc+R7Rs0P//ShF/5UIe0puh1Tgf5pKHJOtVydp80zw7yQgj+8p11GsrxaWI42mb9GEw7xe//+Tz/8ZfG6HYsvZ7lho2aN16m+HdfKTmyr8eGLQnSOka2JPScZCmJaVQl2jkWSsFiPWX1zCKjZUFPK3KpcEIiBARZSTjTB+foBppSyIEuvSDpZ1ghsEpC5W9QemGI0QppBkFeSqyUGClwUiCsGwjinPrGoNbPUNaQxQFU7qxhmUIpEuM95Uukt5Sdz6mQJPTp2JRShoO3slgEVipCCgpiakFGISPkWEo1KNdnDx5HrkpxMz3YfRzSAPvYUXpHCvTCEq5ZQ61KIQ7AOkQtxLUL1KYmnFiCl115+gQfO3Tes3gAuXEElMDunz/vnzXkh5NhkB8y5BzwSy9PyEpHhqDXO525KyUIE0U26NXHIwH9xbP361c1JP/v21NS6/iPRxr81CsixqXj0JJj6pE+29YrRvOK43MVv/W6Ggs9x998vsPGSxMuXqW5Z5fhmpeNIQ1MVhWlFPSB7lidkdk2Y0VJV2nkqYl469CRROyawwlBL9BoayilxAyCvBOCLI19Gd86siCkCALEIOOsBpk/eMU6Mfivl7H1a3y1Xk7cz+gmMdL4m4G+DABBL4nRwvvVG6kxSmOaCTkhKX0W8iaVDL3rnJJYBOSWmIyciKRqk5Egx+Llcn25a5bw8nHv8HZ0AUZTaMaotU3YeRRTgKgHOClxg/19tbaOeOqEbzncfPHpi7LjEGw/v/148Dd5wS0bKe8f9uWHnB+GQX7IkHOAVoI/fHuDY13HkwfLs76WNBS9JR/Yk2ZAtlR+y+vfeG3MTTXD3iTiv99d8L//whgms3ziS12u3RxQSsF73jvLmlUBd5Ax9UgXOR6xZX3AhpWKex/qczKNqFlHaBw9qVhIE5qdHs2iJAsUtcKX4TUOM5qgqgojBH2taRYllZQEVUVUFFgpCcqKQmuUcWSBX8U7lclb7U1oQHj9+oHRjLDO3xg4RxFq6llBLw4I8goEZDpc1ryv3Klyv8CFirIe0ScmoUdhA5y1VGhsGGCFIjCQkFGkNaKFOTIboyZizEwf5xz2eJf41rXYk21cp8SNpLh1E0TbJ3HfOIQ53kVUBltYsA6bGdRkgrtvj9/JueS05SyPXZggD74vX9437MsPOT8Mg/yQIeeIzSsUW9YG/PGnOxTVmcN3mn7bZ/LJyNnl+jN5+y0RF2cFHyzrzB/ocVsrYdpI7nugi0k1e6ct/+PTbV54ZcQWV/LHOyyjieBFL21SVHC8mdDVmhcuLlFJ7w4336wP+ucQVSWdMEBWBlkLKQM/TNdXinpZIp3DOYcetBbiLGe0kyOs93OPyxIn/Jb88oS99BazYhD8hXODTN7SrqUgvB2tshbhHL0gwCGIipK6dmRpiHJefc4VBokhUH7iPjVdKjTOCawDVVgCCuRkneDYNDmxz+TncqpjHZx11F++EXVyDhdEOCEp05To8hHsoQXsfIY7togrLM5Y3FKBrIe4L+yC1SNnW85eyCB/y8ZhkB9y3hgG+SFDziGXbQgYC+EPPtNbfq7W1Kcz+dFnzuQBNkYV24scJ+EXPlXx86+rszqGfgWFcbz05pT/+vEuK1YFiG5FbWXEzuOGpRze80uThLnlvokRxsqKVXmJFpb50Qa5lIxkOZVUHK+nKGt5wasm6SQJhIpcSWplhXIOO+jLC6AKNI0Zb7BjpaTe7yMGLnTKmGWVO11ZgtL63rwblOsddNOYMtCERYVAoJ2hHwR+ct8amllJHmsCZxAY1GKflAybxgjhaNKmQnmteUAOuvpyVYI+PE1BjBUSmWr69x7BWkHUWoXqtnFW4LoVRa6Iag67aQV62yrs7lnUeIwzDjPdQ4QSvnEQtq09fSGyAg7MwGVrzvWvxzOir1tD9eQstv3MpkdDhjwXvueDfKvV2txqteZbrdbdrVbr/lar9UfP9zkNGfLtqNUVP7ot5MP3Zzy4zwfzpKHpDoJ83NT0F545yLuTPUIl+NnrvB3tv/zdE/z7fzVOVBiqyhE0NRevVtz1hQ5WSf7bW+s8fKRi5/GKq6+p0RsJmFaSz0+O0Wp3GekX9GoJpjKM5BmdKGT/SBPp4PDTHSJhMHqghmcM0jlKKSm0QlpHEQZMzrWXs/dmr4eqjA+sxi4HeVVa4qwaDO6BFRKspZMm5GGAziuUMSjnB+icEEjniA4u0a8FaAxVXiKyioQMW0tASZp0qNAI59f2QlFgRECcGmwjBSFxFvRkTPdzB2A0RsUBQVCABTfdpXe8JMx72LEmassYcmUdOZniKuen8ksDT8/AbZedvhBPHIVLVvlJ/QuAiDTBdWuoHhxazw4593zPB/kBX5+amnrJ1NTUzcBVrVZr6/N9QkOGPBNpzQfA//TmOu/+izbd3JE2Ff3BrnyQKJx1lLn5ltdO7+mwZa3kR9dL1o0KPubqfO3eBV71wgTp4O++1OX/+LlR+h1DJhUyM7zzpojPPVHSzR16VcxqY+hqxTfqNfppDEqi8pJ6L2cxjphL/UrYI1+YpasVxJqkqpDOoa0lk5IyjBDOUgQBo0vZ8lT8aK8LwmfyZhDQAaRzqMpShmpQBfBGNSOdDt0kQueWWpFTSUk4aGOMzy8Rz/UJnMMg6TVSG3dypwAAIABJREFUjJVEFJjYZ+ghFQqLwWvkxzajpyNi18esW4FwlqoEPZmQPTSNvmgUAE3hfeIFFMcy5NFZLAqaMXr7KtRkgi0dekMDji+AdcjbLj19IS5gqf4Uw778kPPF90uQB6DVamkgAdrP97kMGfJMpDVFr2t59TURN14c8Nt3db3q3SCTF0KcJYhzJif3dLl6a8Lup3L+/mfrSAW/+jXJG18QUAmBrRz/30eXuGWTYDoI+NKXO9x5ZUgjEvzbv+/SsYLrVwhC63i4UaPvJIH1Vq6NLGch8ta0uVI085JDMqS+OqZWeRW60BhyJakCDQiUMZShxuLAwVi3TaUl0loYlPQBpIM88up2TgrvQuccm4/O0E0iwrwirkpyrZan88cXuigcK+aW6EchvUZKSUhAhcut97THoUIohd8MiFzGfNIgztpUk+NIHKZToSZiygOLRNeuhLJCliUuDHGrRggvH8c9ctir4lmL2uaDvDOOYOsK1Ik5sA62n7Eu99ih8650980M+/JDzhffL0H+hlardTewEzg8NTU1/L9hyPckPsj7LP3f/U817t5V8Him6bXPEMR5hjW6om9YOp5x0y11duzO2b5G8VuvipkPFf/6v3ov+Mms4uG9Be2TBWMTAe//Qp+R2K/gffaJkiNtw4SpGItACViIte+xD3ry3SDACZhPIhQwHQTMFoLJUa9SF1WGTCmM9uYxYVkyvWoEMRC8icqKLPK762E5OH/jvCJe6jNnNxDMEcDEUgdlLcpCbEv6YTDIySHtFkhjGF/osFhL6BsvkAMCOd0mcn4tTmnox4PPpGAhrRPML1DWm0gF5UKJmoxxCxnJi9fDE0dwKsJagWnWCa8axz5xHHN4CTvd9Zn8RIKrHOF1qwjmF6AWfpOc7YXP5PXNGyi/ehhn7Xc+eMiQ74LvlyB/qlx/GXCs1Wq95fk+oSFDngmvX+//UDcSyXt/ssGfPCE4uXA6yMcj3zp8N7Ovy8SmlPVrQ4xxnJwx/K8vi7lqjeLLQY1AOPSWhKXMMn8i511vHSezgo98fInFvuNP3lJjseMd7i5eF6ABURoQDpUmVEIQDHriu8d9WXu9Kzi84Ni8QiKsQztHrpUvxytFlJdMr2xilVoO4GWgAHw2D1glBw51Pkt3wjvWnTomzEvAEZqKbhQOHOxA5xWRKWn2+kyPN0k7GRE5Bo2YSKjjdehVUZBJ3xuXQD+NUMdnyHUNKaFYKFGpxhpB8qK18I39OB3iCkuhYpKVCrdmDLVlHLtzGrV9NXIyAQfhC9cSVH24+IzVOXheyvVqdQMxFmN2z1zQzx3yg8/3S5A/k3lgxfN9EkOGPBNe8e50QL/50oA7L5H81Wy0LF36TGt0J57ssPLSOkIItl4es2NXhpKCu95VJ1B+PmxeSa5YISmk5G/+sccWWXLfEyUzbcvqEUUcSfozBesmFSOpQBtLGWpwjumxUaQDAyzUUxywsdMDBF+d9uX1yBhyrQnzgkprgrxiaTTFBAoH9IKQwNrBHjwDeVoQ1ovjKOuH8U6t05VhgKqsD6gYOkGIHPwMnBEEVUViSk6OjxD1SoR2VGjYMkGDLg6BNAYrFQElIBExCCkoug4hHOViiesUXiZ38wjuof24ykFhyPuKUBbYlWOo7aswBxdQl00gx2NwEF29Ei3KswP6fBeW+rBpkguN78sPRXGGnFu+X4L8DYPp+i8BLeD9z/cJDRnyTKTP4ET37hdHzFSSj3zNr0g9U5A/uccHeYBtV0Ts2O2P3Tyu+OMfT3ACDh4qedPNIaVW7J02jK0IuH6tpF847t9XcP1qia4c8yUksSK0liWhqHe7lHFEZC2VFD7YC0HQL5GB5MmuP4ekrCiUJMgLrJIo64iykjIKEA56UYjmzHKyG6zHOZxwCOMDuKosylh6cYizAy96NTC9MRacwzqJU75En+Y5uQ3o1wIqocgnxokoqFAgBdJATB8nJaOmh7tiHWY2Qwpfrq+OdSAOEFLAA3tBK7CO/rECvdjG6BC5uoG6ZAIRakRlcYC0BuEs9qoz+/EHYet6P2B4gRn25YecDy7MjshzYGpq6mlg7Pk+jyFD/imkdbVcrj/FyHjAHe15fufvAm6+JCBu6m8ZvDv5VIetr1wFwLbLI/7HJ5dwziGE4KdvjPjVTxYcs5pPfnya1k0NPrrL8lTf8cKLJVrABz7e4eoNin6q+fzukolEkBpLRysa/Zy9Y6Osdg7rBKWU9MOQuKqQ1nJH2UE4R1z6NThpDFWgEdaR9HoY5Uvx3SBCG3vatHpgMTsQtaUMlLedtY4ky2mPNaktZUjn6IUBpVJEZYkArBTIylEIzfhSm8po5iYbTLR7dNuSMSxdUcM4QVAZ6nRwUjGSL8E1GzH/mBE4S7lUYXt9SAKwFvfoEdzkGuyxDFc4xJ4T2CWNDBV6u//52nlvaMOjh0AIzOpxglPf047DF7xUf4rglo30//iB5+Wzh/zg8v2SyQ8Z8n1Bmkr6XXOWq1ja0NQXMn7x5Qnv/os20TeZ1NjKMbu/y8pL/PDX2tWaqvJ9efAT+S+5WOMQHFx0rJyQ3HBVxKKQPPBkyboxSXvREJ/o04s0r90aMN02xNZQaUFclBxNYnRecHm3RyUl3SRGWctoQzC6lPnytTEYKQeBG0wgSfvZshNdL4zQxg/c+e9OUGoNOBSCMtTL0/NJafyKnfMqeJ0oop8kOLwDXJ6EBMKRyYCJxQ5YmB5t0E4Sqr2zAPRESq4VcVWR0AcBo/1FxE0XYWb6CGup2hX2ZA+RaNh/EhdGMJJSoQkvaWIfPox5ehG6BWr7av/zPtbxKv5f2+//HZ/hNPc89ONPobetxB5ews71vvPBQ4b8ExkG+SFDziFBKJFSUOSng3wYe8/1d93iV9geOOrOGrybO9SjPhkRpr6w5vvyEY/vPq2AtnlMIBRMliW/ea/lV9/WZFSDtQ5bOKbjgBN7+8wIxTteEDGeVywFmjgrvY68VoycmGVlUVCrKo42ajghGC0LyvJUT95r2QvnUJUhj0Iic2qi3pEFAcHAlQ7hB+vaI3Wc8Ot25tSKnBBIICgq5CDId4OQXhJRDqRj282EEEMuNSOdHlka0ujnzIw0CI/5IN+xCXnge/3gpXRH2vOIWy/GdkswlrJb4Rb7IAV842lcow5CULqAZH2Eq6eI0RizZw61zQ/YVU8v4AB375PYeoKdy05fwAvkPvdMCK3QL1hH+dXDz8vnD/nBZBjkhww5x6T1b+3Lp01N3rG89+0NPvmkZfpEsfy1U0N3Z7L18pgdu08HnxV1SUNBEEh21lL+7X85yW/84jhGSLpLBqmg4SxdKxlPBZuqgiNRRK3bpwg0kbVkUcjXRxpcvtRlbb9HoRTl4S4gkM4SGjcYpLPo0u/ICyGxwsvbeLMa4wMkvvde62SUgUJXlkp74Vkn8BP51nlLV6AXBlglvBoe0GnEBKby9rcVuNARliVzzTp1swSARVNGERLjdepNRVgUiEtXocZjhJbYzOvm28z4yfoK3GJObiPiusOtn0Bftwbz2HH09tU45yh3zfqKwo6j2LUTmJlB5uzcoFy/8dz+QnwXBLcMRXGGnFuGQX7IkHPMKUGcs54bCOJsnFC89WV1ntqfk5c+2z9z6O4U266I2LHrdCY/kQpSa1m/JWa8JvhgnnJsT5crtnj71xXdnMhanJR88d4uo/2CTqwJipIs0ITGspTGdLTieBxSNAel8KLE4rNyNSjCGwFRv6DSygc+6zBKUkmFNoblprxzjM93qLREVad79VYK8khTSklgDM4BTi7fIOAcjV4fcFRCUVlF7HKMlPSj0OvXI1EYrBTeXlbEKAqWJiYQUqLGQog0zjisUpiFAju1HzfXx013yIkIqgwTx8jLJ3HtArlpFHOsc6rXALMd3BXrsLODHv3hOUhCmGyco9+E756h7eyQc80wyA8Zco755jU68Jl8byBt+6M3pyTG8Huf8hnkySc7rLy0dtbx61ZrytJxcsa/ZqImUNbRWBvzt++qgxL84j9U/MyP1Qico0AgE4Uc1Xz8yz3Gel7hbrKXUWhN5CxLaUJsLE/XE8oKisivtAlrEdbhpEQCpVTE/RJhLU5J6u0eRaAxwovmnIqREh8vpbGUWi1PpIdVRTuNMcoPzeH8yl2cFcuzCivnF8h0CEqQE9Aou7RrKbVO7rXs0V4et7TU6FCNNtGULK3yJXc1EkGo/cjfZA2ZauzUQRivIS5fiUEjpxcwPYsciVFbVyKEoPjGCcJrVwECE8a4q9ZjZwZB/nks1Z8ieOEGqgeP4KpvlT0eMuSfwzDIDxlyjnmmNbr0TE/50ZCGM3z0wYyv7ikGmfzZ2aMQ4qxVuolUYKxDTkbcepHm3S+OOBaG/G9/vkA3kCjjWKgEKxLB+nHJZFZwOAyp5wVOghKOXi0mrgyVE/TX1cnjmEor4rxYFqmRzlFoP3ynB05zkycXyOMQK1hWpQO/GueU17IvQ02p/eBdUlaUWmHxu/oORxGFg2qARDgY6fVZihOwjoKANO/Ri2NWLCwAUAlNFmlqZUmNDuLSFShKOqt9kNfNEBH6SoNY30SPhZg+sKoJl6zy38/Oo5jDbZxxqMFkffHwCcJrViJw2MIirlmPPVWufx6H7k4hxxLk+ibVYyee1/MY8oPDMMgPGXKOSWuKXu+byvXN09K2UV1T9g3/54/X+Ffvb1MGivpE+C3vs/XymMd3+b78RCoorKAaiwD4969O2DQu+AQ1SgQ6FCxKRXU0487rQ3paURUGbQxRaSgrSxkHRNbvqc9aSZzlzI6OEJYl0oEVAm0tpdJe3KayGOn1762UOARmYFDjM3iHlWJ5ij4PA+9MJwRhWSFhMDQn6KcRldI+48f9/+y9d7Sl2Vmf+ezwpRPuuaHq1q3UFbqqWh0lVR8EQqKVA8kSWiRhY0Q2jNeMhzXDALOWx8wajPGYBZ6xvZCRlzAGEYQDLINHCLCEgFY4HdShOlV1V3XFm+896Yt77/ljnwpdXd2AqKrb3XzP6lp94nf2Pefc+37vu9/39yOuKlam22hREVJhVcDsYICW/j0yTjKKQqKs8rr1B30mP9ztg7Vsawikz/b3T6MjsNNToBRmuk1Ahs0tFAZ7ro+edNYXD10O8iZJkAdmMRfL9VsgZ3st/Lx8XbKvuT685oJ8r9erL9eXt/RyoyV56omTL7i9Oa0Zrpf0ej2kEiRTmtbqI8xFjvU909c8zuEDIY89uQnAfAvGUrJS+V/ZRx5+gF/8UJNYO6Tx5fpQQq7h5JNjhlHATFFihSCwlmZRMZ404AXGsJ4KkqrwI3Di8p+BwBjGYQASlDUY5ZvpKqUmj7gsEnNR9Q68h3xYFDghMFpOVO/cxf8oAo0TkjJUKGMJTcXKTJvQlETkWOGPH0g/daAxFFIjlaUgYmN5GUVFsW/evz/GwkRiN379PKQFVVFhhwV53xFS4ZIYdWQb/c8+gz7q/eL7j5xF3zYHOEZzTS+gUxp/zC8+C2/ct+XfH9EIOPPo8S1dQ3351Xf5pRBXzvO+RnjN/UA1ry5+/3dWqCrHB77zsvryQ3+8yjMP9Pn2Hz8AwCd+6AHu+9Fb+eBvVXxfucSP/os7XnScpZWKn/rZJT7287twzhH9eJ/v2lnyKz/mJVc/9vmc//mTI2aLCuvgXet91rc3eN2M5dwzI/7j3Bz/1+cfpt9MeGx2mqW5Dp1hyvkwpBEFdE+exTYS9pxfxAGD6Snu37Gd3WsbvOORk6zNNzGBJhiVrM622Lm4wsL6OqtJC+EgLC1GQmgsm50mo0bE9PqAhjH0k4gi0Ox/fo1wWPLU7XuwGm5ZXGV1bor7Hn2CT73pHr7mS0+SuILhXIMvHj7CdzzwaZplxpgmj00dZCHt0yiHBPummD/1OI//6k9y9LsP8Pw9HycYjTj+bMzrv/h3OP2WT3BYHqfSMcu7j6CePs9Mc0B5zyHMsWVml38KESjOHP4l5n/vWzl7x79l+n0LhN/9JtLfe5ptP/d18KZ/DBf+Ncity31cVrKy918w+4UfRh2c3bJ11LwquaZM42suk6+p2WqaLcXoqsa7uZ0Ra+cvd8tP70lYfn7MSurYmVx9BE+rKRlNyv5CCOYjy+KZy8c4tmjInCDQgpGUhMYgcscw981xATCII79PbgxDoby07URzHimQ1iKE8CNvztEpKzaaDZxwOPzM/PL8NFMDr33bKvz2gR+TE9iLf1aEz/altYyTyJf1cVghCZzxpX/ly/bt/ohcau5cX8Q5iZSGZxcW6GyOaFUpOSEZMdI4EjNirJqosysUImR6r29QLJ/vY9ZzHH5+PjYj2D8H0wn5qTFBQyJetwCLfYK3H0BMsn43LhFLm0gcbmaK6okVgtu3wacfhffctaUBHiD/nccJ7t1VB/ia60Yd5GtqrjPNtmI8fOGe/OzOiLULVwT53QknnxmzswFRfO1fwyQWlJWjrHxx6vA2Rdq/bFH75bOV3xtPFA0FuYBIWDZHFuP83vjZqSZRWbEjzSikJDCOURjgHATWoYzXcRf4LvlOntOPI0otEQIsoJylOfLBPam8LK2TvlVP4jvnAYKqIiwNeRggrUVPNOJjU6JLQ5BXjJoxrVHOOIw4fDAgJ2IzSViZmqIMJNI5BrTIiAiso2WHFK0WUTUmlzHT+xqY9QyyimqzQGpB8cgyU3YD7t6N2zFNNKPQu5tw2wJueUjw3kOX3jOXVvDMBQQWE4SUF4P8px6B9979N/vgrwPpR3skP/xVW72MmtcQdZCvqbnONFuK4eCFmXxzWlOVjmzSdT+9O2Hx5Ji9iUVH1/41FELQTCSjycz9Gw8EFE6wPvGif+yCpW0MwZSiE8BaELCrBf2+wTowCI5tnyYqK2aznFZZonGkWnu3OCEITIWVPmMPqoqZUco4DMgin/mO45i4KCkDr8anrZ3ss/sGPOEuN9/FWUFgDcJapHNoYxAOhHC0RymtQc6glTAzHPsRu8n5yjN793LgwiLT+cC/pmiSEROWBk2JmmkQkpGLiM7uBvkTa+jZCGMFuqXJ/uI0DZnBdJPCBIQU6MNzcGAbYpgRvu/wpffUjkv4wgmkdNhhRfnEKvrwNPzJsS0P8tXji5hn1wi/6bYtXUfNa4s6yNfUXGea7ReX64UQzC5cLtl3dicMz2fsjixBrK51GH+spmQ4KdnftkOx0oj4Qm/IMHesjR0zlaHZkMTCsRloWtYQ+kI7pRQ8MeNH8zKtaJYVRgoiaxDOkcUhYVliEEjnkJWhMxpjpKTUCicF/WaDoKrIE1/2t2Ky8Scujtx573mBYNhKkAjkRPveSV/LN0rRHmWEzhDlJe0sY9CIGT6yQihyVmc77Fte4vYzpwAIXEmJRhpHiUYHjoiMUkWoUFI8sYaoDEZpgumQ4sHzaGGwqynjMzlqPEIf3YUtQTiL7PiJBGd8t7144DlkU2NWxpjnNggGfdgzCzu31gcr/WiP+PuOXtpaqKm5HlxXF7put7sfeAh4GGgAv9Hr9X7xivu/C/i3wEKv1xtObvsMEOGtrgXwy71e71euOu5sr9db63a7/wT4WUD1er3axaHmFUmrpRgNXixmMrsQsno+Z9ehBtO7E8xaxi5tCF6iXA/QbkqGk0z+1jlJPwl48pEx2460SCTMYWgEglFhGQSabG1IS0qMglIIRihGjQgHtIqCEkFi/bS7VROlOiEw0pfKk7JEW8soCmgIwdTmAOEceeRH/HLl/drspEwvnKMIFAhIoxAnBcJajJIgJU5AHmiStGB1oUUyygipGDVCqsWS/lSHbf0B7SyjXa3ihKDtRqzTIVCG1DTQw6Gfzi8lzjnyJ9Zw/QwXxwTTIe7EaezuWdyDZ6iCOYK1DfR9B8j+5V9AO8J+7jjqW96ASytEEiBOnEEu3Ea5NEbvbiM+8/iWZ/FuXJD9+peZffBHt3QdNa89bkQm/0Cv13sH8LXAj3S73SulvD4M/Dvgg1c959t6vd5bgW8EPtLtdt9x1f37ut3uT0+O+eNAi5qaVyjXyuRhsi8/yeQbMwFUjh1Vjo5eJpNvvDDIj5Ri8fiIYxcMWMeO2JEokJllFCrKsSWsLFJLGtZSWDg70yYuKtp5SaYkzcpn8uKiSyz4ufhJmT20jqWpFkZKpjdHcFH0xkEWBCAut/E6AUXky/+dzRFVqH2QFwKEF74ZqwBdWooooDHyP7+TgsJqLszNEqcFgamIKTBxPJHbEURkjGig1zfJRYwLNfljq2QPL0FeYaQi2BahhinyrQdx5zYJ77sFiyK4dxfmiSXE/jncZ5/2r5lW3q1umCMPb8euZ+jb5+APH4X33XM9PvqvmOy3HyP4mr2ofdNbuo6a1x43slzfAEJAAXS73e2Tyz8LfOe1ntDr9TaAnwG+6wauq6bmhhLFAlM5yuIazXeTIF8a2IhC2qP8JffkwXfYXyzX7+0IUisYreQcO1ORW9g9LYkrSyRhjETEkiCvcFLQwhIp+OJ0hyQv6OQ5gzCkXZZExmK5PP9eaT1pqJPEZclms4GwlqCyYO0l+9liksnLiTNcJSVVqHBCsH1tg1ESIY1v5btoO2ulokKSNUKm+yMKNIExDFWThhkzCiKs8CX/LGpSEiBwtMyQYmqKKBuSqxi30Gb0R89TPryIQ1CNLXo6IHAF8u2HMElCvCtCaIlIAuzpTeSbbsF+9hlg0lk/OZ/Sd87jhgXh/rb3lX/r1u6D+4a77pauoea1yY0I8vd2u93PAeeB/6fX6/Unt38H8Iler3cBMN1ud8dLPP80sPuq2071er3/A/gL4J8Dwxuw7pqa64IQYjJG99JB/uSyIW9HlOvFy5brW83LjXdaCeZbgqVOgxNPjKgQLOwMCQtLCaQIsgp0aTEO2sKhpGB1d9sHzSJnGAS0y4rIWnIhqLTypftEX1w8SZYziiNUZQgq45XwjDeLyXQAOIz2jzeBX7sT0BoXXtHOOYR1E0EcwFryMMBISWeQkktNkBe4ShJkJdvygTesQ5JlmpwAiaPlhphdM96gRiXowzMMP3UKtzaGdoTaniDOb2KQOCMpxpIgHaHmIsrPnfSa9nftxJ1Ywa2PsOMSUVUwlaD2zWBzQ2iH8LWHvTHNFlE9cgF7ZpPwG45s2RpqXrvcqHL91wH3Ae+94vZvB7632+3+f8AtvEQ2D+wFzl55Q6/XW5v8/5/0er283o+veaVzrZL9lWN0T18whNtj0n75suX61hXlevAl+2cbMcPnU1rGMrU7wo4MRgqUhOlbYrSxVAY6gc+kZ9qaMolIKkOqFUlliSrDUOtLgbizI5pYykLiLJtJDM5htEIhkdZilSJTk+A+8YU3Sl4aoVMCwrwC4cfpvCIeKAPDTkRnkJKYilwprAxwymGqkJ0rK0hXYZGIvCTHB1wHhDMhMWMKF9A4Os/4c2d9M91MQri7BSdXKHVM9enj2J3TuKeX0fs6lH94HLmzhWxHiK/ej/2zEz6TL0o4PI/a3QbjCM6e3/JSffrRL5H8wL0IXTfc1Vx/bli5vtfrPQic73a739Dtdm8FFnu93rt6vd77gbcA33r1c7rdbgf4SeA3b9S6ampuBs1rNN91toeMNiqq0vLMomFmd0I+qF42k282Xxjk79wheVaGdPoZs1WFbGqKYcVULNiWCBoHmkjncNYxFYJxECrBcjMmrCxJZZB4cZy1OCROs8keuCMPfSk+EYJRGKCspQwVDoEVAqMkpVKTsv7Ehhb8/51v5JPG/8x6Mn8PICyMphOm+iNCKrJQMQ4iYpGhjUE3QkJKDIpYllRopLDkRLhBSkyGsYrkwBSqHXgJXCUI97WRq31cp4npnUbfd4Dq2Q3UnfMUn3oGOddENALk2w7jPvO035PPC3jzrchO6NfXe25Lm+7sMCf7jUeJv//eLVtDzWubGz1C9wvATwB/F/jUxRsnmXjW7XYv1qc+2e12/wz4b/iS/h/f4HXV1NxQmm3F8KpMXilBZ3vI+oWCpy9U7DqQUIyrl92Tb1+xJw9w23ZJFgfM5yU7bUlaQjUyTEewpyNZrnw2LpwjCQSlE2yMLJ+fmSbOC9pFQamUV8ALNEFaALB6vmSY+Ka36cGIUkqEdRgtsVqC81a0Am86Y7TwzXfOgbMI5yhDTaEV0voJu4v7+A4YtyOa/QyN4cLCNDPrIwgcgS0pnCagxKAhVFipiUTOUDQIzqxQEBAZg2wGCGMxQuPSkuiWJjpLcbumEWfXiL/tLsxyirptO/ZcH2INiQ/y9rPPYEcloqwQ33gPblgCAlc4uHPr7GXz33yU4Ov2ofZ0tmwNNa9trusIXa/XOwm8+4rrj+LL9td67HsmF99+PddQU/NK4FqZPHBpVv6ZC5aPvLvF/akheLnu+uaLy/VIwVqoOSRKRoWD1JK0JfPzkucuVBwR0JCOVAgMcGrdclD7zvm50Zg0Dpkfl+RCUDgIpMDhGMYJ2+mzrT9AORiGAQneRjYc5d6+VXgFPFVOlGycD+jSWUZxRK4UickxUqBLL5xTaUmeBDQGOZWQLM/Psu/UcUzTj+GNUonCUBARzbdwp6Fhx2zQorXRJxVN0JJyKYX1MSQxbpASmYwMCa0YZyF6z34GYwsWgnfditvIEI0A8ab9uKcWMY+cQWARb7sN++8fRwgwb7iVQFxT8vumkH60R/On37llr1/z2qcWw6mpuQG02i8R5HeGLJ/PeXbZcOcdCaZylzq+r3mchnhRkK8MnIli9qqKzXVDpQTl2HLn3oDTm/6xSWVIJ0ZwuYP3njtPpRXzoxQjFeVEo32t08QKgTQOp+TEWtYSWsN6I8GJiw5zDgGUYYAyligvvWoeXjteWMcoiVDWoip/MqCNH9MbTidEeUloDOM4QpcVVFAqBQhEVniZWRSuGeGsIGFEP2iSuBHjoAUNTfYXZxHG4AqDG5cEp89TEGI3S+y2KXhqCScE1ZfPE773kN8dioiOAAAgAElEQVSDbwSIKEB81T7cf30MqSUiCjBnvLufuXXXdfrE//qUD57DLg0J33foL39wTc1XSB3ka2puAM2WZDS69qz806cKtrUlrYZCakE+qK5xBM+VJjUAB+ckhXGcjH0j3XDDMJSSInO8fr9mzUvMowpDP3Uo59AOkgMdRlHITJYhnSNTklIK0mYCCJI0AyFIlUA6SIqS1XYThCDIK5rDwlvOXpynt87bzLpJdm+Nn7EvK6T1u/GqMj74T8VM9ccEWJZnp0g2hhgUIxkTVzk77BoSP7Tv/W8cETnjdpMGY0a6hWxo0i+cxyII7tmOlCA+fwIjNOb8AHH3LqrPPItqaco/OkHw3sO4cYFoTEb+3nYYc2wRMeXV76oT6zjnsNu2TuUu/eiXSH6wi1D1n+GaG8cr/tvV7Xb3d7vd9W63+5lut3t/t9v9f7d6TTU1fxnNl8zkI54+X3FkwafvQgpGa8VLHqd1Vbk+CXz2vB5qhusVg7WSDMGeBc3B7YqxE2gg1xo5KNDW0qlKnlw0nJnpMJ1mhA4KKSmkxOorGuiE4PnYW+JNpSlrzQbgZ+LbmxmyslgpkTgvZ6sVQggcAm0dYVESVBZtrC/hW4O0jiIJ6GyOEaEjCwNmN0fE5GAVTVJmzeYlk5xsscC3AQpMO6TBmKFpoBOFOTvCao2+a94/Yn2EmAqxmznh+45QfuksaiZCbmuibpmGcQkN36kv33YEt54iFrzMr/zySUBi+uXf4FP+yrGDnPy3HyP+vqNb8vo1f3t4xQf5CQ/0er2393q9NwN3dLvdO7d6QTU1L8e15uTBB/lTm47DC5fbYUYrLxPkrxqhK43DOtAIFvbGuKWUOIRbdgUE1mHA68snitaopGksrVhSHpjm7PQU2lgaZYlxjkIIFD4LB4EO4NRsBwfs6o/oT8boLI5WP0eXpVfKwyGco9LqUgc9QiAq72onrb//ouxtGWmCcUloK9rjMVOjAi0qhIWGK2iQk0/ag/JcEYiKsWog26CoyIoAWRlwDrmjieskSGOoWg30XALOEb77ENWTK4hEX3Kdc+PSK9wB4qv34wyI/XMAqGfP+BOJc4Ov8BP+m5H/+pcJ33kQtWtqS16/5m8Pr5YgD0C329VAAmzNb2ZNzV+Rl2u8O5dJDm33v3rWwXA5f9HjLhKGviksn6jnnVixaG/txsE7mySbBe0Q9u7UfPmpgsg5NqVi5/6IbUXJbFFQVY50X4dKSvIopF1WCGvJpSQ2BpzvmLdKME4SskCzbTwmDTTCuom3vENWvos+jaNJt73w+/LOYYXAOlDGm+OISTm/DL3RTZqEKOcYxhFhYTEXtXeMQWEZSF81MFFITMbQtugwIiPxynmbGUZq9HyDclAhcAyLCBF721xx+w7MmT6kJeHFIJ+WiEkm7zbG3jlvKsKspST5JuitCfLOOdKPfom4tpStuQm8WoL8vRMjm2PAmV6v9/wWr6em5mV5qXJ9EEk244DdifN7wsbRX8xe8jhCiBeU7I8tGtTE3nXuYEIrK2gAe3cFPHY8J3KOQRRwslJMVxUH0jGZkzxbaBplxWYSEzh3abY9qbyQjgPsqAIhGGv/2FL60TlpYdgOL2Xmw0YDJvvxfqTOUQYKi0UbhxN+Nt4KGLUiGuOcvBORC02pJKKCURz4asC0D+5D1cQBphI03JCBazAzWmdME43DDQuMlUhnGR9bB2AwinGDHBcEiCTErBfYpRHB2w8CXGq8A+C/PIQTErnYp7r/FFrkyEaAOXvzxTOrL53F9nPCdx+86a9d87ePV0uQv1iuP4IX2HkptbyamlcE15qTB5/FbeiAmarCVg4hBJvnXjrIwwtNap5Y9F7xTgtWo4ikqpC54ZZdmidPlTScZRhpfncjYCUIuHN5nVEUcHzVsTAcsdJuevU6KZkyFQIwQqLzkiQviAFR+NtDYyiVQlpDniikdUhrSSPvaqcme+/KWiqlMFqiKy+Co6zDKsFoKibMS1pZRmUEezfXqFD04wRZWRplOnljvEe9LSwJY1ISOutrpCJBxhKMxbUiyuc2SR9f853+NkJdWMdGAXZjjK1AvWkvohninIO0gkm53v3xE9AM4eQK7vceotq5A9EOMReG/rE3kUsNd/LV8ue35tXMq/Fbtg5s3+pF1NS8HM2WYjwyLwogZ9ctsXKU6wVlZtGJZHAhw5qXDjS+w97f/+h5Q2XBKcmT5w2pUqhByc7tmjMrlvkIVlXAvC1Y1oo9GwPiULCYQbso2GwkhGVFBcynOZmU4CyqMsRlSctaOmmOA3ZvDhiHAcJBEQhUZZHGnyD4IO9PYoSYCN9M/OOdAGkdRgmyZkQWB8ytDshVwNRk1n6qyDFK0B6uY5BEGCwC5yCkwMWa1miTlAbhtkltv7DQCpFlhZiI8cSzCicV5X8/gZSW8OsnRjNZBZG6HEgfPo3b1oaz64jPPYk5eiuyGYCSuP5Lb5dcb+xGSv6fjpF8b91wV3NzeLUE+Xsn3fWfBbrAv9/qBdXUvBxaC8JQkqUvbL575oJhbwvWzudUuSGINHEneNl9+VZTMphk8g+fNcTWkiF4+lTJWhgwpw1KCfq54/AsrEnFPeeXmR2NGMcRB2a9Ul0pBKF1GAHNvGQ+yymkoJAKKwRx5tvf2uOUMgrY3R/QjyOvbCcEenIiInC+y95YrBS+DG4sCIFRPtBL46iUII8DKq1plAUWgcnBaWjnBUWkaJQZmYgIrMEwWacKoaFolENyFxPH1mf5SYi6awcxGWiBEKC1wzpB9eenkMIRvu8wcLHpLrj8Jp5Zg+0dxL4Z5PGziPe/3s/QzzUw529eyT77tS8TvudW5I7aLbvm5nBdFe9uBBMVva0bZq2p+QppthTDgSFpXFa7eWbRcOs2yeq5nDK36FjS2RawcTZlaiG+5nFaDe9EZ6zjuTXLtsqwoQJOLVa4KOSAydgc+jJ+mVsGgWbhdVM07z9Hv9nAjCoaxrDcSoisZaw1nTSlIiYXglEUMD0UBKVBWou0ljwO2TZKeW62wy0bm0h3hasc+Nl445vrjBK4yWx8KSWhMX4bINAI51g4s05SFYyEpsgEZQTtNCcPpW+6S6awmcSiCUXOiBZx01Ct+T9P4bk+DoGbb8F0QpIPcTEgBeVGga0s1RfOIIRDvX4BuNh054O8Pb8BRYWbaaGmHe64QL3rCPLXnkW6BHt+AK/bdv2/AFdxseGu/YvfcMNfq6bmIq+WTL6m5lVHoyVf1Hz39IWK1+0JWLuQU2WGIFZ0didsnE1f8jjNiX79qXVLIGDeVOydlqwPLZtBgBuU9B5NkTgeWLKkSlG2IhJjWG41cWdGBM6xuK1FaAxrccy20ZhWVVEIQakUgbNIAWHu5WtzqYlMxSAIvOgN+P12IQiKatJR793mjFTYybZEEXkDG4AqDBDWsn2pTxqGOCHIK4UJHNI5Zgrf2Z7u2UGuAioUiUvpuyZNPSKjgcIiEm+SU5aCcnGIlhZbOoRwZJnGFZbyiRXU3s7l8vy4hItNd59+HLTCWRDSYpxGH5xBNAPkdHzTMvnq/tOQVQTvOHBTXq+mBuogX1Nzw2i1FWurL1SzO7FkuOvWkLXzOWVm0JFkZk+D53vrl7Lhq2k3Jf2B4akli8IxLwy3bRNkBhCCxnTAn//ZEAWE1tI2FeOnNnlw2ywbYcBCVuCEYEloQmNZbiW0ypKkKMiFpFASHUqwjoX1AZXSCCkplCKyBie8C52bBNBOfwACjBQ00wIrxaVu/TJQl6xnizikMcqIq4r1doPKKUo0aMswiNjXXwbANWOs1D7IM2JgmzSLISkJWlgfrKUgW8zJjvdRgcAaQePWBjkxMtFU6wX6rfsuvWduXFwq17s/PAY7O7hxiTyzjLg4GRBraEeYCzcnyKcff5C4brirucm85r5tvV6vvlxffkVc/tp3dPj9T67wxS9cvr3hNjg/AikFjzz8JDi45wO7uHByld/9qccoRtWLjnPoQMgTzxTY5cfIneCUCtn+4CnOxCHjQLGiLNOmxADPRyEHhmNOxg3asmIpCtiTFQyCgAuBxgpBYB3rSYwwviu+k+WY7Q0qIWgVBTYOcDhKqWjnXhHOKt94JxwERYVDkMchwcXmOwdMmuouuuBJY7BSooRl2GyQ6gCLxCpBKRWF9DPs5twaARUOCCgpiJDWz+EJCTLNKUQA1pGtGbAWg6RxdBvCOVxhwDrOvCG89L49fuyJS0p+owdPwMHtvmfg1JLvFNSS/sllRGWR0/FN+T7YlTHq0Owr5vtZX35tXX4pxM0eH7kJvOZ+oJpXJ845/tU/O8uR2xPe90GvtPbJL2Z8+rGCNz5yjrd8wxwP/sYpPvLxLqa0/MkvPMPZRzb54D+7m+k9yaXj5LnlI//oHB/7+V28/2ND7j9p+K0Dfb7n5BTby5K705R3zJT8x36TTQFvTzf4ZGuODz91nE/deYh3n1nhd7fPsNaK+PZTS6zHEbuXV5kuCpbbTQ4sr7GybYqptSHSOkbTbZyUyDTFIZjfHBCNc3ad2uTCnhZxXlJqxaDdYt+5Zc7tnEUWJdJ6xbuZ9QycY3Vbi8Fcm7d9/hhP3rab5pkx04OMwYJgx+aITGu+anCMC8kCrlT0qyYLnOd4cJiFZI2Z0WnW5W7aYkS/bLAxs51ivWKfO4+VmuYPvZGNjz7CBlPcGp1m+ve/G/nO1wFQPbHE4EOfYOaJf4TZ9WOIb34DS08r2p/9M+R0i2Tt/+a5nf+Gxv6Y6Z95B9E7b3wJffM7fovoW24n/s57bvhr1fyt5Jp2iq+5TL6m5pWCEIIPf/88n/6v6ywveunatx4J+PNnSqYXIvrrJbacmLkEknf/r0d4w4d28xv/4AFO9dYuHSeKJLcfjvjysYwfeUtMKOGpW+b49j2GgdIsq4Dzp3M60nJAWY6riDe0DSdbbUaloRRweJwSWcf5KKRZVQwaPpPflhecazUYVqClILSWYRRhgEIHdLIcjKUKFEE+abyb/CkpogCE17Z3aqLF7yaZvIU4zbFKgoLVqTZWKSQGIxQCh1FeFredbSIrXx0YyylUU5Glfn9e2wqMpXAa1QoJtJ3M7AkYZ+iZEOks0Z4Eisv9DyJQPsMHb097924wBqdDWJjGpiV2PcOe7aMOTN/Ir8FlAokrXyx1XFNzI6mDfE3NDWTbfMh7v3mG3/x3izjn2DmtmG1KRtMx/dUSc8V8vBCCN3xoN9/403fyBz/9BA/9zplLc/b33hPzwCMZH7w7wAK/+lDJP//+GQZKciIKWdIBR5oVmRFstiMOrQzo7Z5nz/qAsZLsSTP6TnIiiWhUFeuNhEZRoJxjqdkgMIbIGZCS08ZQKYlUglz7RjqrFcp5S1mjpRevURIrBMpYnJK4SbkefLkevBPdZqdBv9XEKoHEUQkF+C7+QgbELkdToqnIkhZSOtz2DpHNCU3Opm7ikIhQEQp/smSdxK2nyHaAxKIPdXDlFU2OoYLS4NIC8hKO3oKoKqzQiP2zVKf66L1t7OIItefm6MeLUL/gRKSm5mZQB/mamhvMu75xls11Q+8vfDf5190W8BwBmysl9hqZ3S33zvDhXzrKI797jk//3FOY0nL07piHHk1JAvj6Q5ITA0iN4GjTMtKKczpELI1JnWDHqCReSdnfcmjgTBTRsnBwOGazGRAay0bsvd+tgwiYH6WoYQ44NgLtRWIQrCYJVnrHOZz3ji+Vd64LypJRM0ZZi7AOnJfHdYCc/FiNYcZ6p0Ua6om3nMOgQfoRvHSmg8KiJnvyBRoxLpBaUhISkzJWCQQKpCAyOVILjJVUS2PcIEdKh2yEUFxuchThJJM/terNc26dRxQlxgrE63ZQnuyjFpqonS1EoF70GdwQJiceNTU3k+sW5CeWsK7b7X7gituOX3H573e73T/vdruf7Xa7n+x2uzsmt3/kon1st9sVE9Gbo1cde7bb7b598m/2eq25puZmoLTgu35wB7/zq0uMhoavOxJwrC/ZXCkw1bVbSKZ3J3z4l46SbpZ88n98mE7oiCPJc8+X/E/vaiCt42P3Z3zk9ZpCSU5MNajGXmFvXjouTCV8zZThXLvJsVaCBA4Nx9hIU0pB4BzLzQbSGBbygkJJBlGIdXDnep+Nts/g1xrxpVJ8ESmskn5mHq9yN2okCOuNZlDesCaPtDewEYL55U2WZ6YAgS4tAgs4rJBoa8nu3sfFNpqcgLKUKFdRLaX+ZEAYbBxjtcIaR2jGSGNRMyHlhRS7niGl9ScBV2bJk+vu2Dl/fX4K0gJXgXrjbqrnNlCdELX/JpXqARHIy1sINTU3ieudyT8J/GS3231BA0C3230r8H3Au3u93tuAjwO/BtDr9X4FuL3b7X418APAg71e78Grjvsh4Lsn/77lOq+5puaGc/BIwhve1Oa/fGKZNx8OeGzJsrLkhVxeirCp+Ts/cxd7j07za9/f4/U7LQ8+mvG2Q5pYwUfvL7jvnpCDwnAyihlqxXZTspZadk5Lhs+O8Pm43zefLSv6hWAxCGhW3qxGGEtoLafbTZbaTXKl2D1OeSBsIoRgtZHgpEQZw6ATUylJYCrvPocjTaJJJ73fl3cC0maCcAInYGFpnSwMidMMNdG1D6yhlBLpoDi0G4ElI8ZISVVCc18D1Q5wKEysGQeaUkjsqCSmgFgT7GxQLOa+J8BZnOWFWfLFcv1Dz8NU4sfmRhkIgbx9gfJkHxlJ9M3aj7+0pnpPvubmcr2D/FngQeADV93+PcA/7fV6KUCv1/sDoNXtdndP7v9R4N8A/wPwj69x3LpjvuZVzwc/vI1HHxyx+nzGoR2K0y6kKl/+qy2k4C0/eJC3/cND5H/wLI996gJCCL5xn6SfOVal4kCag3MsTSW0lWE9iZl6eo320oj3xGOkdWxqRSTgtv6Q9TAgqCwbSeyDM1CEIYkx9OOI0DmejhpYAetJ7MvdpWXcDpGAdOCkQFhLpf2fEGksdrJHP2rEfpROQOAc7VFKUpQEpQUEyhkq6bP9tNBILCUhTgkqJ2nujgl2NQCJais2dUBpBWazIKSEToze26LKBPr27ajpCLeZvbBcfzFrfvwczLf9bQMvOCQOzFE9t4mw9iZn8gpXVH/5A2tqriM3Yk/+nwI/cVU2vwe42h72FHAxyB8HAuBPer3etZQp/jPwHyb//vP1XW5Nzc0haSi+7Xvm+fVfXuSthwJWtzWuuSd/LW575zwf+oXXEz66yH//1yf4kfsiSuP4lS+VfO3hgF2h5fNJG9EvyIRkdbZNgGPq3BCrJF+cbhM7x10bfVaDAG0M/UZCXHqhnGljmMlyBlJhleKOlXVWmzHVpANeOEvWCFGloRQCK/3cfJwXFIFGOB/omXjHm4lZjcTRHqZIZ9GVN6HR1vjmOwH2+DICR4lGTP4aicqQuIySkEQUbIQRNlCY1KAw0IyQcwkSQ/SB21HbG7j19IWZfOCzZvfsEuzz44sMM0DAbJPy5CakZZ3J17zmue5BvtfrnQEeAD54xc1ngVuueugtk9sB/gHwx8B93W73RQOrvV5vrdfrfWbyb+3q+2tqXi0c/ZoWc/MBs8tjzkbxS+7JX4s9d0xh33+IZ+5fZ/UTz7BQFvzmQwW3Hwl5z4xlI9B0qgrtLOXOFnuOdsgywZvPL3E2jhDW0XCwngQ0jWEYhX5/3Vqmi5ILrQZOATjedeY8zzQTBFBJCVJSRhphvbStkwJlDLo0ZHGEtBZVGpyUxFmO0dLb0DpHazPFKkkeeolc6aw/phDsfOxRKjQVAa5ySAnlYkq0vEomm4TDIYVW6NBb0UoETinM8XUCcsS+WdTOFm519IL9bqGk7/Q/30ccWYCiQhQlrhEhhKB8bhO3Oqr35Gte89yo7vqfBf63K67/B3x2nwB0u933A2mv1zvb7XZ3AT8M/O/AjwH/6gatqaZmyxFC8J3fu4MTX9ikX0Ah5MvazF7N0a9qkd63j8ZsyA8/8yzbspwLOoDlgthZvjTToVGUXKgUTmnC6ZB7V9cQTrCmFYVW7M4yIuv141caCbo0SOdYajZRzlEKya5RysnQ77fnWvvueoGX0S0LhHOIyl7al3diooQ3CfKllgjnUFiCUYkAhlMRlVSUSmOlBAmz/RVGNLF4JzvVDqiWM/TyJrmNkFnOzHCITA1CghUakxqKY6uEZNhhibplGrc8enHneqhgfQRv2AvPr4BSuHYDOyxwoxJzM2fkL66n7q6vucnckCA/yeZ7V1z/LD7Q/9HELvYHgb83uftfAj/V6/XGvV7vT4Glbrf7rTdiXTU1rwTm5gPe98E5uuMRZ9oN7F8jmz96d8LDxwre9b8c4Za3zvORh5/mTz+7Rlk57msbHms1mbEVKxk8e7KgURmOT0+xfzzkS502TWu5Z3mT1VAjrWOl2fBiNoBSkt3DMWtxhFWSKedPBMaRxirpZXADTaMoENZ5SVkhqAJNEYSERYWTAp2XOOkzeY2lUpooLRlNxxihvFkNELkMiWXAFAElMTnhzgTdH2JmpyDUlFGDXcN1xLjCSYeVmnI1x/YLgthiF4eo3W3fZLc2esF7JUIFpYPX74WTK95oZzqhPLmJvmUKt5qidrWv74f7MohQ15l8zU3nulnN9rwl7LuvuP4Pr7r/4/iu+quf921XXf/e67WmmppXKu/8+hl+73fXudBqYY3lr3q+vTCvaSSSk2cq3vuD+/iO5yTv+NNnUa+fJ9o1xx8PJblxVA50S7N7T5P1pYo3L67xiT23YBHMFCVn2k20Maw3Gxzc6ONEzGxRYIVgqRGzczjitv6Q8+02wzBihxghjKWIQ5K18pLYjRWCMM3ImjEzm6k3fpHCZ/2TTL5UksYgZ9SOsEKShyGtLGe22mCgmlQmJKBAIAlu7RA/mVI0tiO1o9iI2J72WVTz6MBhconNLDIKCOcChstD9JF5xMIU7tT6C98s6Tv8xcHt8J+eAwtirkX13CZqRwNVTfmy/s0ikLUYTs1NpxbDqanZApQWvP0Ds0wh6G/89Tqu770n5sFHUnbMa2Y6Mb/yxiPIE2vYPz3DbXlBb3qKRmV4NooRDc3+lmTf4gahcDzWaoASNKqSVlWxnsSEpbeObRclS82ESgisUswPBgjnKAKfCwjnsIEimZTrrZQIIMoL8iRCGes77kOFtIbYGAy+4769kZI3AioExURYZ7Zc53S8iwqFwlChaOwK0ZQUY4e+ZYq8CkhsRikUgTY4K8BZ2NYmmI+wK2NkK0Ds7eDObF71TjkQEmabuOeWwTrY3vJCOFMB+ibux8NEoKduvKu5ydRBvqZmi/im93U4HwV88hMrf63nHb074cFHM4QQvOeOkH4c8vGjtzFaK/nmE89xLo4QGM6OBBdWLBvPjxk3Qm7LRjzVarDSSNg1TGlXhjQM8OI0vsFu2IjZMxxRCcH05tjPsmvlR+2kb7iLyhKsw0kB1qKLiizxM/TCOqyW4BxRVVEKiRMQjyuEg+FsAhY65RCHYMO2KfCWsAUhjQtLpCLBraaEd20nLwNCm4GUaCoQDmktVmmCvS3MeoZqaeQtM9hzLwzywlpcO0YIgTt2DiGATkL53AYylDd3Px5eLNhTU3MTqIN8Tc0WEYWSIY4nHkt55onxX/l5d9wWcepMyWBouOeOmKORYcVIHr1rL509Ld68uMw5rXHG8egGzO2KmHtdh13LAyxwNopoGMNUWaGA9UaCqoy3i5WS7WnGShIxm2ZehtYJZGWwyqvgIYSfnXfOP2dSnR+2Gz6wSomRgrgsqVBYKYnyiiTL2NjeQhnLznyFvp4iUZYKjQ0DCkLU509QxE2UhOie7eQuJNYFwoK0BcJZZFNTXRgTHOhgN3NkM0Dsn8VdGLzwjTIWtrUAcMcXvdpeElKd7COM2aJMvg7yNTeX67Yn/5XQ7Xb3Aw8BDwMJsAT8OLAA/L1er/cDE7W8nwNKIAZ+otfrfWZLFlxTc53Zm6YMb53mE7+8yE/93D6C4C8/7w4DwZ23RTz8eM7ddyRM//oGZbvFSidCH1ngtgc3+LWowfvOr3B8b4f3zwiCQrHnyRXmi5wnmw0OjceUCKSxXGg22DsaY5ViR5ox1prNKGT3pB9QWocqK6ooQFaGUeJtcIV1KGMoA01jmNLvNGgNB0hjKSJNPKwohcJKb1Szvb/G6bmd6HTEQr7K6WAPMRUFCtWQREUOGylmdo6w3yc4OE1OTEQO1iGsQeCwt86i1gxyzwx2cMGX6xcmzXcX+oiFieFMZWDnjL/8/BqIGT8K+Nwmapvegky+3pOvufm8EjL5B3q93jt6vd7X4EfvfhvvmXGRnwc+3Ov13g68BX9SUFPzmuBgkdIrNNsXAj79e+t/+RMmHL075sFHU6anFfumJbdOw0ObgqV1y7qI2ZXlDHAcObHMmVRw4XzJrtGYI3lKKQSnWwnaOrQxLLcaqMr47nMHoyhkqihI4xAcyMqic983IIxhvdn0Wbx1SOuwWtEcpaSN2M+yV5Yq0sRlRSk0woLRkoNL5zCBZHuxwUjHWBFgMi+P6wzM0qdCoZsBWIuxUBIgsChbEZkSKwTr22YJ9k/BjmnMqEK1AkQUIOaa2AdOX3qPRGW8EE5awCiHZoQrDNXJTexNnpGHOpOv2RpeCUH+Er1e737gUaB7xc0j4P3dbrfd6/VMr9e7urumpuZVyw5RURjBWz+4jT/5b+ssnS/+Ss87enfCQ49lWOu4+46Y+2YhCeGzzxsWtineMAt/vmueheGI5d4Sab+EhSaNcUHTVByLGzTKkk5ZsdlIiIqSUklKKRkmMQujMUoIAmMQxiInWb1wsNFqeYU758B5X/hGP6WI/WicRVIFmqiqqJxCWocJJLPjAcI6Au14vrnDW81W3vzGjg0tUtJSIWOJKAybf3QGCZTtNgljYmvIA83mhYzwQGfiC2+QrQBChZhNsL0rhDWNhUM74NQKNooRMw3sqMRVFsnX0zkAACAASURBVHt68+aq3QHUVrM1W8ArKshPOA08c8X178UH/Ye63e6nu93uvq1ZVk3N9SeMJPtdwSPL8P4PzvKJjy1e8pB/OXZs17SakmdPldx1R0xnLWdcwNk4YM/OgDfuCdiRF3zyyEEWo5BkZUC4LWHe5OzMMkZKsh4EzBUlhdZYIZDWEVhHIHwwHwWawBisE3gDea9ZP0wSwO/HW+Gz+8AYlDFUUcCgGWK1RFuDtQLhoIg0IYZ4XLDR7nCqtXBpDA/h1fMckBMjrHe02/zt40gsRdggIUUbwygIMIMSt70BOzqYwqFaGgKF6MSYSZB3G2PA4W6Zg+eWsGjEjjZ2PfMz8sMSuaN1oz7WayICWXfX19x0XolBfi9w+OKVXq93qtfr/VCv1zuEd677P7dsZTU115kwkewajPnc0wXv+PoZxkPDFz/X/ys99967Yx54NOWO22LOnMz5ptsVF5xk7AT9vuWO0Yi1QPPAkd1cWOhQPLXB7OqQO/oj9qY5D89O0TAGCZxpNQiKHG0tzbKiUBKsw1vKTLrrnMMp3zlvlR+fk86hywqrJPE4I4sjyihC/P/svXmcXedZ5/l93/csd7+1L6rSvliWLVuOrxwnNtgOMgQIYegOZJKwpBtIM01Dk8AsTHfoYYYZ6BkCk+nmM93T7NAhdALdDQkQnMVOvMW+tuVdkm3tS6n2qruc9X3f+eNcbbZkW7KkcpTz/Xxkn3vuuWetquc+2+/Rhk7RR5ONn+0UfRyTsmp2lpPVQULXQxjwSRC+g0tC5BdJcJFzLYQjIDUI3yEURYoECCtYKhSpVyUtIzNPPqHnyTuIqo/thevtgZlMoG+4CgdnMalArunDLEY4I0WctfWsn/9q4uXV9TlXn7eVkW80GrcB2zlLLa/RaGw9a5MTvM3OOSfnreAVFUOzbR7alyAEfORjY/zln87Qbr2xMTjVSlcqSVZPuNw7ISg6gq8fN7xyKGH7WhfXGua14veGxun2lSnHKWNBl2qacKhQAEAZw3ypSBeBdhRd1yHwPcpJkoXkyURlrBUYKbNBM042uMZNDSrVpI7Ci2OiYoHEd/HjhLlqFe0orFBYJVDWsGPqxUzaViqkAQeNrLsUiUlG6mgU7vwiaIu7qoSqeXRTnyJBdh6eQyFMmFlIYbCKthLliaw9zRHYWGetdM8czUr+PRf7yklsYlGbhzCtGFV1r3o+HnpT6PKcfM5V5u1gMG9tNBpfazQajwCfBD4ERGe9/3ONRuObjUbja2R6+Lknn3PNoDzJkA9VH148oVm7scCt767yn//jzBt+dtsWnyPHEpZbmhu3FSgvJngONFuStRMON20rcctiiwCBspCOVugMlqiEETtOzrE6jFhWikqqWSwVMcaQysx4h56HZwzFVBM4CiMF2sla56wxpK4LArw0RfWq6R2dEvseqaMoBRHz1TJWgJMafJPi2JSxZB4rBGEp+4JhERTLEOEihyooNL5uQ6KRwqJGS3QjL/PkFZRqHnKuy5FDEUaAQSE73cxLTg2ysRrTPIzdfbg3ECbF7plCSIFY249txQjnKs+RP0XuyeesACvaQteTwu2/wNv397b52at1Pjk5VxvlCKr9DjuGBd/YG3PDhMMP/MgQ/9svHWTfC122bCtd8LOuK7hxq8/u50Nu3Fbkzz63wE/fXudTX4swVYfQSm5ot3l4sA9TUDzRLXDbYBlbkFTnE3YdOsaT4yMMxzFHS0VGuiGz5SJFbZCAMZZyknC8WsQKgUACWe48dR2sEHhxCgWPxHcAixMnhJ5DrRNwuL/KgOjghwlJVeDahDn6sQbCko+VAmMkxaTLIlX6ygpXpHg2JsBi5gIKt46y8EKLAiGBstTGi4QvzRP5Lgv7WkhhEbPLiJ7QjLx9PeaJI6g9U1BwsnGzL00hrEFM1DHdBKH1injyuDIfUJNz1Xk7ePI5Od+2KFdS6XO4rqR5cF8CZHPnf+SjI3zmP5wkeYNCrVMh+y0bfY4eT/iRG12EgMcWBc/sjRnaVGZzJ6BtJAeKBaII7HyIHstC6V6S4Kca7ToYAUsWEAItBZHr9gbUuFlxXJKAtUggdRUWgdNrvUt73r4fRiAkpSTBTVKiooOTatoFH4eUE3IYFaakrosVoIXEPTnPMiWsBkcZFBZRcLDzAf6OYSLjIABHJNTWVLNJercOcOyhaaQLTC32KtfT0548h+ag4kOsEUcXwHOQ9SK2m2Db0dXvkafXQpd78jlXmWvOyDebzXw5X/6WWfbKDqWSxDlylMf3p1hraTab3LyzQtDVfO3Lu193Pzt3FHjsyTbtrmHjeo+Xmi+wqiJ4eklw+HjEPffUecf8ErGBllAkkcGGKbQSDg70UUpTCsaggOOVMlOuQ6IUHcchLHr4aVaYZ6ToadPb08p3pqd0J2wmNXuqSh7A1dn42tSVpK6iXSkgsMyLPkpLAQhoFTxAEE6UsEKSzCUIEiyAEphuCp7kVK+BEwfYQpFwoEB10GP2y8dRbpy1ytWLBMfmEBUf5jqYl08iJ/swL02jY4Nd1Y+JNSZM0c+fxL1p9Ko/a1EvYOaCt83PXr58bS1fCPFm2nW+xbjmLijn2uWxPzvC4WeXaQmPfyMH+auP15kcUBx6JeT3Pn2cX/30eoR4/SrwP/7cIkvLmlpR0N+n+PM5yZ89lfKxWsQv/Ggfn/oXB/jziVEcYfnAyWkGZ5bwXcWz/f2oOGFYW54ZqDM+PUdsLRuEIAL6ugGREDyyehX/cPdzuIkh8V1OFaWX59vUw5DFcpGwXMRIwXKtSuA67HpkN3vWT7B2zxyOtuxurOPjj36Grzi3MzdSZWrDIJPTM1y37yTenWMsPThHxdNMxvsBSbhmDe2WRCuBnV1mE6/QcfqZ33wDsztXY24cIfnUk9yw9DRDR34FWy0S9/0ifOR2ODSL8/XniX7jx9CffQLniX2oX/5eluMq7d98hPJdqxj+6o9f8Wf7aqy1zA7/BgPP/TPU2NUbcZvzbcN5/1Bcc558Ts63EiObKwRzEScPBmwdV7xwLFOWe/yhZXbeWXtDAw/wgffVeOq5EL8gOXw0YecaF09YqDkcOq45uabOWBgRKMVh5aErPjoxDJQt/QZaSuInKe2iz0gYAhZPG5CC/m5A6iimyyWUzhrqjJRZL7+AyHMRltNT6VLXwYkTFqtlykGESg1KG1q1rLZAYih1I4pRTOIqrIDpFztILDKJKRATlfoI25bSrjUszQrGmSJRBYJbtyE8Se29a0n2LODNdelfDwzVEL4Lm4fRf/k06pv7EB9+J+7OSdKnpxAW1EdvZ/n3n0U4gsIPbX2du3nlEELg7BgjferEihw/59uT3Mjn5KwgI5sqzB/qksaGTUOCPSc0xliaDy+z84435+2VipIP/VCdb+4OOXwkYvu4wpGCeSM5eCxhwy0VKqlmOIwJyy5aKTxpWF3KxG0iIajECZ2Cz6pOQAIUdYpE4BiDNJYDfTVkmk2iw55xGWInK7gTxhJ7LoVuQLUTsFgtU+t0e+F86Bb9rOXOakpRSDkM8XVK6HnUq9kfopLqYpBYqYjmE9RiixRBlSWs4xLFDoO/eCsD19WxXz2CO5gQNzaduRGjdYQSiG4I//oDqIpERwKzZojW3x7Gv64fWXKwBe+yPsOLwdkxTro7N/I5V4/cyOfkrCClPhe/7DA07jIqDS8cT9n3fJdan8PYhP/GO+jxnjvLABw+rrl+RBJbOB4KDh5N+M4bfRLHQRgLSmLSrPWtbg0dKdHWUtCa0PMoJykdkXnrWkDsOtTDkOlKJdOpFwJlNCCQ1pI4MjP61pJ4HqV2l3KrS+w5VDtZbzuAk6YYoXBIqSQx1U6HdrFI6HlUahYHw0A6T0gJ1gygBotMf3maCU5ihcOCM0I63aX+wS1UKgr/yDKrClMsrD4jgGlbMWK5C3dvRY7UEF98Mps8933bWfztJiqOKHzvBpKnT17OR3hRuLeMk+6eWrHj53z7kRv5nJwVZmRTmVpZ0h/G7DmuefyhFrfdUbuofSgp+KmP9JEKQbiQ4is41IFDxxJuGle4wEzBZ2yxi5dqnE5MuBijhcBasuI7IZgqF2mTzZYPHIdUKQaCkFbBP11c5yUJtufKq9RkQjmAFeBFMcpayt0Qx5pMJU9AdTkgVg4STTmNWTd3koVyFa0k3aMBBoFDTFysEpyMKawu0bZFhplBux7xqhEGfv4WhKdY+IO9tMaqFObnOFYZBcDGKea5KYgjxKc/BID5vW8g0YRJAVX1sEcXqXz0ZuLd05fv4V0kzo6x3JPPuarkRj4nZ4UZ2VxBWYMzG3B0NmX3Yy0abzJUfzY3XFegryb5y79tsXVYcDLOjG9fNgOGWAgKsSZxFB3PozsboQGlNWVjkdZyslQkMRYjBbGjQAj6ghDtqNMGuxDG2Tx5wEl11nKnJH4UZ3r2rqLUjVDGZuI5AmrLHWLHxUVjhWW8vYA51arXhhRJiovoLxLPRcR7pinTpUiH5do46VSX/o/diG4nzP6HF7G3DDA3tIqpnlNuvrIPgUFIhbh+HPadwB5bQvQXaX3hIG6fQ+XnbsPbOU789DTWrEx9rrpuCH10GdOO3njjnJzLQG7kc3JWmJHNFZLlhLlDAde7Kf3jHn0D7iXt645bizz+dMBtYxJjYWDU4fCJFLcgKRvDw4P9WAvtSgFlDdKkVK0lEQLZk7ctJwmCbGANQF8QoUQWnrdAMQiwCIzo6dkLgVESL4ozr14IvDiTxDUia78bWOgQuD5FE1OSAYdGxoFsW5WAAbpUsBP9yJrHfFhmnGksksVulb5/fAOqr8Ds7++hes8q+iox8+vXMfdyC4Dk9x5GdrswVMG+PIP9zMMkqY+9fSN6IUI/fZzyP7kV1V9EDhZJX3nzY30vJ8JRONtG0M+sXMog59uL3Mjn5KwwI5srtE4EzBwOmQxiqusvrHL3Rmzb4jPcr5BHQjxhCQuKg0cTxsYcStrwcqVIJEVWjR6m1K2mKAQdJXHTlLBXfGetpaCz8Hy9G4IQhI6DsFAMIxCgZfbnQ8ssL69SjVUKJ0kBiTIW42R97gNzbQLPx7MpfbrDkcowmKyCT2AQWGKnQOdAB0cnSCwVlonGRzBGMPDxd2BTw9RvP8PYL93M4NQxlupDhEsJ4VyA+avnUEMFxLs3YHcfxfzBNxBAEPv4OqD0o9uRA0UA/FtGiXevnJF1bhknyUP2OVeJ3Mjn5Kww9bECcaDxixIxH7FQK1zyvlav9jCJZnEqwccykwgOHUu4bbtPSRtcLAcGq5BmYfrJiqDjOmhrqSSaru8zGoQEWDytkVgU4Kea4/1VpDEYlcX/U8/BSzSILGwvLFglkYnGYpHWoJVAWnDjFKktJWJmvRppaJFpipaSku0isIg1A6SzEa2OpJ9linSYiUYo3bEKb22Nhb/cjzdRprJzmIHnXmShrRjYUGH5dx9HJAnyV38QuWMS++UXMFMdknWrCHfP4CYh5Q/dcPoeeTtG3gZ5+bz4LufqcNW16xuNRh34r72XO4AXyQbS/FvgOPAgsKnZbO7vbf+HwF83m82/aDQaI8B9wB3NZrN9tc89J+dKIKRgZFOFQ5GiXnHZO3vpM8fHRhzaLcsP/3CNx/5zl6Ndl4NHE95/R5nP9orrZqtFmFok9DwGi5J2KJFRQlmkCCVZ9lxCC4lSYAwFKegLAk701RicXyBVCmkMqasoRTHLtohKU7TrgrVZCN9m4f3UkShtCAuKcjfCQfKCO4BbUHhB1itfJGSJKrHrI1RArF3qLKEdj2BJsO7/uANrLVO/+TTj//M74JnD1AckremIte8qIf/tl1AeiJ/+TsQXn0P/ySPo1KMzPkFxYwH5dAcWuqfvkbdjlNa/f+pyPLpLwt0xTvgHK3f8nG8vrron32w2l5rN5t3NZvNuYDfww73Xnwc+Anwa+PBZH/lF4FcajUYN+G3gk7mBz7nWGNlcYTGSTIwo9hy/dH1zKQUTq1y2rHPpw3CwDUenUkrthGqqiS3Mkc2EDwo+S7MxXSlRxlDsydueKJfokIXhY6WwUjLcDpitlrHGkkqJ0hqjFNp1ECZroRPYXgheQK+Qz0qR/RMCP9ZEjkOEj+sLhmaX0UpiyIr4wiNdYm2p06XMEq2R1TjjJUq3jdF+cIp0IaLvB9bCAy+g7t5GfW2Fsm8pHp1D/eS7EI5C3jyB3T+PsZLuc0vYF6fw7t14jgCNt2N0RT15ddMo6QvT2DTXsc+58rxtwvWNRsMFbgH+J+B7T61vNptzwG8BfwMUms3mX63MGebkXDnKq0q0Y0E9TQgSy1z70r351ZMuR48lDKwrsGQEtarg8Uc6SAnKQksLljwHFScEESCgqDVFbRDacLJcQupM+CaRWXV8fxjQKvpEUqKlzNropGC+v4awZ52rMWfa60xm5BNXUolDLIr5Ujnrt48Mw8tdjBQsFGqkrsJ0U0J8ynTwCJmbLTL487cAMPWppxn7xM0IJeGBF+CubQxsqdH3xSZCGOT/+YHsoEsdsJb24DiFd4zgrq3jf/+Wc9rW1JoaNkzRJzuXfI/fCrLioyZr6L2zK3L8nG8v3jZGHvge4G+azWYE7G40Gree9d7fA+8E/mhFziwn5woz1RHUbcLc0ZCt44o9x9NL3tfa1R6HjyS886YCvrV0EDz1TICsKMpa03EUU76P8RVGCCbSiBKWjlIUk4RWqcBgFCGwOD352qGlDmHBJ0GglaIUZsV4U6ODyJ7cLb3/WiGwCKQ1JI7ESEE96WIFtH0PacB0E/o6EdIa2l6ZVCo0kgohngiInDLaOPR/4h2E+xZpPzzF4E9sAWPg6y/2jHyV2u79nKgPQrknHPSZRzBIOh0fMbNM5ZfehXqVypwQIvPmV1AUJ1O+y/PyOVeet5OR/zBwb6PR+Dsyj/5Hz3rv02Rh+082Go2rXkeQk3Ol2bM3orjcZfFkxJZRxYtvIWS/etLlyNGYm1YplITDy+CUFOs2eJS0IZKSBd9FlRz6VEIl1EgkoRA42hD4PhOdgNRaXGMQFkbmO6RKEgtBohS1MMAC9VbPGxacVr6jJ46jjCV1FcJYCjYGUqwjEcZSWQ4QMqWQxkSOgzCGCEWNLlW7yLI3RPk9q5FKMvXbzzDyMzegSi48fxT6SjAxQP+JE9SCDk9dt4P2yRCsxfzRg3Sp4A24iDCh8ANbUFuGMCdamOXw9D3ydowQP7WSRn6MJNewz7kKvC2MfKPRqACTzWbzrmaz+d5ms/lu4I5Go6Eajcb3AzSbzf8H+GvgEyt5rjk5l5vpEzHzcykTo4r+fsWEb3jxLXjyayY9Dh1NuHFMkkpB25N0U8GdNxcpGYOrDWnZASFxOiHCWiIlwWh8Y9BONko2tlleXWCR2lKOYrq+S+K6FJIEhGB4fikrtOsd+5Sm/anCOyMlBRtjESiboqzGIqhEMUNmnkISoaXCSzRlIhIUHhHLQYWhT95GMhMw/9mXGfnZXnX8Ay/A3dnywL/7O+ZKNZxbVzP3chueOoieT2g5AxTDBSqfuB2hJEJJnBtH0c+c8ZyzvPxKe/K5kc+58rwtjDzwD4Cvv2rdM8D7gF8HfqG37jeADzYajbXk5FwjPPbgMre+q8ro5gqVsmQwSdhz4tI9+b565sH3K0tqYc5KgtAybDRlnZnjdsGDUCOWIpTWlIzBjxPKWqOE4ES5SGgtieNCr9K+PwgJfI/Qc1HWYITAj2KskplxP2tgnugV3qUS6nHAsiqRKkUxjUFCMUnpt4vUOgHCQoqgjw4lsUSXCqKvRPGOCab/3+fp/8AG3NGedkAvH2+eOoR7YolDg6uoTxSYe7mF/dOHaadVRF+BwsIcpZ+4+fT5OLeMv62K706F66/BUd85bzNWNPTdq7AH+OPzvPdTvcX/eta6GLj11dvm5HyrYq3l8YeW+ejPjjP3VMLMsTmKiyF7TxQwxiKleOOdnIc1kx7HjqWMFWDOKFCC+76wRC0xJOUCi2mmiGcAzxhUGFN0HYw+U2Hvak0qs8r3yHcZ7AZ0Cj6LRZ+Fag1hLUHBwzhZSN72pG6tFDg9775gEnxipr0hEu1QSEIKJkWKBGMVXqpR2iCdFJ1KKrRYEgPUf/x6bKiZ/p3n2Xr/+0/drCwf/6kfx3zw/8NKh85tm+kvKuZebmP++EE6dhx/6wDq0ZfPKQhUO8ZJHz92+rV7/SDpoSVMJ0aWr/5UOjVeRTgSc2wZNVm/6sfP+fbh7eLJ5+R8W3L4QIQxsG5TgdHNFZJWwvKRgIGK5NDcW6uwP3w0ZkSnhAiGxxSdtsG1ULCWlpQsFD2CQoEKKZNHT9KXJihrEcYwXypQSlJET9WuW/EYCALmqyUWikVODA4gjaFdKpzWtc/ofSmxYKRk0+IUbaeIlgotFKUkoqhThkw2cW6hV20vqoI2Pr4N6Lj91D96A7N/so/yzmGK1/dn+9xzDEoexnUw3zyEvHmC2o1DkBpmn50jWHZJ3AL62SnEtjHss2eM+qvD48JVuNcPET87c8n3+K2Sz5bPuRrkRj4nZwV5/MFldt5RQwjB8KYK7amAkwe6bB1Xbykvv3a1xysHIgrLCR4WUXMxQULJmF6FvcNh5ZG4DrVul6VqCaSirSSu1nQLPqNBAGQeeVDy6V8OmK+U6bgOrWIJYSyR6+DEvfPs6difCu9rIZhszTJd6QcEqXIoxhG+SaixTIrHsuPjaE27VMATHQIqiKEK3vYhTv5WJmF7mvuzfLz9xGcxjo/6+bsZvK5GNB+xdCJiKemntKVC6YevRzbWYncfPf1RZ/sY+sUZbHImDZIp3+V5+Zxrm9zI5+SsEMZYmg8vs7M3ca5QdSj2uehAs3lQvuUK+5dejrltvYOjBMc6mY/tlwT1RGOBZcchLnk4M23a1TKB6xILKCQpsefRH8Wk2mQfVJJqN0Zgsa7D2MICApDG4MUJiGzZCAECOmUfIwTzhSodL2tvi5SLn6akSDQes6UysVJ4ccJ0uc6AWGCZPvr+8Q0s/81hZNmheteqMxf1wAvY2zdjP/8kRiqc/2Y7A1tqLL7SYmxxmpAiZqpD5RO3I3dMYs4y8qLsodb2oV8847mvfF4+l7fNufLkRj4nZ4XY90KXWt1hfNI/vW5kc4W+PsmI1G/Jk1894TK/qHnfu4skFg4sWdJY893vrTGQajxr6ToKKQUyTHAHSswXfIQ2VFKNIwRzxQJaZ9XwWoDQlnoQYR2HiZkZLDZTuhNZiF5qgxVZ2L5bcjFCcLzYn7XUCYHWmeZ9giSgxNFaPxKDl2qWKmX6zSJdt4/aB6/LxG9+6ebT+8ZaeOAFzO5jGOEgd21F9JXo31xjft8S1x09gVcyeLdP4l4/jLhlNfapI+fck1f3y3v5oJqcbwNyI5+Ts0I8/mCLnXfWzlk3urlCwYG+IH5LgjhLS9lwmY2TPq6CE6kg8lzueWcZ11pSAy3PQUWG2HNxHVhyXcpRTElrHOB4qURoDFYIIqUQFupRROC59C0vIw1IY0m9rH43E8XJGEzaGCkIHA8LWAFekL1vMcTKpdBKmGgvZhK7RY9lUSOtFUlDQ7S/Rf8HNpy5oJdOYF0Ff/JNzPggzofeAYBfdSnrCC8AKTXVX3oXAOKmCexzx8+Rjn11eNy7aYTk2RmsvvTah7eC2jSIPdnBLIVvvHFOziWSG/mcnBUgiQ27H2vReHf1nPUjmyvYSKNmAo4vGrrRpbVYPfpIm6FBh+MnEtaWYFkppCfpUxBKgUagDMg0ZaFeRrcSIikoxTFlbRDGMlsqYAAjBFpk+vOVJGVZKaarFaQ1OGlK6vaadIwlc9stN588hOlV2wsLTmpIhIdCUydk38g40gpWtRexCAo6Zm99Pe3GGqY+9Qyjv7Ad6aozF3T/CzAxhA1SzEKIev/23jENa49NYRxDp1jBuyvrrhW1IozXsS+dCcc7O8bRZxl5WfNR42WSffOXdI/fKkJJ1PZR0qfzkH3OlSM38jk5K8DzuztMrvXpH3TPWT+yuUIwGzJ7KGDjiGLf1MV789ZaHn2oxbatBQ4fjRmKEywwtMrl8ImUomMpG81EJ0DFCfP1CtWyoOZYKtqQCIFjNI6jqMeZ6I2ylnalQNFYuq7DgYH+bIZ8kpJ42TVIbRAChrst/DRBC4kVoLTB0YbQ8XtGvsueydXU0w6C7PpGWrO8PLCa6YEqS39/hOGfuv7ci3rgBeyL05gbV6N2XYeoZuN47f0vMrAUstBXZv/k5JnwPmRjZ88uvut58mf3pq+0KI67Yywvvsu5ouRGPidnBXjikRaNO2qvWV8d8cHCzIEu140pnj928cV3x48lRLFlx81FDhyMUTMhjrV0Sy77DyeM64SiNpg4YcHzEBUPiWGyYpFS0lYSTxtCv8CqTpD10mtNp16kFscEnsdcpYZREmstqaMySVssWNi4cJIlVcKI3iz5JMUgULFFYolxmKtWGUmW6YgCAvDimE6lCE/NMvSPtqJq5/au2688i12OMf111I/ccnp9+9e/jhCGmUqdg4U6cefMlyJxy2rsk4dPv5ajFfAU5ujS6XXeLaPET65sXj59MjfyOVeOa87IN5vNfDlfftsvz04nLHf2v2a9EILBm2GgbBkMIv6+eeJ193O+5ZmZhMlJj7C7l30vR2zVMRbLNxYlDz/ZZVXSYSjVPD/Ux7zroGLLdKIY0W1iz6NjLas7AYGrUNZiRDa9LnYdvCRldGmZdql0RvwGenr1mRddjiNaXgFhLVaAk2pSJxuBZ4EIF4lFWcuyKAMQeAVA4LRCyo3h11wXsy1wXexCwIt6LltnLeHDB7HKIAcraHHGQ282m8g7N2Luf+mc/SRpAkqe3qZw52rCBw6v2M/D3r4W8f0HsNau+M9kvvytvXwhxDUoq3jNXVDOtcf/8vED/JNfXHVOZf0plk+G/MFPNDk2PsCjG8f5+r/sv6h9P/xgi2eeat1/rwAAIABJREFU6fIz/3SUn//vj6Hmu5wYL/L5oMy9NuTGoMPTqc8+IaknCe+ZXyD0JGOuZC6SOMstpgb7CV2H2186SLtUwLouseNQiiKiKEG7irF2l/65JeZH+ikttXHilKjk8317n+JAaYhyZDhWr1Oc1wTFAhvbx7lO72Mv1/GFO2/lJx78GkfkIK4RPL9jlDApsaW1xI5/czv971935oK0wbofwhQHiFetwv/Cx5DXjcKzh5m97d9xQg4wfcsGXkwq/Oyj954O2dsoIR7+H/AO/hpioIw1hjn/XzHY+VeIXrGgjVIOD3+ayYP/FDVQvOTnealYa5mb/L/oe+AncTYNXvXj51xTnFce85rz5HNyvhUIuppi6fy/frXRAtfdPcxEFHB8Xl/0bPluYCgVs32vW+0QWcFPrknwrGVvpcBsrGiMwnftP8rBepVYgWcE7QQQglhK9nsOY0FEqiSqJ3LjJSkWGG538VKd9cQDwvTOz2b/lDE4JsnmxguB0j0fX1osAoOgECe9kbQSgSFWHtIYHGmRpVepbQcxOAp8J1su9UL5X9yNcQvErofnC7ySOicnL3w38+a/tjc7vcUQUfFOG/hsG4fCnZOEXzt0Uff4ciGEwNu1keTLr6zI8XOufXIjn5OzAgRdQ7GkLvj+Oz+yGuZDRqKIx/cnl7Dv7Fd7YswhsJLVoy47TcyhjuCgdLntepdt03Moa9nnF3G1YdpxsQIOV0tsmFvkpOfSqlYQgEZk8rPWYgA/1USugyWrnofMjRCAsgY30Shr0UIgsCidoh1xlpGPMVkhfpand9ysQI/zGPluBI4Ez8F2E0TPyNsvPIUJUmLXx/MlfvXcIkYAsWsr5r49AJiZDmK4/JptCrvWE3754EXd48uJu2sjcW7kc64QuZHPybnKpKlFpxbPv/Dwmf7VJTa8q5/JIOBLD7Uvav/drqHUM/KDfYrQSkRRce8mh9U1eKpUoK0lRZ2yoRvy3EA/U7UCwhosMFFXbF1c5pt9NcJiASMliRLEroPShsVigWKaYoTgwOhgZqlPGXprUcZgrURagxFZf72rNamjMiMvJF6SqeQJCwJDohyktjjGos5n5JUCz4FuDCUX5tvYJ49gCj6xUriexKu8dt6W3LUV8+XMyNvpDnKk8pptirvWEdx34KLu8eXE+64NxF89sGL9+jnXNrmRz8m5ypwK1Z8dWj4ft//YWiYXWzz0YnxRI0nP9uR1YilazbGW5PpNPh8atywpxdcOW9xUsyqM0FKwZ6DKcJigtOGetYKKMfTHMYtYuqUii76HUQJlDG3PwdUaJ9U8Nzmeqd6RqdoprVHWkAiFNBYtJAKLk2pi18Eg0ULipWlP614isSTSQWqTRQuKrzbyMUiB9RXEGgoufOkZzMQwtr9CLBWOf34jL7ZPQCvEHpjFzHSQI6/15N3tw5hWTHJg8U3f48uJWlVDrqqSPnl8RY6fc22TG/mcnKtM0DUUyxcO1Z9ieEOZnVs8ThrFC83lN73/s3PyQddQTSJePmnZtsmjdSxiNE743KxCasOIjrnr6BRHpc9UOfPmvzTnUwxDbphf5Im+GlpKlosFVO97Ri2MERa8NKWYJiTqzLW4OsvVp9LJ5skriQWkAF/HpNLJ8vw6pffNAEGmqicsEOvzh+sR4LlQcLIvR1/cjQkspljIjLwn8c9n5IU47c2b6TbyPOF6IQTFXesIv3LwTd/jy42Xh+xzrhC5kc/JucoEXUOx+OZ+9e756BoG45jP/vnsRexfUyr3RsR2NbUwYu/hlE1rPU7MaL5naRGtDalSrB1S3DwzR0soZiaquMZweMEwHHa5fm6Rk6USXhAyEKckUiCspRbFvVw73HT4BB2vVwgnQFpDKiSJUL2xtWT99EApCUiUQ6qySIDoVepZAcrqzOjH+rXh+iAGIcB3s6I7bbBffBobJFiliIREeBKv8tqcPJwJ2dvpDuI8njxkefngvoNv+h5fbrxdG4nvy418zuUnN/I5OVeZoHPhyvpXM7a1ypZiyt4ZzaEX3lxuvts1FIuZdx10DcV2l/klQzcwTI4ofAQ7iikdx2FkxKWYaibChD3WIxWC0SjCDyPKScL6pWX2Visok30pkNZyouAjrUFYmJxbxApLKiUWgTAGLSUz5TLSWqTujZ8VlnIckEiHRCm8JMkm2iGwMivqs1Jgwwt58oCnsqK7R1/ClMvI77sRE2oSqUCK83ry0DPyX7mwJw+c9uStWZkOXPeudaSPHcN24xU5fs61S27kc3KuMm82XH+K995TY8rxuP/P3pwyWnBW4V3QNYgg4frrCjz3QsjaUYdAKv7371C0PZdvJi4OlrLVTBvF0XoZxwBRChaun1/kuYE6tU6AlZJlz+NgvUohSXu5eEEpSohclRXSYdBCsuwXsICjs1C8FYJSGmGEJCh4+HECvVy+VlmEwAiBjTSi8Kp7043BgvXcrOjui7sxxRLy+2/EBClKQorEr57fyIvVA4ihCmbfzHkL7wCc1TXkUJH46ZVRv5NVH+eWceIHD7/xxjk5F8H5fysuI41G4ybgXwNFwAM+D/wccAhQwEHgo81mUzcajT8EfrfZbD7YaDQs8Mlms/lrvf38CvCrzWbz9auVcnLe5pxdGPdmeO89dX7tKwknnp/lxCtdxjeWXnf7bnAmHdBppXgKbrixwLPPB6waFDwiJOtr8DUl+Ysln1vLDtWiYGM35Km+Kj+wNIV2XVJXsX5xmfvWTbLoKMpaM9NfR3QCQkedLrhz0zTzyIVAGYuWklKaYqQ8M5lOCBQapRULfWUm59tZNAAwvTSAUCBP5dzPuaAIa8n65IsW+9dPYY4HON+zDRM+glM0xFqct/DuFGLXVszfHTlvC90pirvWEd53EP+WsTfxVC4/3q4NJPe9jP/dm1bk+DnXJlfUk280GjXgT4F/1mw27wbuAJ4HdLPZvLvZbH4HkADffZ6PHwTec9bre3rrcnK+pXk9IZzzMVZX9FUVoYT7/9Mbe/PdrjmTk28bCkXJ9m1Fnnk+ZKAEoVLoIMGRkq5ULPke20zMuiDiuOOxWHY5PjJEx1GUjOG6xRYv9NfwkxRHCHxHMV8snDbyqVJ4aYqWAtdknnw9zPL21gqUNpkhx6KMZaleRlmLtBaEJVUKYSxKideG6iHLyRsQnoNQEnNoAfGO1Yj+MjYxKJEV3b+ekZf3Xo+Zap23uv4UxXvXE3x5BVvp7t2UF9/lXHaudLj+fcBfN5vNVwCazaZtNptfOvVmo9GQQB/nl+PTwLONRuMdjUbjVuDp3rqcnG9p3kgI53zcvtVjdrDKoW8uMHP0wvPH09SSJha/14N/qshv1biDtTA/l+JYw7FDEVZJVkUx99UHuenWCv1Ks7kT8kK9ysnBARLHQVm4fmGRl6oVhAWtU/pch1ScVq0nkQJHG4yUnKhX0VLi2KzKPnRUr19eIDFgYLGvTCaLk+XktZIIA457ASPfjcBYrOtAJ8SMDSHfl42atYnBxRAn4F+g8A5A3r0F200RVe+C2xTuXkP0yHFMePGT/y4Hzs4J9P4FzExnRY6fc21ypY38auDIedarRqNxP3Cc7C/Fl86zDcBngA/3/n3mSpxgTs7V5mLD9QDv3OjS3TJIVaR8/XMXnj8e9kL1p0LeQWgol7PX228ocPBIShnDkf0B2nH4wUJAc2SIL7YUlVCzoRvydLFCpFMckw2nGeuGeNZwvOCzbmoWIQRJsZDlyXuDaXQv5P7w5g1okV2bEYKEzIDbniePhdhxMEqcHmyTOAqMxfPlBYx8nM2qdxQstDEL0WkjL7TBQRMlXDAnD0DVzwbo7LvwvZP1At6NQ0QPHb3gNlcS4Srcu9YRfyX35nMuH1fayB8B1pxnve6F768Hxsi8+dfQbDa/CewEGs1m87ErdZI5OVeTiw3XA+xc77KnIylWFHsfmGVhOjrvdt3gzBcIay1hZClVsqjB9m0Fjs2kVJVl+lhE6iq+c9ywKgx5+KgldgR1qZkIYx4Z6qeoUzQCxxjWdQL21MoU0xQ3CEnKZYwAIyTCZnl4RxtO1mrsHxw6nWt3dKaiJzGZJ4+g2IkwjtOLA1hix0GlFr90ISMfZa6AlNk0uqKH2DaeCQRpm43Fjc3rhuvtfIAoONiv7n3d+1y4d2UlbrOQ/f433jAn501ypY38F4D3NRqNjadWNBqNe08tN5vNBeDfA//j6+zj93v/cnKuCYLOxYfrt4wpFruW6z64lrrSPPj581eBdztnKuujyOJIKNSyMPb2bUXmW1D3LYvTEVpJRqqCOxcXEMAx5TLoWq6fX+LJ0SGWHQfdG1CzqdXhlWqZFOjrBiitWazXsDL7EgCZV3/Hy6/wxRu3gwAtBLUoRgCFXsscQHkpxDgShEAKS+R6OKmhUHORxfPcl24E2mJnW1D0kT+wHdGrxEdkojxR9Po5eTOd6dafkri9EMVd61Y2L79rA/F9L1+UwmFOzutxRY18s9lcBn4M+J1Go3F/o9F4GNj+qs0+C/xgo9G4kDf/R81m84+u5Hnm5FxNguDiw/VSCm5d57AwUcN14Nm/n6a98NrBNcFZlfXdjsZzOC0S09encKXFcyUq1qTKAW145wgMO5Zpz+VApHj3vkPcffg4Xx8fAZl56gNRzHAYs7e/TiFOqC8ts9RXI/Sc00V0bd/jXfsPsG90hNhVGCnxY42wFmlMz8gL6ovdTKa2N7Uucj3cWFOquxcuvLMWji9mMrjf38vHB1kFv5ckBKF53Zy8nekg1/Rh901j5y6sN+DfPkGybwE9133zD+cyorYOg7bol+dX5Pg51x5XvIWu2Ww+Dbz3Vat/66z3Y+C63suPnrX+NX0k51uXk/OtxqWE6wF2bnB54mDKP/jxtXz9Dw/z0H+Z5nv+0cQ525w9nCYIDK46N1ddUpZASIY8w6xSmMSwfkOBycMRu4s+iYUPzi9SlJp/8R23cdfxaQbCiFKcsLHd4emRQbYtLOGmKVG7w9HxYWrzS0hrmS+XKEwl3L13H0ulAmPtFspkhl0DAotBUowTPJHQ8kuIxBK6Hl6YUKo7yOXzGOpuVl1vj8xBopD3bAHAdhO0EHhRTBDYC4rhAJkQzmgF+R2bMF/di/rhW8+7nfBUb/TsYcof2HpxD+gycGr0bPzlV3A25/Plc946uRhOTs5V5lLC9QC3bXB5bH/Ktu8ZQaaaJ/56iqB1biV4t6vPEcJxhcU7awSrZzStCEpoIqUwsWZw1OOWYYlvLF5F8Z+2rKdgLDfNLvDQ2BC65y2v6oYcqleRWmOlZGBukeVKmcR1kcYSSUmqJHe+9AqpI4mVQugsne7YTMZWo1BaU4wi5sp1hACtFG6s8Wvn9+RtO+smsCmIdYOIYlYhb7ppNuwmiEgRKP/Cf87MdAc5XM765d8gZF/YtY5gJfPyuzbk8+VzLhu5kc/JucpkincX/6t38xqHPSdSIiO4/cfXUFeaR78w89p9975AdDtZe9nZuWon0SwH4PbmwaeBxq84vOfdJXa0O8wWPO7bOEmnVuTO49M8MTxIy3dxjME1ho0LS1mfvZS42uBEEfODfVig4zloJSgkCf3tgKVSEWmzYjs/ybpftVA4WlOMY+ZKtZ5ufYqXaPyyOn+4vhVklfG+j7hh/PRq203QUuALi1/zXneqn5nJdOvlvW9s5Iv3ridcwdGz7q6NxF/LR8/mXB5yI5+TcxWx1l5yuL7oCbatcth9KGH7941jw5RH/+IEUXBGPuLsnHwQGJQx5wxuSRPLUJ9EdxISx6G7nOJVHO5sFJnoRlgB7zo0xe7hIQaDkO1zCzw0NowwhkKcsHlxmchxshy7NVQ6XYwUtGoVln2PQpIyWy1T74YslQosl/yeJ5/1xWuRqeD5cULLL2cqeVYjtcnEcM5XeNeJslE2YYrcsfr06mQhRIvMg3+9ojsA29OtFzesgk6M3T9zwW3dG4YwnYRk/8KbezCXGTVWRU5USZ/IR8/mvHVyI5+TcxVJYouQAte9tF+9xgaXx/enOL7knR9ZTVWmNP/uzIS6s6vrg65Gpvp0Tt7aTChn7YSL7qRYR7A4E+NXHGoVhQe8p5xyrL9C23FR1nLXsSmawwO0Cx7lOKYepzjGYLOZM9SDiMpCi+nRQVxt8NOE/UODKGvwk5Rv3Ly+d2aZl50KhbIGZQ2lKAvDK1KksSydCM/vyS8HgMpa5ybP1OdG02E2otZTr5uPBzAzXeRI5ZzRsxfizOjZQ2/wNK4c+ejZnMtFbuRzcq4iZw+PuRRu2+Dw+IGsqv7m96/CtBMe/PMTpEkW2u0GZ/bf7RpUqk/n5OPIIgRs2eBBlKI8RXshOf0lwMFSWYhZKBWY6HTRwGCUsGmpzUNjI/has1wqUErTLN9uLY4xVIKAUiek7CiksSAgVZJKGPHshvFsCh2il5OXvRC9odrtgs2WhbHMH+ie38jPLGOQMFbLRs32CKcDAKzv4L2eEA5Z4d0p3fo3F7Jf4bx8LnGbc5nIjXxOzlUk6GoKb8HI71zv8sSBFGMsXknR+JFJSjrhqS/P9/Z/pj0v6BpEnJ4OZQddjVSwdpVCWPA8QdRO8crZ+9JaZpcN/+3eV+gUfJTJxsTeeXKWR0cG0UIQKIk0llQKsLbXJpcwOjWD63uEvkc1TNFKIo3hxgMniJ0zIXhts3y+tJZyECAARdZmN3chI7/UxaIQg5VsCl2P+Cwj75ffIFw/0zmtWy+/ayvmK3tfN+dd+K4VHj37nWtJH89Hz+a8dXIjn5NzFbkU3fqzGapKBiuCvVNZHv4d/3AC04p44M+OobUlCM4dM0uo8XuefNg1CJEVqmlX4SiJjTSymBlIY+GGNYrG3ByxUrgmU6sbCWNWdwIeHR1kuJMZVtfC0VoFIwSOsbhJik5Snt6wiSXfw9WauUqZnXuPEXguXa+nwofASJHNmk+zmfSC7P+6nZCKV/1J0gbbTQABRTebJ98jnu4iBBhHnVN3cD5OVdcDiMl+xEgVu/t8itsZzmQNNVwi3r1Co2crvdGz31i5lEHOtcE1Z+SbzWa+nC+/bZefe24PjiPe0n62r3b4woMvAVCoOgzdJFBhwomXuywsLKNUtv+pqRlIDdKVNJtN0jTzSl/Ztw+kILGZ9z6z2Cvcs5YtfQYsDNveEByRtcDdOr/IM0MDDMRJz7AbXumr91LtFmEts57HkeFRjpbLlKOEowN99LUDEkeyZ/UIAMYIrMjOIyWbPpcqiXUEhSBm7+Ez2vLNZhMefwWDC8Jip1qIofLp+6CPLKOVwFR9lCte977ZTowoe6fXi3dv4ODnv/6699l/9wQvff7RS3pGl2PZffca0sePvS1+bvPlt//yhRDXoHziNXdBOdcOxw5H/N6nj/Mrn1r/xhtfgE/+RZs1A4qfvqcIwCN/dIgn75tl1z/fxN99o8ud31Hl1p0VPvcfZ3j5Lw/xM7+5lf71FeZnEv7Xf/4KH/v4OI985Kvcf9c72PHSAb7z13aw884+PvGhPdw8aVn7p4/wlR+6g+pTRzHKIS54nKiU+NzqcX7u2b0MLHfo+C6PDQ/ynuMnUd0IJ0n50q03sLnVRs7N8OHHX+R37n4X739gHwdW9ZHWLB97/m9pujdxdKCfd868wpQZBA+e2z5BdTpm4uQipT/4bt7x4bPGXXz8j0k+/QB2uI80kBTnfwPRC//v3fi7TIWCNd+9ij1jq/jeX7/5gvdsftVvUH/sv0NN1gFIf/m/QNnD+Zffd8HPLPzy/YiKS9+/uOOSn9VboftbD6EPL1H9vy98jjk5Z3HeHtJrzpPPyXk7U64oOq23NjG5ryRZ6J7JJxdqDhIIWimViqLdzt4rVxXWdwgX49OvtbYEMYBFxxpRcFiczd53PEHnlWVG5xYpjxZIlELYLJReTDRBb/Ss6Xn3WgqcNNOP///Ze+8wy67yTvdda+14UsXO3QqtVkaRo4RaQtgC4zGYYOMwjI3BkcFzr2fwXMAefME2tu+99thzPQy2x3Mx4DS2Z8SAwUYgJBACSRxlqRVbnXOlUyfttNa6f+xT1VUdpa7UEvt9nnqec/Y5e++1d3XXt7/0+2Y07t0sY3UvIpOSTuChtKFb8ugFCoNibLBK5Dt0XS/PxXsp016ZqOZjpaCtjsmt3/UExjpwyXrkDefNGnhrLHJPkyk/QN2wgah56ty1GClh50rVjpRh4tTStXIkxEycfKzvUiNGStjTrLGg4HQURr6gYBkpVyWdtl7QAJKhsmCyc3T/sOYirKXb0pQrknY7f4ioVBR6jpH3+jPmp5sZsuyiUo0sObTG8mp9zxOwp8mhwRq1YTcfAWsBaymnGZGTG/1U5WF2KySOzs9lVV5MJ41mMEqZCkOkNghAK2iHHgbJ5HAZaQyxcnHR4GksEmuhOVplenyOHr+1mGcOAAK7YRh1y+bZj5Kn8rbBHgr/po1EU8fr+M9FjJQwE70578un1LCH3Mjr8d4pv7OUyJESZgXPX/DqoDDyBQXLiOtKHEcQRwsx8sd48gMuaEN3OvfkO52+J19RaKWIp3MDKITA9QXNiQx3wEOlGrfi0p7oPwQo8DC8uGYV1aoiVflwGmktjrF4WpMoReQ4uSa96HvykPerAxhDoA1j1QqD7QgLBFrTDEukONgQjFJoI9A49EoeVoDfS+isrdKenCPT+/wBbJoX5tmdk8its8Ms6X55O2BJQ49wdTh7jSdDnsiTH++cch81Eq6okZUjIWaFBuUUvHoojHxBwTJTri4sZD9UOtaTdzCpycP1VUW7f+xyRZIKOevJA/i+pDmZURrxcdIMt+LQ63/upBoXy8Hz1lAuSzIpEcYgrEVYQynLQ/Y910HpXItezrShCfDTjEwIJJKDI4NsGJsmdfOWu2aQG3nfxExXSzgpOKS0VIgVAj/OiDfV6DTnGOu/fwAjXBgIMI/tR95w7uxH3X98EWfIJRGKYMAlap7Ok59vMMVIBXsaIy9X2Mgfl2IoKDgDCiNfULDMlCpqNqR+JuTh+rk5eZcsMnm4vixnc/KViiKxcl4oOywpWk1NZdTDyzLckkM0nXvPqhNDopm4cA3lUOVGvl85j4Uw03QcSdfNtewVeTTfKAkISnGMAWLXZWywypqJDt3QBSytIMAgGOx1mCqXMFpSYZos9rBSYIXArK/Qm/vw8+VHsLiwZS3yNesQZX/2o/ixw3i+QFuQSqBTg05O3vcuh1++Jy+HgyJcX/CKpzDyBQXLzEKL74bK8ricfBZpurOFd/2cfFURa4jnFKWVKopOK/fkvTTDupKklWKtxdvfpFsOcNaWUa4gb0K3fU/e5p68mvHkLZ42pFJipARrqSQpfpwR+Q6p5zLUjGiWAwSCju8jsQx1W1S7CUYKyrQJJvO1tisBQUkRdY7eF/P4bqyV2AvXIrcezcenu6cxvQyOtAkGPOJmSjDg0jtF8Z0YKc335IdL2ImzO1wvBgPsdFwMqilYEIWRLyhYZipVRWchnnxJMNU9auTdUGKNpTuVUqkeLbwrVyRRCr3Jo8avUlV0O4ZgyMfLMlKRD6vp7u4w1OowPVChWpb56Na+hy37RYKh1vQcRSZyQZtqmtJ1FFbm+Xg/zRjs9kg8B5tZXG2YqvoEaUrH83BJqUUdRqY6CCNwyZD9jtd2ycf3JXGvb9AON7HtFLDY8d48I9/96k6kMTgXDOEPe8RTCcGAd8qQvRwJ53vyw2WY6mHNqbz/EDMVrZjqnVASUfOxUytX4V/wyqcw8gUFy0y5sjAjXwkESWZJ+uI2QgiCqkO3meaFd/1wvetKlIJO82gxW23QIeoZ/ME8XJ9Yge5ljN9/hFW6RzsIqJYliRHkwfocQ27ku44D1qKlpJxmdF2XXDHH4mvN2qlpUtchnI7ohg7tss9gu0fkOiiRUY26jE60kf3Z8kkl18CPAg/HhSTuG93/9RBWuBA4mAd3o+Ya+c8/jzPo4t96LsGgR9RMCAZd4lMY+bwdbU51vaOg4sPUyT114UhExcM0V87IFsV3BQvl1ILPy0S9Xv9Z4KfmbLoQ+Dzwr4FfaTQa/6n/vRcajcaWFVhiQcGisdDCOyEEg/3iuzUDeVtcOOAyMZ31c/J5i54QglIoaY8dNfIDww5JZPAHA/wsIzICEWkm7j/C4FSLruNSrUh6GbPz2YW1aCkIrKXjOmzSGi0EpSwjUpIwn/ZOKY4ZaXXYdc4aBg60SQJFJ3CpdSP8TNPyQ7wkpZJFlGgTUyILDE5miD0HjEVr0JlFff67GFzE+aMI4yJWVWevIXrwAF5F4W3dhH9fN/fkay69U3nyw6XjjeVIGTveQQyXT7rfTMheDYVn8JtaOEXxXcFCOSs8+Uaj8d8ajcZtjUbjNnJj3wR+GzgAvK9er6/M/7CCgiWgXJEL8uShL4gzp/guHHAxiUYKUI4g6rfozRXHARgcdkhTizfg4mcZXa2QScbkPXspZQkpkmpZMX0oJpMC2e+TF1h8bei4Dl6msVIQaE3HdbBSgoXR6Q4TpZCu57NmvEXqSbqeg5dm+GnGdFAi0x5KGipMo3HxbYqwNhfXSSxKQa+dYR58AWsVXLphXqheT0bo8QiaPbyt5+Se/FTar7A/dU7+WGMpRspwul754WCF2+iK4ruChXFWGPkZ6vW6A/wVufd+AOj23//iii6soGARWQzVu+MEcQZc/EDSa+n5xXcDim7vqJGv1BykAgIXP9N0MomrNXp/m+EbVwOWciiY3NlBOxKFRRqLAkqZpus6eMbkLXPa0PZcjMw9/uHpNgcHqvQ8n1onJgoUsaewRhKkGU2/RM+EeCalFzooLKVeroUvgLSnkVi6h7rYsS5gsRmoW472x/e+sQdpDarq45wzgD84k5M/dRudHDmBJz9cPq2i3EoL4ojhIlxfsDDOKiMP/BbwrUajceecbZ+k8OYLXkWUq/O96zPhWEGcsObguaJfYS9n8/LVmkNWUK9gAAAgAElEQVQmJWlPz55bSoF2FW6W0cpAaYM74lK7ZSMgUNYydSiG0EFaZtX5Qq3pKoWDRVhwrKXleeQm2lLr9tg1MkTiOExWPIwQaKkwRuBlGc0gpEUZYQUHayNILEFHk7l51jDp5SNne3c/i0WBkpjGnnmefOeO51BlB+/WXN8+GHSJXkLhnRgOsZPRvEI78VIFcVZQ2lYeU0tQUPByOWuMfL1efxNwM/Abc7c3Go0O8Dngl1ZiXQUFi025ouguMFx/rCcfDLi4Lse10ZUrClHxZtvoytVc+107CjfNiFKBVpJEW8JbNiAl2Fgz3dQ482a7i1lP3rECx1oyBInnovqGM0hS9g8P4mSaqYEARH5sg8LPMiaCMhElSnQ44g6hhcRJoBd4CCDuZNjMIv75MYzwEJsGscYiNo/OriK6dy9q0MXb2jfyA/m1BQOnKbxzFaLsYqfjo9teorRtoXpX8ErmrDDy9Xp9HfBHwLsbjUZ2gq98EvgZIFjOdRUULAWVBRbewfE5+aDqoAT0pvVs8V1+LokJjoayyxWFNZbYSmSSkWQWIyUdI/GvXoNyBPF4TNfKXLLWWqQxCCxBv7peilzq1lhLqhRKa6S1tMKATEncVBOVc6kcCxghCNKMI8EgHglVmtB285n1IiVx8oeJuJ2BNbiPbcdaBy7dgLpl82wBoIky0t0tZBzj35IbeX/Q63vypy68g35v/BlI265ouL4ovCtYIGdFdT3wH4Aa8Ll6vT6z7aGZF41Go1uv1z8H/N4KrK2gYFHJw/WL4Ml35+fkJX1Pfk46oFxR2GDOJLqKQhvyPL2nINZYY4k2jyAciecJus9P0asEOIcO5/3oVtO1UM40XUchmZnnnFfdu6nGMYZmKcTVBi/O0D7IFIQFa/Me+rGwhsNerGuothNSxyE0vVzxDoi7Gs91KB8YAxS2WkLefDQfHz14IG/qiw3OZasAXnLhHRz1itUFI0AubWu2HTj1PsMh6TPjL+M3s7jIkRJpYeQLFsBZYeQbjcYHgA+c4KMPzvnO7wO/v2yLKihYIsJSLvqitUWpE46APi3DZcmOI3PkamsumJkhNe5s9X6lotCuMxuuV45ASZiayFAVF5VmSAnJ+nzOuhdIOrtadFWJysFpMikZintMWYuf5a1zpu/dS2NB5pPoHGNohQGrJ9u4aYYrwdcZyhisFPhpRsstoXFohz5HgirrmuPUTBdcCQLSxDIsWgRJCkKhnzyI+6E3zl5j9389j3TB23oOol/sd7Tw7tQ5eTjZuNnT69evqLTt8MqmCwpe+ZwV4fqCgu8lpBSEJUm3s1D9+rmefK4yN1td3+rr11cVmVLz9Os9XzI1keEP+jhZhmMMcS2vaw1CSftwzGAcU+7ExI5DKY4QWJQxhJkmsbnnrfpyq06WG/me57L2SAthNY611KIIxxgSTxImKaVeRkCPrixxeLiCSg0+SV7tj8Boy4VjL6KFB2uq2L1TiCvXz667e+dO3GF/NlQP/cK75umr6+H4djQxXD7tkJoVl7YtwvUFC6Qw8gUFK0C5elSZ7kzIxXDmD6kxyRz9+v4DRLksSZHzQtl+KGlNZZRHPdxM4yYpicoL8kolSadnOX+yiadTElfNDqjBWkKtybD9cbMGicXNMoyQaClZd7hJKgUOMNjrUo4TWiWPSidmVatNlWlELIlKLqnMR+G6Ir8OKwQbDu4B68DF65A3npcr0wFWG9JnJ5HC4G3ddPRa+oV3fs0hbqaznQAnIle9e5lDas6C6npTVNcXLIDCyBcUrACLMaRmrn59MGdITXlOC125qkiMmFd5Xior2tMZ5REvD60HkqT/UBCkKWk1YO2ecZQxGCVJlZMPqcESZpoYQcv3UdrgWPDSjMTN5W5XT3RoBw5C5v335TihXfIYbMecPzZOiQ6lKKGSpIxXymRC4Zs0T9wLqDUnc3Gc9cPzpGyTp8YAi53o4tWPeveOr5COxKQG5UvSU0RHju05FyOn9+RXOlx/7IjcgoKXS2HkCwpWgPJCh9QcM242rDmkPU2necwkuooizpg3U35GO18BXpblxV3t/CHAb/ZIQ5ehA1NYIXCEIJEqH1Jj8175SAimwgABhFmWD7pxHKSxZErSDnyMlKRGUYpTuoHDULPH6qkOPj2k0qyebLF/sIYWCk8nCAALTmYAi90xiZwjgtP90otIa/Dq6xH+/FKiYNAjnjr9JDp5opz86cL1K6x4J8oeZAYbnToVUVBwMgojX1CwAizYky/lnvxMeFq5EseT9JoplYqk3T92qSyJs2Mm0Q0oeh2Dnkrwk4xspITu5J2r/v4mmZA4WYb1JAhBKvOQvZGSUppL2bY9ByMFlTSjlCSkjkJpQ7vmEytFphwm3YAgzegGHqunWghpyHBxVMboZIu9I4N5D318NBwurGI6LGOe2I+8/tzZ7d0vbUeN+PNC9TMcbaM7jSDOsRKx1QDiFBufYp+aj40ybLKwbogzRQhRFN8VLIjCyBcUrAALNfK+K3AVtKP5IftefxLdTAudlILAF7SOnUQXGZKDPfwkJR4sY6IMqw3ec2PY2NAue7geJJ5L2s/XZwKqcUIrDHCwaCFZ3WrjZRqjcv36TsUjdhwS1+X5VSP4WUYn8AiTlAEzxbgcxLcxXpJxeKiGRVDqtLEiL+ZzNBwpDyNesw5R8oBccS9+7AiOD/7Wo0V3s9c94M72yp9O2nauJy+EyEfOnkLaNjeyQdErX/CKpTDyBQUrQLmi6Cyguh5gsCyP65WP25qwJIgig+nPQS+X5bwHisEhhzQ2pNun8LOUnuMg4ozoiXEGywKbaLQjGGq1yBxFNlP8JiXVKKYVePiZxgo4Z2KKpu9hhQAB3YpHqhSx67Fz1RCu1nR9F09kuCpiX7iaQCdMDpaJPQ+sIOz2ZvXrPZ3R9stw09F8fLZrOvemD3fwXndiT35Gv/7042aPH1JzOtW7XNp2hYfUFMV3BWdIYeQLClaAsLTwSXTDZcGBqaN5+dKgixKW1kSGH0i6/Zx9WJJ05uTvKwMKrSGIE7xM09USL07Z9+U9rLlyACdNQcBIs4WxgJCzc+UHuj1agY9nDFYI1k21OFwpYYVAK0HmCoyUdD2fdtlFGUvkOShr2b1qkJYf4BrN5HCZ1PORFsJeFyMFEkvLC6kkMek1c0L1d+1CGIOzZQg5eLzopV/LjbtfdYmmT2Hkqz5m8phK+dEKHJw+5X2Wg8GKVtiLsoudLIx8wZnxqjPyjUajeF28Putfv/hcD8OhBR3nR68L+KOvdPnud/PtV71tHaWsx1/+1ovozLLt6UfodTWHD2eU/KOa7d/86l4qZQmDASrTMBCwa/1qvvKlMfZOC0S/gM41GtPX6hE2nytfTjJ6jsIIAdZSjmMMIg/Xk4e3tbEkjkMVgxGCUhQDgiO1EoFJwMKh4QGabl61b0Wez5c6n0LnZBn+ptrs9fa+sgPKAu+GjSe8D52DEaXVAfueO0hp1D/pfUu++AzTl5TnbZdvvBT99w+f/D7f/yDp0+O4Fw2vyL+TbPsEvW/vxN167rKet3j9ynt9MsSp+kpfobzqLqjg1UWSGD78i9v52B+dT23gzEUnU225/fem+MhbS7z5yty4ffFj23j6hYT95Sp/+CebeeC+Fl//n4e5sdTm+377arS2/Op7nqV+TUjts4+ww7hMvOVynut5/Pr6Izx+52EONiGc7nLNwV383S03c+6BMaLAp10u0ezFfPmS83jn9j2sHm+ydftOdgwNsn/jaiqTLbrVEv+0+VwuTxLKrRabdh1kLCjxxqe2s+9CSxbVeOPuh/j4W97LY7USn/nrv+Ufb7qWplujFHf5mcYXODi8gc3/8OOoW7cAsOvCP0PFMYMfupHKB6477j587vVf4e1/fQv/8Avf5Z1/eh0DG0vHfccaw+SW/0j1b34c94ajIX97oEly2cfxdn0CUTt+0GX07b1MfOBO1j/yvjP+PS2E5r/8O5xLV1H+6BtW5PwFryhOKJ/5qvPkCwrOdrY92mHT+cGCDDyAqwS/+SNlPnZHh16SP9ve/u8upBOD6ibc/8UjNB5os07FjFxcA+D5pzoYbbn++jJpYhFK0NvTwXMF3qqQ+ohhulxGWYNWajbXLsj72IMso+c41KKYI6WAIE3RjkSafPws1hKL/El7oNvFCMFos4t2BJUoYaTVQitJN/DYG/gg4Eh1CAuUkghPJwSuhX49gbWWbHcLZTXu1WuOuwe98Zisl6FKiqSdUVt/4onU6T8/jxwOca7fOG+7WDeAvP1SzF8+eML9enfuIHjT+Wf2C1og6cP7Se/eQfhvX7ci5y94dVAY+YKCZebh+1tce2NlUY71+ks8Lt/g8Kd35znbsOYydNUw1STm7r85wLYnupQPNhm9JDfy9945SVhWrF3nkvQMypVE7QxPWLTvQDehWwpIRR6Sn60aMBYrBOUso6cklThhx+AAfpqRqLzFTph86lyqFK7WDHbaGCEZ6kTErqIcxayfbGIFlFtddoUhmVRYKxHAcLeJACppd9bIZzubYC1mrIt71drjrn/8mSYjlwww/nyb0Yuqs5r2x9L75P0EH7hxdqLdXNT7b0F/6psnVMuL7txBuEJGvvORr1L66G3Iir8i5y94dVAY+YKCZSRNDE8+0uGa66uLdsyPvaPMf727x77J3CQ3Y8nmLSHVVR5OkjH+YpvRi2sYY9n2aIdrb6rRbRtMZlCOQA+XUK2IzHex7QQjBcpajCNn/0DkYjiWINOEmcYKwYFKPlrWCokyJp84B8RK4uqMSjfCSEE5SuiGDtUoL15zdcbmvQdY1e2ROg61bi5Is6Y3iUUSTLegr4sfffcgQmvUphqy4h137ePPTjNyyQBjz7UYvejE91S/OEH24F78n7jyhJ+LN1wMSYa9b/v8/aYikieP4N+88YT7LSXJXdvR2ycIf75++i8XFJyCRTPy9Xr9vHq9buv1+tvmbHthzuufrtfr99Xr9W/U6/W/r9fra/rbf6Zer/9x/7Wo1+v31Ov1a4859nC9Xr+t/zO8WGsuKFhutj3WYeN5PrXBxRsAuWlE8TO3Bvzm5ztobdm3L+GHf+V8dh3SXLhBcmRgCFyVh+qN5ebbB3n+sRauI1ACzECAOtLO++HbKVZIpDHEvoM0/ap8Y3G1xjOGVb2IVElSKYldFwtIPeMFC1JH5ZPpsjTvfTeWVsljoBuhcVAYotDnPdu2E7luHgEQMBC3EAiEEvDkHgB6d+1Clhy8a4734gHGnmkyckmNI8+1GL3wxEY++tQDBD9zLSJ0T/i5EAL5S7eiP/XN+ft9fRfBzRuRwfIO67TG0P7QnZQ/cTvCVct67oJXH4vtyT8DfKRer8+LidXr9a3A+4DbG43G64FPA38J0Gg0/gK4tF6v3wD8HPBwo9F4+JjjvhP4qf7POxZ5zQUFy8bDD7S59sbF8+Jn+MDtJR7emfGlB3oMDTsEVYdeGKCfHmOgAv/jD3byzTsnCULF+nN8nnt4GscRCCyZlHiepLNtDNvJ2+ektSSek3vwQmCkwM0yFIKNrQ5N3+O8ySaR64Bg1pMHi2fyoTVa9kV0XEWmBH6myejr4K8JGI5jEqVIlIuUAlfnDwVsGIY7HwcgfmA/zoCLexIjP/50k9FLBhh7bppVFx9/X20vJfqLhwl+6fpT3j/1nhsxX3oSe6Q1u22l8vHxPzwFFvx3Xb7s5y549bHYRn4f8DDwtmO2vwf4nUaj0QNoNBpfBir1en1D//N/DfwX8pnyv3GC4xYV8wWveNLU8MTDba65YfGNfMkT/J9vL/M7/9Rj4yaPxx/pcOGlISMjDkOBpTWZ8mSjzbU3Vek0Mw7uilEq/wOQZlDaWKZ1735MOze0wuaT5iSAtWgpcTJNpiSbpjvsrZQ4f2qaxHUxCFTf47dArRfhak3sOghAS4FjNAKLRSKxsDpg3/o1dB0PV2dgLano/znaOAzfehp6CekLTaSyJzTyWaSZ3tOhuqnE1J4uw5uPr3OI//ZxnOs2oi4YOeX9E8Nl5NuvQn/6O/l1WEv0lReXPR9vU03n179G5f96E0IW2dSChbMU/4p+B/jwMd78RmD3Md/bBcwY+RcAF/h6o9E4kfzUHcDn+j93LO5yCwqWh6cf77LxHJ+BRQzVz+WHrvbwrGWHcnnogTb1GyoMliytiZTzr6ygtWXdKoenvtNk89VVMLkxz7QlPKdCb1+HqJ3L3woLPdUfTAOYvupd5kjWtzs8OzzIhk6P2HWwApTWYPP9RroRjs6YLJfAWiQWL8sQWHxiBJZxE9ANfaarZZxMEzjQ8vtGOvSwF6xF/9V3crndiR7u1ccb+ckXphk4r0JzX8TgxhKOPz+0ba0l+uT9hB+44SXdP/X+W9F/ei/WGLLtk9hE4142eqa/jjOi9+cPIc8bwrv9gtN/uaDgJbDoRr7RaOwFHgLePmfzPuBY0elz+tsBfgm4C7i1Xq8f9+jcaDQmGo3GPf2ficVec0HBcvDwd1pL4sXPIITgJj/ly7ssjzzR4+rXVph8ocX3/fIF3PPFcYJQcu/fHODhr41z6Q2DYPI/AFqD7yuc284lTbI8bCagI44aeQAtJZmUhJnmhYEqo72I2HOwQqC0QQAGWNXt4WrNdBAiLHiZptIfQuORi/JMdyUK6JRC/DRlILRMlAfyE0kBt72G6M++g7AGWXZRa4730sefmWbk4tpJi+6yB/diJnq4b77opd2/689DDITYO5+m16+qP1E1/lJh2jHd37qHyu+9cdnOWfDqZ6niQb8LfGjO+8+Re/chQL1efzPQazQa++r1+nrgF4FfB/4d8J+XaE0FBSvGUobqZ7DW0j0QcdMGye5VZVSmSbsZF71xNR3HY1XJ8v0/tY69z3fZcGEJawwCi9YWzxOo159DNeoh+poaHakQ5N6+tHlxnBGSsTDAs5ZymhK7eTGbow0WsALWdLo4WtNzPaS1hHHKUDuvoPdIsICxgiCKaYYlqlGPZNc0Y8FgfiECuGEL8eNHUK7Ffe26E17v2DNNRi/N8/GjfR2AuUT/5QGC99+AUC/tz5wQIvfm/+TeFcnH9/7oO7i3nov72g2n/3JBwUtkSYx835tvzHn/DXJD/7V6vf4N4OeBf9X/+D8Bv9ZoNLqNRuObwOF6vf6jS7GugoKV4pknuqzb5DM4vHSV2lNTecj8ShOzSyvu+840IxfWePHZXi5kM9FmYnuL0fU+X/zUHtAWYS3a5FPt9EDI2EAVQZ5b76lccx4EjtaYXBWHI2HAQJwSJCmx4+QV9JkBIRAWhuIERx+dMe8YS9Af1eoRAYJMSMq9HtNBidFOk9IFNaLM60cRBHgO8cBqQrdz0sr6mR75E1XWm7EOyReeJnjfa1/WPZQ/WUd/43miu3cR3r58Rt6Mdej+0Xco//bty3bOgu8NFu0vTqPR2AncPuf9Lx/z+afJq+qP3e9dx7x/72KtqaDgbOHh+1tcu4RePMDuXTEbN3m8+FSXf//udfzuV6f52MU17v3KJH4geef/voX//sEnue3/uISn7p4gS/rFchY8D5LU8sAlF+QbgEgpPJ1Pm7Pkg2c8bThUCSnpjHIUE7sOpBrHaFB5y50g9+wzV+EYTc9zKGcCkVlcMqwQONZSbk8jHZ+Bbod9o2XU02M8O3gOFwsBxhJFHqujHcirjle6s8Yy/sw0w/1w/apjwvXRf3sI7+2XIUeOl7g9FaISkL3hCpzvTKJWvbx9F0LnE98g+IkrcLacukCwoODlUpRvFhQsMVlmebzR5pobFkfl7mTs3pUQeILzLvB5z20hUc/wyMAgTz3S5uobqgyfXyV1XfZ96wg/8sFzsdqiI4Ox4LmCKLbcv2XzrAD2jLG2QiCMQQtwjWZPtUKgDaUZIy9BagMIVF8Zz80ytFI4/WE1mn7oX4ARAj9OCKMIP00oJRHjY4ZN6WEeGb2IVqownRTd1ni6jesfP1luem8Xv+aSdDVuSREOHRXKsdrkvfEvseDuWJI1q/BaU9h0YVMCXyp65yTRZx+l/NHbluV8Bd9bFEa+oGCJeeaJDms3eAyNnFiMZbHYvSumPa2p31BFScEPH9zLn+3w6WnB1jcNse3+Kc65ZRVHtrfZ+2gTJSHpacDiKBif1FRN1teqB4WdLbxzk7zNzdGGQ6UQsPhpHpIHiZYCK8WseI6jcwOZC93kaQHR74S1QmC0RjoOXpYRZimdrmVd5whXjm/nvoNV4p3TCGmJ3GHUXY8cd63jzzTnePHz8/HJl59Frqng1s9MqS56ZIxgcwXzhcfOaP+XS+c37iL85RuQJyguLChYKIWRLyhYYnKt+qUN1UNu5A/sjbn2ujJZrBl+cYxzXM1zlRKbzg948ttTXPn6Yf7Fr1/CXX+8nRSJH0iwkPQMY1OaDWkXZD4/3u2PfwXwuzGONnRdh1qc5Jr1jmJm8FXP9fIq+754jqM1jjFIk0cDpMmH3EyE+X3YVimR+GEusKMN1ncYbU9y6eROLIKn7m0isSRXXoz422/nzfxzGH9mRgTn+Mr66JMPEHzgxjO6h3qiR7ptjPCDtxyngLcUZI8fJLlzO6UP3rzk5yr43mTFjXxfDneyXq/fXa/XH6jX67/S376jXq//+Zzv/XRfNve8FVtsQcHLRM+G6pfWyEeRYWI849zNAdWaw+T2NtVNZc7b12RnKWDbzoTdz3S4uF5j/eU1Ln/zGsbW1JjRW3ns6+NMTGo2EmNtXiVfTlKwueftpBlupjlSClnd7hAmKYlSQF513/UdjBT5fHjAMRorJF6mcY2eVcN7cv1mpDE8XauQOi5elua9+kYw3JlCAls3tNi2X9IbKaNedwFcuBb+6dF51zv+zDQjl+ZFd3Pz8fr5MbKH9+P/2GvO7D5+fRfBLZtQP/Fa7BP7Mc8dOqPjvFTaH/kqpV+7FVkLlvQ8Bd+7rLiR7/NQo9F4A/A64P31er0MaODcer0+M4LpR8j77wsKXjE8+2SX1es8hkeXNlS/d0+ej7+uP91u7NkmYtMAbmp4300+H/6rFhdcVcMLcsGYrT97PqnroBODEBBWHQ4dSlmtUqy1GAS1XsRMkH0q9HG1ZnetwsZmi3Ickyo1W4nf9T3szAQ4ASrTaEcRpBnS5q16Vgj2jKxBWssvPJ2PtfB0hrBQrikcm0cNaqHlgukJnqitQl21Bn769fCZe+Zd70xl/dhz0/M8+d6nHiR477WI4Mzu92x/vO+i3nsT5k/uPaPjvBSSb+wg23aY8BevW7JzFBScLUZ+hhLgATPSVV8Gfqher68GUmBqpRZWUHAmPLRMofoXt0ckkeaa63IjP/7sNAdEgOdJPviOCrvGNL0LBma/7/iSNYebZHFu5C++YYBYw24d5KI2QhCm6Wx//ES1hDCG3dUKG5otqlGch+ttXnnf9v189nz/vTKGTCr8VOfHQOTHKdUQWL6ycT0AUmdgYc25ITO6M9bC+oMTKGt4bq+FH7sJvvYEjOe68tFkQjyd4tVcombKwMa8Ct52E+LPnF6n/mRYa+f1x6tf2Ir+7P3YXnJGxzvdudofupPKb9+O8Jd3AE7B9xZni5F/bb1evxc4APy/jUZjur/9b4Ef7//83UotrqDgTNCZ5bFlCNUDPPFoh5FRl4GB3GAceXqa3UcsV15XwcSG68Yn+f+egSg9qmAXZhlS5VK03cgipWBn5ve16gV6xnADY+USwlhSR1GLU2q93MjPqOO1Ax+j8rnwCFDWoFUerjcw22O/+fABAIazNE8DkIfyS0mE6ecO0pZGCctVB/fw5D8fYuKIhh+8Bv72PgDGn20ycnGN8RfajG45OkM+/pvHcV53Dur8MxtUmT0/AdrgXpK3sYnNqxDXnYv5u8UPICaffxqiDP8nr1j0YxcUzOVsMfIPNRqNW4BbgTfNbGw0GgeACvATwBdXaG0FBWfEs091WbXGZWTV0obqAXbtiLnq2jKQe4m7d0VoDVvfOMS2+5u84VKPi9c5/Ne7e7P7CCVmFe12Ptsh8MWsodVC0AtLpI7CWuiUfDIpGUxTgkznRl7leXgroFnyMTPhekBqjZESN9OkQvU9ecGWQ3sRwEXN3CsfMjHCQrS/w99f8mbGSgMk4xnKZAxsGeC6X7mUuz/yMPpf3QqfzQvhxp/pz5B/vsVof/KctZbeJ+8nPMOCO+CEUrbq/cePoF0oNtO0P/JVyr9XDKEpWHrOqn9h/RGzB+r1+r+Ys/mTwB0zE+wKCl4pPPLA8oTq40jTbWlu+/48HN/a12NioIbrS867MOTJ+6a44uZBPv7OMn/y9R77J/vtbVJgjcX1JXtfjBHa4vdb4DIp6QUBqesCFiEEh8shm7o9Qq0Z7PVIlEL3jdR0GM4x8oJmGKCsxc0MmZRoKbEC1k1OYIGhNO99D9I8FP4DH38NV4y/wD9evJXvdgawocS9Zi2XvutcgkGPx3aVYM84PLPvhPn47P492FaC+6YtZ3wfZ4z8XOQPXYHd38Q8sueMj3ss0V88glxXxfuBM19rQcFL5awy8n3+EPjwzJtGo/HlRqPx+yu4noKCl43WlkcfbC+5yh3Affe2cFzBmnW5IMyRZ6Zo+iWurFeIOpqd29pcct0A544qfnprwG9/oZvvKAXWgOsANZe0lxEjyQAjBYnroYVAC8lou8uuaoX13QhXG0a6ET3XIVN5+Uyz5GNVbuQtsL9Ww9WG2fj9LAItBI4FYQ1B1Mtnp/uSy6Z28GNPfI2OdvjaRZdzeO0oQghe/1vX8MRf72D8rbfCZ77R16yvceTZoz3y0SfvJ3z/9WfsGdtEE31jD8H3nzdvu1AS9fNb0X+yON687SZ0PnZ3Pkp2GYffFHzvsuJGvtFo7Gw0GnPlcJ9oNBq3NhqN4x5zG43G7X353IKCs5rnnuoyssplZPXSh+of/HaLNeuPKr49+91pjBBsfeMQTz/YZPMVVfxSbnvkd5oAACAASURBVIz/zRtLPPhiygPbU6TK8+SOEiRW4mpDJgVtR2GdvD1OGUOqFNUopuO5eNaAlIx2ukwHPpmSgKAT+JiZljoJ+wYHUdaSKoUREmkt0hq0kEyGuWEWxlJu5wG6pJ2ChDCLufr5ndSP7OBbD8fc+fEnUaHixl+9nLt3rSL53H00d7apnVthcleHkQsqmMNtki89i//el6dTP5f4/n24Fw2hRo+XslU/dzPm7x7CTi88mNj94/txb9yIe/2ZCfUUFLxcVtzIFxS8GskFcJZewSxNDTtfjLnsiqPG6fGnExyHPFT/rSmu2Do4+1nJF3z0bWV+/R/aWCUQUuBKSxZpSpkmkZK24yBcRSYVUmtSJamkKSpvmsdIwWinx5FyaTZE7ycpdqY6Xgj2DgyAEGRKkDoSYS3KGiyCI5UhANw0JYzz0bPZZAxSoHEQ1rLx0CHe/Zkb8Gsuf/mT38GEDuXza3xn8EpqQ4rpAz1q60OcQBH9eQPvRy5HDoVnfB/zUP3mE34m1g0gb78U87kHzvj4AGaiS/f376P8iWIITcHy8aoz8o1Go3hdvF7x19uemOCiy0tLfq6DB1KEMGw6x5/dPh4JNmz0ePjhh9jzXJfzr6jM23e9foI0g/3njICwKCyOAE9rSlYTKQFSEHsuQRKTKEWYaUJt+l3zAoSg5zsYBEJAkGRInX8mrGUqzA1upiRaKXwSUpnL2Lb8vECwmiWofm+8bsWYxBIToGyGHAp4cs82Xv9vL+atf3A1X/vEU9T/t0t5wa7G0S3aByNq60Ma3/0u0V88TPCL1y/ofh7+5nN4r1170u+IrRdw+CsPL+j3ldz1Iu4NG3m0tWtBxyleF69P9PpkCGvtab/0CuNVd0EFrzz+n4/u4h3vXsWWS5Z2ktmhgwm/+Wt7eNdPreK2N+Rh8A//+BMMbQj50H/cwv/9s0/xc5/YwvBaf95+P/afm7xt8iD6b7bx+A9ew55JwUA3IlCGfUax9fmdHBoZZPPYEZ4fHGL9VIv7N63lsnaP1fsO05WW4Shm+3kbWTM2yVcvv4g3PrsDJ4qISiHfvGAjm3spP3DPw7Rdl5vHH6Xn+lTShKc3buTbm69msN3iRx75JlOlIWqf2MrgR/87R9ojyNChcu0Q1Xs/MLveT7/jW7ztD6/i7998F+uvqHL1v7+axqdf5K0fOIfpt3yWoR2/uqAc9+Gf+Dylt11I5ScvP+HnyZv/GPWzr0O9awEpgX98lt6nHmTwSz91xscoKDgFJ/wP8Krz5AsKzgaCUBL1zLKcxxhLHB09l6tymVsAP5TEJ1hHyROUblqLjQ1lmU+iM0KgkTjWIk0+gGba9wFBJnONe4FFGsM9W87lkoNjeWGelAgLUueStsIYgixDGjNbVT/IJBoPj5ipav7go4UAK9m1Zg3eN59EtzQRJRyZ4pwzf+iMW1LoR3ajMKRW4ZYUSScjueMpvLdftuAiNln1sK0Ti97YZg/77ReRP3jiB4CXiqh62PbiC+sUFJyKwsgXFCwBfiCJo6UPKgW+RGs7a9QBHAVpkp/bCyRJdPzI1Eog0DUf5UucVozpL1ULCLRGWEulmzAZhEhycZyZoJ80lhdHhxHWMtzu5tXyWucT6IRAWoObaYQ1GCkJiYgICNIUj4R912zBAoO9Fgk+O4bX4N75GDEBQhikEsjy/IJFr6RIvvoUjidJ2hleySHtaeI7tuG/47IF30dZ8TDt40faApgvPYF8/YWIysL05UXFw7biBR2joODlUhj5goIlIAjkPO96qfB8gTHQ7R49l+9C2le280N1Qk++7AvasSVcHSIOdkDkYjXaCoIky419lBI5LlbkXre1FmEM0hg84NENa7jgwGG0lARJhtI2T9cbi9v/nlGSwEaMM0JARCQCjMmV8c6dOATC0hUOjnDoiQrOoJ9XnrfnG0Ov5JDe+wJuzSXtZrglhTPWxuydxtl67oLvo6ie3ACbOx5DvuPqRTiHX3jyBctOYeQLCpYAP5DzvOulQgiB4wi6nTlG3pdkWd+TDyXJSYx8J7aUN5UQRzp5Nk+ARhDqjExIYt+hGqW5sp3Ii+2kMVghcK2lsWkdFxw8gsVS7cb5ZwiktTjGADZXvSNmjBE8Yg74I6gXjwCwutlCSwHWYjsZPcooH7xbzjvOyLtZQtrLcIcC0p7GLTms2nMQ762XINTC/4ydzJO3vQTz1aeRb124/GzhyResBEsyGaFer/8ZcFGj0bhtzrbzgT8ARsgfLvYA/6bRaIzX6/UeMLc/5V2NRuPInH2HgR8G7gGmG43GxFKsu6BgsThZLnwp8DxBt3s0JB+EkmxyZh2KuHd8uH7GyHsDHtUhMztS1hpDkGpSKTC+QynOOFINsIAReajeSIlnDAdrVcYrZVZPtzkcVvPqeleAyY28taCVJNEuhhCXlL2l1YRRQtM3+LGh53mUky6xCUBaRJTi3LiR7Ovb5q3XPTxB8toL8aRL1mvjhJJ1hw/jvf2GRbmHouphXjx+/pX52jOIqzciVi1c1Kjw5AtWgkU38vV63QOuAg7X6/VzGo3G7nq97gD/APxCo9F4qP+9K+acf9/cB4JjjqeA9wBbgSuA+4D/udjrLihYTPxg+Yy864l54fowFBg7Nyd//DoqvmD/lMEtOQyul9gUyIfI4WlNLCU4kiDOPXfb9+KlsRgl8IwhdhRPb1zLpXsOsGNgFGkNVji58I2xIAWpo+ilATUgRaFxqfVixiuaxHWJXYfzJw/kXnzFJfzhLYjBEI4xht6ug6RvuQx3T35d9lCbwW4beev5x13bmSAr7gkNsLnj0UUJ1QOIsovtplhjCs36gmVjKf6l/RDwBeAzwL/sb7seeHrGwMOsst2hl3jMoi2u4BVFsEzhesjD83MfKMoVlc+EN7YfUTixJ9+OLG7Zoba6r5Zn8z8IUhtSJRFYIs9BAlaAsjYfPCMkrrVESvHcutWsnm5T6/QQBhACYSzKWqy1ZI4gxUNgmXIHKCUpw+NNhIXdo6N0PZ/zJ/bTkxXcqiJ4xyWIio9tRUcXu3ccd3KaZP0oXtlB+Yre/9jG4ZERMrM4f8JE1cccU11vM4354hOot1+1OOeQEhHmhr6gYLlYCiP/k8DnyKfG/WB/2yby8DwA9Xr9rnq9/mi9Xn97f9OGer1+T//nrrkHazQaGvhs/3h/TB6yLyg4q/GXqfBu5lxzHyjCsoMA4sjgherEOflA0EksTtnBw2DJJ7kJQBlDIiUYS+wpRL/9Vho7W0znGkviKBLXYf9QjU3jU3luHQCLNBBkCdpRGKFw0BwaXUcljqkmXbSUvLBmHZm0DHa7WAQ0I4I3bYaqPz8n//nv4l60mjS2OCWFciXZF57m8Ma1JN1sUe7hiTx5e+8LiHOGEOeOLMo5YCYvX4TsC5aPRQ3X1+v1AeBm4M/6m86r1+tXkRv4t858r9FofH+9Xv8Y+RhZOEW4vv/9CeAvFnOtBQVLyXL1yQOEoWR6TtFYqSJnjbwfSjpTxxvCsgedvifvTEQgwFiLQ+7JJ0ohrSF1JEiBtCD6lfNGSnxj6Ll5m9uONaNc8sIhdpSDWTkOZQyrelPEnkPVWgSGrldhOJvCD1O0lExUqlSzDpPOINKV+G86FxG6UPHnF6jd8SDeTW+g09V4ZQdHgnlgD5M/8HrS7vFRijNBVr3jPPnFDNXPUPTKFyw3i+3J/yjwu41G482NRuPNwPuAdwMPApfW6/W5clFLUvRXUHA2sJyefBhKkvhoRius5v+14sjgB+qkffKd2OKWHGQ683kuSau0IVaqP0BOzFbMS5sbb60kbj8nj7EcHKrhpgZhbe6RA8pYNraOkDoOkG8XnQRpLaU4RfZrBobiFokJcYd8wndc0l9c7slba2G8BY3tuNecQ9rLcEoOpV4Xc/UG5EBIukie/LFFcdZa9OcXp3Vu3nmKCvuCZWaxDe27gV+Y8/5b5PPgP0z+APAH9Xp9BOgCkxz1+DfU6/V75uz3c41G44VFXltBwbIRBGLZjHypLGfFbwBKtfy/ddQzeCep8p/pk3fLDjbOjbwRILOZyXMSmVkQEivzanllbe7JOwq/7+0rm8+abwYBQZbSFLlgzEi3SS3qsH8gN/oahUg0FpCJwPQ9/mq3S8sZhYkOwVsuAkA4CjwHeil88SH4/ivwBgOSzhTeWo+g3SN702a8jiJZLE++4s7z5O1DuxGBi7hs3aIcf4aiwr5guVlUI99oNL7vmPcx0H88ZwfwzpPsd+bjowoKzkKW05MvlSRpmhe6CSEoDbhYezRcn5yk8K4b5zl5G+t+m3zuyUutiR0HGZGH343A7QvcWGswwsEzuZEXFoSFrutR7UUcEjUEcNnYLg5UB8nr4nK5XE9nCGHIhEsmFa7OmHKHGK+UWfXa1cjBOYpyM3n5Ox6EH70Rt6RIexrHEzidiPjac3AbrUX05D3snJSHueNR5DuvXvSZ74UnX7DcFH0cBQVLgB9Kot7yNIWUygqBJevbu8pgP1zfywvvTufJm16W96/IvMROGkOi8hnwCIGwuRcfZhmplFiZt9BFjsLRGoXNxXLIw/kWuHRsFy8MryV1HURfF19mFp+U/aNDGJF/t0eJ2FM4P3TRvPWJio89NA13PwVvuTZXvOtmyJ0TxKWAxPdwy87i5eQrHqbVTxGwNPl46HvyhZEvWEYKI19QsAQsa3W9L1GOmK2wLw26WGZy8ifvk+/E4JYcsm6GEIDMHXelDbHjoKwFm7fDAfiZJhUSKyS+1sSOIogzlLE4mWG8Usrb7KxlbWeCp1etJ3UclM5767Hg2ZTHNp2LIR92g5G4JsXevmX+Aqs+3Pk43LAFhir5QJqehkf3EQ+USTsZbqgWrbpeuAociY015tmD2GYPcd3C5XKPO0+lKLwrWF4Wu7r+PODPG43G7f33EvgU8BrAALvJ8/Af7+9yA0eV7n6u0Wi8UK/Xfw34eWBzo9Gw9Xr908D5wHlADzgEfKvRaPyHxVx7QcFiEoTL1ycfhAIlcyNfrSpKA3nVe7djTqp4V/IF3cSiSg5pJ0MO5L3wgry63iiFEfl/WmUsmRQEWpNIiSsFvs49+UorxgksjjbsGxpg0CZIq9k5sI62H5A4uTiOlgKV5fPodw4OUU1SLIKxWhUrIavNz9iJio/9yuPwjuuBfEBN2sngu3tItlxE2s3wFtGTh9ybt60Ee8djyLdftSSCNbknXxj5guVjqSvc3ww4jUbjZsjlafvtcLf1379wgta5twBfJ2/F+1aj0Xhv/7sfA15oNBp/ucRrLihYMK4rMNqiM4tyFjeveyx+IJHy6HhZJ1BgLe3pNC+8O8HDhpKCwAXt9cPgSoAVs33yxlFkQvaNvCGTEu//Z+/Ngy257jrPzzknl7u/vfZda5VKKkmVkmVb2PLS7I0FGBNsDU03TE83hKcZZoYemKF7CMAQwUwQ3QGDA6YNJrqHaAJhjLFhLCRh2Zas1FpaSqWSan9Vb3/vrrmdc+aPvO/VU2mz9e6tKon8RNxQZr7Mk+em6t7f/S3n+9OGSEmUlDgmr5gvdVJMOffWF2sVaj2NigXHx3fRdd3cyBuLkYKyTeh4JURqqKYRqfSZHR+hkXReu5a/6sHXn4PP/Ez+PCsOSTPBmyxjpCLtaNy6N1gjX/cw7QR731M4v/59Axt3PbknX4TrCy4fww7Xt4GDQRDsh7X17m9IEAS3Ac+Re/8/PuS5FRQMDSHEZWtSUypJhGCtBkAIgQRaS1leePcGhrDqC2In95Ad1deuJ8/JWynIpFjLnWdK4uq+SI7MXX5fa2JPoYVEGkPH98hkvn9yZBuJVHm4vi+FW7IJ50fGcJOMsW4HIyWzI3VS13lNtEH0YuzWcdg2DoBXVqRdTeXDezHarHnygwrXQ26AzfEF7PE5xAevf+sL3s493qRvfUHBMBiqkQ/D8B+APwB+LwiCE0EQ/A9vccmPAX8chmEIHOjr4BcUvCO5XHn5UqkvfhNfvJfE0m1luP2OdEa/tgiw5gtiqcg6Ga6Tr4c3QqB03hc+kRIrBE5f5tbrK+HZfpFdSWuisiSTEqUtrYqP6RfsKWNxjCZ1HBxjEMLikzE/OsqO5XncNMMKQeK4SGtf68nPrcChi7r00stb6vrfcS02tWs5+UF78vpLzyO/52Ceox8ColYsoSu4vAy98C4Mw/8nDMMPkTet+akgCPa93nn9/P33Ab8SBMGXgE1clMUtKHjHcbl6yvsliQV66wylAjotjRACz3/94ruKL+iSpxV8Zcmbw1qkNgjZN/LkOflUSpxVudt+w5pSpumVFaYvfNsteUhrkNaydXEFL03RSiK1wbcJMS4+CdcszKL6DriRAj9LX+3JG4M4M4+9cfvFQ09fwLEGdeMkOsk9+by6fpCevEv298eGUlW/do96XsVfUHC5GKqRD4JgWxAEjf5uizx8/0YJyg8Bf7VOLe97yD37goJ3JJfPkxdYw6vupaQl6nemy/Pyr6N65wt6SZ7vLkuLtXmbWCMFLpCo3JvNw/UKKwSpEmuevGsNpTSGfmGdxeLrFCMEmxdXKKVprnUvJb5I6eAz1l5m+/ISpUhjRR458OP41T9CHj0OFRdK/tqh+L7n8UoSpEQn+mJ1/esUFb5dpK8wR+eQ33FgYGNeSlFdX3C5GUbh3W1BEHy5v60ALwgC07/X58MwfPkNrvsx4L+s7oRh+HIQBPuDIGiEYdgcwjwLCoaKf5n060tliTGWKLoYkncka/f2y4q4a+CSPivr18pXlMFYgTAGrRSescRKUu0vicukJBOCTCpynx9cY2n0ukQVD6MEB+dOoYxG96vS980tIisVtCORWDqUmFiaB+3Qc/JzLIJymtBsrzPWf/Eo4uYdrypQS+57HnfPIXRqsMaSdNK8ur4zOE+epTbs34qoDC9LKIt18gWXmUEr3p3kNV8lb3r+teu2f/p1/n7zuu1/v8HpFRRcVvzLJG3r+xKjeVWRn6sgTfqe/Juulc9V7yrKYhC5Nr2Ta9NHjqKR5kZUS4mWAi0lwlqEtbjW4mQp0li0krz3zIucqe/DCsHMaIPg5FmO3HgtVgoSFBIHJxV0VJl2LVe3M+T966N231hbm6vc/cCHoG8M9UvzmPkO/uESWWRwSoqkrfOc/AA9eTG9DO/fNbDxXvcehSdfcJkpxHAKCobE5eop75ckmbb01hk8z4Wkr2f/ZmvlV3vKV5XBWpDakimFbwyRUjhZrmCnhchfSiL6AQPXWE6PTSA0aCW489wxrMkr7+cbNQ6euYC0ede6nvQBgdASJ7P0vH5hmwBPZ/RafSP/7BnIDGL/tjVPPr7vefyP7c8Fcbp5k5q0neb7A/LkbSeGc4uwZ3Ig470RhaxtweWmMPIFBUOiVJb0OsM38o4jUBJarYv38j1Bkq4aeUnUeWP9erfqUEKDEDhao1W+Dj5SCmX6uXMpMUJgZK5vD3lO/tT4ONJYhLCs+BWEARAkymG5WsbNMjKl6Dl5CFzjErkuju4bZylwdEa0Gq7/fAgfC3LFu74xTD73At7335Tr13c1TlnlhXdlZ2CevLn/KHL7SP4jZYgU1fUFl5t3nZHPV98V28X2ld/ec22Zl17oXZZ7bdvp8/yR7trx6w9USBLL8mLKjhuqPHL/y6+5dq5laM6dZOrWcdyzTcCu9YxfdhRlozEyL7hb8T1cYyglGUprsJYF3yNzXLQUCAuR40GuXouVgguNGpHvU+vEYGx+vL9Mb6maK9wJm99PeflX0cyzL8GeKcRUjeaJ89heSvbUeY5UF+guJng1h/aFLpUJn+5iDCX9mvf1drZPhs+RSRdn78hQ/3+ZmTa9qnhb1xbbxfabbb8RYrUhw7uId90bKnhn0mpm/OonT/Bbf3ANrjfc39N/+4Ul7vtvC/yHT+1m8xaX5ekev/LJE9z7Y1McvLXGZ3/tFX7xDw+8qqvat//2Er/1wzW2L7X4/L96lC/uP8Du+SX2vnKWP7vjJm5ZWGQk1jjGcGSkzgdPnuWCVIyVXNoln9++5QY+8cpZ9s0uc8dTJ7nDPsZf3PBdmCwj8z38XsQr+3bxg194hMVqiWpbM8kKketx3/tuoWYFntX8wGNf5bFf/3E+/gt74N9+BnZNYr77DuLv/TTOZ/4ZnU/+NaPhv+H//icP8N2/ehNf+dWnmNw/wjX37uboF8/zvb9z24afn/7jrzP9819h89f+Od7BqQ2P90b0PvsUyd8cY+S/fmJo9yj4R8vrhqHedZ58QcHVQr3hsH2Xz4vPdYd+r9uDGsLC42EbgNFtZeoy46t/u8Tm3SWEhAsne2vnW2s5MWfYO6WYumUMooxqJ8JKiZNpzvs+VaNxrSXxXcZbHZZLHttbHVLHYdFzqacZm1fa9DwHqWEk7uRePSCMYaVeZaTVxkpBNclD1KvFfcg8J+8IkDJfArgesbWBvdAkfeQMzl076a0kWA0rr7QoT/iM7K6xfKbL6K7KQJ6f7mhMZHAPDDcnr19aQF33TdcmFxRsmMLIFxQMkUN31Hj6sfbQ7zO12WVkVPHIw621YwcPlJhfyIh6hgN3jfD8Iytrf5tvWTwHRisSIQXixkk2LS6TuApHG6ZLPuXMIIBMSTytWfE8XJsX5k2XS2zvRuycX6Lr5dr1ILAyj9dLbelUyow1W2RSUkoyBHm4XhmDb/PwPdYglOA1EcV6CYwle/gkzl27WDnTY3RnmdlnllCeZGR3lZUzXUZ3DsbIJyeaeBMuQg43J6+PF0a+4PJSGPmCgiFyKKjxTNjGmOFnke58X50L5xOaK3lR2z0/tAVr4ZlvNNl/1+irjPwrc5p9UxelW/V1E2yeXyJ1FMIYPK1R2pBJ8OIUIaDnqPwLwxrO1ips7/bYMb9C23VQmSHCWxPKUdrQq5SZXG5iBRghgXyZnrC23+AGbGaRktd68kIgttTJHjmD+96dude+s8LM00tkkWZkz2A9+eTlJt74sPt1gX5pEacw8gWXkaH8qw6C4NPA9eG6DnNBEOwFfod8Hb0EzgA/H4bhQhAEPS62nAX4oTAM59ZdO04uefsg0AzfotFNQcHVwtQWj1pDcfJ4xL7ry299wQYI3lPj/r9d5sknO3zwnhG2H2hQQvPQXy/wi791Dc2FlKWZmLHNPifmNHvXGfloU4N6L0JqTeoo9nW6CG1IXI9Kp4fjKLpOXmFfThJO1ascPnWOiZU22pFYAbHw86ygALQldV02LTYRwqKVQmS5J5+6Tp48FGCNRcjX8eQBO17DLnSR+8ZZuv8VquMeF5opaS9jZHeV5dMdRndWB/Ls4uMr1IZs5K21Rbi+4LIz8H/V/aYyh4DZIAh2hWF4OggCB/hz4GfDMHy8f97N6+5/Lnxty9nV8RTwk8DdwM3AV4G/GPS8CwqGxaE76jz9WHvoRn7nbh/HFXz94TYfvGcEgOt2OTx3JkUby413NHjh0RXe932bODGn2TN50cj3YlgZbTCy3KLrOuzoRTj97nOVbo+4XKKnFEZKMmNZ8Vy2tbp0lMIxFu1IupTXOtmlnovKMipJSmYVmVQoDBZBp5zL1Qpt8HzZN/avfT/GcVDXjCKEYPlMl3pdMnVghJmnl3CqDkk7ozrlv/bCbxFrLMnLTdyPNN765I3cZ74LAsT4cP8dFBSsZxjh+u8B/gr4Y+BH+8fuBF5YNfAAYRgeCcNw5pscs6iYL3jHcuiOGk891npdb3WQCCE4fEeNV17qrYnwfPDeKayxvHikw4G7Rnn+0Txkf3JOs3fTRSPfaWtmJ0YZX2zS9lw2JQnSWBQg4pSxOCZSCq0kZ6sVtnV7+DrjizftwzMGrSRdWc4/qELQK/nILMXLNMpqZP+9WySdcglhLcoavLLKc/Wv82hMDGprDYDlM12SpZj6ziqNnVWaZ3uM7KgMJIeeHl1ANTyUu+Gh3pTVfPz6FQ4FBcNmGEb+R4DPAp/nYhe5neTheQCCILg/CIKngiC4t39oexAED/Zf968fLAxDDfxJf7z/SB6yLyh4x7Brr0+aWC6cG74Iyh3vreM5gmeP5BX9N9w9gbKGhz4/z7W31jl3vEu3mfVz8hc//t2OZn5shNFWh47j0EhTpM0Fcc41aihjWe4b55MjNXa2ulghOb1pAtdatBL0ZAkj8la0vUoJdIarNa7RCGMQ/Zx8u5xL2voYvHJfw/51rLxejFB1B2sty2e6tM50KI16eaj+bJeRAeXj40fO4d0wCkOum8iKUH3BFWCg4fogCEaA9wOf7h/aEwTBIXID/09XzwvD8CNBEPx7oNY/9Ibh+v75i8BnBjnXgoLLhRCCW4K8yn7rjo2Hl9+M624oY4zlka+1CO6oIYRg16TgpaMRyhVcc6jOC48tc3JevCpc31nJyBzFbKNGSWtSA8JaelLQq1cYNxopJdIYTo7UuWNmgdRRjGCQxmKUoCN8BLmufbdahm4TxxissMQyf98WQbNaBgtulOKWy3nr2kvC9TbV6AsdpDBEKykCy8LRJluDiX4+fnCV9fEj07mRvzDcpY5FPr7gSjBoT/7jwG+GF9vF/jR5d7lvAPuDIDi87tzhl7IWFFwlHApqPB0Ofymd4wgO3lLl2ae7aJ17pnd/xxhaW06/EnHgrhEe/VoL34GRSv7x19oSdTQWOLp5gnqSQpIryblxQuy6ZELgWQsWTtVr7FtuoqVkd7uTN7WRksgt97dV3q42S9FC4Nosb2pDXlHfqZRQRlMRGcp5fU9eP3MBuaUGix2Wz3SpTXhUN5XozESM7K6xcqbDyMCM/Dn8G8eH7snrlxZwrh0f6j0KCi5l0Eb+x4Avrdt/mLwq3pD/APjlIAgeCoLgi8A+4B/6560P1z8YBMG1FBS8i7j+QIXZ8wnLiwNsjfoGvOf9NRwBx16MALjtuzcjjOUrX5jnxmCEZ16MXuXFL8yluBKsEDyxbYpGFFM1GVbAZLuDg0UagwPMRn7dkwAAIABJREFUVUt4xjCSJBhrUdZSylKMEkTKxzGaqORR6UaUk4xU5Tl3aS2CXAwn8j28NKPu2jWNrks9+fSRM7i3b8Oeb7J8povvCjYdGmPlVIfGmie/8cp604rJXlnG3de4DEZ+sfDkCy47g241++FL9mPgxv7uCeAH3uC6oty04F2NcgQHb6vyzONtPvBPRod6r5tuqZKllke/3mL/gTKur9hSNzwTtvmJTzqIrRUm1EXN99npBNmvbT1ZqxK5Dn6qsQi6QrC50yNTCqkNJ8ZG2N6L6HkebqY5V6+yfbmJVpJEeDgmI6rWKXd6OGlG4ijKWR76twhiN//KqSQJjVLG6lrYNUe+/9/skTM4d+/GfvUFlk93sVHG5kNjnPnKbC6Ec3Ywa+Tjb5zHu20zwlMYM7xmQtbaQgin4IpQiOEUFFwm8qV0rbc+cYOUSpJ915V4/BvttTD4e+6uE8WWmekYsbWCt3yx3ens+QShLR0pMAKWGtV+i1jBkU0TbOr2aJdK1JKEE2MNtncjEtfBT1JmGzX8LEMrQSodHKPplUpU2128RBM7Dqu9aQWGXtlHGkO5FzMqMlYLzV8lFiRELmf70WthscPS6Q7xfMT49Q3SXoZTdkg6eiDL5+JHzuHftR0h5VA9eTvXAUcixweTYigo+GYpjHxBwWXiwKEqrxyL6HUH0x71zbjr7jo6tZw+lVf0v/fj28Favv7lJToll/R0B9PP2c9MJ9jMsOQoJrVmdqSBlQIrJScbdepJSrNconqJkfeyDG3AMQbtyLzlrDXEJZ9aO8LNDJHn5sV45JH5btnHIqj1Inyt8yVwl6yTN+0UO9vGObgZJmssH28SN1OEIxnZVWXlXI+RHeWBLEWLH5nGv2sbSDFUI5+9tIC6tvDiCy4/hZEvKLhMlMqSa28s89xTnaHf69bbqxhteewbebFfZcRlzDM89tAK55qWbTU4dTSfx4Vzee5+0XGYyDKWq2W0oxACrJRgLXHFp5SkzFQrbI7ivEe873Ht7DwagXYkylgiz8NLE9w0w80MXc9ZdeQBS7fsYaRgpNvFdC4uKVxfeJedauHcuSP3rrc2WDndZfLACK0znbwxzenOQCrrrbVrnjxSgB5euD6vrC+K7gouP2+Zkw+CYA/wJPA0+ZK3CeAUsAXw+9vHyYvsfhU4CZSBfxeG4QPrxnmV1G2/+K5MnrM/D6yQq+IFwB+GYfhwEATXAb8LVMl/kPx6GIbrC/sKCt5RrDasCd43XHW1xojD5i0uj36txcc/kXuQt91W5v5vJJyc13wyqPHCI8vsvanG+bMJwloWHcWBKCV1JFZKUqMZjWJKSULqOCz7LttaeSFeSym6JZ9NrQ7SGDJXgbV0/DLVThdrQGlL278YUhdAVPKQxlCNY2yLi4V365zo9FQb56689jbePIaY02w9PLFWdLdyusvIro0X3WWvLCNKDs72Oual4Ybr9UsLhWZ9wRXhm/XkH+8b5w+Tfyw/CnwK+KMwDO8Jw/Bf9s/7ozAMPwR8ov934FVSt60gCHYBhGH4Xf0xv0SuYX9PGIb/ad01DvDfgF8Ow/CDwL3Ap4Ig2Pe2321BwRXm5sM1nnu6Q5oOz2tc5b1312kuZ8zNpgB88Ie30RMSBzh8d96VrtfVRG2dC844ilqqMVIiteGC6zHZi/CzjEocc6pRZ9dKXlOQCYhKPiWtcVONdiQC6JTK1LpdpLVYAT3PhXVh9ajsUo4S3Exj2sk6DfuL885OtXDv2gnAysgIjjFsPjRG83SHkV25EM4gPPk1Lx6GHq7Xx4vK+oIrw7cUrg/DsAlcIPfm34xxXt3A/vWkbt+K9wDPh2H4ZP/eC8DvkyvqFRS8IxkZddi63eOl53pvffIGuS2oIYHHH89D9uM7K2hHUIlTtu4tYwwcfbKFK2Gp7FLVBqEkrrU4meZctcLOlTZGKcbbXV4Zq7NjpQ0IMikxUiKsBWH7TWoE3VKZeqeDkGAURN6rtWKjikej3c1FciLNqpVfDddbY8lOt3He0zfy5So21my6ZYyVU+18jfyAhHDW8vEwfCNfCOEUXCG+JSMfBMF2YAqYe4NT/kUQBCHwEPBv1x1/Panbt2IHcPqSY6eA7d/0hAsKrkIOBTWeCodfZb95q0e9rvj6Vy7eq7bDw48y4ijvMf/M15ugDXPVEuOZJhOCstY4WcapkTq7mi2W6zVqUcyZeo1dzTYW6Lku0locrTFKoaUkcRxSpahGXawArfpL5mzeST5VCmEsjU4HpTX4CqHzorxVT14vJYiai5zMw/HzsY9SUJkqsXKqk6vdnRmMpO3l8uTXus8VhXcFV4Bv1sgfDoLgAXJD/bNhGL5RrPGPwjAMgF8GPgKvkbr9HBelbt+Kc8CuS47t6h8vKHjHcuiOOs+EncvUY77G+XMJ7VZe0V+9boRqpnn28TYH7hrhlRe6mMwy43uMZRpXQl0bpNacq1VoJClzYyPEUmCFYKrbIxOCnusgrcVLMqwUaEfQrpepxBHKWqwEI3Mjb8kd9th38OOUWjdCaYt1FWT5V8mqJ5+dj3B319fmv7BsGXEz4maKjjWyJMkiTXVyY8vnTC8lfX4B7/bN+QEpYEjr5M1MG3wHOVbIgRRcfr6VnPyHwjD8cBiG97/16fwe8INBEEzyxlK3b8UjwE1BENwKaz3l/3vgz77JORcUXJVs3uZRrkhOvxIN/V6H76zjKsFTT+aV9AvCYSxNefCv5tl9oEa7nYveTCuXsUwjFZS1ZrHkU0lTJNAt+UzXqkz0IlxriZUk6veE9+JcwU8IaI6WKUUJEoOREq0EkeMA/fazroubaMpRghWQcLGifbXwLr0Q4eyprc2/vZQxZToXQ/VneozsrGx4+VzyxAzugQlkuZ9OGOI6+SIfX3AlGcoSur6n/4fAJ3kDqdsgCN703mEYZuQFfL8ZBMFD5Dn9XwnD8Pgw5lxQcDk5FNR46rHha9nv3puHu7/2cB6yPzGn2T9Jvn7egnAlHaXoIqj3m8lg4Wy9yr6VPDQ/2upwslFlIooRxhJJSc91EdbipCnYvPFMq17BS/JKfSMFmSNJlWK1yWzqSJQ2+ElKpiRpJnJPfl3hXXbhoidvrSVpZ2xvztI83a+sPzOEojsYarg+r6wvls8VXBnecgldGIYnyavpLz3+mbfY/49vMN56qVvCMPypS/7+U+u2X+Sbz+EXFLxjOHRHjT/5/Qvc+yNTQ72PlILbgxpf+1qLXk9zcl7zm981ymf/cI5jz7VJUph1HTYneQW+G2dIaznTqLKr2cZISSmKOFWvcf3iCgboeA7SGARQTmOENRip6FRLjK2s5C1lhcBIiF3Fag1u5jg4qUZaQEJPOZg4TyNYazHNCN1MUdtyI94810Vow6bpCxw70b6Yjx9Q0V3l+69f96CGa+SLfHzBlaIQwykouALsvqZEr6uZmb4MPebfV8NzBA8/1qPmC4KP5j3mv/wX8wDM+C6bstzI17oxsZKcrVXZ3OmR+C5CGy5Uy0x2I1IpaXsetf6PAk9nCAup46K0xtGGTDg42mBF7vGvYqTAS1IsAikM1nVImvn7twayx87hTPkIlX8tnfqHWVTVRXmS9rHFvhDOID35bRcPDNvIF+H6givEu87Ih2FYbBfbV/22lIKtu3pr7WeHea8b9ldIU81XHm2zqSF54skn2DEOx49FCGPouYpSX3rWTzWZlHQch0qakbgukaPyLnIWtBBkQuDq3APXUoDNK+kdbVCZIZMKV2d5sZ1zsdudBUpxbuSVzdfjZ5FBJyk6s5iZNonM1vL0xx47gVtzEKNlFl84T317hdb5HufbZzb0TKw2mIUez5w8unb8uRePQr++YNDPX59a5ljvwkDHLLaL7Uu33whxaR/ndwHvujdU8O7kyBNt/u5zi/yP/+HSRSSD53d/+xzhsZQTuxs8/L+N8/B/PcP/e18LRwpOeC5HalUO9VKqOmLTco9vNKrceW6Gfc0W7ZLP7966nxsWmvzgkRd54NANNEsl7pyd59CRF5iZnCBzHM5u3cw1L59lJFpGJIL5yTLPbdnOL/7NgzQpcWLnZiqtiO0r89RUzPO7d7O4ZYzvfibkM/d+jF/8nX0s7fwU4790CPHvP87jf3qCJ377WX743Ne5/7a7uecPvo0v/NLTfNenbmXimtpbv+k3YeZjf071h/dT+9GbALDnV0hu+w38C781iMf9Khau/b8Y+ZufwLl+cuBjFxSs43WrUd91nnxBwTuFGw5WOHsqXlveNkzufF8dB8NKN/8NfMf3bQVjMcCedpdzvk8GpCUX1xpuaDaZL5eodXs061VuWljmTKOKYwyVJMOovDntUqWSF/AJqPQiopKPFhJrwc0ylNF5Zb2SaCXxUo2yGqwgUxItJUQpUUcjp6qoLRXSo3kDWmsFpU0lzpsK7ZahNOYRLaeUR903epvfNJV7r6f7l8cuHhirwGKHYTg9ZqlXLJ8ruGIURr6g4ArheZLrb6rw3FPDr7K/+VAVmRjaUW7E/KrDmGfQBlwLW6KYWdchRSKt5ZrlFvPlEmhDp1LmpoUlZislhLU00pR6FKOlYLlayavjgWo3ol0ro6XCCnC1ycP6ArRyMFKgtEGhwUIiFdoKyCxZrNHa4t8yTvzcMgBpJ2P0ugZnKpP02hqv7hI1U/yRARj5772W3t+dwET9JYAlF1wFnfgtrvzWsMZgV2LEaGmg4xYUfLMURr6g4Apy8+1Vjjw+/K50tbpi+1aXRNs1b/W223Mv3CjJtd0eM55DpPMCNE8bylnGXK3K2EqLTd2ITAoWfJ+xKGY0ikmkInXcfoJMUIpjmo0qqVBY8ry9q/N1+LrvySttURiwgkRJMg2UHSoexF2Nd3gTycstrDYknYzJ6+qcrU3i1V2SToZXVShn419baqqCd2gT0d+fvHhwvAqL3Q2PvR7bShAVF+Gqtz65oGAIFEa+oOAKcvPtNZ5/pkOWDb+U5L3vryMtnDmfV8Z/4BNbAdBCcl27xwXXQQpQ1mIETHUimiWf8aUV2vUq1y23eHbLBI7WjPciUpV7/atNZoSASieiU61ghMDVBj/LsHnLeLSUCGOQfU8+dlyyzGLLLhXPEnU0audIrmr3yBmSrqY2qqjaBLfs9EP13sCeRx6yf2ltX0xUsYuD/cFll3qIscKLL7hyFEa+oOAKMjLmsGmLx/EXButBvh63Hq7hWMujj+WGbHJXJdeNtzCWpvjGsqLUmme+vdUmcRSjy01a9RqH5hZ5eusUKs0oG4sFEs/BrsrdCMHU7DKdWgVEXm3vZ1leTa9N3qnOgOxfkTkOrifRFY+qZ4k7Gsoe3jaP5C+fzz13DNttC2MMveWE0iCN/Meuo/u5Y9jVPvLjFVgYrJEv8vEFV5rCyBcUXGFuOVzlmcsQst+yzcUVF408gO/lNl0o2JGmzKjcaGdSMtJLqGSaMyN1UgujacorYyNkWKS1KGPouu7aehaVaTbPLdOq19AiN+ylNMUAwlgyqRAWwGKlIFMKr+aQlktUPIi6uZH3JyXxfc+TdDNcm7HN6ZI0M7pLMeUB5ONXcfeNobbUiB+ZBkCMD8GTX+whCiNfcAUpjHxBwRXm5sM1jjzRHkpl93qEEDQqkjPnUnq93Hud2urloXYp2BXHzLi5CGbiKKQxVNOUp7duYtZ1WKhWuHZxmVfqNcDiZRqj5JrwvKM1tWYvr6b3XSyCSppihMjX2Dt5Rb7EoKUgVQ5+wyUru5SdPFxP2UO5GaSGZD7C05qaaxBKsHC0OVBPHqBy73UXq+yHkJPPPfkiXF9w5SiMfEHBFWbHbh+dWS6cG7763cSIAkfw7JHcmI1v9cFCamBTNyaSeVvYWCmk1vjacGTzFM81qszUa9xyYYEXxkeQxuIZg5fpPBkPSG0AwVizSbNRQ0tFOUnzXDy5nr1FIMg72kljck/e93Ij3/fkRZTi3bufeLaLk6VoRzG6r8bM4wuUxwbnyUM/L3/fi1hrEeOVIeTkI8T4xhX6CgreLm+pXT8MgiD4NHB9GIb39Pf3Ar8DTJD/8DgD/HwYhgtBEPSAR9dd/kNhGL5RP/uCgnccQghuvr3GM4+32bpjYy1U34qpMUX3FfjGI23uuLNGuaIQQGYF9YpkS5KRWcgclefRgZbngqMwqeamuUX+av8+vuvCAspa0Boj+0beGKwQjDVXODe1hWx+jlKW5mF6DWatc5xACHC1xvEVqedRUibPyW/xoJfg3XuA5OtH8dKUrnCYOjjKK393nh0f2DLQ5+HduhmbGtLn55HjVZhrDXT8wpMvuNJcdiMfBIEHHAJmgyDYBUwDf07ep/7x/jk3r5vbudUfAwUF71ZuPlzlS/ct8h0fG67Gea0sqO0s8ezTeT/7ckXmsu1S0GgotnbyHHqmFMoYjBAcujDLYzu3UY4SylozGsWcrZbYGcUobcikRALCWrQQjHTaHN9Vouf6jCUtYkfhJXZNijJDIbXB0RrpClLXwZcXw/X0Etxv201qXkTNtkiQTB0c5ehfnB64vrwQYk0Yp765gnlxZqDj59X1RU6+4MpxJcL130PeNvaPgR8F7gReWDXwAGEYHgnDcLCftoKCq5gbbqpw7nRMu5kN9T5VT7B9j48EXj4e50beyXPmwlo2pVleG+AIpLFoKbltepZYKWq9iHbJ5+DcIscaNSz0l8j1v0ZsXlAnrGW02WJppE45TekpZ63gTgAzY+NYwDGaqKNJHQdfmrVwPb0EVN6mlqeniY2kPO7jT5Zonhispw3r1O/GqzDgcL1ZigojX3BFuRJG/keAzwKfJ28ju5M8PA9AEAT3B0HwVBAE9/YPbQ+C4MH+6/7LP92CguHjepIbDlZ49snhVtnXSoKRzR5Zang8bFOuKKQEaS2thQQHgWsMqZRkSoEQbG/minxeFNPxPW6eXeClRq4d72ca+kvipAUrQViYXFqi2ahTTlI6nocVAqUBLOfHxzFK4WLpLqWkysEThqhj1ox8FhukEphnZ4kzQXncR1Y8Fp5bGvgzKX3bTrJXltFaYActhlOE6wuuMJfVyAdBMAK8H/g08DlgD3CB3NADEIbhR4C/BFY7UJwLw/Ce/usjl3O+BQWXk1sO1zjy+HAlbqu+ILOCbdt9wkdblCv5V4ArLTrKe8R72tBFkjkSIwQnN01Q1hkLlRKxUuxYaRMpxZLnoqxFkq+Rx9rc0gPjSyt0q2X8LKVVLqGlwMk0ArgwPoaRAtextBcTEqFwrSFe58knnQy35qKn28S9XLc+s7Byok20NNgCReFIyt97Lb2nFmBhsM/fFEvoCq4wl9uT/zjwm2EYfmcYht8J/DTwMWB/EASH1513RQoCCwquJAdvq/LCke5Q1e9qJUE7trznfTVaK5okze/lehJhcslbz2i6SqIdhcXSrFXY0+lyvlah5yisUuxfWuFYPf8dLvtL6DIp6Vt8/CyjFCWs1Oo0SyWMEiitEViksaxUKniuQChBLwUP86qcfNrV+DUHZ3MFd7mXN6dppmx7zySnHrrwRm/vbVO593p6X5kejic/Xhj5givH5TbyPwZ8ad3+w8B3A58AfjkIgoeCIPgisA/4h/4568P1DwZBcO3lnXJBweWhMeqweZvHS88PT/2u6gk6seXWwzUkcPZsjLW5N+tYkyvVGYNrBZGb59LLwK1Ly5yvVYj6ufKbFpZ4qVFFWrtm5OfrNay0eW4eGF1pcn5igpVKCS0lbt+T37K4xMzoCJ4vqU54dHoW1/SNvO9CqklaCW5FISd9at0e0pXoyLD3O7Zx8svnB/5cyt++l/ipWcxCd6B6BaYovCu4wlxWjzkMww9fsh8DN/Z3f+ANrik+IQX/aLjlcL6Ubv8t1aGMXysJ2pFlyzaPSkXy4tEIa/Nwuy9zT14ZS1VrWq5DHUs1zZgp+5RSzUy1yq0X5tndiThfLtF1FOW+fv3sSJX9EoQBEEwsLnNq7w7SpS5aSZw4AyxbF5d5Zt9u9pahOu7Re8XiGE0c9dfcl1yS5Qiv6iB9yUgc0ZvpUhp12XPPFr76a0dIexlueXBfX7LqUfrQbuIvzlDqpVAZjOiOXYoKWduCK0ohhlNQcBVx8+G8K92w1O+qfu7JAxy+s8b56RRj85Vpvi9xjEFLSVVrllw3l67JMlZ8nz3LTabrVdCGzHfZ3e5ydGIUA2AtC40aVgJGYISgHEUgICt5aEfhpykCmGi26PoesqLwaw6JEZhOQq+j80mWPZKlGK/iYLsJ3VqF+EvHKY96+CMem24e5exXBy+VUbn3eiJVG1iFvTUG2yzazBZcWQojX1BwFbF9l4+1lukzw1G/W2/kb7+zhucKjMmNvMksntZkSuIZS8d1SIWg3o3whODA7AJzlRJCG5qVMvuXVnh2ahyEQABKG4wUCANWSrCC3TOzGM8lU5JSnEJf935ypUlHemgNeA7d6W4uhgO5kV+J8SoKWhGtXZNkXzhKaTRXu9vz0a2cvH/wIfvK915LnDiY882BjGebMaLqIlTxNVtw5Sj+9RUUXEUIIXIt+yFV2a8W3gFce30ZayzagraQJhY306RSIbEoKekoSS2K2B4njHXz9rItzwEpuX6pyfMTY5i+kF0sRN/I56I4ANvn5zAll9RReGnGqubdpsVllmNJlhiskrTPdcgSg9a2b+QTvKoD7Zj2jduRD71MudE38h/eyukHZzCZGeizUVMV3Lok+vLJgYxnF3uIouiu4ApTGPmCgquMW27PG9YMg5qf5+QBHEes5f61ASmhbDWpkggLvoCulEibG/C50TolbTg2OY6XpNS1YTyKma5VEcbi6gwjBVKDkfkYU0tLWEfR810cfTEFMbW8wmLLknQztBXEcxFeWa0to0tbKW5VQTdGXDeFHikz0VrJ38PWMrXtZS48sTjw51PeWaL796cHMlbRZrbgaqAw8gUFVxnX3VRm+kxCawjqd1Vf0I0vGts731tHYMkMKEdQcwyZyvXsK9aSCIEFelLSrlcoW8vRTeOUopjEkRycW+RsvYqwlslWN29CYwRaSaSxWCFxewnz4w0ck6/Dt0ApyRgbU3SWU7LMUq4IlMPaMrqkneJVHGSU4m6u0rp5F2MvT6/Ne+9HtnJiCFX2pf0j9B6dudhjfgPYQu2u4CqgMPIFBVcZriu58ebhqN9V/YvheoADN5WR1mKsQEkoCUOqFEYIKg2XaqbpeC4dz6MqBLVMc2qsgUhSjJAcnF9itlIGa5nqdDFCooWDlqqvZS+ptHssjDVw+uvkIZfQHR+VRC2N4wlKNRcym+fl+0bedfPcfmmyxOK+rdSPnFkrSNzzkTwvP+gCRXfPCKrqrPWY3whFc5qCq4HCyBcUXIUMS/1utfBu1Tgq7Fo/eCx4xqCVRAtBfZNHLUmJHIf5SomKMZQyze6lJqdrFaQxbG918PoyuI04IVMKjUD3O9NpIWmstFnur6kX2L6CPWTNhDS2uL7CKUnSbkavk+VGvqPxlCVzHUqjHsuVGsIa9HOzAIxdV0c6koWjgymSW2O8Smlf5WKP+Q1QNKcpuBoojHxBwVXIwdurHD3SJU0GW1zmKIGroJfm+93lDFf1DbKxONpgXYWWglLDoZbkxXIjcUJPgGMtN8wtcaJeQyUpEtjZ6rDiewiRe+5SW1LHwYq8JU01SqhEMfPjDegbeQEsn+4CFulJTD9dMPtyNzfyXY2LIVMOpTGP3kqK+bZrSP76KJAXKO6+ZzOnHxys+p0YKVHa5ND76+MbHsssdIucfMEV511n5MMwLLaL7Xf8dr3hsHOPz+f+/JmBjj/fMjjCUM4L1Xns4SOMN/p5dyGwzZiOcui6LqdfTtZ6xE802/SEoON7aCnwdF+4hrxPvLAWZfNzpck9eAkslst4mabSi+mWfAAEuUffNRIhBEmWYgygJKdPnAJHsrxkWDr3Mj3hMrK7xuxLy3hZhpysrL2XeCVlpnnhNe9xI9vm+QvMmQg5Wd7wmHN/9xzOoS0Dm1uxXWy/2fYbIYYlunEFede9oYJ/nDx8/zLPP93hZ39h+8DG/MqLCf/nl7rc98lRAMLPXeDE8x0eejJfl7/jwhzP7NpGSVimltpsOnWeo1snuH65yd/t3cGF8XEm5hbY3u2xO03ZsrDM/Xu3c9f0LJPdNiSGsemYmT11Ns0vMTNeZ6yZMbtljMnFFgeOn6VBBwt84a7b0a7LeAPeP32cP91+Gz/4s1u4+U/+jN8/d5Cf/OlRpv+nv2XXyf+ZP/6nD/FDxx9n9Cs/g7pmAmst/+Uj/x/f80fvZXRvfWDPJ7n512gfvgWxa4yx/+MDb3scawzzU59i/JmfQ21vDGx+BQVvgni9g+86T76g4N3Cbe+p88IzXXpdPbAxX5jW7N92UQ526XzEjmvKNMYdhLEorYkcl2tuzL3u1HW4MNagHsWcLZepZxkz9SpbWh0ypbDAXLmMn2mkzefpGI0REgEc2zSJqzWVKCHx8vMFYFyZi+iIPCCgMyiVJFlsWcp8Gg1BfHQOO1Vn8eU2OyYFQknkvnEAWme7mNQwsqc2sGdj51rY04tER5cp3bNrQ2NlR2aQE5XCwBdccQojX1BwlVKtKW44WOHJRwdXgPfCdMaB9UZ+OmZsa4lv+/YxpNFopTBSsHtfhbbrkFRL9EareFrT0JpGHDNfLbO12cE4KlfAWy2lE3kYTZrVYJrl+KZJHGvxo5jUdRCyf46y60JugjS11EcVcTtjPikxOSmJX5xH7Rhh4XibHbqN+6G9iH6KYPrReba9Z3JtfxCYh16Cu64hfXYO/70bi56kD5zA/dDeAc2soODtUxj5goKrmDvvbvCNhwdXQZ578mptf+l8xNg2n/d9eBRXa1KlsAiWW4am65BWylSSjKbncnB+iXIUU8o0pUxjpGS6VqWaZLk7LixGCJQ1SGsAQaec57ZLSUbqOv0fAgIvS/rXAALSzDI26RK1M+bTEpNJhXOoAAAgAElEQVRTEn16GffaCRaOtxifW8D90L61eU9/Y55td04O7LkAmAdeJN25BS/YilwtWnibJA+ewCuMfMFVwMDaOAVBsAc4AdwbhuHn+seOh2F4bX/7nwH/HZABs8DPhWE4EwTBTwGHwzD8+SAIBPAA8AthGD6xbuxx4Jb+7jNhGA5e6qqg4Crk4O1V/vTTF1hZyhgZ29jHNdOWYxcybux78tZals7HjG4t4VcUE3WIuwppDEee7NB2XYQxjHcTwl3bOHR+jkd8j4lelCvbYTlfK9NIcoMtsbnSnbGU0gwtBY0kQViLl2QkroNjdO7BOwJhDIj8B0eWWsa35uvjW0mJWyYEzDSpHJxi4ckWB1+8gHvP3rV5T39jnsP/+oYNPY9LsQ8cI77jEKV7Nm9sHG1I/+EU9d//vgHNrKDg7TNoT/4o8O/6xnqNIAjuBn4a+GgYhh8E/jPwpwBhGH4G2B8EwXuAfwk8sd7A9/kB4Cf6r+8f8JwLCq5aPE9ya1Aj/NrGvfkT85otI5Kqn3882wspflnhV3JDu2trXlVfyTJWOpCWFaV2l0aScnqkznK5xEg3YrIXY/sV9eerFcaiGCtA2lyzXiAoJzGZVIxFMUob/CQlcR1cm5FKRXP7BI7WQO7N68wytaNE1M5YSEpMTIKz0qV2+2aSZ2eRVRe1N8/HN0/lIkGN3YNrx2tnmtjzK8QvLFP+0O4NjZU9fQG5uYraOriCwIKCt8ugjfw54AngY5cc/0ngN8Iw7AGEYfg3QC0IgtXE178Gfg/4N8D//jrjFhXzBf9ouePuBo893NrwOC+ce23R3dg2f21fpppWKRfASZSCmkO12aGaZjSV4vj4KJNRxFSc9I08TNeqTPYi6IfpIf+wVtKEVEkmuj1kZvDSviePJlOC2Rt34GV5f3lr8jX6UztL9JYSEiMR2lLOYrLROls6K3gfuWZtnquh+oHm4x88lufjn5/He8+2DY2VPngCb11qoaDgSjKMnPxvAL90iTe/A7i068MpYNXIHwdc4O/DMHy9KqP7gM/2X/cNdroFBVc3NxyssLSYMjO9sfazL0xnr87HT0eMbr0ou7oyHdHyfRxrEdbSysBPMzIpqRrL+XqVzd2IiX6feA0slzwmezEAwoLs/xwvp7knPxLHOJleC9dnUuIKQ3PLJFpJ0BajLdKRlBsu3YWECT9m8XyKazQLi5ptSXMtVA9Dysc/eIxk+2b8O7chSxtLiyQPnMC9Z89gJlZQsEEGbuTDMDwLPA7cu+7wOeDSNSm7+scB/hVwP/CBIAheU60ShuFiGIYP9l9FPr7gHxVSCg6/d+MFeM9Paw5sX+/Jx4xtzT15ay3d2SgXuxGgrGE6lShjiB3Frl6En2lOjtTYttJGWFh0HTZ1eqi+1kYq1VrOvZLknnwp06jU4KYZievSLpWoZHHe2tb3ENqQaZCOxK85xCsJk15E60SHrFFh4Xib0ZnFtaI7a+1aZf0gsQ8cI0kcSh/a2NI5m2nSr5zCu6couiu4OhhWdf1vAv/Luv3Pknv3ZYAgCL4T6IVheC4Igm3kBXm/DPwC8J+GNKeCgncsd95d57GvNjfUkCX35Ncvn4sY25Z78r3lFIMgVQoJ+Jlh1nMRFhJXsbMb4WjNyXqNWpKgtGbB99nW7gIgrCFRLo4xIKAax2SuC+RKeE5myBzFSrVKz/VpnJpD+y5Yi040yhGUag5ZN2PSj+me62I31el8/Ryi5qF25eI9KyfbSFdS31F528/hUuz0Mna2Rfz8EqV7NpiPf+oCckcDuWlw6/cLCjbCUIx835sP1+0/RG7ovxwEwUPAzwA/3v/z7wL/axiG3TAM/wGYDYLg48OYV0HBO5Xd1+TG+NTL0du6vtkzLLYNuycufuSXzkeM9cP1y+d69FwHZQxI0NYSKdVvKiOYL/mkjkNX5SI3UhtmSx7bWh0EoIwhVU5eTGcF1SRGuwo/S/tjgJtmLIzVODU1xeZj55BKgJLo2CAdgVdVmEQz6UUkM13UrlHk42eQ79+zNufpR4eQj3/oJXjvNaQvLuLfuXVDYyUPnCi8+IKrioEtoQvD8CTw0XX7P3fJ3/8zeVX9pdf90CX7/3xQcyooeLcghOivmW+x59pvvenJC9OaG7c6SHnROC5Nx2uFd/OnunSVSyVL6TiKFSmprYraaMOZaoWugN0LPXquoh4L5ko+t7U7YEGhc716Y/O18BasUjg6zX84AF6asdhoMDs+xo2PP0bp2pSuo9CZRqhcx14YS0PG2BWB+4Ep6k9MU/35D67N+dyj8+z6wMaWuF2KeeAYybbN+HclCH9jX4npA69Q+heHBzSzgoKNU4jhFBS8Q7jj/Q0e/1oTrb/1kP0L0xn7t18suos6GVliqI7loi9nX+zQ8xzGyGiVfVY8hxGtMULQU4p536PpOkx1esw0GhglmS37bGu2AYurM4xY/TqxrJQrGCfvKa/6Pxb8NKVVKdMerTK3fYrdMzPYVY88zlg510UoQTuSjMiEuFpmU3sF/9vzynprLecfWxh40Z194EWSSG1YytZmmvSrp/E+uGcwEysoGACFkS8oeIeweZvH2ITLsee63/K1l2rWL5/P5WxXw94zJ7p0PY9RkxALRW+8xFiqsVKw4iqqWcqc7zFiodWoYpTk/2fvzaPsuqo7/885d3xTvZpVUpUGS7KNZ8u+xgYPTMYYDDYQhkAgIYQAKw39I9AJBAJxuhPopAMhISE0nRVMIEPTJMQQSDCeMGAwvp7xKGuyVJKqSqrxTXc45/z+uE+lklySSlLJ1nA/az2vO5z73nnXqrvfPnvv7662YjqjBGHAU5kgzp5e8bvLmZE3Kqufh8yTbzk2vc1JhlcOsHLrTow2WJZANxJ2ra9hF2zGGy5VGVMfS9AlD2uwms15wwy2b1EZXMR4/LYJzESD6NFx/KOtj79vO3JlJ7J38er3c3KOltzI5+ScQFxyReWIsuwfG95fs37fGvnp7U0ajoNsxNg2NDtcqirFCMGMbVOJEmIpsTwH27KYsSwuHx5p970y+Gm0V81CCLZXO7NzaSaaA5knj5RcuPkxxruqWFrjRzHStTBRythDu3E6HMabDkUd09o0TXzO3pr14WOQVa/vfCqLxz89gRcsQjw+l7LNOc5YtJj8QgmCoArc3N69EHgciMiy6rcDPwbWhmG4sT3+JuA7YRj+SxAE/cAPgMsPUE+fk3NSE7y4g+/+yybiWOO6C/uNrrXhiR2KF+xXI981p0Y+Go9oLndotSwSLdhah1U606Kv2zblNEULgXJsRKrYWK1w3li7mtVAMWkioN0pXrCz2kExSfFb8ayRd5MUoTU9MxNoZRhevYyu6RlmOnowBYexH+2g0NXBxBYXP46Y2TKJ9Wt749s77t3NyqOUnH3WvbnzKeKBJXgvihGudegLDkJy5yYK779kkWaWk7M4POeefBiGU2EYvjQMw5cCDwJvbu9/E/gVsmz7t8+55CPAp4Ig6AD+HPhkbuBzTlWqXTYrTvN55L76gq/ZOq6pFgWdxbmZ9XuT7pKmQiQaYwmSJWViR1LxBTOOjZKChm0T2RaeVthxgpekPNldxdEa3V6eL0dNQGTOvDBMFYvYiULqrFENZJ68NNCyXU7f/BQ71w7SVathSaDosmtbk2Kvy2TsImstijsn6bgh06c3OtOrX3Zp3yLcxb3oO54ibsmjXqo3iSK5eyvOVasWZ2I5OYvEcbNcHwSBA6wDPga8es/xMAx3A58Dvgf4YRh++/mZYU7O8cELr+jg3p8sfMn+se0pZy/b10udq3Y3vL5Oy7Hxo4Rp38fuslnVJVGOpOU4pDJLvuuKE7QReFqzrVphvOiDFEitKCXN2SQ6A1hCYicpQoBGIMg8eTBs71/GuRsfJe0s0HQ9CvUmqefQEjZ9tSnSFIgNTcehelF/Nt+nZ3ArDuWlh19ZcCDMM+Mw06L18K6j7x9/7zDWmi5k9+LlC+TkLAbHjZEHXgV8LwzDCHgwCIK5dSi3AJcCX31eZpaTcxyx7tIyT/6iQb2mFjR+f8162KNbnxn5jb+o0XIdKq2IqUQgKzZlBySCsXKBUpIy7jisrDeJ2gI2OzpKJHYmnFNQLYTJ+sO3O8fiK40VZzF43V7I95IEDDx5+llU69PYzRa7y2X8yQZ1YdPVZVF84Bl6TQ3luEwv789q6WlL2V7Ss2j3ELKlevOitaSbp/EuHjiq94rv3LRPK9ycnOOF48nIvx14ZRAE/0nm0b9jzrm/IFu2/2QQBM95HkFOzvFEoWhx1vlFHrhnYU1rntixr9KdSjS18YRqvwvA9vV1Go5DJYpIFDRsSdzSFEuSsXKJcpww5disajRpFTzGpaSYpCAkBnBVihHMdqbTQuArNbtcb+Ys12MJauUKTcfngvt+zlS5hNVKULGh76Je1MZxutMaqbZIzx+anfMxSbq74ymSJX34lw8inKOLx2ciOKsWZ2I5OYvIcWHkgyAoA0NhGL4kDMNrwzB8MXB5EARWEATXAYRh+JfAd8ikb3NyTmleeEUH9y4wy/6x7Wqf5frJkYhKr4tlZ3/+Y5sbNByHchEsW7C9ATNTiqIPu8pFHKWxjaGiNallsdW1Gag3EUqjhEBJG91+lAgMsW9lXr0BP1Xt41mzG2Nn83hy6WpWbd6AFoJWZ5HqxAy9F/Qw0d9LV20Sk4DzslVAFo/fce8xaEpzx5NEdXHUUrYmTkl/lsfjc45PjgsjT9Yv/q79jj0MvJZMB/9D7WP/E3hrEARH91eZk3OCc86FJbZtiZjYnRx0XCM2bJ9QrO4/cGZ9bbRF5DqI3iLNxLB12tCYUqSxZqJUQGHoSlIa0sKPIkZ9j4F6Ey9OaUlJw/ZJxN5HSct3EW0BnOrM3gRBL07QnoUxcM/K83CTmK76JK3OEv3jU/SuLjHVWaVrehptCbouzjLpx5+axu90KS1ZxHj85t0QpUQP7z7qpjTJz4exzuxFdi7e/HJyFovndem7nWEP8PfznHtPe/PmOcdiINeMzDnlcVzJhS+sEN49wytf133AcU/tSFm7xMK25pez1dog6zFJVTJd8dDKYqhT4m/XTCWKqVKBjkaLapoS2RY90zWm+rpZOzqOn6bElkWpOc2E3wlCgIDId7CUxggo1aPZ8nk3SdGeg9GGWDiMVHs5ffdW1i+7gMi26d++m1rd4EUpDdejd23W5OXYLNU/iblsLekd07jrji4en9yxcZ9WuDk5xxPHiyefk5NzmFxyReWQS/bZUv2Bk+5GRxPcNMXWhl3Kxqk6LK0IitowHoOlDdOORWeqcITAb0WMF33KSUI5ikkswdLaGOOFzkywHkPs25mGPeDFaaZlD7hJQiol2oDWcNeai+luTKNSw9beHlp//zDSlRgcWp5NsSf7IXJMlurvfIqkrxf/iiGEfXSPwfjOzbkITs5xy0ln5MMwzLfz7VNi+4yzi4zvSrjrzvsOOGZsWtPXIfc5vnXjCKXOTLP+x3c8ipISX6XMNFOUK/FtQBtiKSnECbGQuFojDdhJSsNx0JaNVIrIcRlo7KJpZz8apDEkroXdjsUz2xpX4KUpiRZoZdASNixfQ8vxMNNNdnV3En1/I+6QxBiJcczsnMfXz7BTbV3Ue2ieGGH0Z8MUrlt7VO+T/mKE1v3bcK5cuWhzy7fz7SPZPhDiaPpTH6ecdF8oJ+dA/NkfPMP1b+nljHPmr8+++f6I7z4Y8eV3d8we++7nNzKwpsTFr1vC+icafOs3f84vhpZSPb3CQ00b67QC9UfrpFFM7Hh0Tk0jfZcz601Wbhvhi+efwWWj47zqkad4YM0Q77/vFn667AKaxSKD23eys7eXQi3GSiIu3LiDpnDxTUpRtvjbN1xDRacMiQbDTYdzNj/FlF/F6ivyih/8lPEv/RLL33cTjSU+y3feCMA3Xnc7r/hsQM8ZHfN+xyNh5rK/ZGqLYXDLB45Y6c5ozcQVf0vhVy+k8P4XLtrccnKOkHn7L590nnxOzqnEkqUuO7fHBzy/pt/i6ZF96+m9gkXczI5VOrOl9ZZlM9QJVjNl87hGOxJPgBHQW2swadsoIHVsepstJn0XLSUgSKSdNaExBltrNFCajgCwMLO/ui2t0QbSRNM75COilB0d/Wig2dCYrgKVf7oXYwncZG9Coe1bqNbCNAEWglGaqfUx1etXHJWUbfNL9yKkwH9vsGhzy8lZbHIjn5NzAjMw6LJz+MBGfnW/xeZdCqX3LnC5RYuokRnNciUrd0tsiyqKwZJkeMrQ222RSEkiBZVWzLRtoYUgsS2W1JtMOg6NgkcpTkiEhSDrGW8rBQKKtYhZmdu2gyHIHjiuK6gu9Sm3GnhJQmIkRhv85WVKP30aVXCw43R2vrZvkS6ika/d9Aiy5OAPHHnesRqepv4Ht1P58g0ImT9Gc45f8n+dOTknMAPLXEa2Rwc8X3QFvRXJ1t169phXtIjbRr5YkGiZGWG7HuFahi4HlvZbKCmpS4mxLSKRSdOmtsXgTJ0J36XluXTWm6SWPduExtIaYQzFRoIxBiPEs+JnngN20WJofDfdaR0ZpxR6PNhVY2TFIKboIpO9Rt1aRCOvazGTn7yLzrevhZ2H381vD7UP/juF33oh9tn9izKvnJxjRW7kc3JOYJYMHny5HmBtv8XTo3uNpFu0iNrL9VIKjJS4WtGaSKg3DF6qWdJno4UkFVArFoilRGPQlkV/vcmE5xJ7Dh315t7lerLEO2EMsWPhJhojsyX/PRgDUhmiJ3aTWjZR0ccTKcQKM9lgp9+BKbuIZO9Pg8X05Kf+9Gf4L1+J96Ih2DF1RO8Rfesx0sfGKP3eVYsyp5ycY8mi1ckHQbAK2AS8PgzDm9vHng7DcG17+1eB9wEpMAp8IAzDkSAI3gVcHIbhB4MgEMAdwIfDMLx/znt3A+e3dx8Ow3B8seadk3Mi09PnMDOpiCON683/m33tEounR1KuPieTsfWKFnF9r9E0UuAazcSUIi0YPKFoaoFvwDKaiXKR3maLMdeh15IsqTWpOTbTRY+h7RGpsGY9eQBhDM2CjRsplJCzqbAGgcBgWgl9N9/Hw6vOpVqfYUkyxY6JAs7VaxEPxejOAkYDSoMlF83Ip9ummfnr+1j2wLsROycwOw7fk9fTLWb+63fp+PqbEL5z1HPKyTnWLLYn/wTwe21jPUsQBFcA7wauDsPwJcBXgK8DhGF4E3BWEASXAu8B7p9r4Nu8EXhn+/WGRZ5zTs4Ji2UJepc4jO44sDefGfk5nnxBznry2ZtIbAzjTcHQgM3qLsEvtissYxAapn2XJdN1JhwHJSUWhlKqGC0VSW2bVMrZ6LsxmZFPXIkXKbQQ+7jyAugc2UUUZ4N7VpeoNqbRBpJLV9EhFbrgYoQNY5kRXiwjP/H7d1F5/0XYK6qIpR2YI/Dk6x+/Fffa03FfktfF55wYLLaRHwbuB27Y7/ivAZ8Ow7AJEIbh94ByEASD7fO/BXwR+C/Ap+Z537wsLifnAAwcYsl+fyPvFe3ZmDyAsDMjP6kthgZs1nQKnhrT2ErjCIgti95ak4is+YwRgmqSMlrwiXwPzV5P3kiB0IbEEXgthZb7xuSFMZwxuoP7htZgWRCVClSbNbTn0LBdyiYh9d1MC3/nJAC2L486uz66fyet72+k+rHLsgNLOmB0BqP1wS+cQ/LTZ4j+9THKf/qqo5pLTs5zybGIyX8a+Nh+3vwQ8Mx+47YAe4z804AD3B6GYW2e9/wW8LX261uLO92cnBObJcsOnmG/dom9rydflLPZ9QDCkWAMTc+lrwSDRcHOpqGaJgigoBS+VqB0VjZnoJqk7PY9Yt9BC4Hc48kLgTSG3Z1FnESTCImYY+WdOGGqWKblulTP66a2tUFnNI3SMKUs/CgmdW0wArN1N3D0nrwxhomP3EbnjVciK5mKnnBt6PBh13yPm3neI06Zfu/NlP/81ciuXKM+58Rh0Y18GIbbgPuA1885PAzs3wViRfs4wPuB24CrgiB41jpYGIbjYRje2X7l8ficnDkMDLqMHMST76sIUg27a5nX6s0poQOwXIlIDQ3bpmRSVEtjGXAwdBhNKVVgWTRsO/PUMXSmignXbXvyclbZzohMw7bue9RKLpq9dehaCKr1Ok939qEcm57VJVq1lO60gU4NE5HAqbdIkSBBPzmSze8ojXzz2+tRYw3Kv3HBPsfF0uqC4/KNP/sJ1opOvLece8TzyMl5PjhW2fWfAT46Z/9rZN59ASAIgmuBZhiGw0EQLCNLyPsEWRvZvzpGc8rJOSk5lCCOEIK1/RYb2hn2bnGvGA6A40vQBh9NMh6zbSRliZ9p1veTGfmG77Hb99o946EzSZlybCIvM/J7PHktsh8Bkesw3lFAz4nHaynQQhA5DkIK3PAZsCS+D1IYdk0aZC1GKcAR6A1H78mbWDH+O7fT9Wcvf7ZG/dLqgjLs0/W7aXzubipffB1CzCsqlpNz3HJMjHzbmw/n7P+QzNDfGgTBD4HfBN7RPv0XwMfDMGyEYXgXMBoEwZuOxbxyck5GlixzGd0Ro/WBU1fmxuW9gkXc0OyRtHZ8C5ShKlImRyNGdqWs7hRM2DaegYJKGesoUYoT6pZEAB1Jwkzbs08tC9jXk9eWxY7eClrtNYpKSlIjSByHUkWiHh3BrnqIagFLGCZ2tBDdBUykEY6FfmYCODojP/Ol+7FXd1K8ds2zzi0k+c4Yw8z7bqb0iZdgrew8ojnk5DyfLFoJXRiGm4Gr5+x/YL/zXyHLqt//ujfvt//rizWnnJxTgULRolC0mNid0tM3f1nXmiV7PXnLkQgJaWxwPIHjSxwMvlDsHIW+Hpv+quBWy2agGeFrzXTBp39ymrrJEukcY5AY6rZFau2tk1dCAgYhDJsGurnskW2zgtpaStxU0fAc+mamkBcNIqYd6C0jjaE2FmEPltEtBZ5Eb58BjtzIq4kmk390NwO3v33e89ly/cGNfOurD2CmIwofvPSwPz8n53ggF8PJyTkJGBh0GTlo8t3+GfZ7Ve/cgoVtNBWpGJ0xDA3YDHqaaWlRcsBRmlQI+upNWkaDEJncbarY5bkoa28tvG5v28Az/Znnm2UCCLQBL00wQjAwPoZZ1QOejRjoxNKKQtXBXlaBlkL4NnpXA9ijXb/wLPg9TP3R3RTfcAbuuX3zDzhETF6P1qh99BYq/+cGhH3kGvc5Oc8nuZHPyTkJWLLsEGV0/RYbRvbqwc/Vr/cKFrYxFIyiJm0GuiROpGhZAhcDQqAFFLViRmbR91hIKknKbs8llfZsnXxiZcbQVynTxQLKFhgEtP+7p2Z+4NfPJ5pKUJYFK7qRSlHt95BLy5iWAt/GTGZyvUfiyScbJqh99RG6/vuBVenEIWLyMx/+Dwq/eiHOumWH9dk5OccTi7ZcD7Oqd38bhuHV7X0J/A1wLtkP+meALwN/2L7kUuCe9vZ7wjB8OgiCj5PF7FeHYWiCIPgKcBqwCmgCI8CPwzD8/cWce07OiczAMpcdwwfWsF/ZazE8oYkSg+eIfTrReSULaQyOUjQ9l05bsX1KEQubNNXYQhAjELZkynUwlkAJQUeaZp68tGaNfORkjxRXGRyVUi84OG0deqEN2sqMfM9bXkDz44+Q4MGaPuTdDSp9HhZlRKSQHTa6ocCYI8qun/jYnXT89iVYS0oHHHOwmHz0/fUkP3mGjl988LA+NyfneGNRjfw8XAvYYRheDpk8bbsE7qXt/afDMHzpfte8FrgduJzMmP96e+yNwNNhGH79GM85J+eEY2DQ5cF7D1zz7dqCwW6LLbsUZyy1cUsWUVva1i9ZSKPRMRhfIOsJo5OwRCimtKQgoCkFDddhV8FHC4ljDJVEsd3L6uQRAoxBWVa7Lt5QjBLGOotUpyMMII1GmCw2X11aoDbSpNXtI84cwNLrqfS5WHYZGaUIV6KxYbJ+2J5868dbie7ZTu/fv/ag4w4Ukzf1mJn3f5vK31yPKLkL/tycnOORY71cXwPODYLgLMjq3Q82OAiCdcCjZN7/Ow42NicnZy9LDtGNDvZtVDPXky+ULYQyRCn0lqE2FjE6pVnuaKaFyLLigXG/QGJJGpZNNUmpKMVuz0WLvbK2WY/5rElNKYrZtLR79vNFO/vfLliksSZtKFqRhvMGsbSm1O1iLS1jRSlSCrS0YcfkYfWTN9ow/pHb6Pr0S5CFQ2jLL63CjunZKoM91G+8HefFK/CuPX1Bn5mTczxzTI18uyTufwNfDIJgUxAEHzrEJb8CfDUMwxA4OwiC/Gd0Ts4C6Oy2aTU0zcaBjeHc5Lu5Mfli2UZoTSsVLOuzGNuZIIGlrqZmW0QILG1o+i49jRaTvoOlDSWlaNgWSsisPt5kMXlhMoNebrV4pr+r/ekCIwWFKMbybaa2NekYLKBS0AOdWEZTslLk0jJWrJCWQSuJGR4/LE++/s+PgTaU3n7OIceKkgeOBVPN2WPJ/dtpfvVBKn/+6gV9Xk7O8c4xT7wLw/DvwjB8GXAB8K4gCFbPN64dv78e+P0gCP4T6Afyv7ScnAUgpaB/6cGV7/aplZ9j5EsVC6ENTSNYtcJl54SmpyzolpppyyKRAl8rIsumuxUz6bo0RSayU01SEtl+jBgzG58XQLXWZLxShKx0nlRaVOsNhCOZ2tagOlTEL1u0mhqpFYXxCaylZewkRWiNcATmqZEFG3ndTJj4vTvp/tzVCLkw0Zq5cXmTKmbeezPlP7kG2V9e0PU5Occ7x9TIB0GwLAiCjvbuDNny/YH++l4GfDsMw2vDMLwWuI7Ms8/JyVkASwYPpWE/x5PfL/HOMoZYC9aeUWAiFnT5UDaGKctCC0GX0RghqKiUCd+dbezSGScoKYHMk9+jXS+Vpm+mzkzRx7SfMolt01mrg50Z+c6hIn7JZve2FhKDHJ5ELinhpFl/eVlx0E/vWrCRn/78vXgXD+BfuWe+7/IAACAASURBVHzhN21Ohn3zC/cgOjz8d61b+PU5Occ5xyLxbl0QBLe2ty3ADYJAtz/rO2EYbjjAdb8C/OOenTAMNwRBcFYQBB1hGB5+4+ecnFOMgUOU0a3pz4y8MQZvTuKd7VlYGFpIVg65NAseZRSpEkzbFqkUdKDZgUFKwe6CT0+jgTQFOpMUjch+ugsDBqQ2CG3oqdVJpaTlWlSaAmUJKrUmRgimtjXpPb2Mv6nO7i1NhIB0eApjWSgpMS2F7PbRWyawfHlII69G6kx/9ucs/emvHtY926NfrzZPUP/jH9L10/fm0rU5JxWLauTbqnc9hzF+7Zztd89z/rw52zce5fRyck5qBgZdwp/MHPB8V0niuzAyrXELFtNj7Tp0L2s1m1gW/d2SlrTwmxE141PQmlgKLASRkEghGSkVuHLnGFvLJTrSrPbe0K6EF2AZjTCKYpLiJwmjXRV6mw1kqpHSoAxMbWuw5uX9+OWI3dtaCEugRmukkSJ2HHSzhVxRRQ9P43qZJ2+MOaABnviDH1F+57k4p3fPe/5AiKVV9PZJ6r/1HYoffjH26Qt+fOXknBDkYjg5OScJhxLEgXaG/Yjap92s42eefGrbCGXo8AxpLWGiYehOU5oIjBFEUpBKyXjRp3Omgas15VQhjcGI9qNEZKVyUhssrSnECdv6q9mpNKvFTxVM7onJlywmd7aQroUab5C2dNa+tqmQg1X0aB1pS6QtUPH8qnfxo2M0/vVJqp+8/PBv2tIO4h9uQW2dovjfjuD6nJzjnNzI5+ScJPQvddk1mhyiUY3NkzsUfsmmPpEAYPsSS2lSSxJNJyzplDTqimYMXUlKC0gReGnKtOdSiROaAlylKWqDPefzjMgy8feUy1XrTbb2ZkaeFKxUk0Sa+q6IyoCPX7KYGo2RBQdVi0kjReK76FgjV3ahJ1pAprevovmN/MQnfkj14y/C6j6CPu+dRRq3D9Px5RuyHvM5OScZJ52Rz6rv8u18+9Tbdl0JaOLIHHDM5Wc4/OtPd7H64iojT9f5wTfvpWuoiFe0KEUJP/+HzdiJoqk1/VVJWSlaMquCL6SKREq6WjFjpSKpFLjGoIWg1dZ2N5ZsK9dmc0ilwFJZtr3EgDFoDXZZYNkS15fMTNaJtcS3NA/87GE8rRBFl52PbcOKm0yFw+Aa3Ir97O91189o3baFynsuPKL7ltyxCdnt85Az+pz//8q38+3F3D4QYn8hiJOAk+4L5eQslI+8ez1/+PnTKHfM75U2IsO6T45z96e6GLlvgru+to33fPE87v63Ee760kaUJ9m9pItS0aa8psztv4jY4rksAepJgiUl3VM1qo0mxUoJS2vO3rSVgmqSWAVSz6FvZBd1z6M8E/FPV1zIuqd28IZ7f4FNgnHgn97wCi4pzPDWmy7jlpuGWf+jXZQf3syrCs/Q/PQvo6/7Kv2rBclYSvUCiydWn8touZ+XfeaiZ3+f7z7N9J/dw8AdR1aIMz343xFXnk7ln992RNfn5BxHzJuwctJ58jk5pzK2I0jTA//OLXqCl77A4T8fjjnrqm66lvrc/X+3c/kvLUFbkri7hJpJSITgjBUOvtI0rewx4acKhaC33mSkUiKxJJZSGKDuuPvUwwttMEDDdembmEEANprEzTz+Up8PgONLVKqp49Ix4NPcHeE0YkSnD7ZEviVg2z27Gbq8f97v07xlE/41px3RvTKTDdKRJs5bzjv04JycE5TcyOfknEQcysgDXH+Rx833RwghuPaDq7j333YyMRxRuGyA0vAUVprSbBkGl9r4WtOyLBDgqSxRr7/WYFepQColrlYINHXHyeLxqSKVEqmzuvrIsVk6PoMhM/JRxQcDpV4PANeT6DTLzXdXddHcOpPJ4Cfgvup09CsvYPuUy9AlXfN+l+b3N1I4QiOvbnuSFAf3ZWuO6PqcnBOB3Mjn5JxE2LYgTQ5u5F9+tsvDW1PGpjXVfo+r3jnEdz+/kcte3UfTdejxDK2moliyKRpNSwoE4GoDRjMwU2fc80ilxEk1rlLUnEyB2koUljGgDUaCkpLumQYGgcQQdxeBvUbe8SUm1pTjJnJNL+mGSSjYqJEmzjVrGd2u6bBjCo9vftb3SLdMoXc3cdcNHNG9Sr/xEFZfAdl1BAl7OTknCIuWTtpuM7sJeH0Yhje3jz0dtmvhgyD4VeB9QAqMAh8Iw3AkCIJ3AReHYfjBIAgEcAfw4TAM75/z3t3A+e3dh8NDNLrJyTlVcZxDG/mCK3j52S7feyji164scPHrlvCL23YhdtTY1t3N2aM70X1FmiMNChiitmytYwzCQGejiZKClhS4SlNI4/ZyfYytUoTRJLaNbvsQvtormJMUPIwxlPr2evImTqlEdTjzXNQtG5GeIN06jfPyNWz7+80MneHD9x6Al+6rR9/8wSYKrzxtwRK2+xP/cBPOlWce0bU5OScKi+3JPwH8XttYzxIEwRXAu4GrwzB8CfAV4OsAYRjeBJwVBMGlwHuA++ca+DZvBN7Zfr1hkeeck3PSYNvykMv1ANevc/n2A5kYjrQE1314NT/7+lZwLabKRXpqdR7/xhY8zGwmq6M1UmvcRFFQippl4WpFKWkRWzLz1tOsnWxLWtSKHlJrpMmEcgyC1Hf2Wa53PImOFJVWHc5eCjtqWDrFWtWJ7Cqw7e5Rlt+wJjPy+9H8/lHE40emSXfHOG8894iuz8k5UVhsIz8M3A/csN/xXwM+HYZhEyAMw+8B5SAIBtvnfwv4IvBfgE/N8755xnxOzgKwHUFyCE8e4KVnuTw2rBiZymrP+08rMnBagT5iNnZ20Tddo7U7Ag2eMcQCHKOx27F2zxgalsRRCl/FeGmKEWBphRHQcj1qroutNBKDEaAFpL6LmRuT9y3cVkQ5biD7O7BGa8hWgnP5ClqTMRMbaix56zkwMgnP7Jqdv1Ga1m2bjzwef+sTKOHgvmTVEV2fk3OicCxi8p8GPrafNz8EPLPfuC3AHiP/NOAAt4dhWJvnPb8FfK39+tbiTjcn5+TBXsByPYDvCF55rsu/P7i3B72MEzqTiNS12VUtU11eQmuDqzUJAkdpvFST2hauNrSERAJeGuOn2Y8FoQ2ptIhch5rv4aYKYdpGHkHiOzBnud7xJU4ropI0sv3JBrQSnFedzvBPx1ga9GAVHLj2QviPvd58dO8OrMEK9rLKEd2n9F8fQVR9rGUdhx6ck3MCs+hGPgzDbcB9wOvnHB4GVuw3dEX7OMD7gduAq4IgeNZP8zAMx8MwvLP9yuPxOTkHwLIFSi1s4ev6i7zZJfu4oRh9qs6bP7QCUsOW3i7G189gpSmuNiTt7nKeUiSOhWs0LSHAGApJhNfWsBc608CPXJvpgo+XJJkIjszU8GIvW64vVB0gi8kLpSkTo1NNod4EpXFeeTrbfjLK8ivapXOvWbfPkn3rlk0UXnVkXjy04/FXrDzi63NyThSOVXb9Z4CPztn/Gpl3XwAIguBaoBmG4XAQBMvIEvI+AXwY+KtjNKecnJMeZwHZ9Xu46kyHp3cqtk8otj4wydKzKpx+aTe9vqZpOZx+7VK6Z2q4xpAIUAi8VJHaNp42NKXESVMcneAphQCMgNSSNF2HmYJHIUozhQ4BGkhsCyGYTZZzfIlGULQUjYmYUhRhCwVVn213jzF0eV822WsugDsehSiT4m3esumIl+rNpl2omsZ93QuO6PqcnBOJY2Lk2958OGf/h2SG/tYgCH4I/CbwjvbpvwA+HoZhIwzDu4DRIAjedCzmlZNzsrPQmDyAawuuOc/l3x+M2XzvBKvategXnJeVlNUHOig0IwbrDZSB2LJwlCa2LTydldZ5cRMjJMU0q6E3QpBKi1Z7ub7UjBAYLBRGSHQKzOkkZ1mQCotiSdLYMInAYHc5TG2qA1BdVc4G9lTg3OVw1+PoqRbxQ6N4h9M3fg7qtidIpYvzkiNfCcjJOVFYtBK6MGsze/Wc/Q/sd/4rZFn1+1/35v32f32x5pSTc6ph24cWw5nL9es8PvefDW4Ix3ndjWcBsLLPAlJu/cEUndUKL9oxxs1rVpBKiacTYsfGElndfCw1SmYevrYsjBAkUtByHRqey4raOAJwtEJJMNog5zx14pkEP40xnUVaj+5GYrCXV9jyk1GGrujft7Xsa9bB9+6nWfPwXjyILDhHdI/S7zwKro21en6BnZyck4lcDCcn5yRioYl3e7jiTIeNIymjTehfm3nNltIIARPSZbJcpLvVor/WQBiNACLXwTKCslJMOxZaWkgDGJOp3InMyDddh4GJTO2uoBIS10Kneh9PPpqIKcVNVH8HyU+eAQlyeZVtPxlj+f5Stq9ZB//xYBaPP9KlemNIfrgZ98qVB+xNn5NzMpEb+Zyck4jDNfKOJbi0W7PjzP7ZOLmKMz16g0AjWN/fxYt3jFJoxWCg5dg4aDrSlAnHJZWZ7K0wBiUEWkoaroOSkv6JWlYjL0XWJz41yDlPnfquFpWojurvRN63DVN20X0Vdty3m8HLeved7IWrMJMNmt9df+RG/vGdpMrCufaMI7o+J+dEIzfyOTknEYe7XA9wxsQUjzil2f2krgGBRWbopzwfVyl6WhHCGFqug22gmqSMFXwSaSPIMutbtoUxhobrYCtFZ6OFQRC5NnXPQyu9j0JdbSSiGtWIBrqwtkwgujxGrQpdayt4VXffiUpJesV5mKkWzrl9R3R/zG1PoKSLe1WeWZ9zarBoMfnDIQiCLwNnhGH40vb+acBngR6yHx5bgQ+GYbg7CIImcM+cy98chuHYczzlnJwTgoU0qJmLTg2Fh0fZdX43m8cUq/osWg2Fa9t4tsDUoKIUtw4N8MaNWxl3HRqug2OgK4rZWSqTWhYGgTCGGceBVGdZ9EpTjmIM2RJ/5LjoFMQc12J6Z4ueqE6zpxNvuoVYXWZ7zTlw17nqUvzK+iNeak+/+xhGgXXO/O+fk3Oy8Zwb+SAIXOACsiz6FcB24JvAe8MwvK895rw5cxve82MgJyfn4CykQc1cdj45Q7Xf47XrPL7zYMQHX1kkqitcx+G8szwev6tJ2YGHu6rcILbSG8WMlQpooDeJeaCnmrWWFYA2TJU8eiYbWEqRIigkKWBouS6JlcXkpbXXQM/sbLIqqpFOKWzLomgrhndqrrx8fk+9uSOltGsYGhEUvcO6N0Zpkh9txrniHITMFzFzTg2ej3/p1wHfBr4KvB14IfD4HgMPEIbhI2EYjjwPc8vJOaE53OX6TT8fZ9UlXVx/kcu378+EcZp1hecKzn5B1vPdMlmcfcT1WNpsEdkWGqgkKZFlU7M9DCC0ZsL3qcQJljLodtY9QOQ4SGmytrJzvPCZbXUqcQP7FztBgUoUtSlF//nPznw3iaL1k+0U1vXAnY8e9r0x9z9D6hdxrl572Nfm5JyoPB/L9W8D/hswAtxC1rlu656TQRDcRrZsf2MYhv8GDAZBcGf7tArD8BXP7XRzck4cbEeQTi/cyG/++QSXv3sly9c4jM1oNowqWvUUr0OwfMjNltqNwDeahmXTshIGZups7e7ENobTJncxVijhpyCNYcp3sbVCYEilxNYaBLRcB2HaJXRt18IYw8xoTDFukd67hdiSjDVsll1WRdrP9j+inw7jrO3Cev3qTP3uNRcd1r3Rtz+Jki6lPB6fcwrxnBr5IAiqwOXAl9uHVgE7gVlVizAMXxEEwY1AWwUjX67PyVkoh5Nd35pJGdtQZ+j8TiwpuO5Cj+88EJHUFYV+kfWfExAh8bVGYNjh+6yenGJbZwfCwOkTo+z2SwzNtBDGYGnD7mIxy84XtJvTZMl6jkqRlpiNp7emEixhAIGcalF3S+yIfIauOkA8fk/p3GtWw+v/F5h9VwUORfqfj6NqKfZFyxZ8TU7Oic5zvVz/JuAzYRheG4bhtWTtZ28gazV78Zxxz0tCYE7Oic7hLNc/c/8Eg+d1YHvZY+D6dR7fvj+iVVf4vqTe1O2EOvCVBgORZTFRLLBiYgphDGeOjzDtZbFxoQ0FlbKtWkIJia2yHwYSTct1QIOwJbTt8szOFhUnJRY+zaXdNIse250Ohl45NO98m7dswn/VaZnyXZzCUzsWfF9MlJD+bCvOpUMIx1rwdTk5JzrPtTH9FeC9c/Z/DPw1WZz+fwVB0AM0gAn2evtzl+sB3hOG4dPPwVxzck44nMPIrp8rZQtwyWk2kw3DiJL0FyTj7Ta0wpi2wc7Y0lVl3badRAWbldPjPNVzRnucppAqdlZKJLbETTI9ewtF5Dp0TU63PfnsfaZ3tijrCIVLq1SkYcARhuqKMvujdjVIntiN/+KhzHt/9YXwvfvhzIV55eZnm1CdVdyX5VK2OacWz6mRD8Pw5fvtR8CeLhFvPMA1hWM9r5yck4WFLtcbY9j88wku+qXB2WNSCl59jsMjw2VW+GLWyFvGUI1itBBoIUgdh9FykdPHRxiszaAsC6EzT78cp4z0ljDSordRxwCeVrQcByH1PqvrMztbVFo1UJIEyUzBY5lpzjvf1m2b8V+yAuG2vfDXrIO//j789msXdF/2xOMLV61a0PicnJOFvI4kJ+ckwlrgcv3ktiYq0fSsKu5z/OrTLTYWiniOYHJagYBCmtLbaKGlJLUkFrCtWqG7Ps2Seg17j+EWUE0SdlRKuGlK70xjVu1O2RZCZqsCe5gZaVKcqqFsiZyOmJEOy7rVvPNtfn8/KdtXnAc/Ww+11oLui7rlCdLxCOfS+UMBOTknKyedkQ/DMN/Ot0/Z7bHd69n4ZJP7fzZz0PFRXWE0/OS2e/c5fvEqm4YQ7BzZRbNlQAoclRl5jKFl2xhAWxYShURSTlIwWQc6Wxmajo2bKvonaxig5TvZKoCUxEJSrtqEYUhjPMadbjJd9IkbKQ1lUShMP2vO8eO7mP7W4xReu3bv8UoBTl/K49+85ZD35PG/+TatX4zjXLmS+x57+Hn5/5Jv59vHevtACGMWXm5zgnDSfaGcnMNhy8YWX/7cMMGLO7jhl3uRcv4M9Hv+4Rke/8Eob/vrC/FKeyN3L/roKJfoFqedXSb88TQ9jRa1iRpenLBhSS8Fz6YYJ7zlobs5c2QLX3zhdbxgeAShDU/2dnHHykE6HId33HofF27eQcGL+EFwPqt3bOehs8/kVR88jcuv6ea7v/sgA397O6wo8tRMF0sGBJefrfD+z9tm56JrMTteeBMdH7mUym9csO8XOPcj8I//Fc4/cEmc2TZB4/w/oSk76HroA1iDHUd3c3Nyjl/m/UM/6Tz5nJxTnZWrfT726ZVs2dDiC5/eRm06nXfcC9++nGXndvDtTz2GSvXs8bWrPCYmUnaPxNQ9G6MMpSShGCU0XIeWlLgGHJ3StB2yHHxAwHClRGecoKXg9G27AChEMQA136fhuFzykk4A6k+MY6OYHFiC1Jpl5QRR3KtXb4xh13u+h/eiwWcbeIB6C8r+Ae+DiVOiG75MIy3S8f9+OTfwOackuZHPyTkJqXTYfPDjQyxf5fGZj2/hmY3Pjl0LIbj6Q6cjpeDWz65nz6resm6LofPKbN7QYuVKj9iyKChFMYppOTZNIXCMwVaKabeArbPrjBBs7qxQ0NDZaOGn6exxYQzDfX30mRauJ0kiRbJpAizFlu2Sc0e2Y0sDxb094me+EJI+NU73X10z/5esR1A6sLRt+tv/j/rGiOInXor7stVHeitzck5ociOfk3OSYlmCN76jnzf+Sj9f+PQ2fvbDqWeNkbbgdX94NjufrHHP1zPhySUdEm/AJ5YWHTpF+xaegVIUEzk2TUFm5HXKjONjaT2bUKcRlLRi3dOzIpZtYRzB7s4qQ27m1d//Rw8gjWFjeYClaz06mk0so2c9+dZPtjH5x3fT9803IAsO81JrQWl+T179073Uv/4Y1uWnUfzdK4/0FubknPDkRj4n5yTn4hdV+NCnlvO9f93NP//dyLOy792ixS/96bk8dPN2HvvBCEuqkokYYgRTj02hCja2MRSTBCUlEZnhdnTKjOdjaYMwBiME/TN1YtvmmoeebAcIs+P1gk9HvU65YjG6oYb5+/tIukrUbZ/lF3agLYlUCoouaqTO2Fv/jd6/uw5n9bM17AHQGloJFN1nn3p0O433fpO0s0rHP7z5iDvW5eScDBx1nXwQBOcDfwIUABf4ZhiGnwuCYBOwBbCAzcC7wjBUQRDcBPxtGIY/DoLAAJ8Mw/CP2u/1KeAPwzAU+31GN3B+e/fhMAzHj3beOTmnEoMrPD726ZXc9Fc7+Pz/2MpvfmgZ1a69f/7lXo83/sm5fONDD9Pz3hcwOmNRLkqC8yv8y/0pp7Ulay2tSYUkaWfd11yvbeQBIRiammFGCDqaES0yA5xaFjPFAqdt34FzTi+3/fFjXDU+xsPVZVw6vgFZPgNl27hJivFsxn753yj/+nkUrztII5lGDAUX9usmZ6abRNd9iZYo0/Xv70BWDxyzz8k5FTgqTz4Igg7g68AHwkxf/nJgT3soFYbhS8MwvBJIgPkCa5uBuQI5L2sf2583Au9sv95wNHPOyTlVKZYs3v87g5x1XpH/+fEtbHhyX+GZvjVlrvuDs3jspo0M70rp6bIIru4mNgJtMlEcYSARoITAVinTrods69obYM34FKeNjs8+WASwcWk/jlI4cUpjMmXo6S08ecELsKse/a1JKDiktkQmKTP/sRUcSeeNh1hir7eeFY83xpC886vUJx0qX3wd9nkDi3bvcnJOVI7Wk38t8J0wDDcAhGFogO/PHRAEgQQ6mT+9XwGPBEFwUfv8Q8xpVjOHvCwuJ2cRkFJw3Zt6WbHa50t/Nsxr39TDVdd0zi5prwq6uOadQ/zDrSkvWy2YbsBQ2WAphWWyhjVKCJSQuDql5vhYxqAABPTUW3TVWlnrWbI/3EfXrKRrZgYtJTs21Dhv5xj39KzEWV5EGo10XZRlYUZbNJ5qsezx9yGsQ/gftWdn1qefu5X6XTtxf3kd/jsuPAZ3LyfnxONoY/LLmdMmdj+stub8drK/9e8fYNw/kvWVf3t7ez6+BXyt/frWkU42Jycn47yLyvzO/1jBXT+Y5Gt/s5M43ltC9+LrlxBbkvHHJhkZTVjbaXBbMZbOjLkSEiUzT77uutkSvmWBEFhKU0jUnqI6dneVaXouHc0mSkpe0BXzgN3Hiz55AVobpNFYGBSCZHOLnt8LsHqLB5j1HPbLrNd3rad54+2Ylb1U/uK6xb5dOTknLEdr5LcCKw5wTrWX8M8CBsi8+WcRhuE9wCVAEIbhzw8wZjwMwzvbrzwen5OzCPQPuPzOH60kjg2f/YNn2D2WAJm3P9BpUaza3PPdUVY4CX6SYATZsry1JyafUHM8LGNIpJz13qXZs/RmeGrtIGdsGcZWCi0E9rZJyivKrH3NIDpSWEZj1Vr49QivT+JduGRhk69Hs5n1ZscUzTf+HZFTpvqddyK8vIllTs4ejtbI/zvw2iAI1uw5EATBK+cOCMNwAvjfwEcP8j5/137l5OQ8h/i+5Df+v6Vc8uIO/vQTW3jikToAA1XJ6hf3UIsFzQ1TWFqjhESbrL4+EhJHK2ZcF6k1aq6qnjEYBI2Cx87+LlZuH0UqhR+12FzzuPLzlyGEQMVZ6Z38+kOkjoVb0vvUyR+UdkzeJIro9V+mEReo/t+3Yi2vHoO7lJNz4nJUP3nDMJwOguCdwF8HQeDTzq4HfrDf0H8mi71/+gDv89WjmUdOTs6RI4Tg6td1M3Sax1e+sINXXNfNQIeFsiXFVWVad25HaIOWAiUEEohEll0/43pAE0sbsCSinZxngPVrlnLaMyNIssx8txWxaqmkelZWFqdTQ2oKsG2aic4KA8noPop3B6Udk09/91vU1zcp/O6VuK88SDZ+Ts4pylGva4Vh+BBw7TzH187ZjoEz27vvmm/MwY7l5OQce15wbomP/vFKvvzZ7RRjQaPaycSM4Q1n+TywyaCBlhD4BupWZuSnXQ8tBI7WmHaynKUNiWWxceUAr77jPlJfYrTGVoqV7ztv9vPKE9M0kgrO285BfWMjIp6/7n1e6hF6d4P6nQ9ivWgtpY+/5BjckZycE59cDCcnJ2eW7l6Hj/zhcopFyeZbxpjYleBojWxn1jdk1mq2KSSOTqg7LloILK0x7Qx9aQwbVg7Qv2uKSqNJbFkkqWDtxAjuhcsAULsaXPjYRjr8KWTFJZEWMkoXbOT1hlFa94yRVjro+Ke3ImT+KMvJmY/8LyMnJ2cfHFdy0Wt70CtKdE01eWraasvWCuqWRABNKXBVSmRbaJF577Now1NrBnnB09sQGOquSzltMdrRie1bGKUZe/vNDPd0USrEyFZCKiUiShALiMmbWovkL39EXXRT/c47kF2FY3YvcnJOdJ7XNNQgCFYBDwAPkinmjQK/S5aN/44wDN8TBMEVZIp6CeADHwvD8M7nZcI5OacIA50Wo9UCfctT7nlGsaSrSmW6RmRJvCgBpXHSlBnHxdZZ+d0eMz/VVcZOFX27s97wsWWxpDnDht4BHF8yeeOPMKnm8aFBXrrlEWQrnTXyHEinvo0xhuRdX6NWK1O+ZhnOumXH8jbk5JzwHA+e/H1hGL4sDMPLgM8A3wDmSll9FnjbHEW9B577KebknFoMVCU7pzW9Sz3OFTNEvkfiurhaYxvDqkYTW6c0HBtH6X2u3b6slzOeHkYCRgpcNFpKtJSoH26hdtMjdH/1eoQUWblbK0EhQRtwD+53qC/cQf22bThnVClcniva5eQciuPByM8ShuFPgUeAYM7hOnBtEASVMAxVGIbPbqWVk5OzqCypSkamND1dFk0lGBwewQjBG0cnEMZQswTJ/9/evcfIdZZ3HP/+ZmZ3x95db2zH2RBsZ+NAQotSSvImKU3T0kqtGkRJuIjiJspFCAi9YVSpUZtEQCNUWkAhlHJL3YSbI0QL1FElQ6C4TUohfSkBXIhLQtYxuRB7gVCHnAAACwNJREFU48R7nevTP85Z7/F4d73EO3Oc2ecjjXbmPWfefc6jV/vMeefseYslqsUiPY3mkbP46VV9TK/uY2O6lnyh2aRYaDJTKlGuVJnY9lU2fP4KtG4VRRn0ldB0nSZg5Z5FF5NpfvNhpm68B9t4KoOXrF10mVnnXOKkKvKp/cCPM6+vIyn63w0h3BNCODOfsJxbOQbLwsxYM1jgcD29yU2zwZ6BVQzW64wXC4z3lpMb3KTT9QgOblh3pMAD9NCg0tMDJl4+uo81f/EKyr+6kUa9SQGDvh6YrtGcfb4Ae+ow01dsp1LqZ+juq9BM9Zjb2jrnjnUy3hpqEzA++yLGuA94K0AI4Rrgr4Br8gnNuZVBEqcPFSj2FRhvFBkGmhLPFgsUzChak//YuCW5mU16Ht9QgcNDg5y3Z5Tp3l7KlRmKGFO9ZV78+JNMlvsY2nYhAM1a0gflHmyqCggrz1/krd6g8trbmZops+bzb6Q4sja9GY4XeeeO56Q6kw8hXAScB8RM20syuzzBSRazc91qeKiAlUQlfW2lIv31Bj8t93FKtcrXN5+brEyXXlk/PtDP0KHDgCg0Lb3NrbH+8DirqlW+v3nTken4Ri09k1/di03WoGALFvn6jTuZ/OEEq7ZdQt9l5ySNLfeud87N72Q4k78ghPANkivnDwJbgQ2Z7X8SQgjAFNAEru98iM6tPMNDRWoSFRMGNEslpntKVApFBmoV7j9jhHK9ASRn+eOD/bxo7z6myiVOG6sBQhjnPP4Ejw6vpdEz9+emWU8Wp9HqXmyshuibt8g3/uV7TH7sOxTCFvrf9ZtzGyYrPl3v3BLkWuRjjKPA2gU27073+aNOxeOcm3P6UIGJhlFXASQogIqiUhS99RoPrtvMC8eTNenH1wzQV6lSrlRZPVMFOLJgzQNnjdBfnYLMDWsatSbFZjO5//y+KqLnmCJvDz3F9NU7qPevY90X3nT08rMTx64n75w7lk99O+fmdfpQgbFpo1yrYxJWLNAUNIDpUg/Dk+P0V2sY8PS6IYaeHQfBmqkZYK7IP7ZhPQgKpbkr55t1o9BswkAfNllDMixz4Z1NVZl59ceZbvYztPNKCutblp/NrELnnFuYF3nn3LyGhwr8bKzBKdUqmEFvgcPFIr3NJmPlVYwcPkR/vcZMuQ8Qq6ZnMOAH544c1Y9JNCUKxbki36g1KVojOZOfrFEwwzJLxNau38Hkz6D/A5fRc+HGY4Ob9DN555ZCZnb8vZ5HJO0CTs07juMplUqn1uv1g8ff0y03z32+PP/58dznpwO5P2hmxywW13VF/vkihBBjjOH4e7rl5rnPl+c/P577/OSVe5+ud84557qUF3nnnHOuS3mRz88n8w5gBfPc58vznx/PfX5yyb1/J++cc851KT+Td84557qUF3nnnHOuS50M965fcUIIo8BM+gC4Icb4lfwi6l4hhA8ArwdGgPNijHvS9nOATwHrgTHg6hjjjxfqx/38Fsn9KD7+2yqEsB74DHA2UAEeAt4WYzzgY7+9jpP7UTo89r3I5+cNs3/0XFt9GbgNuLel/ePA38cYPxtCuAr4BPBbnQ6uyy2Ue/Dx324G/G2McTdACOH9wPuAN+Njv90Wyz10eOz7dL3rajHG+2KM+7NtIYTTgPOBu9Kmu4DzQwgbWt/vnrv5cu86I8b49GyRSX0LONPHfvstlPucwvEz+Rx9LoQg4D7gL2OMz+Qd0AqyCXgsxtgAiDE2QgiPp+0Hco1s5fDx3yEhhALwdmAnPvY7qiX3szo69v1MPh+XxhhfBlxIslDXR3KOx7lO8vHfWX8HTOB5zkNr7js+9r3I52B2CjPGWAE+ClySb0Qrzn7ghSGEIkD684y03bWZj//OSS9+fDHw+zHGJj72O2ae3Ocy9r3Id1gIoT+EMJQ+F/Am4IF8o1pZYoxPkeR8a9q0FfhujNGnK9vMx3/nhBDeC1wAXJEWFR/7HTJf7vMa+37Huw4LIWwB/hkopo8fAn8aY3wi18C6VAjhw8DrgNOBg8BYjPGlIYSXkPwb0VrgEMm/Ee3NL9LuM1/ugd/Dx3/bhRBeCuwB/g+YTpsfiTG+1sd+ey2Ue+DPyGHse5F3zjnnupRP1zvnnHNdyou8c84516W8yDvnnHNdyou8c84516W8yDvnnHNdyou8c88zkuqSXrnEfV8pqd7mkJ6XJF0r6aG843CunbzIO7fMJO2WZJLe2NJ+cdo+mlNoy07SSHpMG5e5Xy/Azi0DL/LOtcePgLe0tL0lbXfOuY7wIu9ce3wReLmkLQCSBoHXA3dkd5K0WtJtkvZLOijpy5I2Z7YPSvqUpKcl7ZN0TesvknSFpO9IekbSjyRd+fMEKuntkvZKelbStyRdmtn2bklfa9l/t6Sb0pffS3/ulTQh6eZ0H5O0TdIDksYlfUPSixbog8x7fk3SK0jWPN+S9jkx39cTkv5J0q0tbddJeliJjZJ2STqQHtu9ki5YJA8LxpR5fUK5dq7TvMg71x4zwOeAN6evtwL/DrTewvJW4FfSx5kkt3+9W1Ix3f4hkkUufhH4JeBykltiAiDpt4HtwDZgHXAN8BFJv76UICVtBW4BrgbWA7cDuyQtdf3rl6U/zzWzATO7JbPtrcAbgNOA/wV2Zo5rQWb2X8D1wE/SPgfMbPc8u/4jcJWknkzbtcCdltzKs0CyCMiZJLfW/R/giy37L9mJ5tq5PHiRd659bgeuk1QiKXi3ZzdKKpAU15vM7DEzmyQpIL8AXJRuvxK42cyeNLNngRtafsc7gNvM7F4za5rZ/cBn036X4jrgE2b2bTOrm9l24PvAHzynIz7aB83sITObBv4cOBu4eBn6nfUVoAq8GkDS2SSret0JYGaPmtlOM5tKY7gJ2Ezyoem5ONFcO9dxXuSdaxMz2wPsA24GhoFdLbtsAMrATzLvmQCeAjal2/uA0cx7Hmnp4yzghnT6+BlJz5CczZ6xxDA3ZX9/6uG0/USNzj4xsyngALBsF+iZWQP4DMkHFUiO++tmth9A0qmSPi3pUUmHmVtOdcNz/JUnmmvnOs6LvHPt9UmSIr89LUpZB4AKSfEAQNIAyfT2/nR7FRjJvOcsjrYPeLeZnZJ5DJrZq5YY3/55+tzCXEGcAPpbtmeLWnORvkdmn0haTVJcfzpfv5JaC+Vi/WbdAfyupBeQnFFnr3n4a+AFwMVmtoa5Dy5aoK/jxXSiuXau47zIO9dedwG/A9zWusHMmsCngVsknZEWwg8CDwL3p9t3AO+RNCxpDUnhyvoQsE3SpZKKknolXSApLDG+O4G3SbpIUknStcAvp3EDROD8tM+SpD/m6A8FB0gK8nxT4O+UdLakMvA+khmDb2f6vVzShvSixPe2vPdJ4LT0mBdkZnvTvrYDg8CXMpvXAFPAofTD098s1tcSYjrRXDvXcV7knWsjM5sxs6+Z2aEFdnknSXH5b+BRkjPP12TO+t9BMkX/IPAD4G7gyIyAmX2V5Pv+95NctPcEycV8A0uMbwfwHpLvlseAPwReZWaj6fbdJB88dqV9DwP/mXn/NMlMxV3pFPaNme7/geS/DA6QXKB3eea4bk2P6WHgAeBfW0L7N+Ae4JG0399Y5DDuAC4DdphZJdP+LpJZkTGS6wy+SSZ381g0phPNtXN58PXknXPLTpIBl5rZfXnH4txK5mfyzjnnXJfyIu+cc851KZ+ud84557qUn8k755xzXcqLvHPOOdelvMg755xzXcqLvHPOOdelvMg755xzXer/ATBUst7zr2GQAAAAAElFTkSuQmCC
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[205]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">summary_plot</span><span class="p">(</span><span class="n">sh_interactions</span><span class="p">,</span> <span class="n">X_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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R4eqsXfobMyqa3C+/lbMQ5+Hi06KOqIxoz5VskuN7zyF26fuAODgalo5rEolJtXywjdPAGDpodMjjkZGY+vZs9h69iwOP//4qEORUah9xWE8e90rATg8rQWCYy+d4n+/eR4A55+trlsi+9yi6fDRc6OOYsypTBcREREREamgQklERERERKSCCiUREREREZEKKpREREREREQqqFASERERERGpoEJJRERERESkggolERERERGRCiqUREREREREKqhQEhERERERqaBCSUREREREpIIKJRERERERkQoqlERERERERCqoUBIREREREamgQklERERERKSCCiUREREREZEKKpREREREREQqqFASERERERGpoEJJRERERESkggolERERERGRCiqUREREREREKqhQEhERERERqaBCSUREREREpIIKJRERERERkQoqlERERERERCqoUBIREREREamgQklERERERKSCCiUREREREZEKKpREREREREQqqFASERERERGpoEJJRERERESkggolERERERGRCsZaG3UMVckY80dgyu4+LplMTikWi9v2QUh7JE7x7EUs26y1Z4+00Z7kLE7vD1RNPPssX3sR0z4Rp1hAn7HRiFM8cczXXsY15uIUC+g7cTTiFE8cP2Nxen+gauIZOl/WWv3E6OeYY47xoo4hrvHEKZa4xqR4xldMcYoljvHEMaY4xROnWOIaV5xiiWM8cYwpTvHEKZa4xlTt8ajrnYiIiIiISAUVSiIiIiIiIhVUKMXPd6IOoEKc4olTLL3iFpPiGVmcYopTLBC/eCB+McUpnjjFUi5OccUpFohfPBC/mOIUT5xi6RW3mKo6Hk3mICIiIiIiUkEtSiIiIiIiIhWSUQdwoHNd9zrgTKAHaAc+7Hmet4vtTgd+D6wKb+rxPO/4MYphCfBDYDLQDLzN87xnK7ZJAP8JnA1Y4Mue5313LJ6/7DkmAz8GFhK8H88Bl3met7ViuyuB9wEbwpvu9zzv/WMZyzAxKl8Dn0c5G10MsciZ8jXqGGKRr/B5Yp0z5WtQLLHOV/jcyln/cyhfo4shFvkKn2e/5kyFUvT+AHzE87yC67rnAb8gSP6urPA8z90HMdwAXOd53k9c170Y+C/gjIpt3gosAhYTfFCWu657l+d5q8cwDgt81fO8ewBc1/0P4MvAu3ax7Y88z/v4GD73aClf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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Main-Effects">Main Effects<a class="anchor-link" href="#Main-Effects">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[206]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">dependence_plot</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;LSTAT&#39;</span><span class="p">,</span> <span class="s1">&#39;LSTAT&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">sh_interactions</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">X_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[207]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">dependence_plot</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;RM&#39;</span><span class="p">,</span> <span class="s1">&#39;RM&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">sh_interactions</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">X_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Interaction-Effects">Interaction Effects<a class="anchor-link" href="#Interaction-Effects">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[208]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">shap</span><span class="o">.</span><span class="n">dependence_plot</span><span class="p">(</span> <span class="p">(</span><span class="s1">&#39;LSTAT&#39;</span><span class="p">,</span> <span class="s1">&#39;NOX&#39;</span><span class="p">)</span> <span class="p">,</span> <span class="n">sh_interactions</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">X_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"
>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Counterfactuals">Counterfactuals<a class="anchor-link" href="#Counterfactuals">&#182;</a></h1><ul>
<li>Find the "smallest" change that flips the decision<ul>
<li>Alibi Module</li>
<li>Expanding circle</li>
</ul>
</li>
<li>Adverserial<ul>
<li>A counterfactual with intent to deceive</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Counterfactual-Example">Counterfactual Example<a class="anchor-link" href="#Counterfactual-Example">&#182;</a></h2><ul>
<li><a href="https://christophm.github.io/interpretable-ml-book/counterfactual.html">https://christophm.github.io/interpretable-ml-book/counterfactual.html</a>
<img src="data:image/png;base64, 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J44cxQAAABxpRE9UAAAAAgAAAAAAAAEPAAAAKAAAAQ8AAAEPAABz9NVozooAAEAASURBVHgB7N0HuBTV/f/xo6IiqNgRCyKWoIiIGBPEhgVQo2CJsWEvxIYFC/beUFAx9t4L2HvHgtGf2AWUpqCCBVGsRKP/fM4/Z3J27szuzO7ce3d33ud5YKfvzmt37pw531Pm+f0/yZAQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgQiBeQgkRKiwCAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBKwAgQR+CAgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIBArQCAhloYVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgggQCCB3wACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjEChBIiKVhBQIIIIAAAggggAACCCCAAAIIIIAAAggggAACCBBI4DeAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACsQIEEmJpWIEAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIEEvgNIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAQKwAgYRYGlYggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAgQR+AwgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIBArQCAhloYVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgggQCCB3wACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjEChBIiKVhBQIIIIAAAggggAACCCCAAAIIIIAAAggggAACCBBI4DeAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACsQIEEmJpWIEAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIEEvgNIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAQKwAgYRYGlYggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAgQR+AwgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIBArQCAhloYVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgggQCCB3wACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjEChBIiKVhBQIIIIAAAggggAACCCCAAAIIIIAAAggggAACCBBI4DeAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACsQIEEmJpWIEAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIEEvgNIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAQKwAgYRYGlYggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAgQR+AwgggAACCCCAAAIIIIAAAggggAACCCCAAAIIIBArQCAhloYVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgggQCCB3wACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjEChBIiKVhBQIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCQOJIwdOxYtBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQqHOB7t27F5whgYQCDmYQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEMi3AIGEfH//nD0CCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAkUFCCQU5WElAggggAACCCCAAAIIIIAAAggggAACCCCAAAL5Fig7kJBvNs4eAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAIF8CiQeIyGfPJw1AggggAACCCCAAAIIIIAAAggggAACCCCAAAL5FiCQkO/vn7NHAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQKCoAIGEojysRAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAg3wIEEvL9/XP2CCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggUFSCQUJSHlQgggAACCCCAAAIIIIAAAggggAACCCCAAAII5FuAQEK+v3/OHgEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBogIEEorysBIBBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgXwLEEjI9/fP2SOAAAIIIIAAAggggAACCCCAAAIIIIAAAgggUFSAQEJRHlYigAACCCCAAAIIIIAAAggggAACCCCAAAIIIJBvAQIJ+f7+OXsEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBIoKEEgoysNKBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQTyLUAgId/fP2ePAAIIIIAAAggggAACCCCAAAIIIIAAAggggEBRAQIJRXlYiQACCCCAAAIIIIAAAggggAACCCCAAAIIIIBAvgUIJOT7++fsEUAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBAoKkAgoSgPKxFAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQyLcAgYR8f/+cPQIIIIAAAggggAACCCCAAAIIIIAAAggggAACRQUIJBTlYSUCCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAvkWIJCQ7++fs0cAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAoKgAgYSiPKxEAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQCDfAgQS8v39c/YIIIAAAggggAACCCCAAAIIIIAAAggggAACCBQVIJBQlIeVCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjkW4BAQr6/f84eAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAIGiAgQSivKwEgEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBfAsQSMj398/ZI4AAAggggAACCCCAAAIIIIAAAggggAACCCBQVIBAQlEeViKAAAIIIIAAAggggAACCCCAAAIIIIAAAgggkG8BAgn5/v45ewQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEigoQSCjKw0oEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBPItQCChgu//999/N19++aX55JNPzOeff27atGljll12WfuvVatWFRyZXRHIp8DXX39tpk+fbmbNmmV+/fVX06FDB9O+fXvTsmXLfIJw1gj8V4D7DT8FBBBAAAHySfwGEMivgJ6NZsyYYcsevvnmG7P00kvbcodlllnGLLDAAvmF4cwRQAABBJpUgEBCGdy6cd91113235w5cyKP0KVLF7PbbruZzTbbzMw333yR27AQAQSM+e2338zIkSPNo48+at5//32jAlM/zTPPPGbFFVc0AwYMMNttt13J6+mNN94wZ511ln+I2OkllljCdOzY0ay66qqmU6dOZu21147d1l+hjPw+++xjfvjhB3+x2Xnnnc0uu+xSsIyZfAgcd9xxZuLEiQUne84559jfVcHClDONfb/RZ9ZnD6fTTz/d6D4WTtdcc4157LHHwovLmr/iiitM27Zty9qXnWpDIOq6KPbJW7RoYQPIq622munZs6dZc801i23OOgRyIUA+qfG/5qOOOsp89NFHwRt169bNnHzyycE8EwgkEYi652WRF5wyZYq55ZZbbP5L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EEAAAQQQQAABBBBAAAEEigrURCDhhx9+MPfee6957733zIwZM0yLFi3McsstZ3r06GH69u1r5ptvvqInWe7KadOmmddff93u3q5dO/t+ccf68ccfzeOPPx63uuTyzTbbzCy22GIlt2MDBLIW+Pzzz83LL79sJkyYYCZOnGgWWGABs9JKK5nOnTubrbbays5n/Z46XprrqzHen2PWp0BWv+eZM2eaV155xUyaNMleFz/99JNZeumlTadOncy2225rdE/IMn322Wdm5MiRZurUqUbn0KZNG7P88svba7B79+5ZvhXHyqFAc+WjckjNKdeQQFb3i7SnTP4nrRjbI2Bs3qixnlfGjRtnn4Oc81/+8pfMnn/I3zlVXhEoX4B8bPl27IlAYwhUfSBh7NixZvDgwea7776LPH8VtFx99dWmbdu2kesrWXjkkUeaF1980R5io402MsOHD489nDIJ2223Xez6UituvfVWW0BVajvWI5ClwCOPPGIuuOACo5tzVFLB6QEHHGB22GGHqNUVLUtzfVX0RuycG4Esfs+///67LdAfMWKEUYA4Ks0777zmpJNOquhvvn/cW265xVx22WXm3//+t784mO7Zs6e56KKLbBA9WMgEAgkFmjMflfAjshkCTS6Qxf2i3A9N/qdcOfbLq0BjXq9ffvml2WWXXcy3334b8D777LNm0UUXDebLnSB/V64c+yHwPwHysf+zYAqBahGo6kDC9OnTzV577WXmzJlT1Gv11Vc31157rWnVqlXR7dKsfPTRR82pp55qVKikRCAhjR7b1oLAsGHDzO23357oow4ZMsTsuOOOibZNslHa6yvJMdkm3wJZ/Z6PPvpoM3r06JKYCiacccYZtlVcyY2LbKCH1eOOOy6418Rt2q9fP3PyySfHrWY5ApECzZmPivxALESgCgSyul+Ucyrkf8pRY588CzTm9arn/EMOOcS89tprBcRZBBLI3xWQMoNAWQLkY8tiYycEGl2gagMJaoGw9957m48//tgiqPuiTTbZxPTp08fWGFA3Qm+88UYAtPHGG5sLL7zQqHCn3KTMxLvvvmtGjRplVPPBT6UCCV988YWtue3vU2xatR6+//57u8k888xj37N9+/bFdmEdApkJvPPOO2a//fYLCi8XXnhhM2DAANOlSxfz888/mxdeeME8+OCD5rfffrPvqevvuuuuM2ut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VCkBhEyEmXkRLARaFEgQLYOZ+eSeSpqjzF3wL+6vFv3UqU2BzCOSIFs+Cabnnsg8B0Py6o4RyVs7CWIkpVEC5fmeOzg4kP5rDKZjFgR+sh+1cHIrCGypgP7PljaMyyKwRMD9ugTFKgI7IqAfuyMNrZpbKTDZQMJWarooAgQIECBAgAABAgQIECBAgAABAgQIECDQmIBAQmMNqjoECBAgQIAAAQIECBAgQIAAAQIECBAgQKBSQCChUlNZBAgQIECAAAECBAgQIECAAAECBAgQIECgMQGBhMYaVHUIECBAgAABAgQIECBAgAABAgQIECBAgEClgEBCpaayCBAgQIAAAQIECBAgQIAAAQIECBAgQIBAYwICCY01qOoQIECAAAECBAgQIECAAAECBAgQIECAAIFKAYGESk1lESBAgAABAgQIECBAgAABAgQIECBAgACBxgQEEhprUNUhQIAAAQIECBAgQIAAAQIECBAgQIAAAQKVAgIJlZrKIkCAAAECBAgQIECAAAECBAgQIECAAAECjQkIJDTWoKpDgAABAgQIECBAgAABAgQIECBAgAABAgQqBQQSKjWVRYAAAQIECBAgQIAAAQIECBAgQIAAAQIEGhMQSGisQVWHAAECBAgQIECAAAECBAgQIECAAAECBAhUCggkVGoqiwABAgQIECBAgAABAgQIECBAgAABAgQINCYgkNBYg6oOAQIECBAgQIAAAQIECBAgQIAAAQIECBCoFBBIqNRUFgECBAgQIECAAAECBAgQIECAAAECBAgQaExAIKGxBlUdAgQIECBAgAABAgQIECBAgAABAgQIECBQKSCQUKmpLAIECBAgQIAAAQIECBAgQIAAAQIECBAg0JiAQEJjDao6BAgQIECAAAECBAgQIECAAAECBAgQIECgUkAgoVJTWQQIECBAgAABAgQIECBAgAABAgQIECBAoDEBgYTGGlR1CBAgQIAAAQIECBAgQIAAAQIECBAgQIBApYBAQqWmsggQIECAAAECBAgQIECAAAECBAgQIECAQGMCAgmNNajqECBAgAABAgQIECBAgAABAgQIECBAgACBSgGBhEpNZREgQIAAAQIECBAgQIAAAQIECBAgQIAAgcYEBBIaa1DVIUCAAAECBAgQIECAAAECBAgQIECAAAEClQL9QMIfAAAA///tIicvAABAAElEQVTs3Qn8VdP+//Fl5iqZmhQlQ5MQl0iouAolhMxThhQyD2XKNUaKkikkikvmTIUbbnGpDNFERdJgKGUqdP2918/a/332d59z9jnfffievV/r8ahzzp6+Zz/PtPb6rPVZq/32ezERysqVKyNsxSYIIIAAAggggAACCCCAAAIIIIAAAggggAACCCBQzgLrrLNOxtNfLWogYc6cORk78gABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQSSJ9CoUaOMkyKQkMHBAwQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEE0i1QdCAh3WycPQIIIIAAAggggAACCCCAAAIIIIAAAggggAAC6RSIPCIhnTycNQIIIIAAAggggAACCCCAAAIIIIAAAggggAAC6RYgkJDu15+zRwABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAgpwCBhJw8rEQAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAIN0CBBLS/fpz9ggggAACCCCAAAIIIIAAAggggAACCCCAAAII5BQgkJCTh5UIIIAAAggggAACCCCAAAIIIIAAAggggAACCKRbgEBCul9/zh4BBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgZwCBBJy8rASAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAIF0CxBISPfrz9kjgAACCCCAAAIIIIAAAggggAACCCCAAAIIIJBTgEBCTh5WIoAAAggggAACCCCAAAIIIIAAAggggAACCCCQbgECCel+/Tl7BBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQRyChBIyMnDSgQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEE0i1AICHdrz9njwACCCCAAAIIIIAAAggggAACCCCAAAIIIIBATgECCTl5WIkAAggggAACCCCAAAIIIIAAAggggAACCCCAQLoFCCSk+/Xn7BFAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQyClAICEnDysRQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEi3AIGEdL/+nD0CCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAjkFCCTk5GElAggggAACCCCAAAIIIIAAAggggAACCCCAAALpFiCQkO7Xn7NHAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQCCnAIGEnDysRAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAg3QIEEtL9+nP2CCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgjkFCCQkJOHlQgggAACCCCAAAIIIIAAAggggAACCCCAAAIIpFuAQEK6X3/OHgEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBnAIEEnLysBIBBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAgXQLEEhI9+vP2SOAAAIIIIAAAggggAACCCCAAAIIIIAAAgggkFOAQEJOHlYigAACCCCAAAIIIIAAAggggAACCCCAAAIIIJBuAQIJ6X79OXsEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBHIKEEjIycNKBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQTSLUAgId2vP2ePAAIIIIAAAggggAACCCCAAAIIIIAAAggggEBOgcQGEhYsWGBGjx5t5s6daxYvXmxq1Khh6tWrZ/bff3+z884750TJt3Ly5Mnms88+y7dZ6Pq6deua3Xff3a6bN2+emTRpUuh2+Rauueaa5qCDDsq3GesRyCugz8eECRPMjBkzzMcff2zWXntt06BBA9O8eXP7edHjOIv+1kcffWRmzpxpP5ubbbaZ/XsdOnQwW2+9dZx/imOlUOB///ufefvtt8306dPtv0WLFplGjRqZJk2amGbNmpntt98+ksqXX35pxowZYz7//HMzf/58s3LlSqP3av369c2ee+5pdthhh0jHibpRKX+zoj4HtkuHwEsvvWR++OEHe7Lt27c3G264YTpOnLNEICBA/ScAwkMEqrBAXJ/XFStWmH//+9/2OmTWrFnmxx9/NFtssYXZaqutTOfOnc3GG28ci4Lqj++8807kY7Vp08bUqlUr8vZsiECaBFRvfeKJJ8yHH35oFi5caNQWpusytat17NjRrLHGGmni4FwR+MsFEhlIePDBB82QIUPMqlWrQoH32GMPM2DAAPsFFLpBnoVXXnmlee655/JsFb56r732Mrfccotd+cwzz5irr746fMM8S//2t7+Z119/Pc9WrEYgt4Dex/379/calYJb16xZ05x66qnm0EMPDa4q+PE333xj+vXrZyZOnBi672qrrWbatWtnzjvvPFOnTp3QbViIQC6Br776yvTt29dMmTIl62YKJvfp08est956odv88ssv5p577jEjR460wYPQjX5fqPfq+eefH8t7tdS/WdnOgeXpE1CA7bjjjvNOXO+9pk2beo+5g0BaBKj/pOWV5jyTIBDX51UdmS6//HKjznxhZd111zVdu3Y1vXr1sh2rwraJumzYsGHmzjvvjLq5uf32202rVq0ib8+GCKRFQJ14L7jgAvPdd9+FnrI6C999992mdu3aoetZiAAC8QskLpDw6quvmosvvtj89ttvObW6dOliKxI5N8qykkBCFhgWl5WAAlqjRo2K9JwvvfRSW7GOtHHIRl988YU54YQTzLfffhuyNnNRw4YNzX333Wc22GCDzBU8QiCHwNSpU20QaunSpTm2+r9VGqGgC7yw99htt91mRowYkfcY2qBx48bmgQceKDoorWP8Gb9Z+jsUBPTZUPDrgw8+8DAIJHgU3EmRAPWfFL3YnGrZC8T1eVV9S9cz2Toa+qH2228/c+211xp1ciq2qOFz/PjxkXcnkBCZig1TJKCRPWpDWL58ec6z3nbbbe21nTrbUhBAoPQCiQokqKedek9ryKKKGolUEdAoAK1TbwZ/D4RzzjnHHHvssQUr33rrrbbxJ8qOCmgoZYUrGnp1zTXX2IevvPKKUaNV1KJUG+otq6Ke4i+88ELUXdkOgQwBNSR1797dC7hVq1bN9lJt0aKF/fxotItGzChNjIqGC957771mu+22yzhO1Adnn312xkiE1q1bG6Uy0pDEOXPm2IZbBRtcUeqYgQMHuofcIpBTQO/To48+2nzyySfedgcccIDR6DOlbdH3v4bD+r+LjznmGHPuued62+uOPhennHKK977Xb8jpp59uNNxcIxg0nHbo0KEZf0e/OdqmmPJn/WYV89zYJzkCCuCqMUO9tVSP8BcCCX4N7qdBgPpPGl5lzjEpAnF9Xr///ns7unrJkiWWRgGCww47zOy22262fvf+++8b/R4qzZErxbYTuP07depklF5TZaONNjL5GjiVpSDutJnuuXCLQDkKaATCiSee6KUUV3vE3nvvbdsQli1bZl588cWMUehq87v55pvN6quvXo6ny3NGoKwEEhVIOPnkk72edqog6KK5ZcuW3guiSsQRRxzhXUjry0i5gkuZH/iuu+6yaTL0JFSJULqMYvIfKuf3mWeeaRu49OU4aNAgo8ZYCgLFCBx11FF2PgTtqyCCggTKDeovani97rrrvEX6fPXs2dN7HPWO8pBe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Jk6cWEFKva41KXP79u0rrHMLCgkkKKWF8rW5op4LCiYUWoI9YfX8FIGlIFBKAeUN1UgDN0mt/29pNIxG4yiIoDRgYSVqIEH7queNKvDPPvtsRo9ud9w6deqY008/3fYkYCSOU+E2n4DSDGmUQDElLJCg46hnmt7bblLy4LE1ZPass87KSAfm3ybqhabbp7K/We443CKQT4BAQj4h1qdFgPpPWl5pzjMJApX9vDoDddxTRyrNhxjWYUSjBlS/C86f6PYvpH6nBlBd82g+xmBHKo0EV2pNzZGgdgc9piCAQLiAshvouiysDaFGjRp23joFEvgchfuxFIFSCCQykOCgVFlQA41GJ+hLRo2hTZo0IV2QA+IWgT8ElGdeE8iqAXXdddc1Crhpfg7dj7uoYq10Rvpsfv3116Z+/fr272mIMQWBqiSg4JcmE1egTWnn9Jlo0KCBcbk5436u/GbFLcrxEEAAgdwC1H9y+7AWgaokENfnVSkqVbfTtYjqd7ru0b8NNtgg9tPVdY/mXVB9csGCBUbzcyllZin+VuxPngMiUIUEli5dalOQ6XOkjAlKFda0aVObfrYKPU2eCgKpEEh0ICEVryAniQACCCCAAAIIIIAAAggggAACCCCAAAIIIIBACQUIJJQQl0MjgAACCCCAAAIIIIAAAggggAACCCCAAAIIIFDuAgQSyv0V5PkjgAACCCCAAAIIIIAAAggggAACCCCAAAIIIFBCAQIJJcTl0AgggAACCCCAAAIIIIAAAggggAACCCCAAAIIlLsAgYRyfwV5/ggggAACCCCAAAIIIIAAAggggAACCCCAAAIIlFCAQEIJcTk0AggggAACCCCAAAIIIIAAAggggAACCCCAAALlLkAgodxfQZ4/AggggAACCCCAAAIIIIAAAggggAACCCCAAAIlFCCQUEJcDo0AAggggAACCCCAAAIIIIAAAggggAACCCCAQLkLEEgo91eQ548AAggggAACCCCAAAIIIIAAAggggAACCCCAQAkFCCSUEJdDI4AAAggggAACCCCAAAIIIIAAAggggAACCCBQ7gIEEsr9FeT5I4AAAggggAACCCCAAAIIIIAAAggggAACCCBQQgECCSXE5dAIIIAAAggggAACCCCAAAIIIIAAAggggAACCJS7AIGEcn8Fef4IIIAAAggggAACCCCAAAIIIIAAAggg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BBBAAAEEEEAAAQQQQAABBBCohACBhErgsSsCCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAkkXIJCQ9FeY80MAAQQQ+H/t3aENwEAMBMFevv+avpbgkFMUM9/AyHrgMVwQAgQIECBAgAABAgQIECBAgAABAgMBIWGA5ykBAgQIECBAgAABAgQIECBAgAABAgQIENguICRsv7D9CBAgQIAAAQIECBAgQIAAAQIECBAgQIDAQEBIGOB5SoAAAQIECBAgQIAAAQIECBAgQIAAAQIEtgsICdsvbD8CBAgQIECAAAECBAgQIECAAAECBAgQIDAQEBIGeJ4SIECAAAECBAgQIECAAAECBAgQIECAAIHtAkLC9gvbjwABAgQIECBAgAABAgQIECBAgAABAgQIDASEhAGepwQIECBAgAABAgQIECBAgAABAgQIECBAYLuAkLD9wvYjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIDASFhgOcpAQIECBAgQIAAAQIECBAgQIAAAQIECBDYLiAkbL+w/QgQIECAAAECBAgQIECAAAECBAgQIECAwEBASBjgeUqAAAECBAgQIECAAAECBAgQIECAAAECBLYLfA4J997tFvYjQIAAAQIECBAgQIAAAQIECBAgQIAAAQL1Auecl4GQ8OLwQYAAAQIECBAgQIAAAQIECBAgQIAAAQIEugWEhO77254AAQIECBAgQIAAAQIECBAgQIAAAQIECEQBISHyGBIgQIAAAQIECBAgQIAAAQIECBAgQIAAgW6B3yGhm832BAgQIECAAAECBAgQIECAAAECBAgQIECgU+DzPxI6eWxNgAABAgQIECBAgAABAgQIECBAgAABAgS6BYSE7vvbngABAgQIECBAgAABAgQIECBAgAABAgQIRAEhIfIYEiBAgAABAgQIECBAgAABAgQIECBAgACBbgEhofv+tidAgAABAgQIECBAgAABAgQIECBAgAABAlFASIg8hgQIECBAgAABAgQIECBAgAABAgQIECBAoFtASOi+v+0JECBAgAABAgQIECBAgAABAgQIECBAgEAUEBIijyEBAgQIECBAgAABAgQIECBAgAABAgQIEOgWEBK67297AgQIECBAgAABAgQIECBAgAABAgQIECAQBYSEyGNIgAABAgQIECBAgAABAgQIECBAgAABAgS6BYSE7vvbngABAgQIECBAgAABAgQIECBAgAABAgQIRAEhIfIYEiBAgAABAgQIECBAgAABAgQIECBAgACBbgEhofv+tidAgAABAgQIECBAgAABAgQIECBAgAABAlFASIg8hgQIECBAgAABAgQIECBAgAABAgQIECBAoFtASOi+v+0JECBAgAABAgQIECBAgAABAgQIECBAgEAUEBIijyEBAgQIECBAgAABAgQIECBAgAABAgQIEOgWEBK67297AgQIECBAgAABAgQIECBAgAABAgQIECAQBYSEyGNIgAABAgQIECBAgAABAgQIECBAgAABAgS6BYSE7vvbngABAgQIECBAgAABAgQIECBAgAABAgQIRAEhIfIYEiBAgAABAgQIECBAgAABAgQIECBAgACBbgEhofv+tidAgAABAgQIECBAgAABAgQIECBAgAABAlFASIg8hgQIECBAgAABAgQIECBAgAABAgQIECBAoFtASOi+v+0JECBAgAABAgQIECBAgAABAgQIECBAgEAUEBIijyEBAgQIECBAgAABAgQIECBAgAABAgQIEOgWEBK67297AgQIECBAgAABAgQIECBAgAABAgQIECAQBYSEyGNIgAABAgQIECBAgAABAgQIECBAgAABAgS6BR4ecgBzV8nY1QAAAABJRU5ErkJggg==" alt="Screen%20Shot%202019-11-13%20at%203.35.08%20PM.png"></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Adverserial-Example">Adverserial Example<a class="anchor-link" href="#Adverserial-Example">&#182;</a></h2><ul>
<li><a href="https://christophm.github.io/interpretable-ml-book/adversarial.html#methods-and-examples">https://christophm.github.io/interpretable-ml-book/adversarial.html#methods-and-examples</a>
<img src="data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABR8AAAN5CAYAAACBvEyhAAAgAElEQVR4AezdC7hmVX0Y/P9+z5lhgIEZLiMDUiRKffACaESrBs1oQkGS4JhKg4m2PNXWS0wiJsEY/b6QzxjFqNhq1HxNv9jWFC0akWqC9RIaUVPxBnirRYNUYeQmMDMwzOXd3/M/nI2bzT7nvOfMuez9nt9+nvO8+7L22v/1W3ti/LvWXhE2AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6KvCEiNja09iFTYAAAQIECBAgQIAAAQIECBAgQIBAhwU+EhFf7XB8QiNAgAABAgQIECBAgAABAgQIECBAoIcCOeqxnP4z+rGHHShkAgQIECBAgAABAgQIECBAgAABAl0VyFGPVfLR6Meu9pK4CBAgQIAAAQIECBAgQIAAAQIECPRMoD7qsUpAGv3Ys04ULgECBAgQIECAAAECBAgQIECAAIEuCtRHPVbJR6Mfu9hTYiJAgAABAgQIECBAgAABAgQIECDQI4G2UY9VAtLoxx51pFAJECBAgAABAgQIECBAgAABAgQIdE2gbdRjlXw0+rFrvSUeAgQIECBAgAABAgQIECBAgAABAj0RmG3UY5WANPqxJ50pTAIECBAgQIAAAQIECBAgQIAAAQJdEpht1GOVfDT6sUs9JhYCBAgQIECAAAECBAgQIECAAAECPRAYZdRjlYA0+rEHHSpEAgQIECBAgAABAgQIECBAgAABAl0RGGXUY5V8NPqxK70mDgIECBAgQIAAAQIECBAgQIAAAQIdF5jPqMcqAWn0Y8c7VXgECBAgQIAAAQIECBAgQIAAAQIEuiAwn1GPVfLR6Mcu9JwYCBAgQIAAAQIECBAgQIAAAQIECHRYYCGjHqsEpNGPHe5YoREgQIAAAQIECBAgQIAAAQIECBBYaYGFjHqsko9GP65073k+AQIECBAgQIAAAQIECBAgQIAAgY4K7M+oxyoBafRjRztXWAQIECBAgAABAgQIECBAgAABAgRWUmB/Rj1WyUejH1eyBz2bAAECBAgQIECAAAECBAgQIEBgvwWK/a5BBfMRyMRi26Yf2lScI0CAAAECBAgQIECAAAECBAgQ6LXAoNfRC54AAQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsERoAAAQIECBAgQIAAAQIECBAgQKDfApKP/e4/0RMgQIAAAQIECBAgQIAAAQIECBDorIDkY2e7RmAECBAgQIAAAQIECBAgQIAAAQIE+i0g+djv/hM9AQIECBAgQIAAAQIECBAgQIAAgc4KSD52tmsE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CBAgQIAAgf0XkHzcf0M1ECBAgAABAgQIECBAgAABAgQIECDQIiD52ILiFAECBAgQIECAAAECBAgQIECAAAEC+y+wFMnHCyIiv2241H9H7H/z1UCAAAECBAgQIECAAAECBAgQIECAwFIJLEXy8dlLFWyj3sc0jh0SIECAAAECBAgQIECAAAECBAgQINAhgaVIPnaoeUIhQIAAAQIECBAgQIAAAQIECBAgQGClBJYi+XjnSjXGcwkQIECAAAECBAgQIECAAAECBAgQ6I7A5BKE8q6I2LgE9dar/F5EXFU/YZ8AAQIECBAgQIAAAQIECBAgQIAAgW4JFN0KZ+yjyUV42jb90KbiHAECBAgQIECAAAECBAgQIECAQK8FlmLada9BBE+AAAECBAgQIECAAAECBAgQIECAwOIISD4ujqNaCBAgQIAAAQIECBAgQIAAAQIECBBoCEg+NkAcEiBAgAABAgQIECBAgAABAgQIECCwOAJLseBMRnZaRFweEYdNh/meiHjF9P65EXHeIoR/5iLUoQoCBAgQIECAAAECBAgQIECAAAECBHom8IGIyMVV6n+nTLfhisb5epn57GeCs2/bTO3rWzvES4AAAQIECBAgQIAAAQIECBAgQGBOgaWadr2x5cmHtJxzigABAgQIECBAgAABAgQIECBAgACBMRVYquTjnS1e21vOOUWAAAECBAgQIECAAAECBAgQIECAAIF5CZzVmFp9de3u/ObjTNOPRz1/fUQcUauzL7szta8v8YuTAAECBAgQIECAAAECBAgQIECAwMgCxcgl518wk4OPmb7tqvnfPpZ3ZPKxbVvKfmh7nnMECBAgQIAAAQIECBAgQIAAAQIEllxA0mvJiR/0AMnHB3E4IECAAAECBAgQIECAAAECBAgQGGeBpfrm4zibaRsBAgQIECBAgAABAgQIECBAgAABAiMITI5QZqmLPDIinhIRz4yI3K9v34uIayLikxGR+zYCBAgQIECAAAECBAgQIECAAAECBAjMKZDfhHz3PBafuaIlOTnnQzpWwIIzHesQ4RAgQIAAAQIECBAgQIAAAQIECIyfwCkRccc8Eo9V0i7vydWy+7pV7Wj+9rU94iZAgAABAgQIECBAgAABAgQIECDQOYGrF5B4rBJ2mYDM5GUft6oNzd8+tkXMBAgQIECAAAECBAgQIECAAAECBDonkCMXm8m3+R5/oHOtGi2gmdo52t1KESBAgAABAgQIECBAgAABAgQIECAwq0Dbdx6vj4iXRsRptTtzdGMmKvNbj21Ju1rR3uy2tSPP2QgQIECAAAECBAgQIECAAAECBAgQWASBZjIxp2Dn4jOzbW9sSUDWE5Wz3dula5KPXeoNsRAgQIAAAQIECBAgQIAAAQIECIydQDP5OOoCMjk6sp68k3wcu1dDgwgQIECAAAECBAgQIECAAAECBMZJYLACjfly45k/aBzPdJjJx/q2vX5gnwABAgQIECBAgAABAgQIECBAgACBbgmsRPLxcw2CxzWOZzp8Su3CjyPimtqxXQIECBAgQIAAAQIECBAgQIAAAQIECEwJ1Kde3zHCNx8vaEy5zuM+bvVp4/X9PrZFzAQIECBAgAABAgQIECBAgAABAgQ6KZArWWfSsUrAzbboTH4TsiqXv1m2r1u9HfX9vrZH3AQIECBAgAABAgQIECBAgAABAgRmFChmvLLwC2dFxG+OcPsJEfGoWrnvRkTzu455+YxamZxu/cKI+HZEfK92vi+7mXBs25aiH9qe4xwBAgQIECBAgAABAgQIECBAgACBXgvUp1TXR/ct9v4je6g0k0EPmyJkAgQIECBAgAABAgQIECBAgAABArMLrMSCM7NHNPrVY0YvqiQBAgQIECBAgAABAgQIECBAgAABAsst0Ofk43JbeR4BAgQIECBAgAABAgQIECBAgAABAvMQWIrk4/vm8fyFFs3vQ35roTe7jwABAgQIECBAgAABAgQIECBAgACBpRew0MnSG9efYMGZuoZ9AgQIECBAgAABAgQIECBAgACBsRZYipGPYw2mcQQIECBAgAABAgQIECBAgAABAgQIjCYg+Tiak1IECBAgQIAAAQIECBAgQIAAAQIECMxTQPJxnmCKEyBAgAABAgQIECBAgAABAgQIECAwmsDkaMWWrNQpEXFGRBwfEY+cx1PujIhfj4jb53GPogQIECBAgAABAgQIECBAgAABAgQIrBKBd0dELsCy0L/Teug0U1t72BQhEyBAgAABAgQIECBAgAABAgQIEOimwBv3I+lYJfAkH7vZt6IiQIAAAQIECBAgQIAAAQIECBAgsGICOb26SiDuz29O2e7bNlN7+9YO8RIgQIAAAQIECBAgQIAAAQIECBCYU2AlFpw5fc6oZi/wnoh4RkRcM3sxVwkQIECAAAECBAgQIECAAAECBAgQWEmBlUg+NkcsfiIijoyI/K1vmWAspq99t3bh5bV9uwQIECBAgAABAgQIECBAgAABAgQIdFRgJZKPzVWt3zfHqtW5ovV5Db/XN44dEiBAgAABAgQIECBAgAABAgQIECDQMYGVSD42CX7QPNFyfFVE1Ec/nhERR7SUc4oAAQIECBAgQIAAAQIECBAgQIAAgY4IdCH5OBPFsY0L1zeOH9M4dkiAAAECBAgQIECAAAECBAgQIECAQIcEupR8/EzD5ZmN4xMaxw4JECBAgAABAgQIECBAgAABAgQIEOiwwOQKxJZJxpw2XW1Pj4icVn1jdWL6NxeWyRWtvxERvxoRj2pcd0iAAAEC8xDYdM6F64/atXHLYKI8tYzyiGJQbC6H5ZFRxPHF/Qt/RRlxW5RxQzEobosy/8oflRFf27bmrk/deumFO+bxOEUJECBAgAABAgQIECBAgMDUatLLzXBuRFxSe+gHIyLP5UI09e861oo8ZPfHEXH4Q852/0Q5Q4i5qreNAAECiy7w2LMufsLEAeWZUcYZRTl4ajFRrlvIQ4YRe2NYXhWD+PTk3rjiq5e/+ksLqcc9BAgQIECAAAECBAgQILC6BFYi6dVMMtYTie+OiBzxONf2noh4xVyFOnhd8rGDnSIkAmMnsOW8dSdvPOVlxaD87YjiQd/PffS62+OJ67fFxoldcfiae+Nha+6JTZM747DJXVMMP967Lm7de3DcsueguGPPgXHnvnVx3c6j4pv3Hvkgpn1l3DYo40/vvjPeccOV59/5oIsOCBAgQIAAAQIECBAgQIDAtMBKJB/z0VdHxKm1XnjG9NTrTEzmaJrDateau5ms/McRcXvzQg+OJR970ElCJNBbgemkY5TFa4qJcnO2Y9OanfHTB98cT15/Uzzp4Jtjw+R9C2rejn1r44s7jomv7jw6vrzz6Ni2e/1UPWWUd8aw+LeSkAtidRMBAgQIECBAgAABAgTGXmClko9HRMSLp3XzW48fqEmfEhEXNb4LWV3+xPSIx+9VJ3r2K/nYsw4TLoF+CGyZPHnrc19ZTzo+9sDb4gWbvh4/c0jzc7qL06Jr7tkc7/vRyZG/uQ3L8q6iLN5x7WUf/aOIK/cuzlPUQoAAAQIECBAgQIAAAQJ9F1ip5OMobpmEfExEHDe9GM0XI6KvSceqvZKPlYRfAgQWReCE51x07MHr1l4SRZyWFZ5y0LY476hrp34X5QFzVJLJxw/ddmJ8bnv+n+qIsiy/tm/yvnO+celrr5/jVpcJECBAgAABAgQIECBAYBUIdDn5OI78ko/j2KvaRGCFBE7aevHWKMr3DYpiwzFrt8drHv65OOmgW1Ykmu/sOiIu+uHT4x92HRbFsNxZTgxeds2HX/X+FQnGQwkQIECAAAECBAgQIECgMwIrkXw8KyL+RURsjIgvR8TbR/h+Y07TfsP0iti5sMG7pr8R2RnIEQORfBwRSjECBGYT2DJ50tazLx4MildmqWdvuCF++5gvxIGDPbPdtOTX7h2uiXdvOzU+/uP8LG/EcDh837Y123/j1ksv3LHkD/cAAgQIECBAgAABAgQIEOikwEokH69ofM+xWmxmLqA7agvRfDciTpjrhg5el3zsYKcIiUC/BLZMnvzLz72kiHj+2mJfvGLz1XH24d/pVBM+c9fx8dYfPq3cVa4phsPyyusuu/x034HsVBcJhgABAgQIECBAgAABAssmMFi2J+3/g/Kbj9X2qOlRkNWxXwIECKwKgZO2/tK/z8Tj4ZO74l0/9TedSzxmJ+RIzPc+6uNFxjgYFFsyWRqxZXJVdJBGEiBAgAABAgQIECBAgMCDBPqUfGyOdDzmQS1xQIAAgTEXOOmX33bxYDA4L6dX/8E/ujJOODAHhHdzO+6Au+Ptx18xNRU8k6UnP2/rO7sZqagIECBAgAABAgQIECBAYCkFlmMkyiMjop4ozO831rfH1Q9a9o+NiK0RkaMdbQQIEFiVAic/922/U8TgVRNFGa8/9rMrtrDMfPAzAfnmR3w6fveG02N3TLzs5OddvOPaj5z/u/OpQ1kCBAgQIECAAAECBAgQ6LfAcnzz8QMR8StLwJTJyO8tQb1LWaVvPi6lrroJjKnAE89++6l7J4svDCImX/Pwz8cZG6/vVUv/x92PiDf84JkxLIsY7ovTr/vo+Z/qVQMES4AAAQIECBAgQIAAAQILFliOade5qvVib7ngTN8Sj4ttoD4CBFaFwJbJfZODd2bicevh3+5d4jG76GcP/X786pHXTfVWEcU7ff9xVby4GkmAAAECBAgQIECAAIEpgeVIPi4F9W8uRaXqJECAQNcEHn/22S8ponzqpjU741897GtdC2/keF646do4Zu32KCbKE0963tm/M/KNChIgQKBd4N0RkTNKqr8L2ouNfHax6xv5wQoSIECAAAECBMZdYDmSj3cuImKOePyFiPjrRaxTVQQIEOikwJO2vPXIwWS8KYN7xeYvxfqJ3Z2Mc5Sg1hbDePUxfz9VtBgO/uDEMy8+fpT7lCFAoFcCb4yIXAkrE4L5+9IljP7ljbqf3Tie7+Fi1zff5ytPgAABAgQIEBhbgeVIPv5+RLym9pcJxPr2ntq1erlq/wUR8YyIeEJE5IrXEo91PfsECIytwJ7DJt9QRLHxaYf8YGrqct8b+tMH3xynb/hejn5cN3lgMZVU7XibMnFSJVIymZIf28xF1GbazmqUz3vz3EK3U6afWY3sqn5zhFZz8bbmMzLOjLe6Z67Ym/c77o5AJvSqfqx+sz9HebdyNGB1T/7u7+jA2VTyncv/n++w6UL5+97ZbnCNAAECBAgQIEBgdQgsx2rX+W3Gt9Q483+Zrq9c/V8i4qradbsECBAgsOW8dRHDF0YU8Rubvzg2Hi/d/KX4zN0/FeW+Yuumcy5cf+ulF+7ocOOeV0ukZJj5n13HzPDN4Uy8vL9RPpMvh+5H+/554z8vq6pyhNaPI+J11YmW34yz/p+1s8XecrtTHRHIJHMm9Jpb9me+b6fO8D5W5ZujAfO4/v+TVeUW4zffORsBAgQIECBAgACBhwgsx8jH5kPrC8Xkf3na3izgmAABAqtd4KSNp5xZFMX6kw66JTav7XJ+bn49dfjkrjjloG1Tox8ftnv9ufO7u9OlczRiNeKrCvQTEfGB6mABv0+a5Z5MSM02CnOWW11aIoFMFNZHm+ZIw/19xx8zS6z5vnXp+6n+/7lZOsslAgQIECBAgMBqFliJ5OMrIofy3P93eERcs5o7QNsJECDQJlAWxa/k+Wce+v22y70+96wNN0zFPygmptrY68bcH3xOZT2j0Y78H9d+rXFusQ+fv9gVqm+/BDJRWB9tmpUdt181zn1zJjfnmoI/dy2LUyL//7k/nh6VmzXmv4H8dI6NAAECBAgQIEBglQusRPKxjTy/a5Xf1sr/ApffNsoRJEv5kfK2GJwjQIBAJwRyOvJgGFszmGceemMnYlrMIE475MaYKMqIQWzJRXUWs+4VqCv/8+uiluc+KyJubzm/mKd+r0OJp8Vsl7pGF8jRjy8evfiSl8xPAeT/sJz/I3P+7s/I3yUP1gMIECBAgAABAgSWR2Clk4/5v9jnFKWvTX+UPP8LXE4ly+9Z5UfK87/U5ZZJyStqf6aaTcP4IUBg/AQetnv9mbkoS0653rRm59g1cMPkfVNTrwcRk7s23J9k7Wkjc8TZh1tif9kSjer/YONZXUs8NcJzuEQCzfdAEnqJoFVLgAABAgQIECCwOAIrmXzM0Y2XtExRqrfskOmDDdNT2nJaW/516X/lr8drnwABAvstMJgYnJiVPPrApR44t9+hLriCTKzmNhhMNqepLrjOFbjx1S3/GfaeiPizJYplY/z/7N0LuFxVff//755zIVcSAoFDoBiV+iiQgFysF6TRiqAViApVrLY8f/kpWltBEaXqr/jziqLhZ7229pH+a8U2XpCiYL2lGi9FQCCAFpHGFMKBhJB7Qs45s3/PZzIrLBZrz31m75nz3s+TZ/bes/baa73WnmTynXUx0zyS/tYRbhegAAAgAElEQVTJwNPJ1ZEHvwhWSNaPf/oRsN7wXv0wqB8V9e+7rvFXWda+fmxUT7h68yAqjbtW17j7qgxuTkW9ZuXTbj3kq7poJEZooWPVT/dwm45V3h+7E96rflR1ddFrJ3oC3uLlr91OBqFlrZEnar9wpXeV3a93UIzKobNwdZZh1iZj9+OyS1/rVeVxz0JWnjqvNMrXbzvtqyyNXB/mrWvCZ0HPn+ra6I/hyiPmqvrGnqmwDDpu9XPh39v3VR2UZ9bnKFYGziGAAAIIIIAAAi0J5BV81JdC9W5sdPtJkLDWJPxBUg4RQACB/hJI0tJhKvHYyOAsNBO2wEEjO/eeSqfGwvf65PilkVWIbzKz93a5/J8M8u9E4EnBCQWbFDzTv81aQdnf9KOfgmi/qRGo0EgF1V8/KiqPcA5M5adAs+b5VBoFXHTf2ObPBaprNJeiAj0qgwtW6/W84OJO1ENZKtD022r7hhY6Vv1k5UZnNBqAUt5+3YLiN3z406q1f0EngtAKQqmNNfJE7adny22u7VRvPStZbRd+t8v6vqZ76XlRm8aeFXdf/1XlqbUAj9Lqc6k6KF+/7bSvkTV6z7Wbn3fWvjPRtX5+8lBdVYd6wTsFHbNcdV//mapl6z87un8jnwtXftemfj1dm+rzyFRHvgz7CCCAAAIIINBxgTyCj/rCqi/JzWzfDhI3+kU1uIxDBBBAoA8EElusUo6NDt6Qa6f/2HDypFJXd75PXvXv2JeCsmpxjfN7MM+j/j1UYMzf2gk8uYBdI/+uKvijQEUs2BIGq/zyxfYVcFGgpZFtRTXQUyttp+qhH0cVaGpkc6MzGknb6TQfDzJsNwitNlXb+gHH4Bb7DtXWtYJk+xJm7ChA2Oi9MrKInn6WmX2rTh1Uv9hUCbEMlV+9crrPRFZAU0FzBf4acVUZmrGt97lQL9V65Xf11ggjNgQQQAABBBBAoGsCeQQftTpn+CVM82NpcvJwOJlf8fA/W830NPDzYR8BBBAotEBiU4ergIcMD27Px4XDuyptkKSlfuz5+M+Rf8de26V5HmPP6l8FJ/VvaqvTkXw66NEVZB09VEBFwb52NwUgFYiqt/k9zrLSdqoezf44qvLcm1WoyPlwvsZIkoZOabiset35W6tBaAXOFKRqZlObtPrMhb13G72vAvy/qpE4/G6ZlVQ9/mIB9DB9o/npOvW0DDc922FP0DBN7Fi274+9EZyr97l4S5CeQwQQQAABBBBAIDeBPIKP4a/DH2pwfizNTeNvi/wD9hFAAIFBEUgtqQQfx0YHOPjoFtIplSt17aO203/ow16C+ncs7KHfzSrpXuGPda0EntQzyh/KqTIroPXH1R8E9aOgAjWax9LfFJTRD4n+pqHA2hRc0w+Kz/fycPnIKdyOCU80cby5mrZT9VA+YcDpnUE9VC/VQ4GwbdX7v7maRu+FW3h9I0GvMI+s44uCN1T2VgKCscCZyq22V9vpj54J1dnfWgnUylj5+pvupVXv3XOiY3/TffW+Vs9uZCJcfTaOq+an1zBIq7yX+zeos+/nF/s86HL9nRB+vw17Ryudn5fqq/LFAtIKWrb6I7v7XISfbd3HObt767OqH/e31DHgbQQQQAABBBBAoC2BPIKP4Zep69uqARcjgAACCCDQO4HwP/S687re3X7fnT6wb2/vTiuBp9cEeSjIo/r5gVT16lNwLQx2vjy4dnU12KPgmhbc0bG/KZ93+yeq+8dHzmWd8gNiCoZ9uJqwk/UI731HcEL1Uj0UCLsteK/XhypL2C7NBqH1nSwWTP9o0KNTz8SZQQX1zCmY2MwW/tigwKDu5YKKek507AcMdZ96cz26MihQfrrXNmqj2Gc2DIC668PXML+sz4Oue7Z3sT4HKre/qa38suk9lU9pYwHIU/2La+xnfS7CSxRkdM7u3vqsHtlgJ4AwP44RQAABBBBAAIGGBfIIPjZcOBIigAAC01EgsfQ+1Xt8z5yBrf6GidmVuqVpMt5nlQx7Aar4CoKFP6x1u1qdCDy9OCjkjUHAyX/7B/5BJGDlv61gioZma15Af3Vd7YebVvBuZDu3GpRS8EebgmEu+Nepeqyv5u2/qPea5oHsxDBzP99O7bcbhNa8huGW9aNwGFDWdc8NL65zHM4t6AfD6lxa920F1xQoDzc9M34wU+/XG7KsNLomlp/euyq8iZm9wDt3irfvdmsNN3eBdJdWr2GA33/P7df6XITTFWkuU30ue/13lSsrrwgggAACCCAwjQXyCD664SCOPfwV3J0PX8Nf5t1wpzAdxwgggEBfC6Q2VAk+Pjg5wMHHyZnVNtobaO2jBvtypLeZejjpP/W1Nq0mGwbiwuN6eYT5xwJP4XDo8Br/OOz9pX9nwzK549jQXD8v7WuOO02RovkDNWw0/Hc7TN/osXqMaY7DrK1T9VCQKuxJqLZV3TdWy9DIHJVZ5ezG+awgdKP3OiKSUCtau3YPXyPJmzp1Z5Baz4gf3FVgTJ+DMDjYyHe+cHoe/1atBDlrXRObe9IPpMcCfH6PYr9s2neB9PB8reN6n4u/i1ysz6WCklptXj8SFDWoHik6pxBAAAEEEECgnwXyCD7eEoCdFxzHDvUFKdxa+aIW5sExAgggUEAB1/Nxb+/AAhaw7SK5no9m6dq2M+t9BuoNFc5/54IoWaUJe3zF0sUCFrF07pwCT+FwzXe4N3vw6pdXQTmtNBwGAntQjLZv4dfjTyO95NwNNHxXdVSQK5zfz6XJ4zWcI1EB09j3pm6UrdnV6vXMhp8dF9xVoFOBsXCRFp0r2ne+opUn1rYavh7rqa20Cu7qR4Lf9PBZiZWRcwgggAACCCAwTQTyCD6GvQr0HzYNzdK8QeEvsEdXvxSFvUHCPKZJc1FNBBCYFgJlu1/1HJ8Y3J6PGydm7W3KZKjfhl2r3Oohd2nkWVQQpddBKQ2l9DcF/3oVePIXqag1pNQvXxH3/Xqot5vm5YstjuPKLuNbc2hrd//wVYGwMMgU9ooNr+nUcRhIbCRfrQzfzBau7t7MtdM9rX4o0aIyWe2kQLWCkOqZzYYAAggggAACCHRNII/go74kh8FDBSA1zCccZvO56pcifTnyt9hcO/777COAAAJ9KzCVTlUWubh7V/h7TN9W6QkFX7Pz4L3n0r2B1ickKP4JLdQQziOnUn8ho+h+gCsjid2c9UaN8wqE5hF40r/jblhqbAVjBTs0H50CdVpZ1/2pUZVc3vLr4QqgemlRGa0MrMBNrJ2V9mvuggK8XhGUoRdBaLXxT4L7NnL4skYSVdPoGao1XLmJrDqatNmFdjp68yYz099VWiBJlmFPaZeVvm/7PYDdeV4RQAABBBBAAIGOCOQRfFTBNUQo61fYehXTfwJqzf1U73reRwABBAot8NDo9hvSqWS3AnSPDU8udJGbKtyWyf3stp1jlWt2PfroNU1dXKzE50eKox/RNIdduCkA4AJwWa+x1aDDfGLHscBTo/Mp+/kpEJdVtvC8ege6TaMUwk292/RvtYKjvd5arUdYTgUh1W4nmdnzI99bFODrdU/XsIzuOBaE1rQ2rfirrmF7x44V0Go2MKjh+f6warWVguf+d0J9z1PPU/nm+X2v1q8/sWfe//EgnN9c7VTrWYkFM1tpO/c8xF5lqV7Rco0F1BtdXTuWN+cQQAABBBBAAIGaAnkFH9X7UasC+l82axa0+qa+LPn/4WnkGtIggAACfSWwYeVl29NkStNR2I+2xtaD6KvqPKGwq7cdYVNpYuWyfe+e699ZWVznCYn644T+LQvn21PJez38OhZ4Wt4AoQI//qaVj2sFXPy0/n5sPsutfoLqfq3gSyR5w6c6VY9aN9RchbGVj+d6F8UWITnee7/bu2EQWqNKFCCstf008mazK1hHssg89WfBOxquL1eV0wU4FexVIL7Twbfg1nUP9UNCOO2PLtJnJDa36hovxx96+25Xfy9kbe+JvPGjyLlOnJKr5i8Nt9jnOEzDMQIIIIAAAggg0JJAXsFHFVb/afv9yHCxrIrol3EFHt0wr6x0nEcAAQT6XqCclCvD43609Ul9X5ewAj/csneNinI6lTUEMLykyMda1EELYoRb1vDrMF2njt8b/KAXCy6E9/pGcEJTnPxntXdUOARTPbPUa0q9pzYFvbgq0wQEea3whnEqL/UG1TyJ3dg6VQ8FR1U3BZzUQ8830HunRArvr8Ic+37y4uqc1rpU+cV6uEWybemUgkphMLzec5C1AIwMwrK68n+wulpyK70S/RWhVUkNwW4l4N0SUAsXqZemfghygXMZ/HPGwkrf9fL3991pBYNl5vLSee0rf73nb/pxvhVfPw89y8pDn1v/nqpDrJdjI1ND+PmzjwACCCCAAAIINCww3HDK7iTUF3X94q3/NP2BmR0TuY3+U6P/DMW+1EeScwoBBBDof4E7H7nzmqUHLN2+ZufBczT0euHIjv6vlJm5Iddls8kZW6yfh1z77aHhrZq32N/c8GsFJ3ux6d/Ij1R7XTZ6v6+a2YfNzJ9XWUMytQBFvc3v8ad/o8NN9Y8FZcN0nTjuVD1UJ1ko4OQPDc4qY2wVZp2ToduUn/9sKKhUrzeiu7aV138ws3cFbVovn9hz04hBK9/LNGe3H2iL3UdGN1YLraHM/5rzatcqr1/mmKeGifserjdy+BwpGFwvIKz8Y71sY/etdU7PXqP3Uz6xgGmt/HkPAQQQQAABBBBoWCCvno/6Nd3/oy9smjdI/0kL/+i8/4Wu4cqREAEEEOhbgVVX7bYkqfR8+fyDJ/RtNcKCf3HDMytDrq1cvu7mVRdvDN/v02P1Houtjtzr4dcKPDUznYn+bW1lCpSwmZRPrP5hum4dd6oezZYvtgrz39XJxA/01kna0tuyUDCxmU3fu8JFi5q5vpm0+jut3rMiIxfw02ru6jGr3pa93mLzIsbKoIDzJyJv6If1RvPwL1dbtNvr0c+vkX21Sd7D3BspJ2kQQAABBBBAoE8F8gg+vrHaC0A9Adyf2Jw6fUpKsRFAAIHOCOzcted9aZpu/8GWxXbj9kWdyTTHXO7adZBdu+lppsV0yiN7YnOm5Vi6tm+t4EOsp1+ted7avmmQgQJPlwbn/EN/iLA77+ZgjpXdpYm9hnmp/uHci+F1Coxq9ehubJ2qRyNlUz2yVmFWALhWwKlZ50bKE6ZRGbLuE1sIRderp129oGB4n6y8wnT+sYb/NtLzz79G+wpCxhZyCtN18viiBkzU1q/M+JFcn0dNF1Tvc+HK7D4fnej16PJs5FXt3upiV43kTxoEEEAAAQQQQMDyCD6+POLerUm1I7fiFAIIINAfApXFWNJEvWfsygeebXvSPP7K7oyVFpj5+PrnVDJLk/IVd6689J7O5NzVXDSXoN+TUAGd9Rl3VKBBPeHCoE8rARp3i3Auwx+4N2q8anVmBRP8ciu5zilAF9t0/shqQE29rmLBMwVQ9J6ChxpWHOblAi0KyoVzeSo/zUWoeZ5/HpTNXyHYlS28PpbGpfVf262HerD+cbWeYcBInjqn+qseWT3TnIPq6zvqetVLQ/Sb2bSIjf9M1XoGXb4qgwJi/v31nq7VMPusTQEota3KrrqGz5Cu13m9LyfNJRhu9dpOc6H6w9LD62sdvyF4s969/OThZydsX6X181NdZS8Trf6t93wP9ywouBh+Fvz7uudBeegzGN43fK70+c3a/PIpTb3PxXHePf2y61qVQ+VRWxB4zBLnPAIIIIAAAgh0TEArC/Z6i02srS9l+tI/6FuaUcE82iGjKJxGAIFiCSwbPvYVZ/zSrHTMaw66w84/5JZiFa/B0nx54zH2hQePt3Karl3zyO3PMA0rZ0MAgekkoEV8vhVUWIFM9dRUkM7fNDWP5ocMA5V8X/KV2EcAAQQQQAABBPpEII9uNGFPDlG9pE+8KCYCCCDQY4FVkxN7hiqLFvzLw0fbf/Th6tcaMv7Fh55ZcUumJt9E4LHHjxC3Q6AYArFFBdeZ2bygeFqN+fDIwjxh773gMg4RQAABBBBAAAEEiiqQR/BRq1KGQ4H0H2vNA8SGAAIIIBAI3HXdhavT1K7Q0OUP33eyrdl5cJCiuIea5/GydX+YquxlK195+7WXqPc7GwIITD+BLZEqa2V1DXHWyBD3R8c6Hy7OkzXUPZItpxBAAAEEEEAAAQSKJJDX8JUDzUz/AT3Rw9Av2q81s63euVq7/ThMm2HXtVqU9xBAoKbA0pdf+dkkSS+YWZqwzz7lW3bEfo3+dVkz2669ue7R/e1ta0+3TZMzFFX46u1f/+a5Zqsmu3ZDMkYAgSIL6LvfbyJBxUbKrB+tNb9iODy7kWtJgwACCCCAAAIIIJCzQB7BR83j8x4z05dQP/jYLIXmAbq32YtyTk/wMecG4PYI9LfAsuGlrzjr6sTs7AXDu+2TT77eFo2Giw4Xo4YbJmbbhfe+OH1gcm6SWnLD7V+/5gwCj8VoG0qBQI4CGuXytchcjrWKpIWOtPAWgcdaSryHAAIIIIAAAggUWCCP4GNswZlWiPpxkRqCj620NNcggIAnsGx4yfIzv1sqJctmJBPpxYf9LHnhvLXe+/nvao7HD/7P89Nt5f0SS231+uEtL9mw8rLt+ZeMEiCAQEEEtPjMy8xM8zueFpRJw67vMTOtUK2pevrth+agOhwigAACCCCAAAIIEHzs7TNA8LG33twNgYEUWHjOZXMOmZz/90NJ+mpV8MwFd9ubx2600aSca301r+PnHjzRvvbwMyrlKJfL14yPbHsdgcdcm4WbI4AAAggggAACCCCAAAK5CuQRfNSE4a/qQK2PM7PbOpBPL7Mg+NhLbe6FwIALLFm+4rwkSf82SZI5R87cZJcc+lPTax7b+j1z7f/8zyl29+4DLZ1KdqeJvWPNNRd+Ko+ycE8EEEAAAQQQQAABBBBAAIHiCOQRfNQQm7PbJFhnZv246iHBxzYbnssRQODxAk8744qnzxguXZ0kiX6QsefNXWd/vvD2ngUh79m1wFY+fJR9f+uTrZwmCjz+enIiPfeub1906+NLyhECCCCAAAIIIIAAAggggMB0FMgj+DgdnV2dCT46CV4RQKBzAsvOm7Fk/tJ3JyV7S2LJfGX8rDnr7dyFd9ixs8Y7dx8vJwUd/3HDUvvJtiMqZ9Xb0Urppx4Y3vI+hll7UOwigAACCCCAAAIIIIAAAtNcgOBjbx8Ago+99eZuCEwrgcXLVszff75daKX0rS4IecR+W+2kOfdX/iyZtcFmliZaMtmTluyOnYfYLdsPtZ9tP8z+e/cBlXwqQ6yHpj63bWjq8rUrL+lOpLOlEnMRAggggAACCCCAAAIIIIBAEQSKFHzUcOxFAcr6AVvlkOBj0MAcIoBA5wViQUjdZTSZsmfM3GBLZj9kh4zssPnDj9r+Q7tt4fBOWzCys1KQTROzbMPkLNs6NcO2T43a/Xvm2N27DrJbd4yZApBuS9N0e5qkXyDo6ER4RQABBBBAAAEEEEAAAQQQiAnkHXxUwPFiM9OKrXu70TyxlI9U53f8spmtfuLbfXWG4GNfNReFRaDfBZYNH7P8rJOTJDnN0vRFpZKd2F6NyneU06HrrJx+f82W21bbqqt2t5cfVyOAAAIIIIAAAggggAACCAy6QJ7Bx0vM7PImgT9rZu81s4ebvK4oyQk+FqUlKAcC01Bg8TkfHZtXHn1RuWxHWzo1lpSGxsxsfpqWx5JySfuWlsrjSVLS8OnNaXlq3JKhcUvT/9o2MnEDw6qn4UNDlRFAAAEEEEAAAQQQQACBPhVQ4FGBuFb+/KJP66xiZ9W3j6tE0RFAAAEEEEAAAQQQQAABBBBAAAEEECiOgIZaZwXhGj2v4GU/bln168e6UGYEEEAAAQQQQAABBBBAAAEEEEAAAQRqCgzXfLc7b56dka3mdrzRzH5Qff94s8r8ZE+NpH+DmX00cp5TCCCAAAIIIIAAAggggAACCCCAAAIIIDCNBW6I9Hx8Yw2Pk83snsg16kHZbxs9H/utxSgvAggggAACCCCAAAIIIIAAAggggEBfCYTBxw82UPpjI8FHBSX7bSP42G8tRnkRQAABBBBAAAEEEEAAAQQQQAABBFoWKLV8ZesXbg4uvT44jh3eZmbfib3BOQQQQAABBBBAAAEEEEAAAQQQQAABBBAopkAewccfBhT7B8dZhwcGb/wqOOYQAQQQQAABBBBAAAEEEEAAAQQQQAABBKa5gIKIm7xh1BqGXW8Lh11/pt4FBX2fYdcFbRiKhQACCCCAAAIIIIAAAggggAACCCAwOAKXeMFHBeReXaNqClb+wkuvwGU/LjajKhJ8rNHQvIUAAggggAACCCCAAAIIIIAAAgggMFgCSY7VUe/FN3n3v8DM7vSO3e4KMzvRHZhZVjqXZLXbKeCrgo+xLc92iJWHcwgggAACCCCAAAIIIIAAAggggAACCLQtkEfQS6tUP7da8neZ2QFt1+LxGTzVzO59/KnCHBF8LExTUBAEEEAAAQQQQAABBBBAAAEEEEAAgUEU0ByPWcOPO3Fewc2ibln1K2p5KRcCCCCAAAIIIIAAAggggAACCCCAAAItC+Sx2nXLheVCBBBAAAEEEEAAAQQQQAABBBBAAAEEEOgfgTyCj5u7zLO+y/mTPQIIIIAAAggggAACCCCAAAIIIIAAAgg0IDDcQJpOJ/lrM7ul05lW81tX4Pkeu1RlskUAAQQQQAABBBBAAAEEEEAAAQQQQKCYAnksOFNMid6UigVneuPMXRBAAAEEEEAAAQQQQAABBBBAAAEECiCQx7DrAlSbIiCAAAIIIIAAAggggAACCCCAAAIIIIBAtwXyCD6+NLLa9SXdrij5I4AAAggggAACCCCAAAIIIIAAAggggEBvBfIIPv5ZpIpbIuc4hQACCCCAAAIIIIAAAggggAACCCCAAAJ9LJBH8HF+xOvOyDlOIYAAAggggAACCCCAAAIIIIAAAggggEAfC+QRfLw54nV05BynEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBpgSeYmabgnkf7zGzA5vKpT8Ta7Xr2J/+rA2lRgABBBBAAAEEEEAAAQQQQAABBBBAoIACx0YCkL+YBgHIWOBR59gQQAABBBBAAAEEEEAAAQQQQAABBBAYOIE8hl2r5+NpZvbvgeaJZrYxo2dgLGg3HXpKBkQcIoAAAggggAACCCCAAAIIIIAAAggggEAtga80EWCMBR3duZNr3aSg77myh68FLS7FQgABBBBAAAEEEEAAAQQQQAABBBBAoHWBPHo+xla7br0GXIkAAggggAACCCCAAAIIIIAAAggggAAChRTII/hYSAgKhQACCCCAAAIIIIAAAggggAACCCCAAAKdFRjubHYN5faBhlLVTnSvma2unYR3EUAAAQQQQAABBBBAAAEEEEAAAQQQQCBPgSTPm0/De2uux9hGO8RUOIcAAggMuMDCcy6bc8ju+ctKQ+mJqaUHJqVkLC2nB1liixOzg1T9VIuxpbY2KSUbLdWf9MHU7NbxkS3f27Dysu0DTkT1EEAAAQQQQAABBBBAoM8FCHr1tgEJPvbWm7shgAAChRM46qUrjhvaLz3dUjstSUvPTobSGa0Usmw2aeV0tZXs+8OTdsMvr33bTa3kwzUIIIAAAggggAACCCCAQDcFCD52U/eJeRN8fKIJZxBAAIHBF1h23oyl84+9ICmlbzdLDvcr/LQZD9sz54zb/KHdtmBklx08stMWDu+wA4Z3V5I9MjnDNkzOtocmZtmmiZm2eWqGrdlxiN21q9Ixcl9WU6ltLKX26a2b7cq1qy7avO8NdhBAAAEEEEAAAQQQQACBHAWKEHx8ipmdamYvMDOthH2gmR1gZurB8eocbbpxa4KP3VAlTwQQQKCoAtWgo6XJO5OhdEzFXDiyw46f/YCdNGe9nTD7AZs3/GhLpd8+NWo3bl9kv9xxqN2841Ab3zOnkk9q6WYrJ/+XIGRLrFyEAAIIIIAAAggggAACHRbIM/ioIOP7zexNNer0/OrCMl8xs1d56dx571Rf7BJ87ItmopAIIIBAuwLLhpcuP+stftDxqJkb7dyFd9jz5q5rN/Po9bftHLOrHlxqetVWTtMtSZpcefs13/yA2arJ6EWcRAABBBBAAAEEEEAAAQS6LJBX8FGBxxvM7MQ69XNBxkvM7HIv7WfN7M3ecb/sEnzsl5ainAgggECLAke+5PLDZ88YvdoSO1lZHDtr3M475PbKa4tZNnWZgo9f3fh0+8m2IyrXpWl669Two+fcufLSe5rKiMQIIIAAAggggAACCCCAQAcE8go+fqZOj0dXNRd8PNbMbnUnq0OyT/KO+2WX4GO/tBTlRAABBFoQWLJ8xXJL0qtKSTJv0eg2e+dhP7Elsx5qIaf2L7l794F2+f3Ptf/efYAl5XRHOlS64LavXfil9nMmBwQQQAABBBBAAAEEEECgcYE8go+a4/G3kSJ+x8yeVZ3v0b3tgo86DgN3eZTdlavV17AOLp9+rIsrO68IIIAAArZseMnyM1eUSslbhPHCeWvt7Yt+ZjNLE7na7CqP2GfGT7RvPfL7lXKUy+Wrxke2/eWGlZdtz7Vg3BwBBBBAAAEEEEAAAQSmjUAph5qeHdzzETM7zsxON7Mbg/f8Qy1A42/qDcmGAAIIIIBAzgLLhpe+4qyrFXgcTabswkN/bu85/Ee5Bx6FouCngqAqz4xkIi2VSueNTez/b2bLhnNG4/YIIIAAAggggAACCCAwTQTyCD4eH9heama3Bedihw8HJ+cGxxwigAACCCDQc4Ely8/4+8Ts7AXDu+1TT77ezlxwd8/LUO+G6on5uad+K1EZS6VkmYKlBCDrqfE+AggggAACCCCAAAIIdEIgj+Dj/KDgdwbHHCKAAAIIINAXAkte8fEV6k2oHoZ/83ur7MiZmwpb7iP222qfWHxDpTekgqVLX778bwarFQMAACAASURBVAtbWAqGAAIIIIAAAggggAACAyOQR/CxVTytkM2GAAIIIIBAIQSWnvXxi0tWunAoSe09h/84t4VlmsFQAPIjT/q+aXh4kqQXLH35io81cz1pEUAAAQQQQAABBBBAAIFmBfIIPt4bFPLo4Dh2qMDjicEb64NjDhFAAAEEEOiJwDPP/MSJ6VDpw7rZxYt+Zs+Ze19P7tuJm2j17UsPX22lJLUksYuXnLXiRZ3IlzwQQAABBBBAAAEEEEAAgZhAHsHHcH7Hd5hZvV6Nrw8Kr0VqwiBmkIRDBBBAAAEEuiGwbHhquPS3JbPh5Qt+bafNv6cbN+lqnn+4/+/sNQetqdwjseRvmf+xq9xkjgACCCCAAAIIIIDAtBbII/j43UD8qWb2GzO7xMyODN57jZl9xswuD87/e3DMIQIIIIAAAj0ROObMM89PLH32wpEd9v8dfGtP7tmNm7x24e22aHSbJUPp05e8/MyLu3EP8kQAAQQQQAABBBBAAAEEkpwIFFB8Uxv3fr6ZrW7j+rwuTTNunFc7ZBSH0wgggAACMYETll1x0MSC0m8SS+b/ze/9h6kHYT9vt+w41C5ee6qlU8nuPY+mz/j1DRet7ef6TOOyP8XM9MOsftDVphEirzWzb1ePeUEAAQQQQAABBBBAIDeBPHo+qrLvNbObWqz1Z/s08NhidbkMAQQQQKAoAhMHDL9fgUfN8djvgUeZHj/7ATt13r3q/ThjeGZSmcOyKNaUoymBRV7gURceYGbHNJUDiRFAAAEEEEAAAQQQ6JJAXsHHh83sdDP7TpP1UuDxzU1eQ3IEEEAAAQTaF1h23gyzsnqT2V+O3dh+fgXJ4Y1jN5lW7C6VbfnCcy6bU5BiZRVDPfw0yaZGEtT7c4OZfdDMjs3KjPMDLfBSM9vUwHPiP0dfGWgRKocAAggggAACCOQkkFfwUdV1AchzG+gFqV6SSkfgMacHhdsigAAC011gyfxjT0+SZI5Wix4b3T4wHAuGd9uxs8YrvR8P3jPn1QWv2LOCHn61inuamf21mWliTgUi6y1uVysv3us/gZdVe4A2U/L5zSQmLQIIIIAAAggggEBjAnkGH10J9SvzSWZ2kJlpLsfwj87rfX6NdmK8IoAAAgj0XCBNklfppqf0+TyPMbgXzNs71WMpGarUMZamIOeOaLEcCkQSgGwRr08vUy9Zts4InBz0IlWPUnoUd8aWXBBAAAEEEJgWAkUIPjpo9YTUIjLhH51nQwABBBBAIDcBDUfWsGQV4JT91+VWjm7d+OS56ypDr61ky7SoTrfuk3O+J5rZ63MuA7cvtsDmYhcvt9I9N+hFqjlF5+ZWGm6MAAIIIIAAAn0nkEfwUXPwqBejm4upkWFQSqMVsnWNrtUvsGwIIIAAAgj0RODgPXNO16IsGnK9cGRHT+7Zy5vMG360MvS6ZDa8e97eIGsv79/mvd5pZon3Rys+a6oWrfgcbu8KT3A8rQQ0usZ/VsL9ok87MK0ai8oigAACCCCAwOAIDOdQlb8yMw1/0qbX6xtYvVq9H/WFUL+0alPvhSOr+7wggAACCCDQVYHSUOnpusHTZg5uZ3wFVm/ZcaiVSsMK3vXzdq+Z6c99ZvbjoCL6HqHhuHqfDQEEEEAAAQQQQAABBHogkEfPx1ar5S8tqv8YMZdPq5JchwACCCDQlECSlg7TBWMjg7PQTAhw0MjOvafSqbHwvT491jQusW1R5KTmr3tjdXTFLyIrJOucRmDUGnmhURr+Stz+XNW6Tsf+6ssazaF7NrLpO4/u7+evMl3SxkI6ylOrgasc/orP2nejU+p911Kd3LUqmxvN0kx5ZaO6hTZF64XYrlfW8+FG97j6q12z5lOUicz950DXqb0a9XLefh5Zbe7SXB55SBXYd22v19izrLrpfPiMKV/Vo9EyR27PKQQQQAABBBDoJ4E8ej626hP2dNR/Hui50Kom1yGAAAIINC6Q2GIlHhsdvCHXDuGx4eRJpa7u/AC+rg/qpADI1cG58FAjLvTnTWb2WTN7c5jAzJ4RrMStxXv+wsw+bWaxhXw0+kN/zjez080sq1utyqfgnBv94W7tyvQGM/uYO9nAqwJCb6uuBJ6V3JVNq4V/yMzenZHQr5d+GJaB5geMBav88r7YzLY0YHNKhnVGcbpyulNeWc+HAnOycZv25X+bO1ENRn4teL7c23ouXHt9wMxeGVzr0qke/1xN6875ry4PPeMLqm800wv65Wb2eS/DrOdWSZSv/uj5mRdc52XBLgIIIIAAAggMikAvgo/6pdjvZaAvP/52tH8Q2T/crDL/VDNfgCLZcAoBBBBAAIHWBBKbOtysZIcMD27Px4XDuyo4SVoalJ6PmmM63H4b+eHyvDBRnWMFZzSfZFZAzr88DCz577l9BZsUoIz1AlMd6gVG9f3ocy6zOq/6DtZImfxsFIBUgCsWcPXTaX9FEEgL39exyqtgqsriB91iaWWtpdg/GnuzB+e67dVIW6gX5A8jwedY9WWrtC+IBCBrBR79vMIgt/9eo/vqXVnvuXV5KfjIhgACCCCAAAIDLtCL4KN+Mfd/GQ9JG/3CHF4X9lwI3+cYAQQQQACBjgiklhyulSnGRgc4+OgW0imV9aNfP2/60fNsM4stLvN3HaqYAnKfqNFb0d2mXnDNpdP3JOUZjuj4pEvQoVf1eGy0TP4tFQT8UXWorH8+3G80b/Wya3RTO+YVfMzbS8FP9XhsJiCotOp5qt60blMAsxlzd52C9Y3++P8Nd5GZvcXbZxcBBBBAAAEEELBezPk4vwvOsZ4LXbgNWSKAAAIIIIBAwQUUaPHnntN3BJ0LAzY3ZQSxflDtyajh1Fol+7hgRWQdfydioGG0jW76IVZBHMWw/zhjJe5Tg8zUEzIW+LnAK1/Wqt5BVpVDBaAU4Aw3v2yufLIKNw3pbXSTl6uvVpiOrTzu8pK7S6u6hZvaMWsOxDBtveNwnkL/udG+f59eeoXl1pB0ba+PPAP/Ejyjej7D9lKg0a9LLPDor/x9UPW5VFv4baUpj/RMaEX5cPOvVxp/yHXY6UBl1j2UTn9UZrW1PquurmH+HCOAAAIIIIDAAAn0IvjYDS6tmM2GAAIIIIBATwQSS7Vyso3vmdOT++Vxkw0Tsyu3TdNkPI/7d/meCrD5PcH826lXnea407BiLYLhz7WndDqOBd7qTRvj7qEAoYZou16N384YwnyEu6D6ujw41qECNn6QR+VVb8Mw+BS5NLogiIJKftl0nconKwWG/E0BQj+g5b/n7yuApetdfbXwz6V+Am9f7SJ3l1Z10/XhVlnwKTzZhWM/oBxbQKUbXgr26RlRcE5/tP/Vat00n6e/qZ0VlPafUe3L2w8a6ppYwNHP61fegeYbdc+lm+/Re7vtXT1L/pymKrPaWsFN/3lu+0ZkgAACCCCAAALFFOhF8HFzB6uuLy/qMaAvSGwIIIAAAgj0RCC1oUrw8cHJAQ4+Ts6sWu4NtPYEtvs3UUBGvawUYPODH7E7a4irAk4K6IUrXqvHXLg1MledAmnKL9y+G54wsxOCc1qUJdxcUMo/r8DdRf6JjP1Yfv+QkVZWsUVs6gW09D0tNjfkzyP3USAtNm/mdZG0x0TOdftUL7z0fGp+Rj0jMtcft6/pA8KeryszKq3rbgzee6F3vM7bd7v/mTHPqHu/ndcwcK0et5rnU3ViQwABBBBAAIFpKNCLOR/1heMWz1a/4vpfpvTFXJOJZ236wqT/9G0LfunNSs95BBBAAAEEOizgej7u7R3Y4cwLkZ3r+WiW1vo3uRBlbaIQGrL7hWrPMAVosrZLqnNEhkO1s9I3ej7LslZZXN5hWTSUuZHr3PXhq//dS+/Vy+/OMIMGju/JSOP31HNJsuqy1SXI4dXvDdgLr4/U+G7rL9boKDSdgP40uynYrUCn/0ypfloURkFBBTzVAzHWTs3eS+k1t2pYTs0bqj8KOn/czFSmrGeglXtyDQIIIIAAAggUWKAXwUf9Iu9PFK5fYv0vdF82Mw3JYUMAAQQQQKCYAmW7X7Mkj08Mbs/HjROz9tonQ/027FpDYd33DK0OrUVa/O8ZGpaslX6zhl1/MGMuxGI+i5SqHQHNUzhdvnNqSLPbFORTD8vYqtkKSLrAoALSf9qBoKA+j4ur+boyuFd9HhX0VDDUTXXg3uMVAQQQQAABBAZUoBfDrkM6N6+PzuuLh3o0siGAAAIIIFBYgal06g4V7u5dGpk7mNuanQfvrVhq9/dxDTUti4bL6vuFv2m4sObKCzcNA40twhKm4xiBfhMIPwPq1ajAnwKMWZs+JxqO3Ym/6BRY1BylYTncvRX0VBAyNremS8MrAggggAACCAyIQB7BR30ZcavdaVLrTg3xGJAmoRoIIIAAAkUTeGh0+w3pVLJbAbrHhicXrZStl2fL5H52286xSga7Hn30mtZzKsSV+pFTw1nD7e3hCTM7O3JOw0I1v7S/Oq96zLEh0E8Csfkh9dlQD2D1DNZiP+HcjKqf3nt/hyqqodz6rq9FdLTidWz7HHNBxlg4hwACCCCAwGAJ5BF8zBI82cwa/dPIaotZ9+E8AggggAACTQlsWHnZ9jSZukEX/WhruChxU1kVMvHqbUfYVJpYuWzfu+f6d1YW1ylkQRsvlBZSCXtcqdeXvmf42/H+QXVfwRn1oCzafHTPipTVndrf7dR4DT1q5adsnhvJK7ZwSSTZQJwqopemGHA/4Nd7dVMRxBpDQUgt9qOh2eqdGG6xXsJhmmaONaek8lRgU8H9cDs1PMExAggggAACCAyWQJ7BRw3p0DxLmpw8NTOtJNnon1v5lXSwHkRqgwACCBRdoJyUKz13frT1SUUvatPl++EWTc9mVk6nsnonNZ1nzhcocKiAR7i9JjgxPzjWYSzoeHQkXbdPhcNjNUw1FhTSD7JfaqAw/x6kUX5aaCe26TvauyJvhCsqR5IMzKm8vWJzU/orWHcKWr0Ttfijv+nZ8LfKtBP+CTNr5TOhoOergnx02MjK8ZHLOIUAAggggAAC/SKQV/BRX5R/U51nyZ8Uvhm32CqAzVxPWgQQQAABBBoWuPORO69J03T7oA29dkOuy2aTM7ZYvw+59ttTQZVw08Ia/nx2N4cJqqv/ujT6vqIgpoaG9nr7RuSGWpnYBSBVRu3HFhGJXBptW61IrACk5r50mxbt0bx/YQBKgWkFj6bLFvss9Nor/DFAczKqB7bayD2jag/tq1ev5k/U+5uCRtJ5/divH/2Vzr9WxycF6cNen7EVyM/3nht9TvTHbbq/6+3on9dzFuvluMVdyCsCCCCAAAIIDKZAHsFHfeH5WuRL7WAKUysEEEAAgcEQWHXVbkuSSm+6zz94wmDUycy+uOGZlSHXVi5fd/OqizcOTMX2zikdG+L5eq+OP/H23a4ClHLQqAyNtIj11HJpu/n63UjmCghqkQ6VTWXUfhgkjFxWOaVnNzbHnwJqOq889edbwWrhLr/ptjBPEbw+5fC9VwUg1UbuGXXPgkYPKUiu98NnQj0L9WO/2lDp/Gt1rCkJ/K3y95x3Yr2373Z1jXtu9Dm51L1Rvb8+N3o+9Z57tpQ+FsiPPeteduwigAACCCCAQL8L5BF81C+erfZ29L1ZJdvXYB8BBBBAoOsCO3fteZ96P/5gy2K7cXv/d8C/a9dBdu2mp5kW0ymP7HlH1wF7f4OPR275Bu+c5naMBSi9JLntqpeh5vhrZFNPtbCXXOy6V0bmwoylC89pwZDp1OvR1T9vLw29ln0vNz1LVwQ3VNuH0wAESSw2hUGYJnashW+m47MVs+AcAggggAACAyuQR/DxlIimvuhovhl9yW7kjybHZpXsCCSnEEAAAQS6J1BZjCVN3qs7XPnAs21Pmsc/o52pnxaY+fj651QyS5PyFXeuvFTDMgdtUw+ucAipfgDVsFW3afhorEege1+vClAqSNLrTYuG1LuvyvYCM7ulgcLpu5PS1quvy0rptNJ32BPOvT/or0Xwkr0CkOFzXMu+mbR+PmpvPR+xYKC+n9fKN3aNn3dsX8+2Fr5hQwABBBBAAIEBFxjOoX7+vEK6vb40a2XJ2ATvORSPWyKAAAIIIJAtcPs13/zUsa844/Xje+Yc8/8/dJydf0gjMZ/s/PJ6518ePtr+e/cBVk7TtWs236654Pph+2k1cOZGUCgYElsMw6+LhoP6Qz3DAIoCTH9gZmebmQKR/hBU9fa6ypu/zs83vO+vImWrtTq08tYQWbf9wO0ErwrOXG9mbzGzF3tDav2y6ZLDguuy7q36apVjzRepH4Q1359fZwWg9N1Mcx7WCzqqt6U/LD02h6YrlvL07xOb01JpNcRXZWimjd09/FflrxW93RBk5RkbPuxfE9vvlFezz4dfFrWDhibrGVVwUI7OR+n0TGsxIPmvqab1r9fq73oellev89uh0faWg667uPocuvvrei3O4/eWPM7M/sTMND+F3wYqk55blVNlaiVg6deLfQQQQAABBBDoE4Ekh3JqImz/y7Z+za335TaHYnbllprzJrbl0Q6xcnAOAQQQQKABgaNeduXJI6Ppj4eS1N5z+I/sD/f/XQNXFSeJhoy/e90fVeZ6TCcnXnL7tZfo32Y2BBBAAAEEEEAAAQQQQKDjAnmMFwt/Fb+v47UiQwQQQAABBLoocNd1F65OU7tCQ5c/fN/JphWw+2XTPI+XrfvDVGUvW/lKAo/90nKUEwEEEEAAAQQQQACB/hTII/iooUP+9hL/gH0EEEAAAQT6QeD2b1z0jjRNPrcnHbJ3/e6PbN2j+xe+2Crj/173QtudjiSp2VfXfP3fBnGRmcK3AwVEAAEEEEAAAQQQQGA6CeQ13Dcceq25YTSXzKBvDLse9BamfgggMM0Elg0vfcVZVydmZy8Y3m2ffPL1tmh0WyENNkzMtgvvfXH6wOTcJLXkhtu/fs0ZZqsmC1lYCoUAAggggAACCCCAAAIDI5BHz0fhvTlYMe+HZnbywKhSEQQQQACBaSKwavL2r3/z3HI5XbVpcoadf8/L0h9sWVy4umuOR5VNgUdLbfUDQ5vPIfBYuGaiQAgggAACCCCAAAIIDKRAHsFHrXat1fq0Mp7btBLhj81MPQMb/XOgu5hXBBBAAAEE8hNYNTk+svWMqTT5ioYzf+C+U+zKB55te9I8/ol9vILmdfz0+En2rt+9yLaV90vK5fI164e3vGTDysu2Pz4lRwgggAACCCCAAAIIIIBAdwTyGHatla1f1YHqPN/MVncgn15mwbDrXmpzLwQQQKDHAkuWrzgvSdK/TZJkzpEzN9klh/7U9JrHtn7PXPs//3OK3b37QEunkt1pYu9Yc82Fn8qjLNwTAQQQQAABBBBAAAEEpq9AHsHHcL7HVvUJPrYqx3UIIIAAAl0TeNoZVzx9xnDp6iRJNJ+xPW/uOvvzhbf3LAh5z64FtvLho+z7W59s5TRR4PHXkxPpuXd9+6Jbu1ZpMkYAAQQQQAABBBBAAAEEMgQIPmbAdOk0PR+7BEu2CCCAQKEElp03Y8n8pe9OSvaWxJL5Ktuz5qy3cxfeYcfOGu9KURV0/McNS+0n246o5K/ejlZKP/XA8Jb3Mcy6K+RkigACCCCAAAIIIIAAAg0I5BF81MIy72mgbLWS3FtdtKZWmiK+R/CxiK1CmRBAAIEuCSxetmL+/vPtQiulb3VByCP222onzbm/8mfJrA02szTR0t01p+QdOw+xW7Yfaj/bfpj9925Nn2x7h1gPTX1u29DU5WtXXtKdSGdLJeYiBBBAAAEEEEAAAQQQmI4CeQQfp6OzqzPBRyfBKwIIIDCNBGJBSFV/NJmyZ8zcYEtmP2SHjOyw+cOP2v5Du23h8E5bMLKzIrRpYpZtmJxlW6dm2PapUbt/zxy7e9dBduuOscctapOm6fY0Sb9A0HEaPVhUFQEEEEAAAQQQQACBPhAg+NjbRiL42Ftv7oYAAggUTGDZ8DHLzzo5SZLTLE1fVCrZie0VsHxHOR26zsrp99dsuW21rbpqd3v5cTUCCCCAAAIIIIAAAggg0FkBgo+d9ayXG8HHekK8jwACCEwjgcXnfHRsXnn0ReWyHW3p1FhSGhozs/lpWh5LyiXtW1oqjydJScOnN6flqXFLhsYtTf9r28jEDQyrnkYPC1VFAAEEEEAAAQQQQKBPBQg+9rbhCD721pu7IYAAAggggAACCCCAAAIIIIAAAgjkKDDcxXsfa2andSn/LWb2+S7lTbYIIIAAAggggAACCCCAAAIIIIAAAgggUHCBr2i0WBf/KLjZb1uWR7/Vg/IigAACCCCAAAIIIIAAAggggAACCCBQV6BUN0XrCea3fmlDV85tKBWJEEAAAQQQQAABBBBAAAEEEEAAAQQQQCAXgW4GH3OpEDdFAAEEEEAAAQQQQAABBBBAAAEEEEAAgWIIdDP4eG+Xq7i+y/mTPQIIIIAAAggggAACCCCAAAIIIIAAAgi0IdDNBWeuMLO1bZSt1qXrzKzbwc1a9+c9BBBAAAEEEEAAAQQQQAABBBBAAAEEEKgjkNR5n7c7K6AFZ2Ib7RBT4RwCCCCAAAIIIIAAAggggAACCCCAQF8LdHPYdV/DUHgEEEAAAQQQQAABBBBAAAEEEEAAAQQQaE+A4GN7flyNAAIIIIAAAggggAACCCCAAAIIIIAAAhkCBB8zYDiNAAIIIIAAAggggAACCCCAAAIIIIAAAu0JEHxsz4+rEUAAAQQQQAABBBBAAAEEEEAAAQQQQCBDgOBjBgynEUAAAQQQQAABBBBAAAEEEEAAAQQQQKA9AYKP7flxNQIIIIAAAggggAACCCCAAAIIIIAAAghkCBB8zIDhNAIIIIAAAggggAACCCCAAAIIIIAAAgi0J0DwsT0/rkYAAQQQQAABBBBAAAEEEEAAAQQQQACBDAGCjxkwnEYAAQQQQAABBBBAAAEEEEAAAQQQQACB9gQIPrbnx9UIIIAAAggggAACCCCAAAIIIIAAAgggkCFA8DEDhtMIIIAAAggggAACCCCAAAIIIIAAAggg0J4Awcf2/LgaAQQQQAABBBBAAAEEEEAAAQQQQAABBDIECD5mwHAaAQQQQAABBBBAAAEEEEAAAQQQQAABBNoTIPjYnh9XI4AAAggggAACCCCAAAIIIIAAAggggECGAMHHDBhOI4AAAggggAACCCCAAAIIIIAAAggggEB7AgQf2/PjagQQQAABBBBAAAEEEEAAAQQQQAABBBDIECD4mAHDaQQQQAABBBBAAAEEEEAAAQQQQAABBBBoT4DgY3t+XI0AAggggAACCCCAAAIIIIAAAggggAACGQIEHzNgOI0AAggggAACCCCAAAIIIIAAAggggAAC7QkQfGzPj6sRQAABBBBAAAEEEEAAAQQQQAABBBBAIEOA4GMGDKcRQAABBBBAAAEEEEAAAQQQQAABBBBAoD0Bgo/t+XE1AggggAACCCCAAAIIIIAAAggggAACCGQIEHzMgOE0AggggAACCCCAAAIIIIAAAggggAACCLQnQPCxPT+uRgABBBBAAAEEEEAAAQQQQAABBBBAAIEMAYKPGTCcRgABBBBAAAEEEEAAAQQQQAABBBBAAIH2BAg+tufH1QgggAACCCCAAAIIIIAAAggggAACCCCQIUDwMQOG0wgggAACCCCAAAIIIIAAAggggAACCCDQngDBx/b8uBoBBBBAAAEEEEAAAQQQQAABBBBAAAEEMgQIPmbAcBoBBBBAAAEEEEAAAQQQQAABBBBAAAEE2hMg+NieH1cjgAACCCCAAAIIIIAAAggggAACCCCAQIYAwccMGE4jgAACCCCAAAIIIIAAAggggAACCCCAQHsCBB/b8+NqBBBAAAEEEEAAAQQQQAABBBBAAAEEEMgQIPiYAcNpBBBAAAEEEEAAAQQQQAABBBBAAAEEEGhPgOBje35cjQACCCCAAAIIIIAAAggggAACCCCAAAIZAgQfM2A4jQACCCCAAAIIIIAAAggggAACCCCAAALtCRB8bM+PqxFAAAEEEEAAAQQQQAABBBBAAAEEEEAgQ4DgYwYMpxFAAAEEEEAAAQQQQAABBBBAAAEEEECgPQGCj+35cTUCCCCAAAIIIIAAAggggAACCCCAAAIIZAgQfMyA4TQCCCCAAAIIIIAAAggggAACCCCAAAIItCdA8LE9P65GAAEEEEAAAQQQQAABBBBAAAEEEEAAgQwBgo8ZMJxGAAEEEEAAAQQQQAABBBBAAAEEEEAAgfYECD6258fVCCCAAAIIIIAAAggggAACCCCAAAIIIJAhQPAxA4bTCCCAAAIIIIAAAggggAACCCCAAAIIINCeAMHH9vy4GgEEEEAAAQQQQAABBBBAAAEEEEAAAQQyBAg+ZsBwGgEEEEAAAQQQQAABBBBAAAEEEEAAAQTaEyD42J4fVyOAAAIIIIAAAggggAACCCCAAAIIIIBAhgDBxwwYTiOAAAIIIIAAAggggAACCCCAAAIIIIBAewLD7V3O1QgggAACCCCAQP8KLDznsjmH7J6/rDSUnphaemBSSsbScnqQJbY4MTtINUvNNlpqa5NSstFS/UkfTM1uHR/Z8r0NKy/b3r+1p+QIIIAAAggggAACCHRfIOn+LbiDJ5B6+/4u7eBrsI8AAggggEAXBY566YrjhvZLT7fUTkvS0rOToXRGK7crm01aOV1tJfv+8KTd8Mtr33ZTK/lwDQIIIIAAAggggAACgyxA0Ku3rUvwsbfe3A0BBBBAAIGKwOJlK+bvP698fjKUvNUsOdxnedqMh+2Zc8Zt/tBuWzCyyw4e2WkLh3fYAcO7K8kemZxhGyZn20MTs2zTxEzbPDXD1uw4xP5r94E2lT72VWoqtY2l1D69dbNduXbVRZv9e7CPAAIIIIAAAggggMB0FXjsG/N0FehtvQk+9tabuyGAAAIITHOBxed8dGzu5Ohbzcpv8WoJnQAAIABJREFUKiXJPHGMjW63E2Y/YM+c/UDldd7woy0pbZ8atZt3HGq/3HGo3bh9kY3vmVPJJ03T7WmSfmHb0NTla1deMt5S5lyEAAIIIIAAAggggMCACBB87G1DEnzsrTd3QwABBBCYpgKay3Fsau77k6mhC9yw6mNnjdt5h9xueu3GdtvOMfvXjUfZz7bt7Vi5d1h2+UvbNpcuoidkN8TJEwEEEEAAAQQQQKAfBAg+9raVCD721pu7IYAAAghMQ4HKnI6jtrJUsiNV/efNXWevO3iNaXh1L7Z7di2wf964xH687QgrV4Zlp/dN7Cmde9d1F67uxf25BwIIIIAAAggggAACRRIg+Njb1iD42Ftv7oYAAgggMM0Eli5fcWFaso+VzIaPnLnJLjn0p6bXPLb1e+bah+57vt216yCr9IK09H1rvn7tR8xWTeZRHu6JAAIIIIAAAggggEAeAgQfe6tO8LG33twNAQQQQGCaCGiY9aLJ/a+2JHmZqvzKA39l/+uQm200KecqoAVpvvjQM+0rDx9d6QVZLtv3to1MvI65IHNtFm6OAAIIIIAAAggg0EMBgo89xDYzgo+99eZuCCCAAALTQGBv4HHe9ZbYyfsPP2rvXPQTe87c+wpV81t2HGqX3/9c2zAx29Kp5Ndbt6TPYR7IQjURhUEAAQQQQAABBBDokkCpS/mSLQIIIIAAAggg0AOBZcOLJvcGHo/Yb6v9/VOuK1zgUQjHz37APvuUb5nKmAylT593gP2bgqY9AOIWCCCAAAIIIIAAAgjkKkDwMVd+bo4AAggggAACrQssG176irOuVo/HBcO77ROLb7CFIztaz67LV7oyKgCpMleCprZsuMu3JXsEEEAAAQQQQAABBHIVIPiYKz83RwABBBBAAIFWBY55+fJ/SszOdkE9vRZ9c2WtBEkTO7kSPC16oSkfAggggAACCCCAAAJtCBB8bAOPSxFAAAEEEEAgH4Ely1csH0rSV2uOR/V4rPQmzKcoTd9VAciPPem7plcFT4995ZWvbToTLkAAAQQQQAABBBBAoE8ECD72SUNRTAQQQAABBBDYK6C5EpMkvVJHfzH2i74KPLo2VLD0okU/rxxOldMVi5etmO/e4xUBBBBAAAEEEEAAgUESIPg4SK1JXRBAAAEEEJgGAmOT89+dJMmTlsx6yE6dd2/f1vh5c9eZ/gwldtD+ByQf7tuKUHAEEECgfwXeaGabzCyt/rmhf6tCyRFAAIHiChB8LG7bUDIEEEAAAQQQCASedsYVT7ckvbiUpPb2RT8N3u2/w78Yu8lGkylLrfy/nnHGx5/dfzWgxAgggEBfC7zczA7wanCat9/K7qvN7B4vmPmZVjLhGgQQQGDQBAg+DlqLUh8EEEAAAQQGWGC/oeTDJbPhVx94Z18Otw6bZmx0u/3ZwbdZKUmGRkaG/iZ8v+DHx5rZB81MPYVcryG9/qJ6Xu+zDa6Agip+u6v32FOarG747BCoaRKwxeQHRj63ri2/YmatfHb1d4Hfg9Dlp0BcK/m1WLXcL/uAmT3VK8WbzOxk75hdBBBAYFoKEHycls1OpRFAAAEEEOg/Ac2LmCTJS9RT8E8Xrum/CmSU+OwD77KZpQlLLD39yJdcfnhGsiKdVuBCAYpbzeyvzSzsKXRi9bzeVzqlZxt8AfUee30T1VRAKnx2mricpG0IPKOG/avM7IdNfm4vqX7m/R6ErngKxE2ndvYDj86AVwQQQGDaCxB8nPaPAAAIIIAAAgj0h8DseVNnJ0my30lz7q8E6/qj1PVLOZqU7eS5/1NJOHPGSNFXvnY9phSgaGRTurMbSUianghofjvXI02v6pXW6nZd5MJGnwtd+ieR62N5RpL17JR6rPm9+bQ/CL34nltHUEHEZj63b6iT3wvrvD9Ibz8ySJWhLggggECnBAg+dkqSfBBAAAEEEECgqwLDpaE/1w1Ombeuq/fJI/M/mr934ZxSkv5pHvdv4p5vMzP1bGxmm9dMYtJ2VUDz2/lbO720vm1mYaBF+TUanHuxX5BqXsqzSJuCdH5vPu3PLVIBu1iW8xvMWwHadp6jBm/TN8nebGa/9Ur7ITNb7R2ziwACCExLAYKP07LZqTQCCCCAAAL9JfD001cstsRO9nsJ9lcNapf2hNkP2LzhR82sdMxRL11xXO3Uub2rXo8aZh1u76wGHxIz058/NrPPhok4HkgBDasPt0YWTtLckGEQO5ZXmDfH3RP4lyBrtU8jc3i+JrguzCd4e+AP9RwfWf27UH8fvnvga0wFEUAAgQYECD42gEQSBBBAAAEEEMhXYHg0PV0lOGHO+oEacu1Uh5LUTp67t0fn0H576+reK9Cr5okLNwUZP2pme7tu7n1XvdfU++f5ZnaTmQ1eV9VQYfoex4ZJN9Jj7tQIWSyvSDJOdUngmki+jQy91urO/hbLx3+ffQQQQACBaShA8HEaNjpVRgABBBBAoN8EkqHSk1Tmp87QlGuDuR06um1vxVI7rI9quLZGWTXU8KTqojNhsnCVYy1YkbWpJ5E/T6FW1Q03P40/j6F6aypvrcDt8tD7WlW5Vq+uTufnl1dl0tyLMvDnE1T5VE6Vrd7quP7cjcrDpX+pV1edl5Xq6eoeW/jDvedeGx02rTrFhl430mMuDFBq+HZsyHWWldpQbeTq7ftm7ctBHv6zICPlEwbQlL88Lo9k9mPPU2nUFlmb8lX+Lj9n7Mof3jfMp5l2Dq9t9vi+6o8F/nX15nJU+f1h6WrH7/oZ1NlX++nzqc9CaCQrnXfPcJ2s9r3tzP3Pltq82XyUofLy/65SGfX5rPUZUZuF995XuOpOVrvW+vuq1j39/Dv1mYk5ql7yUPl1HzYEEECgYQGCjw1TkRABBBBAAAEEchNIy5VVoA8Z2ZFbEbp947GR7dVbpP2w4rXjUHCilf+EhkGwWgtShIuYnOBu7r36adz8c/rP82+qASR/iK/ef1M10KI0sa3T+bl76D/tKtPnqisA+4EbpVE5VTYFuPSf/Cxbf+5G5aG5CVWXb3nDmXVew+QXuZs3+Bq2Tb3LFFwLt1jPRpdGdfLbQ+djebj2i1mpDdVG9ZzcPRV40jx88vDvLSPlc3Xg7Z4hd32tV78tXDoF1RSoUr7KP8zPlV/vK11WYMnPu147u3u38/qF4GKVM6tsSro8SK92fDg4l3WoIJ7aTwFePXOhka7TebWZ2i7rs+ryVzl9c3m5TW2ufNQTu14+ukZ5KWCp9vE/DyqjPp+31shHbRbe25XDvcbaVT8c1Pr7qtY9Xb6d+MzUclS95KHP5KfdTXlFAAEEGhEg+NiIEmkQQAABBBBAIFeBUpIsVgEO36/aOzDX0nTn5gtHdlYyTkpDY925Q9u5ro/koP+M/2eTPdAi2XT8lP4TrsCBHwQIb6L3lKZWcMVd04n8FGzRf9prlcndT6/6T36tAKSf9pxqXfxzvdqPDZcOezb6ZYkFJj/vJ6gGduq1n7uknpMCYgo81duUTyPDjOvlo2dFQbVYMC12rdL9sMHnsNvt/NVIARUwj23qSeoH6ZUm9izErtU5BfGa2fQ8KEAX2/QZVnCunrk+e/oc1tvUHn6QOpZe5anVezp2TdY5tat+OKj3d0Otv68a+TvK3T/rM6MfBlT3eo7KZ77LjFcEEECgEQGCj40okQYBBBBAAAEEchUo297egIcMu96BuRanKzdfOFwNPtreXp5duUl7mWpex+9EstB/VBVsUU8h/Qe4CJv+k97oFhtaG17bbn4KmjQbbFEZFAB5f1iYyHGtQEksaBzJYt+pWBvvezOy0+zQ67C3nHq13eblq0BSM966VPV/vZeH29WQ3jBA5t6LvbqV2f3VimPp/HPf8A4UjGokuOVdUtlV0Olr4cnIca12jiRv+pR6LYYLxmR9psMgctbQ+aYLUeOC90XecwGzyFvRU/UCfLqokTRKd3H0Ds2fbKZdY8HgTn1mFHxvtO7N15IrEEBgWgsQfJzWzU/lEUAAAQQQ6A8B1/NxbHRwg4+P1S0p8rBrrWytIENs03+gFTTSvGAK+mQNGY5d261zCqRp4RutOqsgaWwVbvUCaqT3o8rYan5filRQeWllc7dKuPbDwI8uU9Cy1R5WaisFjd09YoFF95579QOBkWJHT8WGTT8rklLPRBgMDOscCwbHVlQPn8N3BffTvcJzSqL76VlQfQ8yswsiz7RbrVj3DTf3PDkvv9fmhyLBGwUytQK8S697x/LV+axAX1iG8Di0CN9v5jhcMEbBqFiPw3cEmcY+W0GSxx3qWZSNzOTj2sQ56VwYBI4F6RR0DgNm8jjXM9dnK/bsP65AwYHfbipbrH6ttldwq32Hrd6zU58Zfzi4CqXy+O2ifbnKcvO+UrODAAIINCBA8LEBJJIggAACCCCAQL4C5TStLGwyvmdOvgXp4t0fq1uqhR+Kuikw9YJIsMYvrwIB+s9w3sOxFSzQKula+EabgnBahTsWhFAAst7Wan4KUITBEZVBZfMDfdpX2jAYp3KFvcyyyqprXUBTr6/NStjh87HhtmEPx6x6/KtXFgVZw7ZQcCq2ovqZ3nXalbG/AI3MQnf5yNitzq6efgoeKqil+QC3BHk2c6iyh4FVBcH+IFhMR/dWfRT0DLeYWZhGx91s59iCMX8WFELBegWi/M1vR/981r6efwV53131cW3i0qtH7d+5A+81/KEgtiiO/o7yA+L6bOl+sUCzl/W+XT0Lfru5vzvCYKier079yNLqPTv5mdkHUN3R8+u3i/blKstOB17De3OMAAIDJkDwccAalOoggAACCCAwiAIlSyoBuQcnBzf4uGFyVqXpUisVOfioMuo/8grWxHoC+Y+fghMajp3Hf1L1H3kFGmPbVZGTx0fO+afaye8UP6Pq/icj59ypD7sd7zXskeS9tW9X7SFrF9DUa2wF6X0XdHAnNvRagbgwMBNaKJjjyqvixHpLXp9RThdU9t/WwjtuC++l8zFbnVdQRSuz+70YXT6NvsbKrjbJWoBF9wp7LIbBy9i9u93OsaHXYVuGQ3/DdoyVO+ucgmdZK17HevTN9TLStWEQVIFZ/5nyklfad4F/ImNf9Y21m/IOt2eEJ1o8bvWeseeu1c+MH2hUNfT3vOad9YP6LVaPyxBAYLoLEHyc7k8A9UcAAQQQQKAPBKaqwcfHegf2QaGbLOKGiWrwsTw13uSleSTXf1IV3NN//BUMCYMofpk0B56CBL3cYoEDd/9fuR3vtd7iCe3kF6t7raBgVuDEK250NyvYGk3chZN+TzOXfdhjMwxEh8GcI9yF3qsC2GnGHy/ZE3Zj7q3aPiHzyIlY2bOCQO7yG91OE6+9aOdw6LWK57dl2I4fa6L8LqkC0/q7QYFLBRnV4zUMJLq0Wa+xldxvyUrcxPkwCOcubadnrMsj67XVe8aeu1Y/M1+OFE7tovy0kriCxLHPVeQyTiGAAAKPFyD4+HgPjhBAAAEEEECggAKJWXXY9ewClq4zRdow4eq2t5dnZ3Ltei4uCPn71XnsYkFIDU2MLQbS9cJl3KDTAahO55dR7MKfrjf0WvMGhsOgmx2qWw9hcb0EvN+QgIZeh5/l86pXKvAYtmNsqHa9G6lHXSuLMNXLl/ebE/A/M+pNrDkdY5sCwwoSK1j8wVgCziGAAAK1BAg+1tLhPQQQQAABBBAohkBq96sgax+t10GtGMVtpRT37dl/72Ule7CV63O+Rj0DNY+d5lrTf07D7YTwBMcDJ1Bv6PXLghq3M1Q3yGrfYRgw2/cGO00J6PMc9mRVDzj1egvnpdSUBFm99rJuqgBmbPGYrPSc755A+JlRu2tRpdjf464Ufx15Ptx7vCKAAAJRAYKPURZOIoAAAggggECRBMoju9RLxm7cvsj2pIP39WUqTWz1tr2j5yYn0u8Vyb7JsqgX4F81eU2vk3d6/rJO59drj07eLwxYKW8t3KEtHKobDrmuJmv5RUGUn7R8NReGArGerOrBHM5L+fHwwgaOXS9KP6meh3Al8diq4P417LcnkPWZUQ9ILQak9siaVkPPQfiZbq80XI0AAgMtMHjf3ge6uagcAggggAAC01PgzpWX3pNa8vNd5RH72bbfGziE23aO2ZbJ/axctnt+9W9v/3mfV3BrAcofLnTiF+lo/6C6f3PknH+qnfw2+xlV98MVe/0ksWBmsz3L/Px6uR+bM049HlXfcKhuo0Ouw4BUYmaxP1pIpNZcmnKo5d6uU2w+wNiz5u6jZypcLKRWbzN3Xa9eYz1Z1eMt3FoZch3WW70nFciKLSIU3q/ecb3Fo+pdPwjvd+ozo/bQHKOaVkNByHALe8GG73OMAAII7BMg+LiPgh0EEEAAAQQQKLJAWrZ/Vvm+t/nJRS5mS2X74ZbqtFul9B9byqA3F2lxCPVArRfA8VccdiULA3DhUD83pNOld6+6ZyubhnTGrlXA5x2RDNdEzvmn2snvh35G1f3YKr4u2Xvcjvf6I2+/nd1YkLVeezZzPwUrwgCagkp/EmSSNeT6p0E6Hcaep0iyJ5z6wRPOmF0aOadTei7Ua1MLavjbHf5BdT8roBj70UCra2cFrtWLMAzI/nvkfnmeivVk9cuj3oq1FmPy0/r7Yb2z8qgXSIwFK9UjL+uZ1ryjm/yCDMB+Jz8zWRxqHwUhw8/24M6DkiXBeQQQaFmA4GPLdFyIAAIIIIAAAr0UGN08+ZWy2eQvth9m6gE5KJuGXP+4OuR6YmfypQLXS/O9KUh4azVQo6CSv/Kp/sOv4E0ssBaunhtb5VeBDJefev/9os0FKbSYhR8sVd4KYMdW1G2k91ar+cXylqMCO36QRPsqr97zNwVq6wWB/PS19mO9897oBcgUnMkKltXK138vHE6tQFPYYy5M465XMCkMTOt5UiA57BGq9tQ5LX6hZyU0+o7L1HtVYErp3HOmuuo5/s/qcOIXemm1G+vFe753vdrMtaGmHAiDM6q72lSubtO9VebY5+TzLlFBXmNDr/2ihZ9r/71a++rp6G965vUcuk1eatNwiLd733+NPUsK+Ktd3aY20jP0rWrAN3yWXLp+fO3kZ0afDbmrLXwjfU7UJupd7G/hj0r+e+wjgAACjxMYftwRBwgggAACCCCAQEEFbl518cYlyz9+3Z7S0PKvPfwMe+3C2wta0uaKdc2mp9vWyf3MUlv96xsuqqzq3VwOuaRWUKCRwIAKpyBQGBj6RiTIpt6FYfCm3copqBEG88I8NZwwq+dVmLaV/DRkWvcIV/Zt1FA9jjq1rYtkpHL5ZbvAzNoJgmk4dRhsDG/7D+EJ7/gjkcBcWEYv+b7dsA0VDNSzF7Z/o+7KeP2+3B/bCZ9TBb9coEu9Vq9+LGllT+kV9Kq36Rkp2srpbuh12FNRdWknKK4ennLxt8+Zmf40u30q8neRyqt2CNui2bz7JX2nPjPqyah2Cdsmy6HV4HNWfpxHAIEBFqDn4wA3LlVDAAEEEEBg0ASGy8kH1fvxnx5akq7fM7fvq7dpcoZ98aFjU1VkYiLJGhJalHq20stFPZz+NFKBr0Z6uEWSVU6FvaSy0vnnw95z/nv+voKd7/VPZOy3m5/u0Uo9FJAKA7cZRWzotHph1qvLvIZyyk4U6wHop5ZDrTkstWq66t2JTYHbevX17xMOS1c5Yz0o/Wv8oadqq1bKLpNGnkP/vr3az6pPO8+lgs/NtEutuqrn34dqJYi896vIuX4+1cnPTKMOembbeQYavQ/pEEBgQAQIPg5IQ1INBBBAAAEEpoPAL699201m5U9N2FDyyQfcIrr9W/PPjD/LdpZHk3I5/dJd110Ym7+sSJXT/HX1AjF+eRW0OD2jV6F6qb2gTgBCwQn1wrvIz7TBfQ3rPrdOWgUeX5lRvvDSdvNTfWXRqJ+reyd7PapOKke9PGO9I0OPesexobDumi+4nRqvKmOzAaVYcFzBQz1njQR+1TafiJRJKy7XCpSFgdRmy656Zn1OIsXp+amshYHqDcmuVVCZyamWq67X3yGNfGbebWaNrIyt++nvhbCXbK2y9st7zT53qlfsM9NIfdUmembZEEAAgYYFCD42TEVCBBBAAAEEECiCwLZNpfelU8n4jdsX2X9sfVIRitRSGW7Zcaj9YMtiSy3dPLq53EqAraX7tnGRerTpP5zHVQNDYVBA/7HXOQUBNK+i/jNc6z/5yk/D+xRg8IdbK1CkgIze0/BfDX313w+DPVlVUq8clUP5+0EOlVFBTUWvmxnm2m5+LgCplWhVvyw/lU2ry9Ya+qxh6/7WSHDNpVc9VAYFCH0X5aG2i81R6a5t9FU92/w2c9fpXKP5K6Ck9lOZZOWXVfkpL/e8/bE39Nndy72qjU+qBp3COisPPR/yyAoAZj2n7tor3I2813plV7n1DKh+Spv1OWmnnb3iPGFXi5So/G7T/jZ3ELyq/mEwWeWvtbK4/zyq3cJ66BZ6DvUZl4NfFqXX/dQm+jvE/7zrvdhQeOWn3n/yVH7+/fWeyus+V7qvv4VlC6/102oBIv85VLnD8jSSXyNp3H0buadLW++5U3lrfWbkLSel8dtE+cul3mfFlYNXBBBA4AkCyRPOcKKbApVhVZEb0A4RFE4hgAACCCCQJXD0yz/26uFk+OoFw7vtE4tvsCP2i60LkXV1/uc13PrNv31p+tDknGRqMn3THde+rZW5zvKvSHFKEH7H0n+e2+mZ0+n8iiNFSRBAAAEEEEAAgR4L0POxx+DcDgEEEEAAAQTaF7jzG+/4ylSafEVBvHf87lTTa79sKuvb1p5uCjyWy+mqO669tpFhqP1SPcqJAAIIIIAAAggggMDjBAg+Po6DAwQQQAABBBDoF4E7vnHN6xS82zAxuxLM64cA5K7ySKWs6x7dv7K69fjI1jPMVk32iznlRAABBBBAAAEEEECgWQGCj82KkR4BBBBAAAEECiKwarISvEtttYJ56k24ZXK/gpTticVQ4PFdv/sjU1nTqeTX64e3vGTDysu2PzElZxBAAAEEEEAAAQQQGBwBgo+D05bUBAEEEEAAgWknoOCdgngK5imo94Z7X2Zrdh5cOIe7dx9or//tGZWyqaxbR/e8gMBj4ZqJAiGAAAIIIIAAAgh0QYDgYxdQyRIBBBBAAAEEeiegIJ6CeZbaag3BvmjtafaPDx1rU2kx1nP78sZj7M33vtTG98yxctluUlnXrrxkvHdC0+JOWoXV3272D1rY73R+LRSBSxBAAAEEEEAAgcEQKMa38sGwbKQW4cqJ7hrawUnwigACCCCAQMsCy4aXLj/rPWnJ3l0yG14y6yG79LDVNjaaz8hmBUIvv/+5dsuOQys1SlO74vZvfPNS5nhsuYG5EAEEEEAAAQQQQKAPBQh69bbRCD721pu7IYAAAghMQ4Fjlq9YNlRK/8ksObyUpHbqvN/a6xausUWj23qisX7PXPvXh4+26zc9NZ2woWQqtY2lqYnX3X7tJTf0pADcBAEEEEAAAQQQQACBAgkQfOxtYxB87K03d0MAAQQQmKYCJyy74qA980srrJS8Wr0gxfC8uevszxfebkfO3NQVlXt2LbCVDx9l39/6ZCtXh3ynZl/dOjTxlwyz7go5mSKAAAIIIIAAAgj0gQDBx942EsHH3npzNwQQQACBaS5w9DkfPrI0sd9bk7R0fjKUzhCHgo8nzH7Anjn7ATtu9riNJuWWlPakJfvVroPtF9sW2U3bDzUtKqOtbDZp5fKXyiN7PnjnykvvaSlzLkIAAQQQQAABBBBAYEAECD72tiEJPvbWm7shgAACCCBQEVh8zkfH5k6OvjVJyhcklsx3LAo8HjPrQTtq1gY7ZGSHzR9+1PYf2m0Lh3fagpGdlWSbJmbZhslZtnVqhm2fGrX798yxu3cdZLfuGDMFIN2Wpun2NEm/sG1o6nJ6OjoVXhFAAAEEEEAAAQSmuwDBx94+AQQfe+vN3RBAAAEEEAgElg0fs/ysk5MkOc3S9EWlkp0YJGjysHxHOR26zsrp99dsuW21rbpqd5MZkBwBBBBAAAEEEEAAgYEWIPjY2+Yl+Nhbb+6GAAIIIIBATQH1iJxXHn1RuWxHWzo1lpSGxsxsfpqWx5JySfuWlsrjSVIaN7PNaXlq3JKhcUvT/9o2MnEDPRxr8vImAggggAACCCCAAAJG8LG3DwHBx956czcEEEAAAQQQQAABBBBAAAEEEEAAgRwFHpuoKMdCcGsEEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEDqu2djAAAgAElEQVQAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBEyD4OHhtSo0QQAABBBBAAAEEEEAAAQQQQAABBBAohADBx0I0A4VAAAEEEEAAAQQQQAABBBBAAAEEEEBg8AQIPg5em1IjBBBAAAEEEEAAAQQQQAABBBBAAAEECiFA8LEQzUAhEEAAAQQQQAABBBBAAAEEEEAAAQQQGDwBgo+D16bUCAEEEEAAAQQQQAABBBBAAAEEEEAAgUIIEHwsRDNQCAQQQAABBBBAAAEEEEAAAQQQQAABBAZPgODj4LUpNUIAAQQQQAABBBBAAAEEEEAAAQQQQKAQAgQfC9EMFAIBBBBAAAEEEEAAAQQQQAABBBBAAIHBExgevCpRIwQQQAABBBBAAAEEiiuw8JzL5hyye/6y0lB6YmrpgUkpGUvL6UGW2OLE7CCVPDXbaKmtTUrJRkv1J30wNbt1fGTL9zasvGx7cWtHyRBAAAEEEEAAgccLJI8/5KjLAmlG/rRDBgynEUAAAQQQQACBQRA46qUrjhvaLz3dUjstSUvPTobSGa3Uq2w2aeV0tZXs+8OTdsMvr33bTa3kwzUIIIAAAggggECvBAh69Up6730IPvbWm7shgAACCCCAAAL5CSw7b8bS+cdekJTSt5slh/sFedqMh+2Zc8Zt/tBuWzCyyw4e2WkLh3fYAcO7K8kemZxhGyZn20MTs2zTxEzbPDXD1uw4xO7aVekYuS+rqdQ2llL79NbNduXaVRdt3vcGOwgggAACCCCAQEEECD72tiEIPvbWm7shgAACCCCAAAK9F6gGHS1N3pkMpWMqwMKRHXb87AfspDnr7YTZD9i84UdbKtf2qVG7cfsi++WOQ+3mHYfa+J45lXxSSzdbOfm/BCFbYuUiBBBAAAEEEOiiAMHHLuJGsib4GEHhFAIIIIAAAgggMBgCy4aXLj/rLX7Q8aiZG+3chXfY8+au60oVb9s5Zlc9uNT0qq2cpluSNLny9mu++QGzVZNduSmZIoAAAggggAACTQgQfGwCqwNJCT52AJEsEEAAAQQQQACBogkc+ZLLD589Y/RqS+xkle3YWeN23iG3V157UVYFH7+68en2k21HVG6XpumtU8OPnnPnykvv6cX9uQcCCCCAAAIIIJAlQPAxS6Y75wk+dseVXBFAAAEEEEAAgdwElixfsdyS9KpSksxbNLrN3nnYT2zJrIdyKc/duw+0y+9/rv337gMsKac70qHSBbd97cIv5VIYbooAAggggAACCJgZwcfePgYEH3vrzd0QQAABBBBAAIEuCiwbXrL8zBWlUvIW3eSF89ba2xf9zGaWJrp4z/pZ7yqP2GfGT7RvPfL7lcTlcvmq8ZFtf7lh5WXb619NCgQQQAABBBBAoLMCBB8761kvN4KP9YR4HwEEEEAAAQQQ6AuBZcNLX3HW1YnZ2aPJlL157Bd25oK7C1XyH2xZbFfc/5x0dzqSlMvpqjXXXHsq80AWqokoDAIIIIAAAtNCgOBjb5uZ4GNvvbkbAggggAACCCDQFYElyz/+xVKpdN6C4d32kSO+Z0fO3NSV+7Sb6bpH97e3rT3dNk3OsNTsq/+vvXsBtiwryAO8zu2ekccMMyADLRqcqLEgMoCA+AIyPhBiFMESFSQVKlKCliZA8dBoIsQgakAsMYoGS1KloGIUCSrGByMiGnwEZ8AYREWCMDDymAczw0z3Pan/zt2wWKxz7jn3nnt7393frpo6++zH2mt9a5+G/nvtva785V99nADyoKrOJ0CAAAECBNYR2FrnYMcSIECAAAECBAgQONcFLvvaF74owWMer/7ef3TFaIPH9NM9P+m68sOXvnbnUfCM0rzvYx794nO9/7SfAAECBAgQOFoB4ePRersaAQIECBAgQIDAMRa479e88BlbZeupJ2bz8j2f9vtnbWKZdQgTQP7Ap/9OyePhs9n8Kfd9zIv+8zrnO5YAAQIECBAgcBABj10fRG/9cz12vb6ZMwgQIECAAAECoxD43Ef98INOn5z94VYpJ5/9qW8sj7j47aOo16qV+L3rPr1837seVrbns7J9pjz8ql992m+veq7jCBAgQIAAAQL7FTDycb9yziNAgAABAgQIEDiHBC4/eebk1osTPD76Ln957ILHdNQ/u9Pflcff9aqdPpuV2YtLufzkOdSBmkqAAAECBAicJQHh41mCd1kCBAgQIECAAIHjI3CfRz3qSbMy/4JLzvtw+dd3e/PxqXhT0ydccmW5x/nXl9mJ+b0ue8yjntHs9pUAgaMXeEgpJcOo85Rc/sv6Zxx9NVxxhALujRF2iirtT0D4uD83ZxEgQIAAAQIECJwjAg+8/AV33TpZnp/mftupPykXnLjl2Lb8/Nl2efo9/min/rPtre+91yNfdOmxbYyKE5iGwBeVUj6zakrW71F9t3ruCrg3zt2+n1zLhY+T61INIkCAAAECBAgQ2KTArXc++X2zMrv4Cy98186jy5ss+2yU9YA7vqc8/KK/yejH2528/WwnVD0b9VjjmhkFVo8MG0aItZ8fKKW8tpTyvFLKV65RvkNvE7jfAucfL6V88h5IbR8ZvbcH2CHsTh/l/m9/F9mWvt1rqc/Nb8lvaC8x+wkQWFlA+LgylQMJECBAgAABAgTOOYHLn3i7UrafkHZ/x6k3Tab5Tz71JyUzdm9tl0df8tjnXDDyhj24GRm2qLp3LqU8opTy70opv1ZKSYDyrEUH2/4JAl+/wPlbSylP/4SjP35DRuoZvffxJkf97fN37//2uvlNvLTd2Pme44Ylv6X7DF98EiBA4KACwseDCjqfAAECBAgQIEBgsgKXXXy/R85mswsuu8P7yqnzb5hMO+9y8uZyvztcvTP68W63XPCNI2/YPfdZvwQoP1hK+eMVRu7t8xKTOu2BS1qTQNd7CJcAjWDXsrDwQaWUsf3On9yM0sxoWQsBAhMVED5OtGM1iwABAgQIECBA4OAC89nsG1LKw+70dwcvbGQlfMlF79ip0dbsxE4bR1a9TVYnwUseKd3r0eFNXnOKZX3dFBt1DrXpiSNr62Oa+tQjZ5tdvhIgcNwFhI/HvQfVnwABAgQIECBA4FAE8jhyHktO4Q+70zsP5Rpns9CHXPjOnUevy1a5PJPqnM267OPazy6lzKr/Uv+HllK+v5TywU55CSD/S2e7TasLfKcAd3WsER6Zx6oze7KFAAECRy4gfDxychckQIAAAQIECBA4DgJ3u+WCR2ZSljxyfcl5Hz4OVV6rjhed/MjOo9dbpZy8+aLbQta1ChjXwe8vpbyhlPLdpZQEjX/SqV5GeApfOjALNv1Csz2PsX9zs83X8QrkN/DXTfW+p/nuKwECBI5EQPh4JMwuQoAAAQIECBAgcNwEtk5s3St1/uzbJ9ea5pJgNcvW1skpPfL4N6WURy4YAfnte/Rk3muY2bLrmX8ze3DeG5lZn9d572GCzpyTc+sZiFN2JsJZ9hh4zs2EOcN59fv6su/nm/0psz5mj2autPviUspvNkducvTjQXwyE3Pts2x27dYyx7azP7fH5H2EWXJcrId+yHrdbzkvfRn/lDscN3xme+6nde6b3Usf+CMh/E81pWxy9ON+fis5Z7CpJ7gZqjnsGz6Hfmptl00kVfdXyll2bPYN18pn+qu3pM9zT2R/fd/lnOHPhtwLy5a6XmnPcB+lDkP78rmf33HOqeuV9cGurlOOSz3aY9OutG+oU32OdQIbERA+boRRIQQIECBAgAABAlMTmM23PjVtOnXedCaaafvorufdeNum+ZlT7b5j/j2J8bd12pDRj4v+gp2QKCPFMrlKG4wkyMmsz9mf45YtKT9/mf/93XNybr2k7EyE81dLgoYvKqVkpOGwZNKduty0o96fMl+xe91F7RvKWufzR5uDNzH6sW5HTPfjk8lV6vYnPM+M272ltcyxFzYHtsfkfYQJb15XSqnfiZr1e++em2A5fZy+jH8vwM/23E+5b/YTKjXVXPvrT3fO2MTox/3+Vhb1UaeaO5vil6W1TQjeW3Jv1f2VYxYdm33f0hTS++0klMtv9SW7/Vzfdzl9+LMh90J+970yclxdr7Qn91Huodw/Q/vyue67ORN65rdf1yvr11dty72cYDPHpR7tsXFO+7yaokKzulkB4eNmPZVGgAABAgQIECAwFYFZuTRNOXX+9B65HrroY4+Tz3baOmyfyGdG+PTe/ziER3UzEwIkJFplyXE5vrcMwdoQmvSOGbYlAEgYsEooddFusLFXudm/yQDh1zuP7h5k9ONh+Qymm/r8rN3gsQ5p2rITnK6zpK8zYvMol4TwP9FcMPfIXqP0mlM+7uumfisfV+geX3qvAOiN7Pv8Tjnpw157c/4Q+g2n/c9hZfczbU0ot+w+qE+J7bIAsj72Rbv/OFFvW3c9v6dXd056XCklI8Cz5JiE6G1bd3d/3EdGO1sIHIqA8PFQWBVKgAABAgQIECBw3AVm5cynpQ13PzndkY+XnLxpp5tm862pjXwcbr83DSvVZ0a51UtGNq0bJOX4XqCR4K8dyVdfq7eegCMBwbIlgeeq5WZkU69uy8pftu/fNDsTxOz33Y+H5dNU8cBfE9SsGjitc7HnrnPwho59QSeE3+/ox4P+Vt69ZpuGx/4TnrXLF7QbSilf3NmWTe1vPtt65/9idX6C4nX/XMjp+Z1+X1XOotVVf8+Lzs/2n+vcp5l0K//wMiyZpf4w7uWhfJ8EVhIQPq7E5CACBAgQIECAAIFzTWBeZjvh46nzJxw+DhPpbG3vtHWCffy7e7Qpod/zm2MyWjIjhzKDdmbUzudTmmPytX1/ZAK/+tHKHJNJP/5FNSt3Qq12JFqCgQQEqyypW2b6HuqWsnujO9u6rVL2omMy+nEIgYZj9jP68Sh8hvod5ufwOGtM8jh1wp70Q/q2noE927K/XjYRONXlrbKeEXA/0By4n9GPm/itpC6DUXtPpYrDvuHzz3fr/VtN/fP1SzrbvqKzLZu+tLO9PT+/o+F6OfxnO+ekzvev6pn1dlRmTktoud/3fH6oc93eprwrMv1YL/mzJZNu1UteIVAvuSfrezXr+fMubVv12nV51gmsJCB8XInJQQQIECBAgAABAgQITFDg4Z1RQU/YHTk0zDSUz5/cDf1qgjZofHy9czcUzDEJ74Yl4UveRdkGL21AMBxffyYcSWDyQ6WUoW4p+1H1Qbvrbd06h6y16T81R+9n9ONh+zRV3MjXOjweQpohoMqkRnk8O2FP+mF4zHW4cLa1E75kX+9x4eGcw/rMux/bkHrd0Y+b/K2s287YtjPYt/d4wtFF4W5CunZ0cRtU1qMF8yqEdrRgfrPp86H/04as59heABmvVZb8Y8IQBiawbv8xpFdGgvy8K7JeUr/ee27rY7Ke+6C+V7Oetqdtq7wCoi3PdwIrCQgfV2JyEAECBAgQIECAwLkmMCvzd6XNV99ywWSbfs2td9xp23w+u3qyjVzesId1dtdhYb37jfWX3fX68eY2zMgj3/Vf8uvT2xGZ7Qim+thhPaFoHXwM29/QGWGXfZsMuXKNNjBdd/TjYfsMHpv6TNiVQGa4H4aQpi0/I9wyCi3v+htmLR5mUG4DopzbTnbTlncY3xNWH3T04yZ/K/tpY/s+xpRR//5673usr1Pvz2+jDRdfXx3ca2s7+VJ1eDcwXOUfFDLiMP+YMPw5kXut9xuvr3Wnznsec69+U31QtT6UPWxKQJt7tbYb9vkkcGgCwsdDo1UwAQIECBAgQIDAcRaYlxM74eN7T084fDx9+90uui1oPc79taDumahl2dJ7NHIIjtrPzGa7bMnopXpJoNiWMXzvhVL1ub3163obd7e1o8KyedMhV2/046qPi6c+h+2zhGdfu55WjTDtFZCRdHlfZx5jTX+mv9s29s47W9t6ox/XeTx/k7+V/Rj8Ruekf15ta9/32I5GrPf33vdYP9rda+sQQleX/OjqXoHhRw+sVhLm16Mtq11LV/M4eBucZhToMBq6Pfnl7YbdezV/niUsT3Dea2/nNJsI7F9A+Lh/O2cSIECAAAECBAhMWmAY+Xjb6MApNnUY+VjK/B1TbF8p5YGddr2zs22/mzb5rsyDBAB/tt8GrHFeRj+2gc4z1zj/oIcexOeg1+6dn9Fj+5mQpFfWUWxLOPVdzYUSWh2V60F/K7n/2kfH69G09XoC4R9r2lrvb0clJghcFN41xZz1rx/o1CDvHV20xC0jLHtLwvIE5/F6Xu8A2whsSkD4uClJ5RAgQIAAAQIECExLYLv8fRp09a3THfn4D7fe4bY+m52Y6mPXvceZ/88Gb9RloxHXvcy1655wFo7PrNv1kvDiqN4TNyaftHnR+wVrn7Gt592lCZrq5Rn1l0Nc38RvpR0pmD7ICNT2fY95RDuhW73k2CFobf9c+JX6wJGv512dbQibEHnZY9Rxe2in7+um5rfd+tb7rRM4kIDw8UB8TiZAgAABAgQIEJiqwJn5mbekbW+7qZ2nYDotvurGu93WmPltQet0WrbTkl4olr+07+cRyR5NQpy/7O3Yx7aDjrzqzea7j2rseUreH9fO1t0+jr1nIfs44KA++7jk0lOe2NmbUaEJeIaZmvOZyUTGtrQTzRxkZuZV27ap30r9Xsbh2pnYpX6fY7YPx7UjdR+8IKSrH7keyh3rZ14H0o5gTV1f1plUp25DwthMkJR7NL/hNsDMsQkxe39u1uVYJ7AvAeHjvticRIAAAQIECBAgMHWB951/w2vnZ2Y3J6D72OPJ02n1tac/qfz5jad2GnTTRz7yqum0bKclSYx7odgqI3vq8GjZev4i307mUDMmMFt2fr0vE5vstWSiiUVLQpV22eQIz7rsF9Rfdt9zuJ9Hajft01TrUL+23nnnZkKbdrTdoVZin4XnN9COfsy7O9ttqxRf38PL1vf6raxyrRzTCwkzOUz9Psccl8mesrxu93P4yLFfNHzZ/Uy729/xh5pj8nXZBE69UYdtmZ0i970pI1jz+6mXjEJ+er1hwXru0cyK/U86/5CQUx694DybCRxIQPh4ID4nEyBAgAABAgQITFXgmlc+54b57Eze61Zef909J9fMN1x/z3JmPivb2+W33/4bz96ZXGcijcyjlem33uQfbXDWzjodgl6QsApNGwYkoNrksNlMNNELQJ7cmYAigcphvcOuN/pxlcBikz69R7Af3+mkeGVW7k0v7YQfi6wfsOkLb6i8dvRjjDL5yLJlk7+VXOdPOxfr3d/1YXFuJ1fKuxzr9znWYWIbViYgbkcJt6Mjc702tMy2ZZNEtZ45fhh9Wdd/k+u9UbV5dHrVP79imRCyDZ0v3mQllUVgEBA+DhI+CRAgQIAAAQIECDQC27Ptnb+Yvv66T2/2HP+vr7v20p1GbM/P9P7yfdwamJAvf+nOpAkJJ3rv48ukDO1opDYQS7tfvTsDbBuE5PtX7s5wnKAmoV+9tO+NS0D1v3ZHxA3vmhuOT10ThGQUWiaQaK81HFd/pryEIrnuEGpm/fn1Qbvrh92n/755bDOPa+61bNLnrZ2L5fHhoU/ik1l839wJZjunrr2pDcDyDsHh2iks98kf7z7GunbhR3BC7rv63s+91b4Hsa1Gffywb7+/lZzfC5DrezuGw30+XC+fL62/7P4jQ/17r+/9/N7rcK3Xzt4s2m1omUvGJ271bzXr+YeO1i6PNOfYw1zy+oheAJnHr+sl9ci9GNs6mIxtjO9SH1xK6Y36bA7xlcD6AifXP8UZBAgQIECAAAECBM4Ngbd+8K2vuu+d73vDVTfe7YI8en3JeR+eRMOHR663Szl9u2vLcXzkOqOQlo1EavspYdEPtxt33/+YUKUODxJQrFL+RU15v7QbBOb8Ycnoy1cMX5Z8XrhkX70rZb9k9796e7v+0+2GDX/PqKkfWLMPNumTR0cT8NTWaeIqNpugyIQmdeB1lNfeRP1TRl5LUN/3e5WbsGtTv5VcqzfrfALkegbxp5RS8ohxvfxR/aWz/gfNtvRVXWa9O/dQ71H5YXRve15C9lWC9owoPIrlh0opj23uxfyZk+A9+7JkJGPu1fZ+3d39CR/H8X8PPqERNoxPwMjH8fWJGhEgQIAAAQIECIxF4IqX3Vxms50RLD/53geOpVYHrsfPXPO5O49cl+3t1/zpFc/4hwMXOO4CEpjknYqLHo39ps6jnPtpUcr/kmZE4H7KWXROb4KI3rEJbNoRnr3jDrotAeeqdcq1Nu2T8HOVJXWsR7+tcs5ex6zb9r3KOxv7E7r1RjMuq8umfiu5RkYX7nX/tAF/zksIuqw/M9q4Xl5Tf2nWE0wuWjK6tx3huujYensmcznsUY/19Z5Wf9ldzz+e1CM0O4d0N6W9R1n3biVsnKaA8HGa/apVBAgQIECAAAECGxK48aZbnjufz2/43WsvLW+64R4bKvXsFfMXN921vPoDn10ymc72ebc88+zVZOUr90ZIrXJyAorH7RE8ppyEYgkn1w1ieo+NJhhJALksHOnV/frexmbbE1YIQ/JoeTtSrClmY1/j1pt1d7hAr02b9MnIrnbm7eHaw2f6NCO+9nqf4XD8qp8JdzO6ba/wLPVb975atQ6bOK732O5Qbu/+3uRvJWXtNUJw0W9/UWiY8Czl1ksbRtb7lo3yW7etuRcS/O/Vpvr6m1hPiJzffbusMzI85+Y+XWXiq/Y6vhNYSUD4uBKTgwgQIECAAAECBM5VgZ3JWOazjIIpP/KeLyi3zI/v/4XOBDMvfPcX7nTlfLb9gre+8rs2Hcocxm2SmWtXCfMSPOQv0AlU7l9KyQy7q47iGYKGh+7+Rb4XGKX8vE9uKH9RyJeALddO8JnwKee1S8rPvoQVeUwy5+y1XFdK+bzdcusyY5OyUvfv3quQJfvbdzL2JhhpT49Bgo82hMu2RW3apE+CnjjX/ZW6pJ+G4DlBYd2W7G+D0Tc2bYhpe0zb9txbCTbT1vr+HK6f/kj96lGo2ffupqD9XLspYudrW05t0js+29IXcarrn+05N4/J95ZN/lZiGKf0V2yGJfd3fme9dy/mmNx3bZ1z/guHAqrP1LcXsqaNi8ofTt+rrblmysnvOLNHL/ozIeXV76LM996EO8N1h8+2Txfdl3mlRNvfw/sycw+mftnfmsV5+LNj2ejwoT4+CexbYLbvM524H4H5gpP0wwIYmwkQIECAAAEC4xC4/OT9vvar/3cpW/d5/F3fUp509z8bR7XWrMXL/+E+5aXvfUDZns/fcdUHr7x3yWPlljEK5J1t7cilhDS999ONsf7qRIAAAQIEPipwfP/Z9qNNsEKAAAECBAgQIEDgsAWuOH3rLSd2Jh/4hfd/Tvm9Yzj7dR4Z/5n3fe4O1OzM6W8VPB72PaN8AgQIECBAIALCR/cBAQIECBAgQIAAgRUE/uI1T33DfF5ekEeXn/+uh5SrbrzbCmeN45C85/E57/xn89R9u2z/yJWvftZrx1EztSBAgAABAgSmLiB8nHoPax8BAgQIECBAgMDGBK78lac9cz6fveSW+YnynX/3ZeWdH7nTxso+rIJSx//wzi8tN8/Pm81L+aWrfvl/HIdJZg6LQ7kECBAgQIDAEQsIH48Y3OUIECBAgAABAgSOt8CVv/Kq70iId9P2eeXp73hkefctF462QdfcesfyXe/4svkHTt+uzMvstVf+8q8+rpQrTo+2wipGgAABAgQITE5A+Di5LtUgAgQIECBAgACBwxW44nRCvO3t+RUJ9Z709q+a/+61lx7uJfdRet7xmLq95/SFszIvb3jPiQ89VvC4D8izc0pmua1npl00y+3ZqZ2rEiBAgACBNQTMsrwG1gYONdv1BhAVQYAAAQIECBAYg8Alj33OBXc/ffF/PTGbf2Pq86i7vK1826k3lfNn22e1enmv40ve+6Dy399/7516bG9vv+rq867/l9e88jk3nNWKuTgBAgQIECBwTgoIH4+224WPR+vtagQIECBAgACBQxe47NEveuJsNn/xbDa74LNu/4HyrE95Y8nn2VjyCPh//H8PK2+7+ZPL/Mzs5vmsPPOqVz31x85GXVyTAAECBAgQIBAB4ePR3gfCx6P1djUCBAgQIECAwJEIfPZXv+Betzu59YrZbHb/XPCLL3xn+VeXXHlkIeTbb7pLeeX7/2n5nev+cdmezxI8/uXpW+eP+4tff9qbjwTARQgQIECAAAECCwSEjwtgDmmz8PGQYBVLgAABAgQIEDjrApc/8XaXXXzf7wgqKlwAABuVSURBVJ5tlW+fldnFqc+DL3h3edwlbyn3u8PVh1K9hI7/7Zr7lj+4/p475We0Y9ma/9h7Tl77XI9ZHwq5QgkQIECAAIE1BYSPa4Id8HDh4wEBnU6AAAECBAgQGLvApZe/6OI7XVyeWrbm/3YIIe/5SdeVz7vg73f+u+wO15Tbb926r2bcMt8qb7nx7uXPbviU8oc3fGr525vvvFPOziPWJ8685PoTZ37wHa981uEknfuqsZMIECBAgACBc11A+Hi0d4Dw8Wi9XY0AAQIECBAgcNYEeiFkKnP+7Ey59+2vKZfd8X3l7ud9uFx88iPlTiduLpecvLHc5bwbd+r7gVvvUK45fYdy3ZnblRvOnF/+/pYLyttuumt584dPlQSQwzKfz2+Yz+YvFToOIj4JECBAgACBsQkIH4+2R4SPR+vtagQIECBAgACBEQhcfvI+j/6ah8xms0eU+fzLt7bKgw5Wqe23bM9PvKZsz3/nqmv//A3lipfdfLDynE2AAAECBAgQODwB4ePh2fZKFj72VGwjQIAAAQIECJxDApc+9odOXbR9/pdvb5fPKfMzp2ZbJ06VUi6ez7dPzba3sl7mW9tXz2ZbeXz6Q/PtM1eX2Ymry3z+f68/79bXeqz6HLpZNJUAAQIECExAQPh4tJ0ofDxab1cjQIAAAQIECBAgQIAAAQIECBA4iwIfe2HMWayESxMgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLTExA+Tq9PtYgAAQIECBAgQIAAAQIECBAgQIDAKASEj6PoBpUgQIAAAQIECBAgQIAAAQIECBAgMD0B4eP0+lSLCBAgQIAAAQIECBAgQIAAAQIECIxCQPg4im5QCQIECBAgQIAAAQIECBAgQIAAAQLT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AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDCAs8qpcw7/2W7hQABAgQIECBAgAABAgQIECBAgAABAvsS+ORSygc6weMQRma/hQABAgQIECBwLAS2jkUtVZIAAQIECBAgQIDAuSPw8FLKnZc0N/stBAgQIECAAAECBAgQIECAAAECBAgQWFvg55eMeszox9euXaITCBAgQIAAAQIECBAgQIAAAQIECBA45wXySPXwePXwmbBxWB8+P+OclwJAgAABAgQIHAsBj10fi25SSQIECBAgQIAAgXNEoH2k+q9LKT/aaXt7XOcQmwgQIECAAAECBAgQIECAAAECBAgQIPAxgT9uRjk+b3dXOwFNjltneUgp5cdLKW+vys96tmXfXss3llLyOHhdj9Qh9euNwmxHay6bpbt9zHxoc12nJ1f1Th2GOn9lKWUwy/b63NQr9U4b2/pkBGnan2vnmFWXlJlrDNdMOblur5z6mBxX1613vbSl9e0dZxsBAgQIECBAgAABAgQIECBAgACBtQUSbA2PVQ+f99stJQHasG347IV+7UXzGHcveBvKGD4XBWO5fh1YDsfXnwnM2gCv3p/11GHRssqxbRsSZuaa7bn5niX1roO83nH1tgSFe80iHqP6nN566jmU07v+sG+3mh/30YawKd9CgAABAgQIECBAgAABAgQIECBAYCMC9ei+BE8J/YYlo+LasGvZaMKcl6Brr+CwLnMIOodr5nu9f9l6grZ6aY/ddPjYjiqsr5d6xKbetsp6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AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4y/w/wGjGp4YYf3OlAAAAABJRU5ErkJggg==" alt="image.png"></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Conclusion">Conclusion<a class="anchor-link" href="#Conclusion">&#182;</a></h1><ul>
<li>Explanability and complexity doesn't have to be a tradeoff<ul>
<li>Model Agnostic Approaches</li>
<li>Shap (<a href="https://github.com/slundberg/shap">https://github.com/slundberg/shap</a>)</li>
<li>Lime (<a href="https://github.com/marcotcr/lime">https://github.com/marcotcr/lime</a>)</li>
<li>Skater (Fork of Lime - <a href="https://github.com/oracle/Skater">https://github.com/oracle/Skater</a>)</li>
<li>ELI5 (<a href="https://github.com/TeamHG-Memex/eli5">https://github.com/TeamHG-Memex/eli5</a>)</li>
<li>Tree Interpreter (<a href="http://blog.datadive.net/interpreting-random-forests/">http://blog.datadive.net/interpreting-random-forests/</a>)</li>
</ul>
</li>
<li>Tools<ul>
<li>Feature Importance (Global - Use entire dataset)</li>
<li>Decision Plot</li>
<li>Dependence Plot </li>
<li>Interaction Plot</li>
</ul>
</li>
<li>Lime vs Shap<ul>
<li>Shap optimized for XGBoost (Problems with Lime and XGBoost)</li>
<li>Some differences arise (Different approaches)</li>
<li>Shap can be slow (Lime is fast)</li>
</ul>
</li>
<li>Model Agnostic Models<ul>
<li>Will continue to evolve &amp; improve</li>
<li>AutoML needs Model Agnostic</li>
<li>Helpful with bias<ul>
<li>Weapons of Math Destruction</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

    </div>
</div>
</div>

</div>
    </div>
  </div>
</body>

 


</html>
